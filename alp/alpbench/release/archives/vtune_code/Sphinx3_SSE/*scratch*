
/*******************************************************************/
/* original code */
#if 0
int32 mgau_eval (mgau_model_t *g, int32 m, int32 *active, float32 *x)
{
    mgau_t *mgau;
    int32 veclen, score;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, dval2, diff1, diff2, f;
    int32 i, j, c;
    
    veclen = mgau_veclen(g);
    mgau = &(g->mgau[m]);
    f = log_to_logs3_factor();
    score = S3_LOGPROB_ZERO;
    
    if (! active) {	/* No short list; use all */
	for (c = 0; c < mgau->n_comp-1; c += 2) {	/* Interleave 2 components for speed */
	    m1 = mgau->mean[c];
	    m2 = mgau->mean[c+1];
	    v1 = mgau->var[c];
	    v2 = mgau->var[c+1];
	    dval1 = mgau->lrd[c];
	    dval2 = mgau->lrd[c+1];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
		diff2 = x[i] - m2[i];
		dval2 -= diff2 * diff2 * v2[i];
	    }
	    
	    if (dval1 < g->distfloor)	/* Floor */
		dval1 = g->distfloor;
	    if (dval2 < g->distfloor)
		dval2 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	    score = logs3_add (score, (int32)(f * dval2) + mgau->mixw[c+1]);
	}
	
	/* Remaining iteration if n_mean odd */
	if (c < mgau->n_comp) {
	    m1 = mgau->mean[c];
	    v1 = mgau->var[c];
	    dval1 = mgau->lrd[c];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
	    }
	    
	    if (dval1 < g->distfloor)
		dval1 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	}
    } else {
	for (j = 0; active[j] >= 0; j++) {
	    c = active[j];
	    
	    m1 = mgau->mean[c];
	    v1 = mgau->var[c];
	    dval1 = mgau->lrd[c];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
	    }
	    
	    if (dval1 < g->distfloor)
		dval1 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	}
    }
    
    return score;
}
#else /* unrolled or SIMD code */

#ifdef SSE2 /* SIMD code */


/* 
   inner loop of mgau_eval (simd version)
   returns dval1 
*/

float64 mgau_eval_inner(const mgau_t* mgau, const int32 veclen, const int32 c, 
			const float32 *x) {

  __declspec(align(16)) static const float32 zero[4] = {0.0, 0.0, 0.0, 0.0};
  __declspec(align(16)) static const float32 mask[4] = {1.0, 1.0, 1.0, 0.0};
  float32 *m1, *v1, tmp;
  float64 dval1, diff1;
  int32 i;

  m1 = mgau->mean[c];
  v1 = mgau->var[c];
  dval1 = mgau->lrd[c];
  i = veclen>>2;
#if 1
  float32 *x_ptr, *m1_ptr, *v1_ptr;
  __m128 xmm_psum = _mm_load_ps(zero);

  x_ptr = x;
  m1_ptr = m1;
  v1_ptr = v1;
  
  __m128 xmm_mask = _mm_load_ps(mask);

  for (i=0;i<veclen-3;i+=4,v1_ptr+=4,m1_ptr+=4,x_ptr+=4) {
    __m128 xmm_v1 = _mm_load_ps(v1_ptr);
    __m128 xmm_diff = _mm_sub_ps(_mm_load_ps(x_ptr),_mm_load_ps (m1_ptr));
    xmm_psum = _mm_add_ps(xmm_psum,_mm_mul_ps(xmm_v1,_mm_mul_ps(xmm_diff, xmm_diff)));
  }
  __m128 xmm_v1 = _mm_load_ps(v1_ptr);
  __m128 xmm_diff = _mm_sub_ps(_mm_load_ps(x_ptr),_mm_load_ps (m1_ptr));
  
  xmm_psum = _mm_add_ps(xmm_psum,_mm_mul_ps(xmm_mask,_mm_mul_ps(xmm_v1,_mm_mul_ps(xmm_diff, xmm_diff))));

  __m128 xmm_shuf = _mm_shuffle_ps(xmm_psum, xmm_psum,14);
  xmm_psum = _mm_add_ps(xmm_shuf,xmm_psum);
  _mm_store_ss(&tmp,_mm_add_ss(xmm_psum,_mm_shuffle_ps(xmm_psum, xmm_psum,1)));
  
#else
  __asm
    {
      mov    ecx, [i]       ;
      movaps xmm2, [zero]        ;
      movaps xmm3, [mask]        ;
      mov    eax, [x]          ;
      mov    edx, [m1]         ;
      mov    ebx, [v1]         ;

    mgau_eloop:
      movaps xmm0, [eax]        ; /*load 4 floats from x */
      movaps xmm1, [edx]        ; /*load 4 floats from m1*/
      subps  xmm0, xmm1        ; /*xmm0 has x-m  */
      movaps xmm1, [ebx]        ; /*load 4 floats from v1 */
      mulps  xmm0, xmm0        ; /*xmm0 has (x-m)^2  */
      mulps  xmm0, xmm1        ; /*xmm0 has (x-m)^2*v1 */
      addps  xmm2, xmm0        ; /*partial sum at xmm2*/
      add    eax, 16       ;
      add    ebx, 16       ;
      add    edx, 16       ;
      sub     ecx, 1        ;
      cmp     ecx, 0        ;
      jnz     mgau_eloop    ;

#ifdef MGAU_NO_LOOP  /*39 elements assumed, undef to unassume */     

      movaps xmm0, [eax]        ; /*load 4 floats from x */
      movaps xmm1, [edx]        ; /*load 4 floats from m1*/
      subps  xmm0, xmm1        ; /*xmm0 has x-m  */
      movaps xmm1, [ebx]        ; /*load 4 floats from v1 */
      mulps  xmm0, xmm0        ; /*xmm0 has (x-m)^2  */
      mulps  xmm0, xmm1        ; /*xmm0 has (x-m)^2*v1 */
      mulps  xmm0, xmm3         ;
      addps  xmm2, xmm0        ; /*partial sum at xmm2*/
    }
#else
    }
  i <<= 2;

  for (;i<veclen; i++) {
    diff1 = x[i] - m1[i];
    dval1 -= diff1 * diff1 * v1[i];
  };
#endif

 /* reducing partial sum to tmp*/
  __asm
    {
      pshufd xmm1, xmm2, 14    ; /* move higher 2 floats to xmm1 */
      addps  xmm2, xmm1        ;
      pshufd xmm1, xmm2, 1     ; /* move 2nd lowest float to xmm1 */
      addss  xmm2, xmm1        ;
      movss  [tmp], xmm2        ;
    };
#endif

  dval1 -= tmp;

  return dval1;

}


#else /* unrolled code */

float64 mgau_eval_inner(const mgau_t* mgau, const int32 veclen, const int32 c, const float32 *x) {

  float32 *m1, *v1;
  float64 vdiff[4],vdval[4];
  float64 dval1, diff1;
  int32 i;

  m1 = mgau->mean[c];
  v1 = mgau->var[c];
  dval1 = mgau->lrd[c];

  /* clears vdval, reset v0 and start from the next record of m1 and v1 */
  vdval[0] = vdval[1] = vdval[2] = vdval[3] = 0.0;

#pragma novector
  for (i = 0; i < veclen-3; i+=4) {
    
    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
    
    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];
    
    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
    
    vdiff[3] = x[i+3] - m1[i+3];
    vdval[3] += vdiff[3] * vdiff[3] * v1[i+3];

  }

#ifndef MGAU_NO_LOOP

  for (;i<veclen; i++) {
    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
  };
#else
    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];

    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];

    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
#endif

  /* do the reduction */
  dval1 -= (vdval[0] + vdval[1] + vdval[2] +vdval[3] );

  return dval1;

}


#endif /* end of unrolled code */

int32 mgau_eval (mgau_model_t *g, int32 m, int32 *active, float32 *x)
{
    mgau_t *mgau;
    int32 veclen, score;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, /*dval2, diff1, diff2,*/ f;
    int32 i, j, c;
    /*  float64 vdiff[4],vdval[4]; */
    

    veclen = mgau_veclen(g);
    mgau = &(g->mgau[m]);
    f = log_to_logs3_factor();
    score = S3_LOGPROB_ZERO;
        
    if (! active) {	/* No short list; use all */



      for (c = 0; c < mgau->n_comp; c++) {

	dval1 = mgau_eval_inner(mgau, veclen, c, x);
	if (dval1 < g->distfloor)  dval1 = g->distfloor;

	score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
      }
    } else {

      for (j = 0; active[j] >= 0; j++) {  /* start from j=1*/
	c = active[j];
	
	dval1 = mgau_eval_inner(mgau, veclen, c, x);
	if (dval1 < g->distfloor)  dval1 = g->distfloor;
	
	score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
      }
    }

    return score;
}


#endif
