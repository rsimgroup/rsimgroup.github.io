/* ==========================================================	/* ==========================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All r	 * Copyright (c) 1999-2001 Carnegie Mellon University.  All r
 * reserved.							 * reserved.
 *								 *
 * Redistribution and use in source and binary forms, with or	 * Redistribution and use in source and binary forms, with or
 * modification, are permitted provided that the following co	 * modification, are permitted provided that the following co
 * are met:							 * are met:
 *								 *
 * 1. Redistributions of source code must retain the above co	 * 1. Redistributions of source code must retain the above co
 *    notice, this list of conditions and the following discl	 *    notice, this list of conditions and the following discl
 *								 *
 * 2. Redistributions in binary form must reproduce the above	 * 2. Redistributions in binary form must reproduce the above
 *    notice, this list of conditions and the following discl	 *    notice, this list of conditions and the following discl
 *    the documentation and/or other materials provided with 	 *    the documentation and/or other materials provided with 
 *    distribution.						 *    distribution.
 *								 *
 * This work was supported in part by funding from the Defens	 * This work was supported in part by funding from the Defens
 * Research Projects Agency and the National Science Foundati	 * Research Projects Agency and the National Science Foundati
 * United States of America, and the CMU Sphinx Speech Consor	 * United States of America, and the CMU Sphinx Speech Consor
 *								 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``	 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LI	 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LI
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 	 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCI	 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCI
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, B	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, B
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; L	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; L
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SU	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SU
 *								 *
 * ==========================================================	 * ==========================================================
 *								 *
 */								 */
/*								/*
 * subvq.c							 * subvq.c
 * 								 * 
 * **********************************************		 * **********************************************
 * CMU ARPA Speech Project					 * CMU ARPA Speech Project
 *								 *
 * Copyright (c) 1999 Carnegie Mellon University.		 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.						 * ALL RIGHTS RESERVED.
 * **********************************************		 * **********************************************
 * 								 * 
 * HISTORY							 * HISTORY
 * 								 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@	 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@
 *              Updated subvq_free () to free allocated memor	 *              Updated subvq_free () to free allocated memor
 * 								 * 
 * 17-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 17-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Added handling of a single sub-vector in subv	 * 		Added handling of a single sub-vector in subv
 * 								 * 
 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Changes due to moving subvq_t.{frm_sen_eval,f	 * 		Changes due to moving subvq_t.{frm_sen_eval,f
 * 								 * 
 * 14-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 14-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Added subvq_t.{frm_sen_eval,frm_gau_eval}.  C	 * 		Added subvq_t.{frm_sen_eval,frm_gau_eval}.  C
 * 		return the normalization factor.		 * 		return the normalization factor.
 * 								 * 
 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Added subvq_subvec_eval_logs3().		 * 		Added subvq_subvec_eval_logs3().
 * 								 * 
 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Changed ci_active flags input to sen_active i	 * 		Changed ci_active flags input to sen_active i
 * 								 * 
 * 21-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 21-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Bugfix in subvq_init() that used g for alloca	 * 		Bugfix in subvq_init() that used g for alloca
 *		though g wasn't defined.			 *		though g wasn't defined.
 * 								 * 
 * 20-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 20-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Added subvq_gautbl_eval_logs3() and used it i	 * 		Added subvq_gautbl_eval_logs3() and used it i
 * 								 * 
 * 12-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 	 * 12-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie 
 * 		Started.					 * 		Started.
 */								 */


#include "subvq.h"						#include "subvq.h"
/* #include "cmd_ln_args.h"	*/ /* RAH, added so we can al	/* #include "cmd_ln_args.h"	*/ /* RAH, added so we can al
#include "s3types.h"						#include "s3types.h"
#if defined(THRD) 					      <
#include "utt.h"					      <
#ifdef NEW_EVAL_LOGS3					      <
#include "barrier.h"					      <
#include <pthread.h>					      <
#endif							      <
#endif							      <

/* RAH, 5.8.01, VQ_EVAL determines how many vectors are used 	/* RAH, 5.8.01, VQ_EVAL determines how many vectors are used 
 * compute the shortlist, for now this value is only relevant	 * compute the shortlist, for now this value is only relevant
 * Setting it to 1 means that only the CEP values are estimat	 * Setting it to 1 means that only the CEP values are estimat
 * CEP and delta values are estimated, 3 means all three are 	 * CEP and delta values are estimated, 3 means all three are 
 * Note, we must adjust the beam widths as we muck around wit	 * Note, we must adjust the beam widths as we muck around wit
 */								 */
int VQ_EVAL = 3;					      |	static int VQ_EVAL = 3;		


/*								/*
 * Precompute variances/(covariance-matrix-determinants) to s	 * Precompute variances/(covariance-matrix-determinants) to s
 * calculation.  Also, calculate 1/(det) for the original cod	 * calculation.  Also, calculate 1/(det) for the original cod
 * (See comment in libmisc/vector.h.)				 * (See comment in libmisc/vector.h.)
 */								 */
static void subvq_maha_precomp (subvq_t *svq, float64 floor)	static void subvq_maha_precomp (subvq_t *svq, float64 floor)
{								{
    int32 s;							    int32 s;
    float32 *lrd;						    float32 *lrd;
    vector_gautbl_t *gautbl;					    vector_gautbl_t *gautbl;
    								    
    E_INFO("Precomputing Mahalanobis distance invariants\n");	    E_INFO("Precomputing Mahalanobis distance invariants\n");
    								    
    lrd = (float32 *) ckd_calloc (svq->n_sv * svq->vqsize, si	    lrd = (float32 *) ckd_calloc (svq->n_sv * svq->vqsize, si
    								    
    for (s = 0; s < svq->n_sv; s++) {				    for (s = 0; s < svq->n_sv; s++) {
	gautbl = &(svq->gautbl[s]);					gautbl = &(svq->gautbl[s]);

	vector_gautbl_var_floor (gautbl, floor);			vector_gautbl_var_floor (gautbl, floor);
									
	gautbl->lrd = lrd;						gautbl->lrd = lrd;
	lrd += svq->vqsize;						lrd += svq->vqsize;
	vector_gautbl_maha_precomp (gautbl);				vector_gautbl_maha_precomp (gautbl);
    }								    }
}								}


static void subvq_map_compact (subvq_t *vq, mgau_model_t *g)	static void subvq_map_compact (subvq_t *vq, mgau_model_t *g)
{								{
    int32 r, c, c2, s;						    int32 r, c, c2, s;
    								    
    if (g) {							    if (g) {
	if ((g->n_mgau != vq->origsize.r) || (g->max_comp != 		if ((g->n_mgau != vq->origsize.r) || (g->max_comp != 
	    E_FATAL("Model size conflict: %d x %d (SubVQ) vs 		    E_FATAL("Model size conflict: %d x %d (SubVQ) vs 
		    vq->origsize.r, vq->origsize.c, g->n_mgau			    vq->origsize.r, vq->origsize.c, g->n_mgau
    }								    }
    								    
    /*								    /*
     * Compress map entries by removing invalid ones.  NOTE: 	     * Compress map entries by removing invalid ones.  NOTE: 
     * check to ensure that the entries remaining do map corr	     * check to ensure that the entries remaining do map corr
     * the original (parent) mixture Gaussian model g.  The o	     * the original (parent) mixture Gaussian model g.  The o
     * the NUMBER of valid entries (components) in each mixtu	     * the NUMBER of valid entries (components) in each mixtu
     */								     */
    for (r = 0; r < vq->origsize.r; r++) {			    for (r = 0; r < vq->origsize.r; r++) {
	for (c = 0, c2 = 0; c < vq->origsize.c; c++) {			for (c = 0, c2 = 0; c < vq->origsize.c; c++) {
	    if (vq->map[r][c][0] < 0) {					    if (vq->map[r][c][0] < 0) {
		/* All ought to be < 0 */					/* All ought to be < 0 */
		for (s = 1; s < vq->n_sv; s++) {				for (s = 1; s < vq->n_sv; s++) {
		    if (vq->map[r][c][s] >= 0)					    if (vq->map[r][c][s] >= 0)
			E_FATAL("Partially undefined map[%d][				E_FATAL("Partially undefined map[%d][
		}								}
	    } else {							    } else {
		if (c2 != c) {							if (c2 != c) {
		    for (s = 0; s < vq->n_sv; s++) {				    for (s = 0; s < vq->n_sv; s++) {
			if (vq->map[r][c][s] < 0)					if (vq->map[r][c][s] < 0)
			    E_FATAL("Partially undefined map[				    E_FATAL("Partially undefined map[
			vq->map[r][c2][s] = vq->map[r][c][s];				vq->map[r][c2][s] = vq->map[r][c][s];
		    }								    }
		}								}
		c2++;								c2++;
	    }								    }
	}								}
									
	if (g && (c2 != mgau_n_comp (g, r)))				if (g && (c2 != mgau_n_comp (g, r)))
	    E_FATAL("Mixture %d: #Valid components conflict: 		    E_FATAL("Mixture %d: #Valid components conflict: 
		    r, c2, mgau_n_comp(g,r));					    r, c2, mgau_n_comp(g,r));
									
	/* Invalidate the remaining map entries, for good mea		/* Invalidate the remaining map entries, for good mea
	for (; c2 < vq->origsize.c; c2++) {				for (; c2 < vq->origsize.c; c2++) {
	    for (s = 0; s < vq->n_sv; s++)				    for (s = 0; s < vq->n_sv; s++)
		vq->map[r][c2][s] = -1;						vq->map[r][c2][s] = -1;
	}								}
    }								    }
}								}


/*								/*
 * At this point, a map entries is an index within the subvec	 * At this point, a map entries is an index within the subvec
 * a subvq codeword within subvector s.  In evaluating a comp	 * a subvq codeword within subvector s.  In evaluating a comp
 * component scores, these maps are used, with 2 lookups for 	 * component scores, these maps are used, with 2 lookups for 
 * lookups, linearize the map entries by viewing the subvq sc	 * lookups, linearize the map entries by viewing the subvq sc
 * a 2-D array.							 * a 2-D array.
 */								 */
static void subvq_map_linearize (subvq_t *vq)			static void subvq_map_linearize (subvq_t *vq)
{								{
    int32 r, c, s;						    int32 r, c, s;
    								    
    for (r = 0; r < vq->origsize.r; r++) {			    for (r = 0; r < vq->origsize.r; r++) {
	for (c = 0; (c < vq->origsize.c) && (vq->map[r][c][0]		for (c = 0; (c < vq->origsize.c) && (vq->map[r][c][0]
	    for (s = 0; s < vq->n_sv; s++)				    for (s = 0; s < vq->n_sv; s++)
		vq->map[r][c][s] = (s * vq->vqsize) + vq->map			vq->map[r][c][s] = (s * vq->vqsize) + vq->map
	}								}
    }								    }
}								}


subvq_t *subvq_init (char *file, float64 varfloor, int32 max_	subvq_t *subvq_init (char *file, float64 varfloor, int32 max_
{								{
    FILE *fp;							    FILE *fp;
    char line[16384];						    char line[16384];
    int32 n_sv;		/* #Subvectors in file, as opposed to	    int32 n_sv;		/* #Subvectors in file, as opposed to
    int32 s, k, l, n, r, c;					    int32 s, k, l, n, r, c;
    char *strp;							    char *strp;
    subvq_t *vq;						    subvq_t *vq;
    								    
    VQ_EVAL = cmd_ln_int32 ("-vqeval");	/* RAH, Currently onl	    VQ_EVAL = cmd_ln_int32 ("-vqeval");	/* RAH, Currently onl

    E_INFO("Loading Mixture Gaussian sub-VQ file '%s' (vq_eva	    E_INFO("Loading Mixture Gaussian sub-VQ file '%s' (vq_eva
    								    
    vq = (subvq_t *) ckd_calloc (1, sizeof(subvq_t));		    vq = (subvq_t *) ckd_calloc (1, sizeof(subvq_t));
    								    
    fp = myfopen(file, "r");					    fp = myfopen(file, "r");
    								    
    /* Read until "Sub-vectors" */				    /* Read until "Sub-vectors" */
    for (;;) {							    for (;;) {
	if (fgets (line, sizeof(line), fp) == NULL)			if (fgets (line, sizeof(line), fp) == NULL)
	    E_FATAL("Failed to read VQParam header\n");			    E_FATAL("Failed to read VQParam header\n");
	if (sscanf (line, "VQParam %d %d -> %d %d",			if (sscanf (line, "VQParam %d %d -> %d %d",
		    &(vq->origsize.r), &(vq->origsize.c), &(v			    &(vq->origsize.r), &(vq->origsize.c), &(v
	    break;							    break;
    }								    }
    								    
    if (g) {							    if (g) {
	if ((g->n_mgau != vq->origsize.r) || (g->max_comp != 		if ((g->n_mgau != vq->origsize.r) || (g->max_comp != 
	    E_FATAL("Model size conflict: %d x %d (SubVQ) vs 		    E_FATAL("Model size conflict: %d x %d (SubVQ) vs 
		    vq->origsize.r, vq->origsize.c, g->n_mgau			    vq->origsize.r, vq->origsize.c, g->n_mgau
    }								    }
    								    
    if (max_sv < 0)						    if (max_sv < 0)
      max_sv = vq->n_sv;					      max_sv = vq->n_sv;
    if (max_sv < vq->n_sv)					    if (max_sv < vq->n_sv)
      E_INFO("Using %d subvectors out of %d\n", max_sv, vq->n	      E_INFO("Using %d subvectors out of %d\n", max_sv, vq->n
    else if (max_sv > vq->n_sv) {				    else if (max_sv > vq->n_sv) {
      E_WARN("#Subvectors specified(%d) > available(%d); usin	      E_WARN("#Subvectors specified(%d) > available(%d); usin
      max_sv = vq->n_sv;					      max_sv = vq->n_sv;
    }								    }
    								    
    n_sv = vq->n_sv;						    n_sv = vq->n_sv;
    vq->n_sv = max_sv;						    vq->n_sv = max_sv;
    if (vq->n_sv < VQ_EVAL)	/* RAH, 5.9.01, sanity check 	    if (vq->n_sv < VQ_EVAL)	/* RAH, 5.9.01, sanity check 
      VQ_EVAL = vq->n_sv;					      VQ_EVAL = vq->n_sv;
    vq->featdim = (int32 **) ckd_calloc (vq->n_sv, sizeof(int	    vq->featdim = (int32 **) ckd_calloc (vq->n_sv, sizeof(int
    vq->gautbl = (vector_gautbl_t *) ckd_calloc (vq->n_sv, si	    vq->gautbl = (vector_gautbl_t *) ckd_calloc (vq->n_sv, si
    vq->map = (int32 ***) ckd_calloc_3d (vq->origsize.r, vq->	    vq->map = (int32 ***) ckd_calloc_3d (vq->origsize.r, vq->
					 sizeof(int32));						 sizeof(int32));
    								    
    /* Read subvector sizes and feature dimension maps */	    /* Read subvector sizes and feature dimension maps */
    for (s = 0; s < n_sv; s++) {				    for (s = 0; s < n_sv; s++) {
	if ((fgets (line, sizeof(line), fp) == NULL) ||			if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Subvector %d length %d%n", &k, &l		    (sscanf (line, "Subvector %d length %d%n", &k, &l
	    E_FATAL("Error reading length(subvector %d)\n", s		    E_FATAL("Error reading length(subvector %d)\n", s
									
	if (s < vq->n_sv) {						if (s < vq->n_sv) {
	    vq->gautbl[s].veclen = l;					    vq->gautbl[s].veclen = l;
	    vq->featdim[s] = (int32 *) ckd_calloc (vq->gautbl		    vq->featdim[s] = (int32 *) ckd_calloc (vq->gautbl
									
	    for (strp = line+n, c = 0; c < vq->gautbl[s].vecl		    for (strp = line+n, c = 0; c < vq->gautbl[s].vecl
		if (sscanf (strp, "%d%n", &(vq->featdim[s][c]			if (sscanf (strp, "%d%n", &(vq->featdim[s][c]
		    E_FATAL("Error reading subvector(%d).feat			    E_FATAL("Error reading subvector(%d).feat
		strp += n;							strp += n;
	    }								    }
	    								    
	    vector_gautbl_alloc (&(vq->gautbl[s]), vq->vqsize		    vector_gautbl_alloc (&(vq->gautbl[s]), vq->vqsize
	}								}
    }								    }
    								    
    /* Echo info for sanity check */				    /* Echo info for sanity check */
    E_INFO("Original #codebooks(states)/codewords: %d x %d\n"	    E_INFO("Original #codebooks(states)/codewords: %d x %d\n"
    E_INFO("Subvectors: %d, VQsize: %d\n", vq->n_sv, vq->vqsi	    E_INFO("Subvectors: %d, VQsize: %d\n", vq->n_sv, vq->vqsi
    for (s = 0; s < vq->n_sv; s++) {				    for (s = 0; s < vq->n_sv; s++) {
	E_INFO("SV %d feature dims(%d): ", s, vq->gautbl[s].v		E_INFO("SV %d feature dims(%d): ", s, vq->gautbl[s].v
	for (c = 0; c < vq->gautbl[s].veclen; c++)			for (c = 0; c < vq->gautbl[s].veclen; c++)
	    fprintf (stderr, " %2d", vq->featdim[s][c]);		    fprintf (stderr, " %2d", vq->featdim[s][c]);
	fprintf (stderr, "\n");						fprintf (stderr, "\n");
    }								    }
    fflush (stderr);						    fflush (stderr);
    								    
    /* Read VQ codebooks and maps for each subvector */		    /* Read VQ codebooks and maps for each subvector */
    for (s = 0; s < n_sv; s++) {				    for (s = 0; s < n_sv; s++) {
	E_INFO("Reading subvq %d%s\n", s, (s < vq->n_sv) ? ""		E_INFO("Reading subvq %d%s\n", s, (s < vq->n_sv) ? ""
									
	E_INFO("Reading codebook\n");					E_INFO("Reading codebook\n");
	if ((fgets (line, sizeof(line), fp) == NULL) ||			if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Codebook %d", &k) != 1) || (k != 		    (sscanf (line, "Codebook %d", &k) != 1) || (k != 
	    E_FATAL("Error reading codebook header\n", s);		    E_FATAL("Error reading codebook header\n", s);
									
	for (r = 0; r < vq->vqsize; r++) {				for (r = 0; r < vq->vqsize; r++) {
	    if (fgets (line, sizeof(line), fp) == NULL)			    if (fgets (line, sizeof(line), fp) == NULL)
		E_FATAL("Error reading row(%d)\n", r);				E_FATAL("Error reading row(%d)\n", r);
	    								    
	    if (s >= vq->n_sv)						    if (s >= vq->n_sv)
		continue;							continue;
	    								    
	    for (strp = line, c = 0; c < vq->gautbl[s].veclen		    for (strp = line, c = 0; c < vq->gautbl[s].veclen
		if (sscanf (strp, "%f %f%n",					if (sscanf (strp, "%f %f%n",
			    &(vq->gautbl[s].mean[r][c]), &(vq				    &(vq->gautbl[s].mean[r][c]), &(vq
		    E_FATAL("Error reading row(%d) col(%d)\n"			    E_FATAL("Error reading row(%d) col(%d)\n"
		strp += k;							strp += k;
	    }								    }
	}								}
									
	E_INFO("Reading map\n");					E_INFO("Reading map\n");
	if ((fgets (line, sizeof(line), fp) == NULL) ||			if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Map %d", &k) != 1) || (k != s))		    (sscanf (line, "Map %d", &k) != 1) || (k != s))
	    E_FATAL("Error reading map header\n", s);			    E_FATAL("Error reading map header\n", s);
									
	for (r = 0; r < vq->origsize.r; r++) {				for (r = 0; r < vq->origsize.r; r++) {
	    if (fgets (line, sizeof(line), fp) == NULL)			    if (fgets (line, sizeof(line), fp) == NULL)
		E_FATAL("Error reading row(%d)\n", r);				E_FATAL("Error reading row(%d)\n", r);
	    								    
	    if (s >= vq->n_sv)						    if (s >= vq->n_sv)
		continue;							continue;
	    								    
	    for (strp = line, c = 0; c < vq->origsize.c; c++)		    for (strp = line, c = 0; c < vq->origsize.c; c++)
		if (sscanf (strp, "%d%n", &(vq->map[r][c][s])			if (sscanf (strp, "%d%n", &(vq->map[r][c][s])
		    E_FATAL("Error reading row(%d) col(%d)\n"			    E_FATAL("Error reading row(%d) col(%d)\n"
		strp += k;							strp += k;
	    }								    }
	}								}
									
	fflush (stdout);						fflush (stdout);
    }								    }
    								    
    if ((fscanf (fp, "%s", line) != 1) || (strcmp (line, "End	    if ((fscanf (fp, "%s", line) != 1) || (strcmp (line, "End
	E_FATAL("Error reading 'End' token\n");				E_FATAL("Error reading 'End' token\n");
    								    
    fclose (fp);						    fclose (fp);
    								    
    subvq_maha_precomp (vq, varfloor);				    subvq_maha_precomp (vq, varfloor);
    subvq_map_compact (vq, g);					    subvq_map_compact (vq, g);
    subvq_map_linearize (vq);					    subvq_map_linearize (vq);
    								    
    n = 0;							    n = 0;
    for (s = 0; s < n_sv; s++) {				    for (s = 0; s < n_sv; s++) {
	if (vq->gautbl[s].veclen > n)					if (vq->gautbl[s].veclen > n)
	    n = vq->gautbl[s].veclen;					    n = vq->gautbl[s].veclen;
    }								    }
    assert (n > 0);						    assert (n > 0);
#ifdef THRD						      <
    for (s=0; s < vq->n_sv; s++)			      <
      vq->thrd_subvec[s] = (float32 *) ckd_calloc (n, sizeof( <
    							      <
    for (s = 0; s < NUM_THREADS; s++) {			      <
      vq->thrd_gauscore[s] = (int32 *) ckd_calloc (vq->origsi <
      vq->thrd_mgau_sl[s] = (int32 *) ckd_calloc (vq->origsiz <
    }							      <
							      <
#endif							      <
    vq->subvec = (float32 *) ckd_calloc (n, sizeof(float32));	    vq->subvec = (float32 *) ckd_calloc (n, sizeof(float32));
    vq->vqdist = (int32 **) ckd_calloc_2d (vq->n_sv, vq->vqsi	    vq->vqdist = (int32 **) ckd_calloc_2d (vq->n_sv, vq->vqsi
    vq->gauscore = (int32 *) ckd_calloc (vq->origsize.c, size	    vq->gauscore = (int32 *) ckd_calloc (vq->origsize.c, size
    vq->mgau_sl = (int32 *) ckd_calloc (vq->origsize.c + 1, s	    vq->mgau_sl = (int32 *) ckd_calloc (vq->origsize.c + 1, s
							      |	    
    return vq;							    return vq;
}								}


							      >
							      >
/*								/*
 * Based on previously computed subvq scores (Mahalanobis dis	 * Based on previously computed subvq scores (Mahalanobis dis
 * components in the given mixture (using the vq->map).		 * components in the given mixture (using the vq->map).
 * Return value: #Candidates in the returned shortlist.		 * Return value: #Candidates in the returned shortlist.
 */								 */
static int32 subvq_mgau_shortlist (subvq_t *vq,			static int32 subvq_mgau_shortlist (subvq_t *vq,
				   int32 m,	/* In: Mixtur					   int32 m,	/* In: Mixtur
				   int32 n,	/* In: #Compo					   int32 n,	/* In: #Compo
				   int32 beam)	/* In: Thresh					   int32 beam)	/* In: Thresh
{								{
    int32 *gauscore;						    int32 *gauscore;
    int32 *map;							    int32 *map;
    int32 i, v, bv, th, nc;					    int32 i, v, bv, th, nc;
    int32 *sl;							    int32 *sl;
    int32 *vqdist;						    int32 *vqdist;
    								    
    vqdist = vq->vqdist[0];	/* Since map is linearized fo	    vqdist = vq->vqdist[0];	/* Since map is linearized fo
				   look at vqdist[][] as vqdi					   look at vqdist[][] as vqdi
    gauscore = vq->gauscore;					    gauscore = vq->gauscore;
    sl = vq->mgau_sl;						    sl = vq->mgau_sl;
    								    
    /* Special case when vq->n_sv == 3; for speed */		    /* Special case when vq->n_sv == 3; for speed */
    map = vq->map[m][0];					    map = vq->map[m][0];
    bv = MAX_NEG_INT32;						    bv = MAX_NEG_INT32;
    								    
    switch (vq->n_sv) {						    switch (vq->n_sv) {
    case 3:							    case 3:
	for (i = 0; i < n; i++) {					for (i = 0; i < n; i++) {
	  if (VQ_EVAL == 1) {						  if (VQ_EVAL == 1) {
	    v = (int32) vqdist[*map];/* If we are not weighti		    v = (int32) vqdist[*map];/* If we are not weighti
	    map += 3;							    map += 3;
	  } else {							  } else {
	    /* RAH, we are ignoring the delta-delta, scoring 		    /* RAH, we are ignoring the delta-delta, scoring 
	    /* I believe it has to do with the beam widths */		    /* I believe it has to do with the beam widths */
	    if (VQ_EVAL == 2) {						    if (VQ_EVAL == 2) {
	      v = vqdist[*(map++)];			      |		    v = vqdist[*(map++)];
	      v += 2 * vqdist[*map]; /* RAH Count delta twice		      v += 2 * vqdist[*map]; /* RAH Count delta twice
	      map += 2;							      map += 2;
	    } else {							    } else {
	      v = vqdist[*(map++)];/* Standard way */			      v = vqdist[*(map++)];/* Standard way */
	      v += vqdist[*(map++)]; /*  */				      v += vqdist[*(map++)]; /*  */
	      v += vqdist[*(map)]; /*  */		      |		      v += vqdist[*(map++)]; /*  */
	    }								    }
	  }								  }

	  gauscore[i] = v;				      |		    gauscore[i] = v;
	  						      |		    
	  if (bv < v)					      |		    if (bv < v)
	    bv = v;					      |			bv = v;
	}								}
	break;								break;
    case 2:							    case 2:
	for (i = 0; i < n; i++) {					for (i = 0; i < n; i++) {
	    v = vqdist[*(map++)];					    v = vqdist[*(map++)];
	    v += vqdist[*(map++)];					    v += vqdist[*(map++)];
	    gauscore[i] = v;						    gauscore[i] = v;
	    								    
	    if (bv < v)							    if (bv < v)
		bv = v;								bv = v;
	}								}
	break;								break;
    case 1:							    case 1:
      for (i = 0; i < n; i++) {					      for (i = 0; i < n; i++) {
	v = vqdist[*(map++)];						v = vqdist[*(map++)];
	gauscore[i] = v;						gauscore[i] = v;
									
	if (bv < v)							if (bv < v)
	  bv = v;							  bv = v;
      }								      }
      break;							      break;
    default:							    default:
      E_FATAL("#Subvectors %d not yet implemented\n", vq->n_s	      E_FATAL("#Subvectors %d not yet implemented\n", vq->n_s
    }								    }
    								    
    th = bv + beam;						    th = bv + beam;
    nc = 0;							    nc = 0;
    for (i = 0; i < n; i++) {					    for (i = 0; i < n; i++) {
      if (gauscore[i] >= th)					      if (gauscore[i] >= th)
	sl[nc++] = i;							sl[nc++] = i;
    }								    }
    sl[nc] = -1;						    sl[nc] = -1;
    								    
    return nc;							    return nc;
}								}

#if 0							      |
void subvq_subvec_eval_logs3 (subvq_t *vq, float32 *feat, int	void subvq_subvec_eval_logs3 (subvq_t *vq, float32 *feat, int
{								{
    int32 i;							    int32 i;
    int32 *featdim;						    int32 *featdim;
    								    
    /* Extract subvector from feat */				    /* Extract subvector from feat */
    featdim = vq->featdim[s];					    featdim = vq->featdim[s];
    for (i = 0; i < vq->gautbl[s].veclen; i++)			    for (i = 0; i < vq->gautbl[s].veclen; i++)
	vq->subvec[i] = feat[featdim[i]];				vq->subvec[i] = feat[featdim[i]];
    								    
    /* Evaluate distances between extracted subvector and cor	    /* Evaluate distances between extracted subvector and cor
    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,	    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,
}								}
#endif							      |

void subvq_gautbl_eval_logs3 (subvq_t *vq, float32 *feat)	void subvq_gautbl_eval_logs3 (subvq_t *vq, float32 *feat)
{								{
    int32 s, i;							    int32 s, i;
    int32 *featdim;						    int32 *featdim;
    								    
    for (s = 0; s < vq->n_sv; s++) {				    for (s = 0; s < vq->n_sv; s++) {
	/* Extract subvector from feat */				/* Extract subvector from feat */
	featdim = vq->featdim[s];					featdim = vq->featdim[s];
	for (i = 0; i < vq->gautbl[s].veclen; i++) {	      |		for (i = 0; i < vq->gautbl[s].veclen; i++)
	  vq->subvec[i] = feat[featdim[i]];		      |		    vq->subvec[i] = feat[featdim[i]];
	}						      <
									
	/* Evaluate distances between extracted subvector and		/* Evaluate distances between extracted subvector and
    								    
	/* RAH, only evaluate the first VQ_EVAL set of featur |	    /* RAH, only evaluate the first VQ_EVAL set of features *
	if (s < VQ_EVAL) 				      |	    if (s < VQ_EVAL) 
	  vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->v <
	/*printf("vqsize %d veclen %d\n",vq->vqsize,vq->gautb <
							      <
    }							      <
}							      <
							      <
#ifdef THRD						      <
#ifdef NEW_EVAL_LOGS3					      <
							      <
int32 sema = 0;						      <
extern pthread_mutex_t update_lock;			      <
extern barrier_t *score_barrier;			      <
							      <
							      <
void thrd_subvq_gautbl_eval_logs3 (int subvec_num, subvq_t *v <
{							      <
							      <
  if (NUM_THREADS == 1) {				      <
    int32 s, i;						      <
    int32 *featdim;					      <
    							      <
    for (s=0; s < vq->n_sv; s++) {			      <
      /* Extract subvector from feat */			      <
      featdim = vq->featdim[s];				      <
      for (i = 0; i < vq->gautbl[s].veclen; i++) {	      <
	vq->subvec[i] = feat[featdim[i]];		      <
      }							      <
							      <
      if (s < VQ_EVAL)					      <
	/* Evaluate distances between extracted subvector and <
							      <
	/* RAH, only evaluate the first VQ_EVAL set of featur <
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqs		vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqs
    }								    }
    							      <
  } else { /* NUM_THREADS > 1 */			      <
							      <
							      <
  int32 s, i;						      <
  int32 *featdim;					      <
  const int32 vqsize = vq->vqsize;			      <
  const int32 n_sv = vq->n_sv;				      <
  const int32 remainder = (vqsize * n_sv)%NUM_THREADS;	      <
  int32 chunk_size = (vqsize * n_sv)/NUM_THREADS;	      <
  int32 offset;						      <
  int32 subv_ex;					      <
  							      <
  s = subvec_num*chunk_size; /* subvec_num is now the thread  <
  if (remainder>subvec_num) { s++; chunk_size++; };	      <
							      <
  offset = s % vqsize;					      <
  s /= vqsize; /* determine which vector to process */	      <
  if (DEBUG&0x4) fprintf(stderr,"thrd %d chunk_size %d offset <
			 subvec_num,chunk_size, offset, s);   <
							      <
  assert(s<n_sv && "subvec index out of range!!\n");	      <
#ifdef RSIM						      <
  lock();						      <
#else							      <
  pthread_mutex_lock(&update_lock);			      <
#endif							      <
  subv_ex = (sema++)%NUM_THREADS;			      <
							      <
#ifdef RSIM						      <
  unlock();						      <
#else							      <
  pthread_mutex_unlock(&update_lock);			      <
#endif							      <
							      <
  if (subv_ex < n_sv) {					      <
    if (DEBUG&0x4) fprintf(stderr,"thread %d subvec %d\n",sub <
    /* Extract subvector from feat */			      <
    featdim = vq->featdim[subv_ex];			      <
    for (i = 0; i < vq->gautbl[subv_ex].veclen; i++)	      <
      vq->thrd_subvec[subv_ex][i] = feat[featdim[i]];	      <
  }							      <
							      <
  if (DEBUG&0x4) fprintf(stderr,"thread %d before barrier \n" <
  							      <
#ifdef RSIM						      <
  ThreadBarrier();					      <
#else							      <
  thread_barrier(subvec_num,score_barrier);		      <
#endif							      <
							      <
  if (DEBUG&0x4) fprintf(stderr,"thread %d after barrier \n", <
							      <
  /* Evaluate distances between extracted subvector and corre <
  							      <
  /* RAH, only evaluate the first VQ_EVAL set of features */  <
  if (s < VQ_EVAL) {					      <
    if (offset+chunk_size > vqsize) {			      <
      if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d <
			     subvec_num,s,offset,vqsize-offse <
      vector_gautbl_eval_logs3(&(vq->gautbl[s]), offset, vqsi <
      chunk_size -= (vqsize-offset);			      <
    } else {						      <
      if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d <
			     subvec_num,s,offset,chunk_size); <
      vector_gautbl_eval_logs3(&(vq->gautbl[s]), offset, chun <
      chunk_size = 0;					      <
    }							      <
    							      <
    while (chunk_size>0) {				      <
      s++;						      <
      if (chunk_size > vqsize) {			      <
	if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval  <
			       subvec_num,s,0,vqsize);	      <
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vqsize, <
	chunk_size-=vqsize;				      <
      } else {						      <
	if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval  <
			       subvec_num,s,0,chunk_size);    <
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, chunk_s <
	chunk_size=0;					      <
      }							      <
							      <
    }							      <
  }							      <
							      <
#ifdef RSIM						      <
  ThreadBarrier();					      <
#else							      <
  thread_barrier(subvec_num,score_barrier);		      <
#endif							      <
  }							      <
}							      <
#endif /* end of NEW_EVAL_LOGS3 */			      <
							      <
#if 0							      <
void thrd_subvq_gautbl_eval_logs3 (int subvec_num, subvq_t *v <
{							      <
  int32 s, i;						      <
  int32 *featdim;					      <
							      <
  s = subvec_num;					      <
							      <
  /* Extract subvector from feat */			      <
  featdim = vq->featdim[s];				      <
  for (i = 0; i < vq->gautbl[s].veclen; i++)		      <
    vq->thrd_subvec[s][i] = feat[featdim[i]];		      <
    							      <
  /* Evaluate distances between extracted subvector and corre <
  							      <
  /* RAH, only evaluate the first VQ_EVAL set of features */  <
							      <
  if (s < VQ_EVAL) 					      <
    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, <
							      <
							      <
}								}
#endif							      <
#endif /* end THRD */					      <
							      <


int32 subvq_frame_eval (subvq_t *vq, mgau_model_t *g, int32 b	int32 subvq_frame_eval (subvq_t *vq, mgau_model_t *g, int32 b
			int32 *sen_active, int32 *senscr)				int32 *sen_active, int32 *senscr)
{								{
  int32 s;							  int32 s;
  int32 best, ns, ng;						  int32 best, ns, ng;
  								  
  best = MAX_NEG_INT32;						  best = MAX_NEG_INT32;
  ns = 0;							  ns = 0;
  ng = 0;							  ng = 0;
  								  
  if (! vq) {							  if (! vq) {
    /* No subvq model, use the original (SLOW!!) */		    /* No subvq model, use the original (SLOW!!) */
    for (s = 0; s < g->n_mgau; s++) {				    for (s = 0; s < g->n_mgau; s++) {
      if ((! sen_active) || sen_active[s]) {			      if ((! sen_active) || sen_active[s]) {
	senscr[s] = mgau_eval (g, s, NULL, feat);			senscr[s] = mgau_eval (g, s, NULL, feat);
	if (best < senscr[s])						if (best < senscr[s])
	  best = senscr[s];						  best = senscr[s];
	ns++;								ns++;
	ng += mgau_n_comp (g, s);					ng += mgau_n_comp (g, s);
      } else							      } else
	senscr[s] = S3_LOGPROB_ZERO;					senscr[s] = S3_LOGPROB_ZERO;
    }								    }
  } else {							  } else {
    /* Evaluate subvq model for given feature vector */		    /* Evaluate subvq model for given feature vector */
    subvq_gautbl_eval_logs3 (vq, feat);				    subvq_gautbl_eval_logs3 (vq, feat);
							      |	    
    /* Find mixture component shortlists using subvq scores, 	    /* Find mixture component shortlists using subvq scores, 
    for (s = 0; s < g->n_mgau; s++) {				    for (s = 0; s < g->n_mgau; s++) {
      if ((! sen_active) || sen_active[s]) {			      if ((! sen_active) || sen_active[s]) {
	ng += subvq_mgau_shortlist (vq, s, mgau_n_comp(g,s), 		ng += subvq_mgau_shortlist (vq, s, mgau_n_comp(g,s), 
									
	senscr[s] = mgau_eval (g, s, vq->mgau_sl, feat);		senscr[s] = mgau_eval (g, s, vq->mgau_sl, feat);
	if (best < senscr[s])						if (best < senscr[s])
	  best = senscr[s];						  best = senscr[s];
									
	ns++;								ns++;
							      <
      } else							      } else
	senscr[s] = S3_LOGPROB_ZERO;					senscr[s] = S3_LOGPROB_ZERO;
    }								    }
  }								  }
    								    
    /* Normalize senone scores */				    /* Normalize senone scores */
    for (s = 0; s < g->n_mgau; s++)				    for (s = 0; s < g->n_mgau; s++)
	senscr[s] -= best;						senscr[s] -= best;
    								    
    g->frm_sen_eval = ns;					    g->frm_sen_eval = ns;
    g->frm_gau_eval = ng;					    g->frm_gau_eval = ng;
    								    
    return best;						    return best;
}								}

/* RAH, free memory allocated by subvq_init() */		/* RAH, free memory allocated by subvq_init() */
void subvq_free (subvq_t *s)					void subvq_free (subvq_t *s)
{								{
  int i;							  int i;

  if (s) {							  if (s) {
    								    
    for (i=0;i<s->n_sv;i++) {					    for (i=0;i<s->n_sv;i++) {
      /*      vector_gautbl_free (&(s->gautbl[i]));*/	      |	      //      vector_gautbl_free (&(s->gautbl[i]));
      if (s->featdim[i]) ckd_free ((void *) s->featdim[i]);	      if (s->featdim[i]) ckd_free ((void *) s->featdim[i]);
    }								    }


    if (s->featdim) 						    if (s->featdim) 
      ckd_free ((void *) s->featdim);				      ckd_free ((void *) s->featdim);

    /* Free gaussian table */					    /* Free gaussian table */
    if (s->gautbl) 						    if (s->gautbl) 
      ckd_free ((void *)s->gautbl);      			      ckd_free ((void *)s->gautbl);      


    /* Free map */						    /* Free map */
    if (s->map)							    if (s->map)
      ckd_free_3d ((void ***) s->map);				      ckd_free_3d ((void ***) s->map);

    if (s->subvec) 						    if (s->subvec) 
      ckd_free ((void *) s->subvec);				      ckd_free ((void *) s->subvec);

    if (s->vqdist) 						    if (s->vqdist) 
      ckd_free_2d ((void **) s->vqdist);			      ckd_free_2d ((void **) s->vqdist);

    if (s->gauscore) 						    if (s->gauscore) 
      ckd_free ((void *) s->gauscore);				      ckd_free ((void *) s->gauscore);

    if (s->mgau_sl) 						    if (s->mgau_sl) 
      ckd_free ((void *) s->mgau_sl);				      ckd_free ((void *) s->mgau_sl);

									
    ckd_free ((void *)s);					    ckd_free ((void *)s);


  }								  }
}								}
