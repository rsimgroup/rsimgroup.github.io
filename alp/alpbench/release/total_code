/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <libgen.h>

#include <csuCommon.h>

#define OPENNING "Sample Recognition Rate Distributions from swapped Gallery and Probe Sets."

/*
   ============================================================================
 Copyright 2002, Colorado State University. All Rights Reserved.           
 --------------------------------------------------------------------------- 
 Permission to use, copy or modify this software and its documentation for   
 educational and research purposes only, provided that this copyright notice  
 appear on all copies and supporting documentation.                          
 ---------------------------------------------------------------------------        
 File:    csuPermute.c                                                     
 Authors: J. Ross Beveridge, Kai She, David Bolme                                        
 Date:    May 24, 2002                                                  
   ============================================================================
*/

/* ===========================================================================
 Compile time configuration optiosn     
*/

#define PRINT_LEVEL 2        /* Zero for a quiet program - nothing to stdout */
#define MAX_FSTRLEN 100      /* Upper bound on file name string lengths */
#define ITERATIONS 10000     /* How many times to sample gallery and probe sets, normally 10000 */


/* ===========================================================================
 Structures user here are:
  FERETID
  FIDPR
  PGSET
*/

/*
 The FERETID structure is used to facilitate most of the operations 
 performed in this file.  It contains critical information about the FERET 
 subject derived from the name. It is also used to carry back pointer information 
 for each test image. Specifically, the local subject index, running from 0 
 to the numSubjects-1, and the local replicate index, running from 0 to 
 numReplicates-1.  
*/

typedef struct feretid {
    char* text;     /* The text name designating FERET image distance file */
    /* char* type; */ /* The type of the image, fa, fb, etc. */
    int subject; /* The unique subject identifier */
    /* int day; */  /* The day of the month the image was collected */
    /* int month; */ /* The month the image was collected */
    /* int year; */ /* The year the image was collected */
    int index;      /* The local index into distance matrix */
    int si;   /* The local subject index */
    int ri;   /* The local replicate index */
}
FERETID;

/*
 The FIDPR, or FERERTID Pair, is a simple struct to maintain points to two
 instances of FERETIDs as well as a locally cached copy of the distance 
 between them. This simplifies sorting lists of paired images.
*/
typedef struct fidpr {
    FERETID** ids;   /* Will become a two element array, the ith and jth FERETID */
    float dist;   /* The distance between them drawn out of the distance array */
}
FIDPR;

/* The PGSET struct provides a single clean place to store information about
 a particular randomized selection of probe and gallery images. More is said
 below about its use. */

typedef struct pgset {
    int* gallery; /* Gallery replicate ri stored for each subject index si */
    int* probes;    /* Probe set replicate ri stored for each subject index si */
    int* gMarker;   /* One if image index is in gallery, zero otherwise */
    int* pMarker; /* One if image index is in gallery, zero otherwise */
    int* recCount;  /* An integer array to record recognition counts */
}
PGSET;

typedef struct {
    char* basename;
    FIDPR*** fidprs;
    int** recCounts;
    int** hist;
} AlgorithmData;



/*
 The next set of functions parse a FERET name and create an instance of a
 FERETID struct to represent that image. This section also includes code
 for the FIDPR struct.
*/


/*
 Create a new instance of the FERETID structure.  Parses the name to derive 
 the subject ID, the image type and the date.   The index passsed in is 
 used to record the local index of this particular FERETID. This index is 
 the index into the distance matrix for this particular image. When the 
 original set of image names are read from the test image names file, each 
 is given a unique local index such that the indices run from 0 to 
 numImages-1.
*/
FERETID* parseFERETID (char *name, int index, int subject) {
    FERETID* fid;
    char *tt;

    fid = (FERETID*) malloc(sizeof(FERETID));
    assert(fid);
    tt = (char*) malloc(sizeof(char) * MAX_FSTRLEN);
    assert(tt);

    strcpy(tt, name);
    fid->text = tt;
    fid->index = index;
    fid->subject = subject;
    return fid;
}


FIDPR* makeFIDPR(FERETID* fid0, FERETID* fid1, float** dist) {
    FIDPR* pr;
    FERETID** ids;

    pr = (FIDPR*) malloc(sizeof(FIDPR));
    assert(pr);
    ids = (FERETID**) malloc(sizeof(FERETID*) * 2);
    assert(ids);
    pr->ids = ids;
    pr->ids[0] = fid0;
    pr->ids[1] = fid1;
    pr->dist = dist[fid0->index][fid1->index];
    return pr;
}

/* This is the function used by quick sort to sort feret image pairs */
static int compareFIDPRs(const void *f1, const void *f2) {
    FIDPR **fidpr1 = (FIDPR**) f1;
    FIDPR **fidpr2 = (FIDPR**) f2;
    float d1 = (*fidpr1)->dist;
    float d2 = (*fidpr2)->dist;
    if (d1 > d2)
        return 1;
    if (d2 > d1)
        return -1;
    return 0;
}


/*
 Process test image names by building the master list of FERETIDs and 
 the subject replicates table.
*/

/* Given the array of FERETIDs, return the largest FERET subject index.
    This is extremely useful because we will want to built integer arrays
    that count how many times a subject appears in the test image set. */
int maxSubjectIndex( FERETID** fids, int numImages) {
    int i, max;

    max = 0;
    for (i = 0; i < numImages; i++) {
        if (fids[i]->subject > max)
            max = fids[i]->subject;
    }
    return max;
}

/* For each FERET subject ID, count up how many images are in the test
 image set.  These are the replicates from which probe and galleries 
 will be constructed. While doing this, it is convenient to record
 what will become the local subject index and the local replicate index, 
 i.e. FERETID fields si and ri.  This is a good place to do this 
 operation, because by going through subject ID in ascending order, 
 and assigning each a unique local index, the resulting table (si, ri) 
 will be sorted from least to greatest FERET subject id. 
 
 This function returns a count array indicating how many replicates
 appear for each subject. A zero indicates that there is a gap in the
 FERET subject ids, and zeroes can be expected. */
int* subjectCounts(FERETID** fids, int numImages, int *subjectIndexBound) {
    int i, j, max, siLocal;
    int *subCounts, *subIndex;
    siLocal = 0;
    max = maxSubjectIndex(fids, numImages);
    subCounts = (int*) malloc(sizeof(int) * (max + 1));
    assert(subCounts);
    subIndex = (int*) malloc(sizeof(int) * (max + 1));
    assert(subCounts);
    for (i = 0; i < (max + 1); i++)
        subCounts[i] = 0;
    for (i = 0; i < (max + 1); i++) {
        for (j = 0; j < numImages; j++) {
            if (i == fids[j]->subject) {
                if (subCounts[i] == 0) {
                    subIndex[i] = siLocal++;
                }
                fids[j]->si = subIndex[i];
                fids[j]->ri = subCounts[i];
                subCounts[i]++;
            }
        }
    }
    *subjectIndexBound = max + 1;
    return subCounts;
}

/* Find the largest number of replicates that appear for any subject */
int maxReplicateCount(int* subCounts, int n) {
    int i, max;
    max = 0;
    for (i = 0; i < n; i++) {
        if (max < subCounts[i]) {
            max = subCounts[i];
        }
    }
    return max;
}


FERETID*** subjectReplicatesTable(ImageList **iml, int *numImages, int *numSubjects, int *numReplicates, FERETID ***fids) {
    int i, s, r, expectedReplicates;
    FERETID*** srt;
    ImageList *subject, *replicate;

    *numImages = 0;
    *numSubjects = 0;
    expectedReplicates = 0;
    /*  First pass through subject replicates list to determine how many subject, how many replicates,
        and that there are the same number of replicates for each subject */
    for (subject = *iml; subject; subject = subject->next_subject) {
        (*numSubjects)++;
        (*numReplicates) = 0;
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            (*numImages)++;
            (*numReplicates)++;
        }
        if ((*numSubjects != 1) && ((*numReplicates) != expectedReplicates) ) {
            fprintf(stderr, "Error, encountered different number of replicates for subject %s\n", subject->filename);
            /* printout debug info and exit */
            exit(1);
        }
        expectedReplicates = (*numReplicates);
    }
    /* Now build the subject replicates table as a 2D array and populate it with FERET IDs */
    srt = (FERETID***) malloc(sizeof(FERETID**) * (*numSubjects));
    assert(srt);
    for (i = 0; i < *numSubjects; i++) {
        srt[i] = (FERETID**) malloc(sizeof(FERETID*) * (*numReplicates));
        assert(srt[i]);
    }

    /* Now build the feret id array */
    (*fids) = (FERETID**) malloc(sizeof(FERETID*) * (*numImages));
    assert(fids);

    i = 0;
    s = 0;
    for (subject = *iml; subject; subject = subject->next_subject) {
        r = 0;
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            srt[s][r] = parseFERETID(replicate->filename, i, s);
            (*fids)[i++] = srt[s][r];
            r++;
        }
        s++;
    }
    return srt;
}


/*
 The function readDistances uses the function getLocalIndex to determine
 the local index of the image for which a distance value is currently being
 read from file.
 
 getLocalIndex is given an image name, it then performs an exhaustive search
 of the subject replicate table to find a match.  If the match is found the
 local index of the image is returned.  Otherwise -1 is returned to indicate no
 match was found.
 
 */

int getLocalIndex(char *name, FERETID*** srt, int numReplicates, int maxSub) {
    int i, j;
    for (i = 0; i < maxSub; i++) {
        for (j = 0; j < numReplicates; j++) {
            if (!strcmp(name, srt[i][j]->text)) {
                return srt[i][j]->index;
            }
        }
    }

    /* name not found so return -1 */
    return -1;
}

/* This procedure iterates through the list of subject names opening the
 corresponding file of distances to other images in the data directory.
 Note that the subject names ARE the file names for the sake of this code.
 When reading a given data file, each record is assumed to contain two
 entries: the name of the other image and the distance to this other 
 image. The code is not robust with respect to changes in this format.
 
 This code is robust with respect to placing the distance into the distance
 matrix based upon the image name. So, entries corresponding to images not
 in the test image file are ignored. Also, if the order of the images in
 the distance file is permuted, this code will still behave properly.
*/


float** readDistances(FERETID** fids, FERETID*** srt, int numImages, int numReplicates, int numSubjects, char *dir) {
    int i, li;
    char buffer[100];
    char *bn, *bv, *name;
    float **dist;
    FILE *f;

    name = (char*) malloc(sizeof(char) * MAX_FSTRLEN);
    bn = (char*) malloc(sizeof(char) * MAX_FSTRLEN);
    bv = (char*) malloc(sizeof(char) * MAX_FSTRLEN);

    dist = (float **) malloc(numImages * sizeof(float*));
    assert(dist);
    for (i = 0;i < numImages; i++) {
        dist[i] = (float*) malloc(numImages * sizeof(float));
        assert(dist[i]);
    }
    fflush(stdout);
    for (i = 0; i < numImages; i++) {
        sprintf(name, "%s/%s", dir, fids[i]->text);
        f = fopen(name, "r");
        if (f == NULL) {
            printf("\n Cannot open %s to read!\n", name);
            exit(1);
        }
        while (fgets(buffer, 100, f)) {
            sscanf(buffer, "%s %s", bn, bv);
            li = getLocalIndex(bn, srt, numReplicates, numSubjects);
            if (li != -1) {
                dist[i][li] = atof(bv);
                /** printf("\n Distance entry %d %d is %f.", i, li, dist[i][li]);*/
            }
        }
        fclose(f);
    }
    return dist;
}


/*
 For each test image, build a sorted array of paired FERET ids, one for 
 test images, and the other for all other test images. 
*/
FIDPR*** buildSortedPairedMatrix(FERETID** fids, int numImages, float** dist) {
    int i, j;
    FIDPR*** fidprs;

    fidprs = (FIDPR***) malloc(sizeof(FIDPR**) * numImages);
    assert(fidprs);
    for (i = 0; i < numImages; i++) {
        fidprs[i] = (FIDPR**) malloc(sizeof(FIDPR*) * numImages);
        assert(fidprs);
    }

    for (i = 0; i < numImages; i++) {
        for (j = 0; j < numImages; j++) {
            fidprs[i][j] = makeFIDPR(fids[i], fids[j], dist);
        }
    }

    for (i = 0; i < numImages; i++) {
        qsort(fidprs[i], numImages, sizeof(FIDPR*), compareFIDPRs);
    }

    return fidprs;
}

void printPairedMatrix( FIDPR*** fidprs, int numImages) {
    int i, j;
    FIDPR* fidpr;
    FERETID* fid0;
    FERETID* fid1;
    for (i = 0; i < numImages; i++) {
        printf("\n");
        for (j = 0; j < numImages; j++) {
            fidpr = fidprs[i][j];
            fid0 = fidpr->ids[0];
            fid1 = fidpr->ids[1];
            printf(" <%d %d %d %d>", fid0->si, fid0->ri, fid1->si, fid1->ri);
        }
    }
    for (i = 0; i < numImages; i++) {
        printf("\n");
        for (j = 0; j < numImages; j++) {
            printf(" %5.0f", fidprs[i][j]->dist);
        }
    }
}

/*
 Generate subsets of test images to serve as gallery and probe sets
 
 These choices are stored in a PGSET struct that keeps track of the 
 gallery images and the probe images using two different representations.
 The first is an array indexed by local subject id, the same as the srt
 table, and it indicates which replicate is in the set for each subject.
 The second is a marker array indexed by image index, running from 0 to 
 numImages, and a one in the marker array indicates inclusion of the 
 image in the probe/gallery set. This second form is convenient for
 controlling selection and counting while iterating through the complete
 set of test images.
 
 The PGDSET structure is intended to be reused: creating a new one for 
 each of thousands of random choices of probe and gallery sets would be 
 slow at best and proably exhaust memory.
 */

PGSET* makePGSET(int numImages, int numSubjects) {
    PGSET* pgs = (PGSET*) malloc(sizeof(PGSET));
    assert(pgs);

    pgs->gallery = (int*) malloc(sizeof(int) * numSubjects);
    assert(pgs->gallery);
    pgs->probes = (int*) malloc(sizeof(int) * numSubjects);
    assert(pgs->probes);
    pgs->gMarker = (int*) malloc(sizeof(int) * numImages);
    assert(pgs->gMarker);
    pgs->pMarker = (int*) malloc(sizeof(int) * numImages);
    assert(pgs->pMarker);

    return pgs;
}

/* The next two functions are very convenient for debugging, but not
 used in the mature released code. Of course, they are kept around 
 because, well debugging may become relevant again :-)
*/
void listPGSETimages1(PGSET* pgs, FERETID** fids, int numImages) {
    int i, c;
    c = 0;
    for (i = 0; i < numImages; i++) {
        if (pgs->gMarker[i]) {
            printf("\n Gallery image %d is %s.", c++, fids[i]->text);
        }
    }
    c = 0;
    for (i = 0; i < numImages; i++) {
        if (pgs->pMarker[i]) {
            printf("\n Probe image %d is %s.", c++, fids[i]->text);
        }
    }
}

void listPGSETimages2(PGSET* pgs, FERETID*** srt, int numSubjects) {
    int si, ri;
    FERETID* gfid, *pfid;

    for (si = 0; si < numSubjects; si++) {
        ri = pgs->gallery[si];
        gfid = srt[si][ri];
        ri = pgs->probes[si];
        pfid = srt[si][ri];
        printf("\n  Gallery %s \t Probe %s", gfid->text, pfid->text);
    }
}



/**
 The randomized selection of probe and gallery images is accomplished by
 shuffling the local subject indices in the srt table and then selecting
 from the columns of this matrix using a fixed pattern. The pattern grows
 in length as the number of replicates increase. So, for example, if
 numReplicates = 2
       r1  r2
   1   p   g
   2   g   p
 For 3 replicates
       r1  r2  r3
   1   p   g   -
   2   p   -   g
   3   g   p   -
   4   -   p   g
   5   g   -   p
   6   -   g   p
 For 4 replicates
       r1  r2  r3  r4
   1   p   g   -   -
   2   p   -   g   -
   3   p   -   -   g
   4   g   p   -   -
   5   -   p   g   -
   6   -   p   -   g
   7   g   -   p   -
   8   -   g   p   -
   9   -   -   p   g
  10   g   -   -   p
  11   -   g   -   p
  12   -   -   g   p
*/

void fullBalancePattern(int* p, int* g, int numReplicates) {
    int i, pc, gc;

    i = 0;
    for (pc = 0; pc < numReplicates; pc++) {
        for (gc = 0; gc < numReplicates; gc++) {
            if (pc != gc) {
                p[i] = pc;
                g[i] = gc;
                i++;
            }
        }
    }
}

/*
    The repetive pattern of selection from the columns of the srt matrix are
 captured in the probe pattern, pp, and gallery pattern, gp arrays.  These
 are then used in conjunction with a shuffled set of indices into the rows
 of the srt matrix to gather the probe and gallery sets.
*/
void balancedSelectionProbeGallery(PGSET* pgs, FERETID*** srt, int numImages,
                                   int numSubjects, int numReplicates) {
    int i, si, ri;
    int *shuff;
    int *pp, *gp;
    int runLen;

    runLen = numReplicates * (numReplicates - 1);
    pp = (int*) malloc(sizeof(int) * (runLen));
    assert(pp);
    gp = (int*) malloc(sizeof(int) * (runLen));
    assert(gp);
    fullBalancePattern(pp, gp, numReplicates);

    shuff = shuffle(numSubjects);
    for (i = 0; i < numSubjects; i++) {
        pgs->gallery[shuff[i]] = gp[i % runLen];
        pgs->probes[shuff[i]] = pp[i % runLen];
    }

    for (i = 0; i < numImages; i++) {
        pgs->gMarker[i] = 0;
        pgs->pMarker[i] = 0;
    }

    for (si = 0; si < numSubjects; si++) {
        ri = pgs->gallery[si];
        i = srt[si][ri]->index;
        pgs->gMarker[i] = 1;
        ri = pgs->probes[si];
        i = srt[si][ri]->index;
        pgs->pMarker[i] = 1;
    }
}

/*
 Given a probe and gallery set selection and the test images sorted
 by ascending distance, compute the recognition counts at ranks 1 through
 the upper bound specified.  Recognition count is the raw number correctly
 recognized at a given rank. It may latter be turned into a percentage, 
 i.e. a rank.
 
 As an intermediate step, the recognition rank is determined for each of the
 probe images.  As a nod to efficiency in this particular code, the arrays
 used to store recognition rank and recognition rate are passed as
 arguments.  
 
 Recognition rank is indexed from zero to numSubjects minus one.  Each entry
 representing the recognition rank for a distinct probe image.  Recognition
 Count is indexed from one to numSubjects inclusive.  The zero position
 represents the number of images correctly recognized at rank one, and the
 first position rank two.  etc.  While the logic computes it, note that the
 numSubjects position must have a constant value: the number of subjects.
*/

int* makeRecRanks(int numSubjects) {
    int* r;
    r = (int*) malloc(sizeof(int) * (numSubjects));
    assert(r);
    return r;
}

int* makeRecCount(int numSubjects) {
    int* r;
    r = (int*) malloc(sizeof(int) * (numSubjects + 1));
    assert(r);
    return r;
}

/* This two dimensional array of recognition counts is indexed by the
 iteration number t and the rank.  It is large, but it also represents
 the complete summary of the performance over the iterations. Finally,
 it will be used to build histograms of the recognition count at rank 1,
 rank 2, etc.
*/

int** makeRecCounts(int iterations, int numSubjects) {
    int **r, t;
    r = (int**) malloc(sizeof(int*) * iterations);
    assert(r);
    for (t = 0; t < iterations; t++) {
        r[t] = (int*) malloc(sizeof(int) * (numSubjects + 1));
        assert(r[t]);
    }
    return r;
}

void printRecCount(int* recCount, int max) {
    int i;
    for (i = 1; i <= max; i++) {
        printf("\n  Rec Count at rank %2d is %d.", i + 1, recCount[i]);
    }
}

/*  The recognition rank is found by searching down the sorted list of
 FERETID Pairs until a match is found between the probe and the gallery
 subject.  Here the first index of ids in the pair represents the probe
 and the second represents the gallery. Thus, the probe subject ID can
 be taken from any of the entries: it is taken from the first for 
 convenience. 
*/

int recognitionRank(FIDPR** gal, int* marker, int numImages) {
    int i, count, subject, match;
    subject = gal[0]->ids[0]->subject;
    count = 0;
    i = 0;
    match = 0;
    while (!match) {
        if (marker[gal[i]->ids[1]->index]) {
            if (gal[i]->ids[1]->subject == subject) {
                match = 1;
            }
            count++;
        }
        i++;
        if (i > numImages) {
            printf("Error: somehow failed to match subjects in function recognitionRank.");
            exit(1);
        }
    }
    return count;
}

void loadRecognitionCounts(PGSET* pgs, FIDPR*** fidprs, int* recRanks, int* recCount,
                           int numImages, int numSubjects) {
    int i, pi, rank, count;

    pi = 0;
    for (i = 0; i < numImages; i++) {
        if (pgs->pMarker[i]) {
            recRanks[pi] = recognitionRank(fidprs[i], pgs->gMarker, numImages);
            /* printf("\n Recognition rank for probe %d is %d.", pi, recRanks[pi]); */
            pi++;
        }
    }
    i = 0;
    for (rank = 1; rank <= numSubjects; rank++) {
        count = 0;
        for (i = 0; i < numSubjects; i++) {
            if (recRanks[i] <= rank)
                count++;
        }
        recCount[rank] = count;
    }
}

/* ====================================================================
 Histograms represent the sample distributions for recognition Count, 
 or after normalization, rate.  There is one histogram built for each
 recognition rank from one to the max rank passed in.
*/

int** histogramRecognitionCounts(int** recCounts, int iterations, int numSubjects) {
    int i, rank, count, rc;
    int** hist;
    int* h;
    hist = (int**) malloc(sizeof(int*) * (numSubjects + 1));
    assert(hist);
    for (i = 0; i <= numSubjects; i++) {
        hist[i] = (int*) malloc(sizeof(int) * (numSubjects + 1));
        assert(hist[i]);
    }
    for (rank = 1; rank <= numSubjects; rank++) {
        for (count = 0; count <= numSubjects; count++) {
            hist[rank][count] = 0;
        }
    }
    for (rank = 1; rank <= numSubjects; rank++) {
        h = hist[rank];
        for (i = 0; i < iterations; i++) {
            rc = recCounts[i][rank];
            h[rc]++;
        }
    }
    return hist;
}

int** histogramCompareCounts(int** recCounts1, int** recCounts2, int iterations, int numSubjects) {
    int i, rank, count, rc;
    int** hist;
    int* h;
    int zero = numSubjects + 1;
    hist = (int**) malloc(sizeof(int*) * (numSubjects + 1));
    assert(hist);
    for (i = 0; i <= numSubjects; i++) {
        hist[i] = (int*) malloc(sizeof(int) * (2*numSubjects + 1));
        assert(hist[i]);
    }
    for (rank = 1; rank <= numSubjects; rank++) {
        for (count = -numSubjects; count <= numSubjects; count++) {
            hist[rank][zero+count] = 0;
        }
    }
    for (rank = 1; rank <= numSubjects; rank++) {
        h = hist[rank];
        for (i = 0; i < iterations; i++) {
            rc = recCounts1[i][rank]-recCounts2[i][rank];
            h[zero+rc]++;
        }
    }
    return hist;
}

void printHistogram(int** hist, int rank, int numSubjects) {
    int rc;
    int sum;
    sum = 0;
    printf("\nHistgram of recognition counts at rank %d", rank);
    for (rc = 0; rc <= numSubjects; rc++) {
        printf("\n  %3d \t %d", rc, hist[rank][rc]);
        sum = sum + hist[rank][rc];
    }
    printf("\n  Sums to %d", sum);
}

/* Determine the mode, i.e. the high point, on the histograms for all rank
 values and return these in an integer array indexed from 1 to numSubjects
 inclusive. Also determine the lower bound of the confidence interval, 
 the upper bound, and the mean recognition rate. */
int* recRateMode(int** hist, int numSubjects) {
    int rank, rr, maxrr, mode = 0;
    int* m = (int*) malloc(sizeof(int) * (numSubjects + 1));
    assert(m);

    for (rank = 1; rank <= numSubjects; rank++) {
        maxrr = -1;
        for (rr = 0; rr <= numSubjects; rr++) {
            if (hist[rank][rr] > maxrr) {
                maxrr = hist[rank][rr];
                mode = rr;
            }
        }
        m[rank] = mode;
    }
    return m;
}

float* recRateMean(int** hist, int numSubjects) {
    int rank, rr, wsum, sum;
    float* m = (float*) malloc(sizeof(float) * (numSubjects + 1));
    assert(m);

    for (rank = 1; rank <= numSubjects; rank++) {
        wsum = 0;
        sum = 0;
        for (rr = 0; rr <= numSubjects; rr++) {
            wsum = wsum + hist[rank][rr] * rr;
            sum = sum + hist[rank][rr];
        }
        m[rank] = ((float) wsum) / ((float) sum);
    }
    return m;
}

int* recRateLowerBound(int** hist, int numSubjects, int iterations, float boundingProb) {
    int rank, rr, stopCount, cum;
    int* lb = (int*) malloc(sizeof(int) * (numSubjects + 1));
    assert(lb);

    stopCount = (int) (boundingProb * (float) iterations);
    for (rank = 1; rank <= numSubjects; rank++) {
        cum = 0;
        rr = 0;
        while ((cum < stopCount) && (rr <= numSubjects)) {
            cum = cum + hist[rank][rr];
            rr++;
        }
        lb[rank] = rr - 1;
    }
    return lb;
}

int* recRateUpperBound(int** hist, int numSubjects, int iterations, float boundingProb) {
    int rank, rr, stopCount, cum;
    int* ub = (int*) malloc(sizeof(int) * (numSubjects + 1));
    assert(ub);

    stopCount = (int) (boundingProb * (float) iterations);
    for (rank = 1; rank <= numSubjects; rank++) {
        cum = 0;
        rr = numSubjects;
        while ((cum < stopCount) && (rr >= 0)) {
            cum = cum + hist[rank][rr];
            rr--;
        }
        ub[rank] = rr + 1;
    }
    return ub;
}


void generateHistogramDistributionReports(char *outFilePrefix, char *algBasename, int **hist, int numSubjects, int iterations) {
    FILE *f;
    int rank, rc;
    float rr;
    char name[MAX_FSTRLEN];

    /* The histogram of raw counts */
    sprintf(name, "%s%s_%s", outFilePrefix, algBasename, "HistCounts.txt");
    f = fopen(name, "w");
    if (f == NULL) {
        printf("can not open %s to wirte\n", name);
        exit(1);
    }
    fprintf(f, "rc\trr ");
    for (rank = 1; rank <= numSubjects; rank++) {
        fprintf(f, "\tr%d", rank);
    }
    for (rc = 0; rc <= numSubjects; rc++) {
        rr = ((float) rc) / ((float) numSubjects);
        fprintf(f, "\n%d\t%5.2f", rc, rr);
        for (rank = 1; rank <= numSubjects; rank++) {
            fprintf(f, "\t%d", hist[rank][rc]);
        }
    }
    fclose(f);

    /* The histogram of normalized counts - sample probabilities */
    sprintf(name, "%s%s_%s", outFilePrefix,algBasename, "HistProbs.txt");
    f = fopen(name, "w");
    if (f == NULL) {
        printf("can not open %s to wirte\n", name);
        exit(1);
    }
    fprintf(f, "rc\trr ");
    for (rank = 1; rank <= numSubjects; rank++) {
        fprintf(f, "\tr%d", rank);
    }
    for (rc = 0; rc <= numSubjects; rc++) {
        rr = ((float) rc) / ((float) numSubjects);
        fprintf(f, "\n%d\t%5.2f", rc, rr);
        for (rank = 1; rank <= numSubjects; rank++) {
            fprintf(f, "\t%5.4f", ((float) hist[rank][rc]) / ((float) iterations));
        }
    }
    fclose(f);
}

void generateCumulativeMatchCurveReport(char *outFilePrefix, char *algBasename, int **hist, int numSubjects, int iterations) {
    int rank;
    FILE *f;
    char name[MAX_FSTRLEN];
    int *mode, *lb, *ub;
    float *mean;

    mode = recRateMode(hist, numSubjects);
    lb = recRateLowerBound(hist, numSubjects, iterations, 0.025);
    ub = recRateUpperBound(hist, numSubjects, iterations, 0.025);
    mean = recRateMean(hist, numSubjects);

    /* The histogram of raw counts */
    sprintf(name, "%s%s_%s", outFilePrefix,algBasename, "CMCurve.txt");
    f = fopen(name, "w");
    if (f == NULL) {
        printf("can not open %s to wirte\n", name);
        exit(1);
    }
    fprintf(f, "\nrank\tlower\tmode\tupper\tmean");
    for (rank = 1; rank <= numSubjects; rank++) {
        fprintf(f, "\n%d\t%d\t%d\t%d\t%5.1f", rank, lb[rank], mode[rank], ub[rank], mean[rank]);
    }
    fclose(f);
}


#define TR_START(file) fprintf((file),"<TR>\n")
#define TR_END(file) fprintf((file),"</TR>\n")
#define TD_STRING(file,var) fprintf((file),"<TD>%s</TD>\n",(var))
#define TD_RSTRING(file,var) fprintf((file),"<TD><FONT COLOR=RED>%s</FONT></TD>\n",(var))
#define TD_FLOAT(file,var) fprintf((file),"<TD>%0.2f</TD>\n",(var))
#define TD_PERC(file,var) fprintf((file),"<TD>%0.1f%%</TD>\n",(var))
#define TD_PROB(file,var) fprintf((file),"<TD>%0.4f</TD>\n",(var))
#define TD_RPROB(file,var) fprintf((file),"<TD><FONT COLOR=RED>%0.4f</FONT></TD>\n",(var))
#define TD_INT(file,var) fprintf((file),"<TD>%d</TD>\n",(var))


void generateRankNComparisonReport(int n, char *outFilePrefix, AlgorithmData** algData, int numDistDir, int numSubjects, int iterations) {
    int zero = numSubjects + 1;
    int alg, alg1, alg2;
    FILE *f;
    char name[MAX_FSTRLEN];
    int *mode, *lb, *ub;
    float *mean;
    double ns = numSubjects;
    /* The histogram of raw counts */
    sprintf(name, "%s_Rank%d.html", outFilePrefix, n);
    f = fopen(name, "w");
    if (f == NULL) {
        printf("can not open %s to wirte\n", name);
        exit(1);
    }

    fprintf(f, "<HTML><HEAD><TITLE>Rank %d: Algorithm Comparision Report</TITLE></HEAD><BODY>\n",n);
    fprintf(f, "<H1>Rank %d: Algorithm Comparision Report</H1><HR>\n",n);
    fprintf(f, "<P><H2>Algorithms Tested:</H2>\n<P><UL>\n");
    for(alg = 0; alg < numDistDir; alg++){
        fprintf(f, "<LI>%s</LI>\n",algData[alg]->basename);
    }
    fprintf(f, "</UL><HR>\n");

    fprintf(f, "<H2>Permutation Results:</H2>\n");


    fprintf(f, "<TABLE BORDER=2><TR><TH>Algorithm</TH><TH>Mean</TH><TH>Mode</TH><TH>Lower</TH><TH>Upper</TH>"
               "<TH>Mean%%</TH><TH>Mode%%</TH><TH>Lower%%</TH><TH>Upper%%</TH></TR>\n");
    for(alg = 0; alg < numDistDir; alg++){
        mode = recRateMode(algData[alg]->hist, numSubjects);
        lb = recRateLowerBound(algData[alg]->hist, numSubjects, iterations, 0.025);
        ub = recRateUpperBound(algData[alg]->hist, numSubjects, iterations, 0.025);
        mean = recRateMean(algData[alg]->hist, numSubjects);
        fprintf(f, "<TR><TD>%s</TD><TD>%0.1f</TD><TD>%d</TD><TD>%d</TD><TD>%d</TD>"
                   "<TD>%0.1f%%</TD><TD>%0.1f%%</TD><TD>%0.1f%%</TD><TD>%0.1f%%</TD></TR>\n",
                   algData[alg]->basename, mean[n], mode[n], lb[n], ub[n], 100.0*mean[n]/ns, 100.0*mode[n]/ns, 100.0*lb[n]/ns, 100.0*ub[n]/ns);
    }
    fprintf(f, "</TABLE><HR>\n");

    fprintf(f, "<H2>Comparing Algorithms (Alg1 - Alg2): </H2>\n");
    fprintf(f, "<TABLE BORDER=2><TR><TH>Algorithm 1</TH><TH>Algorithm 2</TH>"
               "<TH>Mean</TH><TH>Mode</TH><TH>Lower</TH><TH>Upper</TH><TH>P(Alg1 > Alg2)</TH><TH>P(Alg1 < Alg2)</TH></TR>\n");
    for(alg1 = 0; alg1 < numDistDir; alg1++){
        for(alg2 = alg1 + 1; alg2 < numDistDir; alg2++){
            int** diffhist;
            float diff_mean;
            int diff_mode = 0;
            int diff_upper = 0;
            int total_count = 0;
            int diff_lower = 0;
            int PAlg1 = 0, PAlg2 = 0;
            int count = 0;
            int maxrr = -1;
            int sum = 0;

            /* Compute the difference histogram */
            diffhist = histogramCompareCounts(algData[alg1]->recCounts, algData[alg2]->recCounts, iterations, numSubjects);

            /* Calculate the Histogram Statistics */
            for (count = -numSubjects; count <= numSubjects; count++) {
                if( maxrr < diffhist[n][zero+count] ){
                    maxrr = diffhist[n][zero+count];
                    diff_mode = count;
                }

                if(count > 0) PAlg1 += diffhist[n][zero+count];
                if(count < 0) PAlg2 += diffhist[n][zero+count];
                sum += count*diffhist[n][zero+count];

                if(total_count < 0.975*iterations){
                    diff_upper = count;
                }
                total_count += diffhist[n][zero+count];
                if(total_count < 0.025*iterations){
                    diff_lower = count+1;
                }
            }
            diff_mean = ((double)sum)/iterations;

            TR_START(f);
            if(((double)PAlg1)/iterations > ((double)PAlg2)/iterations){
                TD_RSTRING(f,algData[alg1]->basename);
            }
            else{
                TD_STRING(f,algData[alg1]->basename);
            }

            if(((double)PAlg1)/iterations < ((double)PAlg2)/iterations){
                TD_RSTRING(f,algData[alg2]->basename);
            }
            else{
                TD_STRING(f,algData[alg2]->basename);
            }

            TD_FLOAT(f,diff_mean);
            TD_INT(f,diff_mode);
            TD_INT(f,diff_lower);
            TD_INT(f,diff_upper);
            if(((double)PAlg1)/iterations >= 0.95){
                TD_RPROB(f,((double)PAlg1)/iterations);
            }
            else{
                TD_PROB(f,((double)PAlg1)/iterations);
            }

            if(((double)PAlg2)/iterations >= 0.95){
                TD_RPROB(f,((double)PAlg2)/iterations);
            }
            else{
                TD_PROB(f,((double)PAlg2)/iterations);
            }
            TR_END(f);
        }
    }
    fprintf(f, "</TABLE>\n");

    fprintf(f, "done.</BODY></HTML>\n");
    fclose(f);
}


/* Process the command line arguments */

void usage(const char* progname){
    printf("\nThree command line arguments required:\n");
    printf("1: .srt File of test image names.\n");
    printf("2: Prefix for output file names.\n");
    printf("3: List of directorys to read distances files from.\n");
    exit(1);
}

void readArgs(int argc, char *argv[], int* numDistDir, char ***distDir, char **distFileNames, char **outFilePrefix) {
    int i;

    if ((argc < 4) || (strcmp(argv[1], "-help") == 0)) {
        usage(argv[0]);
    }
    *distFileNames = argv[1];
    *outFilePrefix = argv[2];
    (*distDir)=malloc(sizeof(char*)*(argc-3));
    *numDistDir = (argc-3);
    for(i = 0; i < *numDistDir; i++){
        (*distDir)[i] = argv[i+3];
    }
    if (PRINT_LEVEL > 0) {
        printf("\nCommand Line arguments are:\n");
        printf("  Directory from which to read distance files ... %s\n", (*distDir)[0]);
        printf("  .srt File of test image names ...................... %s\n", *distFileNames);
        printf("  Prefix for output file names .................. %s\n", *outFilePrefix);
    }
}

/*

This function will create and configure experiment datastructures for one
distance matrix. It starts by reading in the distance matrix for the set of
images. It then, for each test image, builds a sorted list of the other test
images. This is done once, and expedites computing recognition rate for each
of the many, typicaly 10,000, iterations of randomly swapping probe and
gallery images.

*/

AlgorithmData* loadAlgoirthmData(char *distDir, FERETID*** srt, int numSubjects, int numReplicates, int numImages, FERETID** fids){
    int i;
    float** dist;
    int lastchar;
    AlgorithmData* data = malloc(sizeof(AlgorithmData));



    if (PRINT_LEVEL > 0)
        printf("\nReading in distance matrix.");
    dist = readDistances(fids, srt, numImages, numReplicates, numSubjects, distDir);

    if (PRINT_LEVEL > 0)
        printf("\nSorting image pairs by ascending distance.");
    data->fidprs = buildSortedPairedMatrix(fids, numImages, dist);

    data->recCounts = makeRecCounts(ITERATIONS, numSubjects);

    for( i = 0; i < numImages; i++){
        free(dist[i]);
    }
    free(dist);

    lastchar = strlen(distDir)-1;
    if(distDir[lastchar] == '/'){
        distDir[lastchar] = 0;
    }
    data->basename = strdup(basename(distDir));

    return data;
}

/*
                                        MAIN
   
   This code will read the file of test images names and then build the 
   distance matrix by reading each of the distance files in the distances
   directory. It then, for each test image, builds a sorted list of the
   other test images. This is done once, and expedites computing recognition
   rate for each of the many, typicaly 10,000, iterations of randomly swapping
   probe and gallery images. At the end, three files are generated that contain
   summaries of the results. Specifically, there are two versions of the
   recognition rate histograms: one using raw integer counts and the other 
   normalized values. The later may be interpreted as probabilities and the 
   histogram as a whole as a sample probability density function. The last
   report gives the cumulative match curve along defined by the mode of these 
   distributions, along with error bars defined by the two-sides ninety five 
   percent confidence interval. 

*/

int main(int argc, char *argv[]) {
    int t, d, numSubjects, numReplicates, numImages;
    char **distDir;     /* Name of the directory where distance files are stored */
    char *distFileNames;  /* Name imagefile used for the experiment */
    char *outFilePrefix;    /* Name of the file to which results are written */
    FERETID** fids;
    FERETID*** srt;
    PGSET* pgs;
    int* recRanks;
    ImageList* imNames;
    AlgorithmData** algData;
    int numDistDir;

    if (PRINT_LEVEL > 0)
        printf("\n%s\n%s", OPENNING, VERSION);
    readArgs(argc, argv, &numDistDir, &distDir, &distFileNames, &outFilePrefix);

    imNames = getImageNames(distFileNames, &numImages);

    srt = subjectReplicatesTable(&imNames, &numImages, &numSubjects, &numReplicates, &fids);
    if (PRINT_LEVEL > 1)
        printf("\n  There are %d subjects and %d replicates.", numSubjects, numReplicates);

    if (numReplicates < 3) {
        printf("\nError:  there must be at least 3 replicates per subject.");
        printf("\n        The image list indicates %d replicate per subject.", numReplicates);
        printf("\n        Please check your file list to make sure it is in the proper format.\n");
        exit(1);
    }



    algData = malloc(sizeof(AlgorithmData*) * numDistDir);
    assert(algData);
    for( d = 0; d < numDistDir; d++){
        algData[d] = loadAlgoirthmData(distDir[d], srt, numSubjects, numReplicates, numImages, fids);
    }

    if (PRINT_LEVEL > 0)
        printf("\nPreparing data structures to record recognition counts over iterations.");
    pgs = makePGSET(numImages, numSubjects);
    recRanks = makeRecRanks(numSubjects);

    if (PRINT_LEVEL > 0)
        printf("\nBegining iterations.");
    for (t = 0; t < ITERATIONS; t++) {
        balancedSelectionProbeGallery(pgs, srt, numImages, numSubjects, numReplicates);
        for( d = 0; d < numDistDir; d++){
            loadRecognitionCounts(pgs, algData[d]->fidprs, recRanks, algData[d]->recCounts[t], numImages, numSubjects);
        }
        if ((t + 1) % (ITERATIONS / 10) == 0)
            printf("\n  Iteration %d.", t + 1);
    }

    if (PRINT_LEVEL > 0)
        printf("\nBuilding Sample Distributions - Histograms.");
    for( d = 0; d < numDistDir; d++){
        algData[d]->hist = histogramRecognitionCounts(algData[d]->recCounts, ITERATIONS, numSubjects);
        generateHistogramDistributionReports(outFilePrefix, algData[d]->basename, algData[d]->hist, numSubjects, ITERATIONS);
        generateCumulativeMatchCurveReport(outFilePrefix, algData[d]->basename, algData[d]->hist, numSubjects, ITERATIONS);
    }

    generateRankNComparisonReport(1, outFilePrefix, algData, numDistDir, numSubjects, ITERATIONS);

    if (PRINT_LEVEL > 0)
        printf("\nFinished\n");
    return 0;

}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
  File:    csuRankCurve.c
  Authors: J. Ross Beveridge, David S. Bolme
  Date:    May 24, 2002                                                  
  ============================================================================
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/*  csuRankCurve reads distances between probe and gallery images and generates
    a single new text file that lists recognition rates at different ranks.
*/

#define OPENING "Cumulative Match Curve from Probe, Gallery and Distances Files."

/*  STANDARD INCLUDES */
#include <stdio.h>
#include <stdlib.h> 
/*#include <sys/types.h>*/
/*#include <sys/stat.h>*/
/*#include <fcntl.h>*/
#include <string.h>
#include <math.h>
#include <assert.h>

/*  CSU INCLUDES */
#include <csuCommon.h>

/* Global flags */
/* The command line arguments are managed by a single structure. */
typedef struct {
    char* probeNamesFile;
    char* galleryNamesFile;
    char** distDirs;
    int numDistDirs;
    char* outFile;
    char* outDir;
    char* imDir;
    int idWidth;
    int argc;
    char **argv;
}
Arguments;


/* usage
 
   Remind the user the usage of running this program.
   The command of running the program should be: run and the index of the training sets. 
   All the other sets except the training sets will go to testing sets automatically.
 
   INPUT:  prog is the excutable program name.
*/
void usage(const char* prog) {
    printf("Usage: %s [OPTIONS] probesNamesFile.[list/srt] galleryNamesFile.[list/srt] [distDir]+ \n", prog);
    printf("  Parameters\n");
    printf("     probeNamesFile....... Name of file containing probe images names.\n");
    printf("     galleryNamesFile .... Name of file containing gallery image names.\n");
    printf("     [distDir]+ .......... Directories where the distance file are stored.\n");
    printf("    -filePrefix <name> ... Prefix to the name of the cumulative match curve output file. DEFAULT = Rank\n");
    printf("    -outDir <dir> ........ Output file directory. DEFAULT = \".\"\n");
    printf("    -imDir <dir> ......... Image directory. DEFAULT = \".\"\n");
    printf("    -idWidth <int> ....... Assume subject ID is fixed width prefix of file name. DEFAULT = 5\n");
    printf("    -debuglevel <int> .... Level of debug information to display. DEFAULT = 0\n");
    printf("    -quiet ............... Turn off all messages. DEFAULT = messages on\n");

    exit(1);
}

/*
   process_command
 
   process the command line arguments.  see usage for a description of functionality.
 */
void process_command(int argc, char** argv, Arguments* args) {
    int i;
    int param_num;

    param_num = 0;

    args->argc = argc;
    args->argv = argv;

    if (argc < 3)
        usage(argv[0]);
    for (i = 0; i < argc; i++) {
        if (strcmp(argv[i], "-help") == 0) { usage(argv[0]); exit(1); }
    }

    /* Allocate space for character arrays that are part of the arguments structure */
    args->probeNamesFile = (char*) malloc(sizeof(char) * MAX_FILENAME_LENGTH);
    args->galleryNamesFile = (char*) malloc(sizeof(char) * MAX_FILENAME_LENGTH);
    args->distDirs = (char**) malloc(sizeof(char*) * argc);

    /* Setup Default Values */
    args->imDir = strdup(".");
    args->outDir = strdup(".");
    args->outFile = strdup("Rank");

    args->idWidth = 5;
    quiet = 0;
    debuglevel = 0;
    args->numDistDirs = 0;

    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-imDir") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            free(args->imDir);
            args->imDir = strdup(argv[i]);
        } else if (strcmp(argv[i], "-outDir") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            free(args->outDir);
            args->outDir = strdup(argv[i]);
        } else if (strcmp(argv[i], "-filePrefix") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            free(args->outFile);
            args->outFile = strdup(argv[i]);
        } else if (strcmp(argv[i], "-debuglevel") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            debuglevel = atoi(argv[i]);
        } else if (strcmp(argv[i], "-idWidth") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            args->idWidth = atoi(argv[i]);
        } else if (strcmp(argv[i], "-quiet") == 0) {
            quiet = 1;
            continue;
        } else if (argv[i][0] == '-') {
            printf("Unknown option: %s\n", argv[i]);
            usage(argv[0]);
        } else if (param_num == 0) {
            args->probeNamesFile = strdup(argv[i]);
            param_num++;
        } else if (param_num == 1) {
            args->galleryNamesFile = strdup(argv[i]);
            param_num++;
        } else if (param_num >= 2) {
            args->distDirs[args->numDistDirs] = strdup(argv[i]);
            args->numDistDirs++;
            param_num++;
        }
    }

    if (param_num < 3)
        usage(argv[0]);

    /* Print out the program parameters for appropreate debug level */
    DEBUG_INT ( 1, "Debuging enabled", debuglevel);
    DEBUG_STRING( 3, "Parameter: ", args->probeNamesFile);
    DEBUG_STRING( 3, "Parameter: ", args->galleryNamesFile);
    DEBUG_INT ( 3, "Parameter: ", args->numDistDirs);
    for (i = 0; i < args->numDistDirs; i++) {
        DEBUG_STRING( 3, "Parameter: ", args->distDirs[i]);
    }
    DEBUG_STRING( 3, "Parameter: ", args->outFile);
    DEBUG_STRING( 3, "Parameter: ", args->outDir);
    DEBUG_STRING( 3, "Parameter: ", args->imDir);
    DEBUG_INT ( 3, "Parameter: ", args->idWidth);
}


/* sameSubject
 *
 * Compares two image names to determine if they corrispond to the same subject.
 */
int sameSubject(char* name1, char* name2, int width) {
    int len1, len2, i, flag;

    len1 = strlen(name1);
    len2 = strlen(name2);

    DEBUG_CHECK(len1 > width, "Name shorter than specified prefix size found.");
    DEBUG_CHECK(len2 > width, "Name shorter than specified prefix size found.");

    flag = 1;
    for (i = 0; i < width; i++) {
        if (name1[i] != name2[i])
            flag = 0;
    }

    return flag;
}


/*  isInImageList
 *
 *  This checks to see if filename is included in the ImageNames list. This is done by traversing
 *  the list and determining if the filenames match.
 */
int isInImagelist(char* filename, ImageList* ImageNames) {
    ImageList *subject, *replicate;

    for (subject = ImageNames; subject != NULL ; subject = subject->next_subject) {
        for (replicate = subject; replicate != NULL ; replicate = replicate->next_replicate) {
            if (strcmp(filename, replicate->filename) == 0) {
                return 1;
            }
        }
    }

    return 0;
}

/*  getProbeRank
 *
 *   This function reads the distance file for a probe image and determines the rank of the
 *   nearest image of the same subject.  The gallery distances are stored in an array.  As
 *   they are read in the distance to the closest image of the same subject is determined.
 *   The array is then scanned again to determine the number of images that are closer to
 *   the original (the rank).  The file is then closed and the rank is returned.  
 */
typedef struct {
    char* galleryName;
    double distance;
}
DistanceRec;

int getProbeRank(char* distDir, char* probeName, int numGalleryImages,
                 ImageList* galleryImageNames, DistanceRec* distRecs, int width) {
    int i;
    FILE* distanceFile = NULL;
    char filename[MAX_FILENAME_LENGTH];
    char galleryName[MAX_FILENAME_LENGTH];
    double distance;
    double minDistance;
    int rank = -1;
    int noMinFound = 1;

    sprintf(filename, "%s/%s", distDir, probeName);

    if (debuglevel > 0)
        fprintf(stdout, "Reading probe distance file: %s ", filename);
    fflush(stdout);

    distanceFile = fopen(filename, "r");

    if(!distanceFile){
        printf("Error opening distance file: %s", filename);
        exit(1);
    }

    minDistance = 0.0;
    noMinFound = 1;
    i = 0;
    while ((fscanf(distanceFile, "%s %lf", galleryName, &distance) == 2) && (i < numGalleryImages)) {

        if ( !distRecs[i].galleryName && isInImagelist(galleryName, galleryImageNames) ) {
            distRecs[i].galleryName = strdup(galleryName);
            if (sameSubject(probeName, galleryName, width)) {
                if (noMinFound) {
                    minDistance = distance; noMinFound = 0;}
                else {
                    minDistance = MIN(minDistance , distance); }
            }
            distRecs[i].distance = distance;
            i++;
        } else if ( distRecs[i].galleryName && strcmp(distRecs[i].galleryName, galleryName) == 0 ) {
            if (sameSubject(probeName, galleryName, width)) {
                if (noMinFound) {
                    minDistance = distance;
                    noMinFound = 0;
                } else {
                    minDistance = minDistance < distance ? minDistance : distance;
                }
            }
            distRecs[i].distance = distance;
            i++;
        }
    }

    if (debuglevel > 0)
        printf("MinDistance: %f ", minDistance);
    DEBUG_CHECK(i == numGalleryImages, "Error: All distance files must list images in the same order");

    fclose(distanceFile);

    rank = 0;

    for (i = 0; i < numGalleryImages; i++) {
        if (!sameSubject(probeName, distRecs[i].galleryName, width) && distRecs[i].distance <= minDistance)
            rank++;
    }

    if (debuglevel > 0)
        fprintf(stdout, "Rank: %d\n", rank);
    fflush(stdout);

    return rank;
}


/*  allocate/free RankCurves
 *
 *  These functions allocates a two dimensional array used for storing the cumlative
 *  rank curves.
 */

int** allocateRankCurves(int numDistDirs, int numGalleryImages) {
    int **rankcurve;
    int i, j;

    rankcurve = (int**)malloc(sizeof(int*) * numDistDirs);
    DEBUG_CHECK(rankcurve, "Error allocating memory");

    for ( j = 0; j < numDistDirs; j++) {
        rankcurve[j] = (int*) malloc( sizeof(int*) * numGalleryImages );
        DEBUG_CHECK(rankcurve[j], "Error allocating memory");
        for ( i = 0; i < numGalleryImages; i++) {
            rankcurve[j][i] = 0;
        }
    }
    return rankcurve;
}

void freeRankCurves(int **rankcurve, int numDistDirs, int numGalleryImages) {
    int j;

    for ( j = 0; j < numDistDirs; j++) {
        free(rankcurve[j]);
    }

    free(rankcurve);
}

/* buildRankCurves
 *
 * This function reads in each probe file consecutivly and builds rank curves for
 * each distance directory. 
 */
void buildRankCurves(ImageList* probeImageNames, int numProbeImages,
                     ImageList* galleryImageNames, int numGalleryImages, Arguments *args) {
    int i, j;
    int rank;
    int** rankcurve;
    ImageList* subject;
    ImageList* replicate;
    FILE* imageRankFile;
    FILE* cumulativeRankFile;
    DistanceRec* distRecs = (DistanceRec*)malloc(sizeof(DistanceRec) * numGalleryImages);
    char filename[MAX_FILENAME_LENGTH];

    /* Set up the rank curve and output files */
    sprintf(filename, "%s/%s_Images.txt", args->outDir, args->outFile);
    imageRankFile = fopen(filename, "w");
    DEBUG_CHECK(imageRankFile, "Error opening file");

    sprintf(filename, "%s/%s_Curve.txt", args->outDir, args->outFile);
    cumulativeRankFile = fopen(filename, "w");
    DEBUG_CHECK(cumulativeRankFile, "Error opening file");

    /* Allocate Memory for the rank curve data */
    rankcurve = allocateRankCurves(args->numDistDirs, numGalleryImages);

    /* Build up the rank information */
    DEBUG_CHECK(distRecs, "Error Allocating Memory.");
    for (i = 0; i < numGalleryImages; i++) {
        distRecs[i].galleryName = NULL;
        distRecs[i].distance = 0.0;
    }
    /* Print out file headers */
    fprintf(imageRankFile, "%s", "ProbeName");
    for (i = 0; i < args->numDistDirs; i++) {
        fprintf(imageRankFile, "\t%s", args->distDirs[i]);
    }
    fprintf(imageRankFile, "\n");

    for (subject = probeImageNames; subject != NULL ; subject = subject->next_subject) {
        for (replicate = subject; replicate != NULL ; replicate = replicate->next_replicate) {
            printf("Processing Probe: %s       \r",replicate->filename);
            fprintf(imageRankFile, "%s", replicate->filename);
            for (i = 0; i < args->numDistDirs; i++) {
                int rank = getProbeRank(args->distDirs[i], replicate->filename, numGalleryImages, galleryImageNames, distRecs, args->idWidth);
                rankcurve[i][rank]++; /* add to the ranking histogram */
                fprintf(imageRankFile, "\t%d", rank);
            }
            fprintf(imageRankFile, "\n");
        }
    }
    free(distRecs);

    /* Output the final rank curve information. */
    fprintf(cumulativeRankFile, "%s", "Rank");
    for (j = 0; j < args->numDistDirs; j++) {
        fprintf(cumulativeRankFile, "\t%s", args->distDirs[j]);
        fprintf(cumulativeRankFile, "\t%s", args->distDirs[j]);
    }
    fprintf(cumulativeRankFile, "\n");

    rank = 0;
    for ( i = 0; i < numGalleryImages; i++) {
        fprintf(cumulativeRankFile, "%d", i);
        for (j = 0; j < args->numDistDirs; j++) {
            if (i != 0)
                rankcurve[j][i] += rankcurve[j][i - 1];
            fprintf(cumulativeRankFile, "\t%d", rankcurve[j][i]);
            fprintf(cumulativeRankFile, "\t%f", ((float)rankcurve[j][i]) / numProbeImages);
        }
        fprintf(cumulativeRankFile, "\n");
    }

    /* clean up the files */
    freeRankCurves(rankcurve, args->numDistDirs, numGalleryImages);
    fclose(cumulativeRankFile);
    fclose(imageRankFile);
}

/* main */
int main(int argc, char *argv[]) {

    Arguments args;
    ImageList *probeImageNames, *galleryImageNames;
    int numProbeImages, numGalleryImages;


    MESSAGE(OPENING);
    MESSAGE(VERSION);

    process_command(argc, argv, &args);

    probeImageNames = getImageNames(args.probeNamesFile, &numProbeImages);
    galleryImageNames = getImageNames(args.galleryNamesFile, &numGalleryImages);

    buildRankCurves(probeImageNames, numProbeImages, galleryImageNames, numGalleryImages, &args);

    printf("\nFinished. \n");
    return 0;
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
File: csuAnalyzePostprocessing.c                                                     
Authors: Marcio L. Teixeira                           
Date: May 24, 2002                                                       
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/** @file
 Purpose: This program performs an experiment where the performance of
 a two-stage classifier is examined
*/

#define OPENING  "Performs a two-stage classifier test"

/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

/*  CSU INCLUDES */
#include <csuCommon.h>

/******************************************************************************
*                               GLOBALS                                       *
******************************************************************************/

/* Global flags */

/**
 * The command line arguments are managed by a single structure.
 */
typedef struct {
  char* allImageList;

  char* probeImageList;
  char* galleryImageList;

  char* stageOneDistanceMatrix;
  char* stageTwoDistanceMatrix;
  
  char* resultsFile;

  int   maxRank;
}
Arguments;

/**
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name) {
    printf ("Usage: %s [OPTIONS] all.srt gallery.srt probe.srt stageOneDistanceMatrix stageTwoDistanceMatrix prefix"
	   "imageNamesFile.[list/srt] maxLikelihoodDistDirectory bayesianDistDirectory\n", name);
    printf ("  Parameters:\n");
    printf ("     allImageList ....      List of combined probe and gallery images\n"); 
    printf ("     probeImageList ....    List of probe images\n");
    printf ("     galleryImageList ....  List of gallery images\n");
    printf ("     stageOneDistanceMatrix ....    Distance matrix to be used for stage one\n");
    printf ("     stageTwoDistanceMatrix ....    Distance matrix to be used for stage two\n");
    printf ("     prefix ....                    Prefix of the external data\n");
    printf ("    -maxRank n          Compute rank curve up to this value (DEFAULT=50)\n");
    printf ("    -debuglevel <int>:  Level of debug information to display. DEFAULT = 0\n");
    printf ("    -quiet:             Turn off all messages. DEFAULT = messages on\n");

    exit(0);
}

/**
 * Process the command line and initialize the variables
 *
 * @param argc The number of arguments
 * @param argv The arguments
 */
void
process_command(int argc, char** argv, Arguments* args)
{
  int i;
  int param_num = 0;

  /******* Set up default values *******/

  args->allImageList   = NULL;
  args->probeImageList   = NULL;
  args->galleryImageList = NULL;

  args->stageOneDistanceMatrix = NULL;
  args->stageTwoDistanceMatrix = NULL;

  args->resultsFile = NULL;

  args->maxRank = -1;

  quiet = 0;
  debuglevel = 0;

  for (i = 1; i < argc; i++) {

    /* Catch common help requests */
    if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
    else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

    /* other flags */
    else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
    else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));

    /* Read in number of images to generate */
    else if (readOptionInt    (argc, argv, &i, "-maxRank", &(args->maxRank)));

    /* check if the current argument is an unparsed option */
    else if (checkBadOption(argc,argv,&i));

    else if (param_num == 0) {
      args->allImageList = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 1) {
      args->galleryImageList = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 2) {
      args->probeImageList = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 3) {
      args->stageOneDistanceMatrix = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 4) {
      args->stageTwoDistanceMatrix = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 5) {
      args->resultsFile = strdup(argv[i]);
      param_num++;
    }
  }

  if (param_num < 5)
    usage(argv[0]);

  /* Print out the program parameters for appropriate debug level */

  DEBUG_INT (1, "Debuging enabled", debuglevel);

  if(debuglevel > 0){
    printf ("***************** Program Parameters *********************\n");
    printf ("allImageList: %s\n", args->allImageList);
    printf ("galleryImageList: %s\n", args->galleryImageList);
    printf ("probeImageList: %s\n", args->probeImageList);
    printf ("stageOneDistanceMatrix: %s\n", args->stageOneDistanceMatrix);
    printf ("stageTwoDistanceMatrix: %s\n", args->stageTwoDistanceMatrix);
  }
}

/******************************************************************************
*                            MAIN PROGRAM                                     *
******************************************************************************/

typedef struct {
  char **nameArray;
  int *subjArray;
} SubjectComparator;

SubjectComparator*
getSubjectComparator (char *allSrt)
{
  FILE *fi;
  void *nameList = NULL;
  void *subjList = NULL;
  SubjectComparator *comparator;
  unsigned int subjId;
  size_t nImages;
  Tokenizer tok;

  fi = fopen (allSrt, "r");
  DEBUG_CHECK_1ARG (fi, "Unable to read image list %s", allSrt);

  tokenizerInit (&tok, tokenizerStreamReader, fi);

  subjId = 0;

  while (!tokenizerEndOfFile (&tok))
    {
      char *subjName = strdup (tokenizerGetWord (&tok));
      listAccumulate (&nameList, &subjName, sizeof (char *));
      listAccumulate (&subjList, &subjId,   sizeof (int));

      while ((!tokenizerEndOfLine (&tok)) && (!tokenizerEndOfFile (&tok)))
	{
	  subjName = strdup (tokenizerGetWord (&tok));
	  listAccumulate (&nameList, &subjName, sizeof (char *));
	  listAccumulate (&subjList, &subjId,   sizeof (int));
	}

      writeProgress ("Reading subjects list", subjId, 0);
      subjId++;
    }

  fclose (fi);

  comparator = (SubjectComparator*) malloc (sizeof (SubjectComparator));
  comparator->nameArray = listToNullTerminatedArray (&nameList, sizeof (char *), &nImages);
  comparator->subjArray = listToNullTerminatedArray (&subjList, sizeof (int),    &nImages);
  return comparator;
}

int
getSubjectId (SubjectComparator *comparator, char *subject)
{
  int i;

  for (i = 0; comparator->nameArray[i] != NULL; i++)
    if (!strcmp (comparator->nameArray[i], subject))
      break;

  return comparator->subjArray[i];
}

/* ===========================================================================
 MAIN
*/
int main(int argc, char *argv[]) 
{
  Arguments args;
  SubjectComparator *comparator;
  ListOfStrings probeImages, galleryImages;
  int *stageOneRankCurve, *stageTwoRankCurve, *combinedRankCurve, *indices, *subjIds;
  int nProbe, nGallery, rankOfProbe, i, r, j;
  FILE *fo;
  char buff[256];

  MESSAGE(OPENING);
  MESSAGE(VERSION);
  process_command(argc, argv, &args);

  /* Sanity check */

  checkReadableFile (args.allImageList, "Cannot read the combined image list %s");
  checkReadableFile (args.galleryImageList, "Cannot read the gallery image list %s");
  checkReadableFile (args.probeImageList,   "Cannot read the probe image list %s");

  /* Begin execution */
  
  MESSAGE1ARG("Reading combined image list from %s", args.allImageList);
  
  comparator = getSubjectComparator (args.allImageList);

  MESSAGE1ARG("Reading probe image list from %s", args.probeImageList);

  probeImages = readListOfStrings (args.probeImageList, &nProbe);

  MESSAGE1ARG("Reading gallery image list from %s", args.galleryImageList);

  galleryImages = readListOfStrings (args.galleryImageList, &nGallery);

  if (args.maxRank == -1 || args.maxRank > nGallery)
    args.maxRank = nGallery;

  /* Compute the rank curves */

  stageOneRankCurve = (int*) malloc (args.maxRank * sizeof (int));
  stageTwoRankCurve = (int*) malloc (args.maxRank * sizeof (int));
  combinedRankCurve = (int*) malloc (args.maxRank * sizeof (int));

  indices = (int*) malloc (nGallery * sizeof (int));
  subjIds = (int*) malloc (nGallery * sizeof (int));

  for (i = 0; i < args.maxRank; i++)
    {
      stageOneRankCurve[i] = 0;
      stageTwoRankCurve[i] = 0;
      combinedRankCurve[i] = 0;
    }

  for (i = 0; i < nProbe; i++)
    {
      char *probe = probeImages [i];
      int leastRanked, probeSubj = getSubjectId (comparator, probe);

      sortSubjectsBySimilarityToProbe (probe, galleryImages, args.stageOneDistanceMatrix, NULL);
      sortSubjectsBySimilarityToProbe (probe, galleryImages, args.stageTwoDistanceMatrix, indices);

      /* Look up subject ids */

      for (j = 0; j < nGallery; j++)
	subjIds [j] = getSubjectId (comparator, galleryImages[j]);


      /* Stage one cumulative rank curve */

      rankOfProbe = args.maxRank;
      for (r = 0; r < args.maxRank; r++)
	  if (probeSubj == subjIds[r])
	    {
	      rankOfProbe = r;
	      break;
	    }

      for (r = rankOfProbe; r < args.maxRank; r++)
	stageOneRankCurve[r]++;

      /* Stage two cumulative rank curve */

      rankOfProbe = args.maxRank;
      for (r = 0; r < args.maxRank; r++)
	  if (probeSubj == subjIds[indices[r]])
	    {
	      rankOfProbe = r;
	      break;
	    }

      for (r = rankOfProbe; r < args.maxRank; r++)
	stageTwoRankCurve[r]++;

      /* Two-stage rank-one curve */

      for (r = 0; r < args.maxRank; r++)
	{
	  for (leastRanked = 0; leastRanked < nGallery; leastRanked++)
	      if (indices[leastRanked] <= r)
		break;

	  if (probeSubj == subjIds[indices[leastRanked]])
	    combinedRankCurve[r]++;
	}

      writeProgress ("Computing the rank curves", i, nProbe);
    }

  /* Save out the results */

  sprintf (buff, "%s_PCARankOne_Curve.txt", args.resultsFile);
  fo = fopen (buff, "w");
  fprintf (fo,"rank PCA PCA\n");
  for (r = 0; r < args.maxRank; r++)
      fprintf (fo, "%d %d %f\n", r+1, stageOneRankCurve[0], ((double)stageOneRankCurve[0])/nProbe);
  fclose (fo);

  sprintf (buff, "%s_BayesianRankOne_Curve.txt", args.resultsFile);
  fo = fopen (buff, "w");
  fprintf (fo,"rank Bayesian Bayesian\n");
  for (r = 0; r < args.maxRank; r++)
      fprintf (fo, "%d %d %f\n", r+1, stageTwoRankCurve[0], ((double)stageTwoRankCurve[0])/nProbe);
  fclose (fo);

  sprintf (buff, "%s_PCA_Curve.txt", args.resultsFile);
  fo = fopen (buff, "w");
  fprintf (fo,"rank PCA PCA\n");
  for (r = 0; r < args.maxRank; r++)
      fprintf (fo, "%d %d %f\n", r+1, stageOneRankCurve[r], ((double)stageOneRankCurve[r])/nProbe);
  fclose (fo);

  sprintf (buff, "%s_Bayesian_Curve.txt", args.resultsFile);
  fo = fopen (buff, "w");
  fprintf (fo,"rank Bayesian Bayesian\n");
  for (r = 0; r < args.maxRank; r++)
      fprintf (fo, "%d %d %f\n", r+1, stageTwoRankCurve[r], ((double)stageTwoRankCurve[r])/nProbe);
  fclose (fo);

  sprintf (buff, "%s_CombinedRankOne_Curve.txt", args.resultsFile);
  fo = fopen (buff, "w");
  fprintf (fo,"rank Combined Combined\n");
  for (r = 0; r < args.maxRank; r++)
      fprintf (fo, "%d %d %f\n", r+1, combinedRankCurve[r], ((double)combinedRankCurve[r])/nProbe);
  fclose (fo);

  return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
File: csuBayesianProject.c                                                     
Authors: Marcio L. Teixeira                           
Date: May 24, 2002                                                       
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/** @file
 Purpose: This program projects face images into intrapersonal and
 extrapersonal subspaces and computes a "distance" score based on the
 maximum likelihood and bayesian estimates. The images are specified
 in a file of image names. These may be grouped either as one
 name per line or several, although for this program there is no
 difference between the two in terms of what is done.  The resulting
 distances are written out to a series of files, one per image, all
 placed in a user specified directory.
*/

/* References:

     [1] Moghaddam and Pentland, "Probabilistic Visual Learning"
     [2] She, Kai. _Master's Thesis_, Chapter 5
     [3] Moghaddam and Pentland, "Beyond Eigenfaces"
 */

#define OPENING  "Project Test Images into intrapersonal and extrapersonal subspace and Compute Pairwise Distances."

/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

/*  CSU INCLUDES */
#include <csuCommon.h>

/******************************************************************************
*                               GLOBALS                                       *
******************************************************************************/

/* How many lines in the training file header have useful text */
#define TRAINING_HEADER_ENTRIES 10

/* Global flags */

/**
 * The command line arguments are managed by a single structure.
 */
typedef struct {
  char* intrapersonalTrainingFile;
  char* extrapersonalTrainingFile;
  char* imageNamesFile;
  char* imageDirectory;
  char* maxLikelihoodDistDirectory;
  char* bayesianDistDirectory;
  char* distanceMatrix;
  int   maxRank;
}
Arguments;

/**
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name) {
    printf ("Usage: %s [OPTIONS] intrapersonalTrainingFile extrapersonalTrainingFile "
	   "imageNamesFile.[list/srt] maxLikelihoodDistDirectory bayesianDistDirectory\n", name);
    printf ("  Parameters:\n");
    printf ("     intrapersonalTrainingFile ....  Name of file containing subspace generated by training\n"
	   "                                     on the intrapersonal images\n");
    printf ("     extrapersonalTrainingFile ....  Name of file containing subspace generated by training\n"
	   "                                     on the extrapersonal images\n");
    printf ("     imageNamesFile...               Name of file containing test images: union of possible probe and gallery sets.\n");
    printf ("     maxLikelihoodDistDirectory ...  Directory where distances files are to be written\n");
    printf ("     bayesianDistDirectory ...       Directory where distances files are to be written\n");
    printf ("    -imDir <dir>:       image directory. DEFAULT = \".\"\n");
    printf ("    -debuglevel <int>:  Level of debug information to display. DEFAULT = 0\n");
    printf ("    -quiet:             Turn off all messages. DEFAULT = messages on\n");
    printf ("    -distances <file>:  Use Bayesian for post-processing. Sort images using this distance matrix, then classify top n candidates.\n");
    printf ("    -maxRank n          Present this many images when post-processing (DEFAULT=20)\n");

    exit(0);
}

/**
 * Process the command line and initialize the variables
 *
 * @param argc The number of arguments
 * @param argv The arguments
 */
void
process_command(int argc, char** argv, Arguments* args)
{
  int i;
  int param_num = 0;

  /******* Set up default values *******/

  args->imageDirectory = NULL;
  args->intrapersonalTrainingFile = NULL;
  args->extrapersonalTrainingFile = NULL;
  args->imageNamesFile = NULL;
  args->maxLikelihoodDistDirectory = NULL;
  args->bayesianDistDirectory = NULL;

  args->distanceMatrix = NULL;
  args->maxRank = 50;

  quiet = 0;
  debuglevel = 0;

  for (i = 1; i < argc; i++) {

    /* Catch common help requests */
    if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
    else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

    /* Read in input directories */
    else if (readOptionString (argc, argv, &i, "-imDir",     &(args->imageDirectory)));

    /* other flags */
    else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
    else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));

    else if (readOptionString (argc, argv, &i, "-distances", &(args->distanceMatrix)));

    /* Read in number of images to generate */
    else if (readOptionInt    (argc, argv, &i, "-maxRank", &(args->maxRank)));

    /* check if the current argument is an unparsed option */
    else if (checkBadOption(argc,argv,&i));


    else if (param_num == 0) {
      args->intrapersonalTrainingFile = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 1) {
      args->extrapersonalTrainingFile = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 2) {
      args->imageNamesFile = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 3) {
      args->maxLikelihoodDistDirectory = strdup(argv[i]);
      param_num++;
    }
    else if (param_num == 4) {
      args->bayesianDistDirectory = strdup(argv[i]);
      param_num++;
    }
  }

  if (param_num < 4)
    usage(argv[0]);

  /* Print out the program parameters for appropriate debug level */

  DEBUG_INT (1, "Debuging enabled", debuglevel);

  if(debuglevel > 0){
    printf ("***************** Program Parameters *********************\n");
    printf ("intrapersonalTrainingFile: %s\n", args->intrapersonalTrainingFile);
    printf ("extrapersonalTrainingFile: %s\n", args->extrapersonalTrainingFile);
    printf ("imageNamesFile: %s\n", args->imageNamesFile);
    printf ("maxLikelihoodDistDirectory: %s\n", args->maxLikelihoodDistDirectory);
    printf ("bayesianDistDirectory: %s\n", args->bayesianDistDirectory);
    printf ("imageDirectory: %s\n", args->imageDirectory);
  }
}

/******************************************************************************
*                            I/O ROUTINES                                     *
******************************************************************************/

void
writeDistanceMatrix (char* distDirectory, Matrix distances, char** images, int nSubjects)
{
  FILE *file;
  int i, j;
  
  for (i = 0; i < nSubjects; i++)
    {
      file = fopen (makePath (distDirectory, images[i]), "w");
      DEBUG_CHECK (file, "Could not write out distance matrix\n");
      for (j = 0; j < nSubjects; j++)
	fprintf (file, "%s\t%.20e\n", images[j], ME(distances, j, i));
      fclose (file);
    }
}

/******************************************************************************
 *           REVISED BAYESIAN PROBABILITY EQUATIONS                           *
 *****************************************************************************/

/* Use nomenclature consistent with Moghaddam and Pentland */

#define CONST_N(s)  (s->numPixels)
#define CONST_M(s)  (s->basis->col_dim)  /* Number of principal components that we kept */
#define CONST_Nt(s) (s->basisDim)

FTYPE
computeRho (Subspace *s)
{
  int i;
  FTYPE tmp = 0.0;

  tmp = 0.0;
  for (i = CONST_M(s); i < CONST_Nt(s); i++)
      tmp += ME(s->values,i,0);

  return tmp / (CONST_Nt(s) - CONST_M(s));
}

FTYPE
computeMaxLikelihood (Matrix delta, Subspace *s, FTYPE rho)
{
  int i;
  Matrix y, deltaCentered;
  FTYPE mahSumOfSquares, ySumOfSquares, deltaSumOfSquares;
  FTYPE ySquared, epsilonSquaredOfX, score;

  /* y is the projection of X into the s. Note that
   * as a side-effect, centerThenProjectImages mean
   * centers deltaCentered */

  deltaCentered = duplicateMatrix(delta);
  y = centerThenProjectImages(s, deltaCentered);

  mahSumOfSquares   = 0.0;
  ySumOfSquares     = 0.0;
  deltaSumOfSquares = 0.0;

  for (i = 0; i < CONST_M(s); i++)
    if (ME(s->values,i,0) != 0.0)
      {
	ySquared = SQR(ME(y,i,0));

	mahSumOfSquares += ySquared / ME(s->values,i,0);
	ySumOfSquares   += ySquared;
      }

  for (i = 0; i < CONST_N(s); i++) 
    deltaSumOfSquares += SQR(ME(deltaCentered,i,0));

  epsilonSquaredOfX = deltaSumOfSquares - ySumOfSquares;
  score = mahSumOfSquares + epsilonSquaredOfX / rho;

  /* Clean up */

  freeMatrix (deltaCentered);
  freeMatrix (y);

  return  score;
}

/******************************************************************************
*                            MAIN PROGRAM                                     *
******************************************************************************/

/* ===========================================================================
 MAIN
 
 The arguments are processed and then the subspaces and related information is
 read from the training files written by csuSubspaceTrain.  The subspace basis
 is read into a matrix.
 
 Once the training information is read, then the images specified in the 
 imageNamesFile are read into the images matrix. This matrix is then mean 
 centered using the mean, or centroid, associated with the training data. 
 Next, the images are projected into both the intrapersonal and extrapersonal
 subspaces and the maximum likelihood and bayesian distances between all
 pairs of images are computed. Finally, these distances are written to files,
 one per image.
*/
int main(int argc, char *argv[]) {
    int nImages, numPixels;
    int i, j, k, n;
    int progress, progressMax;
    Arguments args;
    ListOfStrings images;
    Matrix maxLikelihoodDistances;
    Matrix bayesianDistances;
    Matrix delta;
    Matrix data;
    Subspace intrapersonal;
    Subspace extrapersonal;
    FTYPE iRho, eRho, iLikelihood, eLikelihood;

    MESSAGE(OPENING);
    MESSAGE(VERSION);
    process_command(argc, argv, &args);

    /* Sanity check */

    checkWriteableDirectory (args.bayesianDistDirectory, "%s is not a writeable directory");
    checkWriteableDirectory (args.maxLikelihoodDistDirectory, "%s is not a writeable directory");
    checkReadableFile (args.intrapersonalTrainingFile, "Cannot read the training file %s");
    checkReadableFile (args.extrapersonalTrainingFile, "Cannot read the training file %s");
    checkReadableFile (args.imageNamesFile, "Cannot read the image list %s");

    /* Begin execution */

    MESSAGE1ARG("Reading intrapersonal subspace %s", args.intrapersonalTrainingFile);
    readSubspace (&intrapersonal, args.intrapersonalTrainingFile, quiet);

    MESSAGE1ARG("Reading extrapersonal subspace %s", args.extrapersonalTrainingFile);
    readSubspace (&extrapersonal, args.extrapersonalTrainingFile, quiet);

    MESSAGE1ARG("Reading image list from %s", args.imageNamesFile);

    images = readListOfStrings (args.imageNamesFile, &nImages);

    /* Allocate storage for difference image */

    numPixels = autoFileLength (makePath (args.imageDirectory, images[0]));

    delta                  = makeMatrix (numPixels, 1);
    data                   = makeMatrix (numPixels,nImages);
    maxLikelihoodDistances = makeMatrix (nImages, nImages);
    bayesianDistances      = makeMatrix (nImages, nImages);

    DEBUG_CHECK(delta                  != NULL, "Not enough memory to allocate matrix");
    DEBUG_CHECK(maxLikelihoodDistances != NULL, "Not enough memory to allocate matrix");
    DEBUG_CHECK(bayesianDistances      != NULL, "Not enough memory to allocate matrix");
    DEBUG_CHECK(data                   != NULL, "Not enough memory to allocate matrix");

    /* Load images */

    for (i = 0; i < nImages; i++) {
      readFile (makePath (args.imageDirectory, images[i]), i, data);
      writeProgress ("Loading images", i, nImages);
    }

    /* Compute rho for both the interpersonal and extrapersonal subspaces */

    iRho = computeRho(&intrapersonal);
    eRho = computeRho(&extrapersonal);

    printf ("iRho: %e eRho: %e\n", iRho, eRho);

    if (args.distanceMatrix == NULL)
      {
	/* Compute the difference images and the Bayesian similarities */

	progress = 0;
	progressMax = (SQR(nImages)+nImages)/2;
	
	for (i = 0; i < nImages; i++)
	  for (j = 0; j <= i; j++)
	    {
	      /* Compute the difference image */
	      
	      for (k = 0; k < data->row_dim; k++)
		ME (delta, k, 0) = ME (data, k, i) - ME (data, k, j);
	  
	      /* Compute the similarity scores */
	      
	      iLikelihood = computeMaxLikelihood (delta, &intrapersonal, iRho);
	      eLikelihood = computeMaxLikelihood (delta, &extrapersonal, eRho);
	  
	      ME(maxLikelihoodDistances, i, j) = iLikelihood;
	      ME(bayesianDistances, i, j)      = iLikelihood + eLikelihood;
	      
	      /* Assume symmetry */

	      ME(maxLikelihoodDistances, j, i) = ME(maxLikelihoodDistances, i, j);
	      ME(bayesianDistances, j, i)      = ME(bayesianDistances, i, j);
	  
	      writeProgress ("Computing distances", progress++, progressMax);
	    }
      }
    else
      {
	/* Run bayesian as a post-processing step*/

	int *indices = (int*) malloc (nImages * sizeof (int));

	/* Clear the matrix */

	for (i = 0; i < nImages; i++)
	  for (j = 0; j <= i; j++)
	    {
	      ME(maxLikelihoodDistances, j, i) = ME(maxLikelihoodDistances, i, j) = HUGE;
	      ME(bayesianDistances, j, i) = ME(bayesianDistances, i, j) = HUGE;
	    }

	progress = 0;
	progressMax = nImages;
      
	for (i = 0; i < nImages; i++) {
	  sortSubjectsBySimilarityToProbe (images[i], images, args.distanceMatrix, indices);

	  for (n = 0; n <= args.maxRank; n++) {
	    j = indices[n];
	  
	    /* Compute the difference image */
	    
	    for (k = 0; k < data->row_dim; k++)
	      ME (delta, k, 0) = ME (data, k, i) - ME (data, k, j);

	    /* Compute the similarity scores */
	      
	    iLikelihood = computeMaxLikelihood (delta, &intrapersonal, iRho);
	    eLikelihood = computeMaxLikelihood (delta, &extrapersonal, eRho);
	  
	    ME(maxLikelihoodDistances, i, j) = iLikelihood;
	    ME(bayesianDistances, i, j)      = iLikelihood + eLikelihood;
	      
	    /* Assume symmetry */

	    ME(maxLikelihoodDistances, j, i) = ME(maxLikelihoodDistances, i, j);
	    ME(bayesianDistances, j, i)      = ME(bayesianDistances, i, j);
	}

	writeProgress ("Computing distances", progress++, progressMax);
	}
      }

    /* Save out the distance matrix */

    MESSAGE1ARG("Writing out distance matrix to %s", args.bayesianDistDirectory);

    writeDistanceMatrix (args.bayesianDistDirectory, bayesianDistances, images, nImages);

    MESSAGE1ARG("Writing out distance matrix to %s", args.maxLikelihoodDistDirectory);

    writeDistanceMatrix (args.maxLikelihoodDistDirectory, maxLikelihoodDistances, images, nImages);

    /* Clean up */

    freeMatrix (delta);
    freeMatrix (maxLikelihoodDistances);
    freeMatrix (bayesianDistances);
    freeMatrix (data);
    freeListOfStrings (images);

    return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
File:    csuBayesianTrain.c                                                            
Authors: Marcio L. Teixeira                      
Date:    May 30, 2002                                                
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/


#define OPENING  "Trains the Bayesian Interpersonal/Extrapersonal Classifier."

#define EACH_SUBJECT(srt, subject)           (subject = srt; subject != NULL; subject = subject->next_subject)
#define EACH_REPLICATE(srt, replicate)       (replicate = srt; replicate != NULL; replicate = replicate->next_replicate)

/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

#include <csuCommon.h>

/******************************************************************************
*                               GLOBALS                                       *
******************************************************************************/

typedef struct
{
  char *imageList;
  char *imageDirectory;
  char *trainingFilename;

  char *distanceMatrix;
  int maxRank;

  int nExtrapersonal;
  int nIntrapersonal;

  int cutOffMode;
  double cutOff;
  int dropNVectors;

  int argc;
  char **argv;
}
Arguments;

/**
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name)
{
  printf ("Usage: %s [OPTIONS] training_images.srt training_output_prefix\n", name);
  printf ("  Parameters\n");
  printf ("    training_images.srt:   Input image names.\n");
  printf ("    training_output_prefix Prefix which is used to save the subspaces\n");
  printf ("  Options\n");
  printf ("    -imDir <dir>:          Image directory.\n"
	  "        DEFAULT = \".\"\n");
  printf ("    -ni <n>:               Total number of interpersonal images.\n"
	  "        DEFAULT = 100\n");
  printf ("    -ne <n>:               Total number of extrapersonal images.\n"
	  "        DEFAULT = 100\n");
  printf ("    -distances <file>:     Sort images using this distance matrix.\n"
	  "        DEFAULT = \"Random\"\n");
  printf ("    -maxRank n             When sorting, take these many top-ranked images\n");
  printf("     -dropNVectors <int>: Drops the first N vectors which are normally lighting effects.\n        DEFAULT = 0\n");
  printf("     -cutOffMode <mode>:  Selects the method for eigen vector selection after PCA trianing\n");
  printf("                          and droping the first vectors.  DEFAULT = SIMPLE\n");
  printf("          NONE            Retain eigenvectors.\n");
  printf("          SIMPLE          Retain a percentage of the eigenvectors. \n");
  printf("                          Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f \n", DEFAULT_CUTOFF_PERCENT_SIMPLE);
  printf("          ENERGY          Retain  eigenvectors accounting for a percentage of the total energy.\n");
  printf("                          Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f\n", DEFAULT_CUTOFF_PERCENT_ENERGY);
  printf("          STRETCH         Retains all eigenvectors greater than a percentage of the largest eigenvector.\n");
  printf("                          Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f\n", DEFAULT_CUTOFF_PERCENT_STRETCH);
  printf("          CLASSES         Retains as many eigenvectors as there LDA Classes: use only with LDA.\n");
  printf("                          Ignores cutOff value and uses number of classes instead\n");
  printf("     -cutOff <percent>:   Percentage of eigen vectors to retain (see cutOffMode).\n        DEFAULT = (See cutoff mode)\n");
  printf ("    -quiet:                Turn off all messages.\n"
	  "        DEFAULT = messages on\n");
  printf ("    -debuglevel <int>:     Level of debug information to display"
	  "        (automatically sets quiet to no).\n"
	  "        DEFAULT = 0\n");
  exit (1);
}

/**
 * Process the command line and initialize the variables
 *
 * @param argc The number of arguments
 * @param argv The arguments
 */
void
process_command (int argc, char **argv, Arguments * args)
{
  int i;
  int param_num = 0;
  int cutOffSet = 0;

  /******* Set up default values *******/

  args->argc = argc;
  args->argv = argv;

  args->nIntrapersonal = 100;
  args->nExtrapersonal = 100;
  args->distanceMatrix = NULL;
  args->maxRank        = -1;

  args->cutOffMode      = CUTOFF_SIMPLE;
  args->cutOff          = DEFAULT_CUTOFF_PERCENT_SIMPLE;
  args->dropNVectors    = 0;

  debuglevel = 0;

  /******* Read command line arguments *******/

  for (i = 1; i < argc; i++) {

    /* Catch common help requests */
    if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
    else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

    /* Read in input directories */
    else if (readOptionString (argc, argv, &i, "-imDir",     &(args->imageDirectory)));
    else if (readOptionString (argc, argv, &i, "-distances", &(args->distanceMatrix)));

    /* Read in number of images to generate */
    else if (readOptionInt    (argc, argv, &i, "-ni", &(args->nIntrapersonal)));
    else if (readOptionInt    (argc, argv, &i, "-ne", &(args->nExtrapersonal)));

    /* Read in maxRank */
    else if (readOptionInt    (argc, argv, &i, "-maxRank", &(args->maxRank)));

    /* Read in PCA training options */
    else if (readOptionInt    (argc, argv, &i, "-dropNVectors", &(args->dropNVectors)));

    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "NONE"))
      { args->cutOffMode = CUTOFF_NONE; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "SIMPLE"))
      { args->cutOffMode = CUTOFF_SIMPLE; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "ENERGY"))
      { args->cutOffMode = CUTOFF_ENERGY; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "STRETCH"))
      { args->cutOffMode = CUTOFF_STRETCH; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "CLASSES"))
      { args->cutOffMode = CUTOFF_CLASSES; }

    else if (readOptionDouble (argc, argv, &i, "-cutOff", &(args->cutOff)))
      {
	if ((args->cutOff <= 1.0) && (args->cutOff >= 0.000001)) {
	  printf("WARNING: cutOff value is %f, expects percentage "
		 "between 0.0 and 100.0", args->cutOff);
	  printf("         will proceed assuming value is as desired.");
	}
	cutOffSet = 1;
      }   

    /* other flags */
    else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
    else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));

    /* check if the current argument is an unparsed option */
    else if (checkBadOption(argc,argv,&i));

    /* read required arguments */ 
    else if (param_num == 0) {
      args->imageList = argv[i];
      param_num++;
    }
    else if (param_num == 1) {
      args->trainingFilename = strdup (argv[i]);
      param_num++;
    } 
  }

  /* make sure that there are the proper number of required arguments */

  if (param_num != 2){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

  /* Print out the program parameters for appropriate debug level */

  DEBUG_INT (1, "Debuging enabled", debuglevel);
  if(debuglevel > 0){
    printf("***************** Program Parameters *********************\n");
    printf ("Image directory:  %s\n", args->imageDirectory);
    printf ("Image list:       %s\n", args->imageList);
    printf ("nIntrapersonal:   %d\n", args->nIntrapersonal);
    printf ("nExtrapersonal:   %d\n", args->nExtrapersonal);
    printf ("distanceMatrix:   %s\n ", args->distanceMatrix);
  }
}

/******************************************************************************
*                             DIFFERENCE IMAGE ROUTINES                       *
******************************************************************************/

void
makeDifferenceImages (char *imageDirectory, char *imageList, char *distanceMatrix, int maxRank, int reqNIntra, int reqNExtra, Matrix *intrapersonal, Matrix *extrapersonal)
{
  ImageList* imlist;
  void *nameList = NULL;
  char **nameArray;
  void *subjList = NULL;
  int *subjArray, *shuffledIndices, **sortedBySimilarityToProbe;
  int subjId, probeIdx, galleryIdx, idx, nIntrapersonal, nExtrapersonal, rank, i, numPixels;
  int nImages;
  /* size_t trash; */
  Matrix sourceImages, intraImages, extraImages;
  ImageList *replicate, *subject;
  char *subjName;

  /* Read in a list of all the images */

  imlist = getImageNames (imageList, &nImages);
  subjId = 0;
  for EACH_SUBJECT (imlist, subject) {
      for EACH_REPLICATE (subject, replicate) {
        subjName = strdup (replicate->filename);
	listAccumulate (&nameList, &subjName, sizeof (char *));
	listAccumulate (&subjList, &subjId,   sizeof (int));
	writeProgress ("Reading subjects list", subjId, 0);
      }
      subjId++;
  }

  nameArray = listToNullTerminatedArray (&nameList, sizeof (char *), NULL);
  subjArray = listToNullTerminatedArray (&subjList, sizeof (int),    NULL);

  /* Allocate storage for source images and difference images */

  numPixels = autoFileLength (makePath (imageDirectory, nameArray[0]));

  sourceImages = makeMatrix (numPixels, nImages);
  intraImages  = makeMatrix (numPixels, reqNIntra);
  extraImages  = makeMatrix (numPixels, reqNExtra);

  DEBUG_CHECK (sourceImages != NULL, "Not enough memory to allocate matrix");
  DEBUG_CHECK (intraImages  != NULL, "Not enough memory to allocate matrix");
  DEBUG_CHECK (extraImages  != NULL, "Not enough memory to allocate matrix");

  /* Load in all the source images */

  for (i = 0; i < nImages; i++) {
    readFile (makePath (imageDirectory, nameArray[i]), i, sourceImages);
    writeProgress ("Loading source images", i, nImages);
  }

  /* Write out difference images */

  shuffledIndices = shuffledNumbers (nImages);

  idx = 0;
  rank = 0;
  nIntrapersonal = 0;
  nExtrapersonal = 0;

  if (maxRank == -1)
      maxRank = nImages;

  /* First, for each image generate a list of every other image
   * sorted by similarity to that image */

  sortedBySimilarityToProbe = (int**) malloc  (nImages * sizeof (int*));
  for (probeIdx = 0; probeIdx < nImages; probeIdx++) {
    sortedBySimilarityToProbe[probeIdx] = (int*) malloc  (nImages * sizeof (int));
    if (sortedBySimilarityToProbe[probeIdx] == 0L)
      {
	fprintf (stderr, "Not enough memory to continue\n");
	exit (1);	
      }
    sortSubjectsBySimilarityToProbe (nameArray[probeIdx], nameArray, distanceMatrix, sortedBySimilarityToProbe[probeIdx]);
    writeProgress ("Sorting images", probeIdx, nImages);
  }

  /* Now write out the difference images */

  while (nIntrapersonal < reqNIntra || nExtrapersonal < reqNExtra)
    {
      probeIdx = shuffledIndices[idx];

      idx++;
      if (idx == nImages)
	{
	  idx = 0;
	  rank++;

	  if (rank == maxRank)
	    {
	      fprintf (stderr, "\n");
	      fprintf (stderr, "WARNING: Unable to generate enough images. Try increasing maxRank or adding more subjects to the list.\n");
	      break;
	    }
	}
      
      galleryIdx = sortedBySimilarityToProbe[probeIdx][rank];
	  
      if (galleryIdx == probeIdx || !strcmp (nameArray[probeIdx], nameArray[galleryIdx]))
	continue;

      /* Compute the difference image */

      if (subjArray[probeIdx] == subjArray[galleryIdx])
	{
	  if(nIntrapersonal < reqNIntra) {
	    for (i = 0; i < sourceImages->row_dim; i++)
	      ME (intraImages, i, nIntrapersonal) = ME (sourceImages, i, probeIdx) - ME (sourceImages, i, galleryIdx);

	    nIntrapersonal++;
	  }
	}
      else
	{
	  if( nExtrapersonal < reqNExtra ) {
	    for (i = 0; i < sourceImages->row_dim; i++)
	      ME (extraImages, i, nExtrapersonal) = ME (sourceImages, i, probeIdx) - ME (sourceImages, i, galleryIdx);

	    nExtrapersonal++;
	  }
	}
      
      writeProgress ("Computing difference images", nIntrapersonal + nExtrapersonal, reqNIntra + reqNExtra);
    }

  fprintf (stdout, "Generated %d extrapersonal images\n", nExtrapersonal);
  fprintf (stdout, "Generated %d intrapersonal images\n", nIntrapersonal);

  /* Clean up */

  for (probeIdx = 0; probeIdx < nImages; probeIdx++)
    free (sortedBySimilarityToProbe[probeIdx]);
  free (sortedBySimilarityToProbe);

  freeMatrix (sourceImages);
  freeListOfStrings (nameArray);
  free (subjArray);
  free (shuffledIndices);

  *extrapersonal = extraImages;
  *intrapersonal = intraImages;
}

/******************************************************************************
*                               MAIN PROGRAM                                  *
******************************************************************************/

/*
    main()
 */
int
main (int argc, char *argv[])
{
  Arguments args;
  Matrix intraImages, extraImages;
  Subspace intraSubspace, extraSubspace;
  char filename[256];

  process_command (argc, argv, &args);
  MESSAGE (OPENING);
  MESSAGE (VERSION);

  /* Sanity check */

  checkReadableDirectory (args.imageDirectory, "%s is not a readable directory");
  checkReadableFile (args.imageList, "Cannot read subject replicates list %s");

  makeDifferenceImages (args.imageDirectory,
			args.imageList,
			args.distanceMatrix,
			args.maxRank,
			args.nIntrapersonal,
			args.nExtrapersonal,
			&intraImages,
			&extraImages
			);

  MESSAGE("Training intrapersonal subspace");

  subspaceTrain (&intraSubspace, intraImages, NULL, args.nIntrapersonal, args.dropNVectors, args.cutOffMode, args.cutOff, 0, 0);

  MESSAGE("Training extrapersonal subspace");

  subspaceTrain (&extraSubspace, extraImages, NULL, args.nExtrapersonal, args.dropNVectors, args.cutOffMode, args.cutOff, 0, 0);

  MESSAGE("Saving intrapersonal training file");

  sprintf (filename, "%s.intra", args.trainingFilename);
  writeSubspace (&intraSubspace, filename, args.imageList, args.argc, args.argv);

  MESSAGE("Saving extrapersonal training file");

  sprintf (filename, "%s.extra", args.trainingFilename);
  writeSubspace (&extraSubspace, filename, args.imageList, args.argc, args.argv);

  MESSAGE("Finished Training.");
  
  return 0;

}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 *  csuCommonCommandLine.c
 *  csuEvalFaceRec
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "csuCommon.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* returns true if opt is parsed and i+=0 */
int readOption(int argc, char** argv, int *i, const char* opt){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            return 1;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }
    
    return 0;
}

/* returns true if opt is parsed and sets arg to point to location in argv that is after flag (the next string) i+=1 */
int readOptionString(int argc, char** argv, int *i, const char* opt, char** arg){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            (*i) += 1;
            if(*i < argc){
                (*arg) = argv[(*i)];
            } else {
                clParseError(argc, argv, (*i), "Option expects one argument.");
            }

            return 1;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;    
}

/* returns true if opt is parsed and sets arg to point to location in argv that is after flag (the next string) i+=1 */
int readOptionYesNo(int argc, char** argv, int *i, const char* opt, int* flag){
    if((*i) < argc){
        if(strcasecmp(argv[*i],opt) == 0){
            (*i) += 1;
            if((*i) < argc){
                if(strcasecmp(argv[(*i)], CL_YES_STRING) == 0){
                    (*flag) = CL_YES;
                    return 1;
                }
                else if (strcasecmp(argv[(*i)], CL_NO_STRING) == 0){
                    (*flag) = CL_NO;
                    return 1;
                }
                else{
                    clParseError(argc, argv, (*i), "Option expects YES or NO.");
                }
            } else {
                clParseError(argc, argv, (*i), "Option expects YES or NO.");
            }

            return 1;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;
    
}

/* returns true only if opt is parsed and following argument string matches arg
* This is used to test for options like -hist PRE -hist POST -hist NONE i+=1*/
int readOptionMatch(int argc, char** argv, int *i, const char* opt, const char* arg){
    if((*i) < argc){
        if(strcasecmp(argv[*i],opt) == 0){
            if((*i) < argc){
                if(strcasecmp(argv[(*i)+1], arg) == 0){
                    /* option parsed inc and return */
                    (*i) += 1;
                    return 1;
                }
            } else {
                clParseError(argc, argv, (*i), "Option expects one argument");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;    
}

/* this reads in an option and an int. i+=1 */
int readOptionInt(int argc, char** argv, int *i, const char* opt, int *arg){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            (*i)+=1;
            if((*i) < argc){
                (*arg) = atoi(argv[(*i)]);
                return 1;
            } else {
                clParseError(argc, argv, (*i), "Option expects one argument");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;
}

/* this reads in an option and two ints. i+=2 */
int readOptionInt2(int argc, char** argv, int *i, const char* opt, int *arg1, int *arg2){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            /* Try to read first int */
            (*i)+=1;
            if((*i) < argc){
                (*arg1) = atoi(argv[(*i)]);
            } else {
                clParseError(argc, argv, (*i), "Option expects two arguments");
            }

            /* Try to read second int */
            (*i)+=1;
            if((*i) < argc){
                (*arg2) = atoi(argv[(*i)]);
                return 1;
            } else {
                clParseError(argc, argv, (*i), "Option expects two arguments");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;
}

/* this reads in an option and a double. i+=1 */
int readOptionDouble(int argc, char** argv, int *i, const char* opt, double *arg){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            (*i)+=1;
            if((*i) < argc){
                (*arg) = atof(argv[(*i)]);
                return 1;
            } else {
                clParseError(argc, argv, (*i), "Option expects one argument");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;    
}

/* this reads in an option and four doubles. i+=4 */
int readOptionDouble2(int argc, char** argv, int *i, const char* opt, double *arg1, double *arg2){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            /* Try to read first double */
            (*i)+=1;
            if((*i) < argc){
                (*arg1) = atof(argv[(*i)]);
            } else {
                clParseError(argc, argv, (*i), "Option expects two arguments");
            }

            /* Try to read second double */
            (*i)+=1;
            if((*i) < argc){
                (*arg2) = atof(argv[(*i)]);
                return 1;
            } else {
                clParseError(argc, argv, (*i), "Option expects two arguments");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;
    
}

/* this reads in an option and four doubles. i+=4 */
int readOptionDouble4(int argc, char** argv, int *i, const char* opt, double *arg1, double *arg2, double *arg3, double *arg4){
    if((*i) < argc){
        if(strcasecmp(argv[(*i)],opt) == 0){
            /* Try to read first double */
            (*i)+=1;
            if((*i) < argc){
                (*arg1) = atof(argv[(*i)]);
            } else {
                clParseError(argc, argv, (*i), "Option expects four arguments");
            }

            /* Try to read second double */
            (*i)+=1;
            if((*i) < argc){
                (*arg2) = atof(argv[(*i)]);
            } else {
                clParseError(argc, argv, (*i), "Option expects four arguments");
            }

            /* Try to read third double */
            (*i)+=1;
            if((*i) < argc){
                (*arg3) = atof(argv[(*i)]);
            } else {
                clParseError(argc, argv, (*i), "Option expects four arguments");
            }

            /* Try to read fourth double */
            (*i)+=1;
            if((*i) < argc){
                (*arg4) = atof(argv[(*i)]);
                return 1;
            } else {
                clParseError(argc, argv, (*i), "Option expects four arguments");
            }

            return 0;
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;    
}

/* Reads in a required argument, only if num == arg_num i += 0*/
int readRequiredString(int argc, char** argv, int *i, int *num, int arg_num, char** arg);

/* Reads in a required argument, only if num == arg_num i += 0*/
int readRequiredInt(int argc, char** argv, int *i, int *num, int arg_num, int* arg);

/* check to see if current argument starts with a dash and if it does output an error and exit. otherwize return 0 */
int checkBadOption(int argc, char** argv, int *i){
    if((*i) < argc){
        if(argv[(*i)][0] == '-'){
            clParseError(argc, argv, (*i), "Unrecognized option.");
        }
    }
    else{
        clParseError(argc, argv, (*i), "Error parsing command line.");
    }

    return 0;
}

/* Output a command line parsing error */
void clParseError(int argc, char **argv, int i, char* message){
    fprintf(stdout, "Error: %s\n", message);
    fprintf(stdout, "       for command at command line argument <%d: %s >\n", i, (i < argc) ? argv[i] : "(Error: passed end of line)");
    usage((0 < argc) ? argv[0] : "(Error: No program name)");
    exit(1);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_COMMAND_LINE_INCLUDED
#define CSU_COMMAND_LINE_INCLUDED

#define CL_YES_STRING "YES"
#define CL_NO_STRING  "NO"

#define CL_YES 1
#define CL_NO  0

/*
 *  These functions are used to parse basic command line options
 *  argc and argv are basic command line parameters
 *  i is the current scanning location in the command line
 *  opt is a string giving the option to look for in the command line
 *  additional parameters are option parameters that follow the
 *  option string.
 *
 *  Optional arguments should always be parsed before required arguments.
 *
 *  The functions are maid to be called within a four loop that inc i.
 *  If more that one argument is parsed i is updated to point at the last
 *  argument read to allow exicution to proceed normally on next loop.
 *
 *  Here is an example code illistrating how to parse command lines
 *  with this api:
 *
 *  int i; int num = 0;
 *
 *  Set up default values here.
 *
 *  for(i = 0; i < argc; i++){
 *      if      (readOption(argc, argv, &i, "-verbose"))                   { verbose = 1; }
 *      else if (readOptionInt(argc, argv, &i, "-debuglevel",&debuglevel)) {}
 *      else if (checkBadOption(argc, argv, &i))                           {}
 *      else if (readReqiredString(argc, argv, &i, &num, 0, filename))     {}
 *  }
 *
 *  then check to see if the correct number of required arguments were parsed
 *  if(num != 1){ clParseError(argc, argv, i, "Wrong number of command line arguments."); }
 *
 *  This code also expects that you have a useage function define that takes argv[0]
 *  as its only arguments and exits with value 1.
 */

/* prototype to use for an external usage statement */
void usage(const char* );

/* returns true if opt is parsed and i+=0 */
int readOption(int argc, char** argv, int *i, const char* opt);

/* returns true if opt is parsed and sets arg to point to location in argv that is after flag (the next string) i+=1 */
int readOptionString(int argc, char** argv, int *i, const char* opt, char** arg);

/* returns true if opt is parsed and sets arg to point to location in argv that is after flag (the next string) i+=1 */
int readOptionYesNo(int argc, char** argv, int *i, const char* opt, int* flag);

/* returns true only if opt is parsed and following argument string matches arg
 * This is used to test for options like -hist PRE -hist POST -hist NONE i+=1*/
int readOptionMatch(int argc, char** argv, int *i, const char* opt, const char* arg);

/* this reads in an option and an int. i+=1 */
int readOptionInt(int argc, char** argv, int *i, const char* opt, int *arg);

/* this reads in an option and two ints. i+=2 */
int readOptionInt2(int argc, char** argv, int *i, const char* opt, int *arg1, int *arg2);

/* this reads in an option and a double. i+=1 */
int readOptionDouble(int argc, char** argv, int *i, const char* opt, double *arg);

/* this reads in an option and two doubles. i+=2 */
int readOptionDouble2(int argc, char** argv, int *i, const char* opt, double *arg1, double *arg2);

/* this reads in an option and four doubles. i+=4 */
int readOptionDouble4(int argc, char** argv, int *i, const char* opt, double *arg1, double *arg2, double *arg3, double *arg4);

/* Reads in a required argument, only if num == arg_num i += 0*/
int readRequiredString(int argc, char** argv, int *i, int *num, int arg_num, char** arg);

/* Reads in a required argument, only if num == arg_num i += 0*/
int readRequiredInt(int argc, char** argv, int *i, int *num, int arg_num, int* arg);

/* check to see if current argument starts with a dash and if it does output an error and exit. otherwize return 0 */
int checkBadOption(int argc, char** argv, int *i);

/* Output a command line parsing error */
void clParseError(int argc, char **argv, int i, char* message);

#endif




/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 File: csuFileCommon.c
 Authors: J. Ross Beveridge, David Bolme and Kai She
 Date:    March 15, 2002
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * Purpose: This file contains File IO routines used by csuSubspaceTrain
 * and csuSubspaceTest.
 */


/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>

#include "csuCommon.h"

/******************************************************************************
*                               GLOBALS                                       *
******************************************************************************/

/**
 * EL and NUM are used to read binary data and convert to proper internal float representation
 */

typedef struct {char a, b, c, d;}
EL;
typedef union {float f; EL elem;} NUM;

/******************************************************************************
*                               FILE UTILITIES                                *
******************************************************************************/

/*
 The following six functions are used to read and write binary information to file
 in a way that is platform independant.  Each function checks the endianness of
 the current architecture and reverses the byte order if nessessary.
 */

typedef struct {char a,b,c,d;} bytes4;
typedef union {float n; bytes4 elem;} float4;
typedef union {int n; bytes4 elem;} int4;

typedef struct {char a,b,c,d,e,f,g,h;} bytes8;
typedef union {double n; bytes8 elem;} double8;

void writeInt(FILE* f, int n){
    int4 tmp;
    tmp.n = n;
    if( isMachineLittleEndian() ){
        fwrite(&(tmp.elem.d),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.a),1,1,f);
    }
    else{
        fwrite(&(tmp.elem.a),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.d),1,1,f);
    }
}

void writeFloat(FILE* f, float n){
    float4 tmp;
    tmp.n = n;
    if( isMachineLittleEndian() ){
        fwrite(&(tmp.elem.d),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.a),1,1,f);
    }
    else{
        fwrite(&(tmp.elem.a),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.d),1,1,f);
    }
}

void writeDouble(FILE* f, double n){
    double8 tmp;
    tmp.n = n;
    if( isMachineLittleEndian() ){
        fwrite(&(tmp.elem.h),1,1,f);
        fwrite(&(tmp.elem.g),1,1,f);
        fwrite(&(tmp.elem.f),1,1,f);
        fwrite(&(tmp.elem.e),1,1,f);
        fwrite(&(tmp.elem.d),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.a),1,1,f);
    }
    else{
        fwrite(&(tmp.elem.a),1,1,f);
        fwrite(&(tmp.elem.b),1,1,f);
        fwrite(&(tmp.elem.c),1,1,f);
        fwrite(&(tmp.elem.d),1,1,f);
        fwrite(&(tmp.elem.e),1,1,f);
        fwrite(&(tmp.elem.f),1,1,f);
        fwrite(&(tmp.elem.g),1,1,f);
        fwrite(&(tmp.elem.h),1,1,f);
    }
    
}

void readInt(FILE* f, int* n){
    int4 tmp;
    if(isMachineLittleEndian() ){
        fread(&(tmp.elem.d),1,1,f);
        fread(&(tmp.elem.c),1,1,f);
        fread(&(tmp.elem.b),1,1,f);
        fread(&(tmp.elem.a),1,1,f);
    }
    else{
        fread(&(tmp.elem.a),1,1,f);
        fread(&(tmp.elem.b),1,1,f);
        fread(&(tmp.elem.c),1,1,f);
        fread(&(tmp.elem.d),1,1,f);
    }
    *n = tmp.n;
}

void readFloat(FILE* f, float* n){
    float4 tmp;
    if(isMachineLittleEndian() ){

      fread(&(tmp.elem.d),1,1,f);
      fread(&(tmp.elem.c),1,1,f);
      fread(&(tmp.elem.b),1,1,f);
      fread(&(tmp.elem.a),1,1,f);
    }
    else{
      fread(&(tmp.elem.a),1,1,f);
      fread(&(tmp.elem.b),1,1,f);
      fread(&(tmp.elem.c),1,1,f);
      fread(&(tmp.elem.d),1,1,f);
    }
    *n = tmp.n;
}

/*
void readDouble(FILE* f, double* n){
  double8 tmp;

  fread(&tmp, 8, 1, f);
  *n = tmp.n;
}
*/

void readDouble(FILE* f, double* n){
    double8 tmp;

    
    if(isMachineLittleEndian() ){
        fread(&(tmp.elem.h),1,1,f);
        fread(&(tmp.elem.g),1,1,f);
        fread(&(tmp.elem.f),1,1,f);
        fread(&(tmp.elem.e),1,1,f);
        fread(&(tmp.elem.d),1,1,f);
        fread(&(tmp.elem.c),1,1,f);
        fread(&(tmp.elem.b),1,1,f);
        fread(&(tmp.elem.a),1,1,f);
    }
    else{
        fread(&(tmp.elem.a),1,1,f);
        fread(&(tmp.elem.b),1,1,f);
        fread(&(tmp.elem.c),1,1,f);
        fread(&(tmp.elem.d),1,1,f);
        fread(&(tmp.elem.e),1,1,f);
        fread(&(tmp.elem.f),1,1,f);
        fread(&(tmp.elem.g),1,1,f);
        fread(&(tmp.elem.h),1,1,f);
    }
    *n = tmp.n;
}



/**
 * Given a directory name and a file name, this function returns a
 * correctly formed path string.
 *
 * Caveat: This function returns a pointer to an internal buffer,
 *         so the value it returns is valid only until the next
 *         call to makePath
 *
 * @param directoryName Directory part
 * @param fileName File name part
 * @returns Pointer to buffer containing combined path 
 */

char *
makePath (const char *directoryName, const char *fileName)
{
    static char path[255];
    const char *osDependentPathSeparator = "/";
    sprintf (path, "%s%s%s", directoryName, osDependentPathSeparator, fileName);
    return path;
}

/**
 * Ensures that a given directory is writeable. Prints a error message
 * and exits if it is not or if it is not a directory.
 *
 * @param directory Path to an allegedly writeable directory
 * @param message Message to print if allegation is false
 */

void
checkWriteableDirectory (const char *directory, const char *message)
{
    struct stat buf;
    int err = stat (directory, &buf);
    int ok = (err == 0) && S_ISDIR (buf.st_mode)
        && (access (directory, W_OK) == 0);

    if (!ok)
    {
        fprintf (stderr, message, directory);
        fprintf (stderr, "\n");
        exit (1);
    }
}

/**
 * Ensures that a given directory is readable. Prints a error message
 * and exits if it is not or if it is not a directory.
 *
 * @param directory Path to an allegedly readable directory
 * @param message Message to print if allegation is false
 */

void
checkReadableDirectory (const char *directory, const char *message)
{
    struct stat buf;
    int err = stat (directory, &buf);
    int ok = (err == 0) && S_ISDIR (buf.st_mode)
        && (access (directory, R_OK) == 0);
    if (!ok)
    {
        fprintf (stderr, message, directory);
        fprintf (stderr, "\n");
        exit (1);
    }
}

/**
 * Ensures that a given file is readable. Prints a error message
 * and exits if it is not or if it is not a file.
 *
 * @param directory Path to an allegedly readable file
 * @param message Message to print if allegation is false 
 */
void
checkReadableFile (const char *file, const char *message)
{
    struct stat buf;
    int err = stat (file, &buf);
    int ok = (err == 0) && S_ISREG (buf.st_mode) && (access (file, R_OK) == 0);
    if (!ok)
    {
        fprintf (stderr, message, file);
        fprintf (stderr, "\n");
        exit (1);
    }
}

/******************************************************************************
*                     SIMILARITY RANKING UTILITIES                            *
******************************************************************************/

/**
 * Reads all of the names in a file into an array of
 * strings. Each element of the array is a char pointer.
 *
 * If nStrings is non-NULL, the number of strings is
 * returned in nStrings.
 *
 * The array is always one larger than nStrings elements
 * long and the last element is a NULL.
 *
 * @param fileName Name of file to read
 * @param nStrings Optional pointer to integer that will on return contain
 *                 the count of strings read from the file
 * @returns A NULL-terminated list of NULL-terminated strings
 */
ListOfStrings
readListOfStrings (const char *fileName, int *nStrings)
{
    Tokenizer tok;
    void *stringList = NULL;
    FILE *f;
    char *string;
    ListOfStrings array;
    size_t numStrings;

    f = fopen (fileName, "r");
    DEBUG_CHECK (f, "Unable to read file");

    tokenizerInit (&tok, tokenizerStreamReader, f);
    while (!tokenizerEndOfFile (&tok))
    {
        string = strdup (tokenizerGetWord (&tok));
        listAccumulate (&stringList, &string, sizeof (unsigned char *));
    }

    fclose (f);

    /* Add a terminating NULL */
    string = NULL;
    listAccumulate (&stringList, &string, sizeof (unsigned char *));

    array = (ListOfStrings)listToArray (&stringList, sizeof (unsigned char *), &numStrings);
    if (nStrings) *nStrings = numStrings - 1; /* Don't count the NULL */
    return array;
}

/**
 * Frees a list of strings.
 *
 * @param list A NULL-terminated list of NULL-terminated strings.
 */
void
freeListOfStrings (ListOfStrings list)
{
    char **p = list;
    while (*p != NULL)
        free (*p++);
    free (list);
}

/**
 * This function counts the string in a NULL-terminated list of strings
 *
 * @param list A NULL-terminated list of NULL-terminated strings.
 * @returns The count of strings in the list
 */

int
countStrings (ListOfStrings list)
{
  int count = 0;
  char **p = list;
  while (*p++ != NULL)
    count++;
  return count;
}

/******************************************************************************
*                     SIMILARITY RANKING UTILITIES                            *
******************************************************************************/

/**
 * A data structure for associating a name with a distance score.
 *
 * This structure is used internally by "sortSubjectsBySimilarityToProbe"
 */

typedef struct
{
  char *subject;
  double distance;
  int index;
}
DistanceMeasure;

/**
 * A qsort helper function for sorting DistanceMeasure records.
 *
 * This function is used internally by "sortSubjectsBySimilarityToProbe"
 *
 * @param a The first object in the pair to compare
 * @param b The second object in the pair to compare
 */

int
distanceMeasureComparator (const void *a, const void *b)
{
  const DistanceMeasure *d1 = (DistanceMeasure *)a;
  const DistanceMeasure *d2 = (DistanceMeasure *)b;

  if (d1->distance < d2->distance)
    return -1;
  if (d1->distance > d2->distance)
    return 1;
  return 0;
}

/**
 * Given a pointer to an array of names of various subjects, and a probe image,
 * this function sorts the array by similarity to the probe image. As a special
 * case, if the probe image appears in the subject list, it is ranked as most
 * dissimilar. This function takes the name of a distance matrix from which
 * the scores are read. As a special case, if this is NULL, then scores are
 * picked at random, which effectively shuffles the array.
 *
 * If indices is non-NULL, subjects is not shuffled, but instead the indices
 * of the rearranged items are returned in indices.
 *
 * @param probe A probe image against which the subjects are sorted
 * @param subjects A NULL-terminated list of NULL-terminated strings.
 * @param distanceMatrix Distance matrix from which scores are read.
 * @param indices Optional array of integers that will contain the indices of the sorted
 *                elements in the original sequence. This parameter may be NULL.
 */

void
sortSubjectsBySimilarityToProbe (char *probe, ListOfStrings subjects, char *distanceMatrix, int *indices)
{
  int i, j, nDistances;
  DistanceMeasure *distances = NULL;
  DistanceMeasure *toSort = NULL;

  int nSubjects = countStrings (subjects);

  /* If we are using a distance matrix, then we load up the
   * list of distances from the probe image. This allows us
   * to lookup the distances from the probe quickly
   */
  if (distanceMatrix)
    {
      Tokenizer tok;
      FILE *f = fopen (makePath (distanceMatrix, probe), "r");
      void *distanceList = NULL;

      DEBUG_CHECK_1ARG (f, "Unable to open file %s in scores directory", makePath (distanceMatrix, probe));

      tokenizerInit (&tok, tokenizerStreamReader, f);
      while (!tokenizerEndOfFile (&tok))
	{
	  DistanceMeasure m;
	  m.subject = strdup (tokenizerGetWord (&tok));
	  m.distance = atof (tokenizerGetWord (&tok));
	  listAccumulate (&distanceList, &m, sizeof (DistanceMeasure));
	}
      fclose (f);
      distances = (DistanceMeasure*) listToArray (&distanceList, sizeof (DistanceMeasure), (size_t*)&nDistances);
    }

  /* Copy the list of names into the intermediate data structure that allows us to sort the
   * subjects by distance to the probe.
   */

  toSort = (DistanceMeasure*) malloc (nSubjects * sizeof (DistanceMeasure));

  for (j = 0; j < nSubjects; j++)
    {
      toSort[j].subject = subjects[j];
      toSort[j].distance = 0.0;
      toSort[j].index = j;
    }

  /* Read distances between probe and every other image in the subject list.
   * As a special case, a subject is said to be infinitely far away from him/herself.
   * Random scores are used when a distanceMatrix is not provided */

  for (j = 0; j < nSubjects; j++)
    {
      if (strcmp (subjects[j], probe) == 0) {

	/* Probe and subject are the same. Say they are far apart since
	 * we don't want to treat an image and itself as being two replicates
	 * of a person */

	toSort[j].distance = HUGE;

      } else if (distanceMatrix != NULL) {

	/* Look for the subject in the list of distances and return assign the 
	 * score */

	toSort[j].distance = HUGE;

	for (i = 0; i < nDistances; ++i)
	  if (strcmp (distances[i].subject, toSort[j].subject) == 0)
	    toSort[j].distance = distances[i].distance;

      } else {

	/* If we are not using a distance matrix, then choose
	 * a random value */

	toSort[j].distance = ((double) random ()) / RAND_MAX;

      }
    }

  /* Now sort the list by similarity to the probe */

  qsort (toSort, nSubjects, sizeof (DistanceMeasure), distanceMeasureComparator);

  /* Copy the data back into the subject list or return the permuted indices */

  if (indices == NULL)
    for (j = 0; j < nSubjects; j++) {
      subjects[j] = toSort[j].subject;
    }
  else
    for (j = 0; j < nSubjects; j++) {
      indices[j] = toSort[j].index;
    } 

  /* Clean up */

  if (distanceMatrix)
    {
      for (i = 0; i < nDistances; ++i)
	free (distances[i].subject);
      free (distances);
    }

  free (toSort);
}

#define FREAD_FLOAT_CNT 256


/******************************************************************************
*                     FUNCTIONS FOR WORKING WITH SFI FILES                    *
******************************************************************************/

/**
 * Read a binary image from a file where the pixels are stored as 32 bit
 * floating point numbers using Sun byte order.  The compiler directive WINDOWS
 * is used to control how the byte order is interpreted when storing the pixels
 * into the data structure images. Images are a one dimensional array of floats
 * that contains each successive image in sequence, where each image has in turn
 * been unrolled into a 1 dimensional vector.
 *
 * @param fname The name of the file from which to read the image.
 * @param n The index of this image in the images array.
 * @param images The matrix into the image is read. Only the nth column is affected.
 */
void readFile(const char *fname, int n, Matrix images) {
    int i;
    FILE *f;
#ifdef FASTREAD
    float fread_buf[FREAD_FLOAT_CNT];
#endif
    /*  char nan_error[100];
	char inf_error[100];*/
    char line[FILE_LINE_LENGTH];
    char imagetype[FILE_LINE_LENGTH];

    /*if (debuglevel > 1)*/
    printf("\nReading file: %s\n", fname); fflush(stdout);

    /* Check to makesure file is of expected size */
    if (images->row_dim != autoFileLength(fname)) {
        DEBUG_CHECK(autoFileLength(fname) < images->row_dim, "File does not contian enough values");
        printf("Warning: file length is greater than vector length.  Croping file...\n");
    }


    f = fopen( fname, "rb" );
    assert(f);
    /*if ( !f ) { printf("Can't open %s\n", fname); exit(1); }*/

    /* check to see if image is of type RASTER_ID */
    fgets(line,FILE_LINE_LENGTH,f); /* only read in enough to determine
                                     * if the file is of proper type */
    sscanf(line,"%s",imagetype);
    if(strcmp(imagetype,RASTER_ID) == 0 || strcmp(imagetype,"CSU_RASTER") ==0){
        rewind(f);
        /* read in the first line to move the buffer to the data. */
        fgets(imagetype,FILE_LINE_LENGTH,f);
    }
    else{
        /* There is no header info. Just read the data */
        rewind(f);
    }

#ifdef FASTREAD
    for (i = 0; i < images->row_dim; ) {
      int numread=0, j=0;
      int toread = images->row_dim - i;

      if (toread > FREAD_FLOAT_CNT)
	toread = FREAD_FLOAT_CNT;

      numread = fread(fread_buf, 4, toread, f);
      assert((toread == numread) && "fread failure");

      for (j=0; j < numread; j++)
	ME(images, i, n) = (FTYPE) fread_buf[j];

      i+= numread;
    }

#else

    /* Set up error messages for use later */
    /*   sprintf(nan_error, "Not A Number value in file: %s", fname);
	 sprintf(inf_error, "Infinite value in file: %s", fname); */

    for (i = 0;i < images->row_dim;i++) {
         float flt;
         /* read in the correct byte order for floating point values */
        readFloat(f, &flt);

#ifdef CHECK_VALS
        /* Check values to make sure they are real */
	/*  FINITE(flt);*/
	if(!finite(n)) { assert(0 && "infinite value");} 

#endif
        /* Save value to images */
        ME(images, i, n) = (FTYPE)flt;
    }
#endif

    fclose(f);
}






/**
 * This code was used to detect the length of old nrm images.  That file
 * format is no longer in use the function was renamed and will soon be deleted
 * -- DSB
 *
 * autoFileLength returns the filelength/4 of imageName. This is used
 * to check the image files and determine at run time how many
 * floating point values. Note, stat returns the number of bytes, and
 * the divide by four converts to the number of floats.  autoFileLength
 * lets the code here auto detect the size of the images, i.e. the row
 * dimension of the covariance matrix, without requiring the user to
 * pass this value in as an argument
 *
 * @param imageName Path to an image
 * @return The size of the image
 */
int autoFileLength(const char* imageName) {
    FILE* f;
    char imagetype[FILE_LINE_LENGTH];
    char line[FILE_LINE_LENGTH];

    /* First, check to see if the file is of type RASTER_ID. This is a newer
       image format which contains the dimensions in a header
     */

    f = fopen(imageName,"r");
    if ( !f ) { printf("Can't open %s\n", imageName); exit(1); }

    fgets(line,FILE_LINE_LENGTH,f); /* only read in enough to determine
                                     * if the file is of proper type */
    fclose(f);

    sscanf(line,"%s",imagetype);

    if (strcmp(imagetype,RASTER_ID) == 0 || strcmp(imagetype,"CSU_RASTER") == 0){
      int w,h,c;

      sscanf(line,"%s %d %d %d",imagetype,&w,&h,&c);
      return w*h*c;
    } else {
      /* Otherwise, we are using an old format and the we return
         the filelength/4 as the size */
      struct stat filestatus;

      DEBUG_CHECK(0,"Old nrm image format no longer supported");
      if (stat(imageName, &filestatus)) {
        fprintf(stderr, "Error: Could not stat file %s\n", imageName);
        exit(1);
      }
      return filestatus.st_size / 4;
    }
}

/**
 * Code to read the image names being passed in and to create the 2 dimensional table
 * of these names. Each row is a different subject. Each column is a replicate for that
 * subject. Linked lists are used along each dimension since prior to reading the file
 * the number of subjects is unknown, as is the number of replicates per subject. Finally,
 * the number of replicates per subject may vary for different subjects.
 *
 * @param filename A filename to assign to the node.
 * @returns A malloc'd ImageList node.
 */

ImageList* createILNode(char* filename) {
    ImageList* node = (ImageList*)malloc(sizeof(ImageList));

    node->filename = (char*)strdup(filename);

    node->imageIndex = 0;
    node->next_replicate = NULL;
    node->next_subject = NULL;
    return node;
}

/**
 * This function reads in the image list file and sets
 * up a subject replicates list.  First the file is
 * probed to determine the maximum line length.  Then
 * the lines are read in and replicate names are parsed.
 *
 * @params imageNamesFile Path to a file containing an srt
 * @params numImages Pointer to integer that will hold the number of names read
 * @return A two dimensional ImageList.
 */
#ifdef THRD
ImageList* getImageNames(char* imageNamesFile, int *numImages, int* numSub) {
#else
ImageList* getImageNames(char* imageNamesFile, int *numImages) {
#endif
    Tokenizer tok;
    char* token;
    FILE* ilf; /* Image List File */
    ImageList *subject = NULL, *replicate, *header = NULL;
    int nImages;
#ifdef THRD
    int nSub=0;
#endif
    
    DEBUG_STRING(2, "Get image Names from file", imageNamesFile);

    ilf = fopen( imageNamesFile, "r");
    DEBUG_CHECK(ilf, "Problem opening image list file");

    nImages = 0;
    tokenizerInit (&tok, tokenizerStreamReader, ilf);
    while (!tokenizerEndOfFile (&tok))
      {
	token = tokenizerGetWord (&tok);
	nImages++;
#ifdef THRD
	nSub++;
#endif

	if (header == NULL) {
	  subject = header = createILNode(token);
	} else {
	  subject->next_subject = createILNode(token);
	  subject = subject->next_subject;
	}

	replicate = subject;
	/*#ifdef THRD*/
	replicate->imageIndex = nImages-1;
	/*#endif*/

        while (!tokenizerEndOfLine(&tok) && !tokenizerEndOfFile(&tok))
	  {
	    token = tokenizerGetWord (&tok);
	    nImages++;

	    replicate->next_replicate = createILNode(token);
	    replicate = replicate->next_replicate;
	    /*#ifdef THRD*/
	replicate->imageIndex = nImages-1;
	/*#endif*/
	  }
      }

    fclose(ilf);

    if (numImages)
#ifdef THRD
      { 
	if (numSub)
	  *numSub = nSub;
	printf("Number of subect is %d\n",nSub);
#endif
      *numImages = nImages;
#ifdef THRD
      }
#endif

    return header;
}

/**
 * This function reads in the image list file.  It then
 * takes the image filenames and reads in every file.
 *
 * @returns A Matrix containing all of the images
 */
Matrix readImages(char *imageNamesFile, char *imageDirectory, int *numPixels, int *numImages, int *numSubjects, ImageList **srt) {
    int i;
    Matrix images;
    ImageList *subject, *replicate;

    DEBUG(1, "Reading training file names from file");

#ifdef THRD
    *srt = getImageNames(imageNamesFile, numImages, NULL);
#else
    *srt = getImageNames(imageNamesFile, numImages);
#endif

    DEBUG_CHECK(*srt, "Error: header no imagenames found in file image list file");

    /* Automatically determine number of pixels in images    */

    DEBUG(1, "Autodetecting number of pixels, i.e. vector length based on the size of image 0.");
    *numPixels = autoFileLength(makePath(imageDirectory, (*srt)->filename));
    DEBUG_INT(1, "Vector length", * numPixels);
    DEBUG_CHECK(*numPixels > 0, "Error positive value required for a Vector Length");

    /* Images stored in the columns of a matrix */
    DEBUG(1, "Allocating image matrix");
    images = makeMatrix(*numPixels, *numImages);

    i = 0;
    (*numSubjects) = 0;
    for (subject = *srt; subject; subject = subject->next_subject) {
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            if (debuglevel > 0)
                printf("%s ", replicate->filename);
            replicate->imageIndex = i;
            readFile(makePath(imageDirectory, replicate->filename), i++, images);
        }
        if (debuglevel > 0)
            printf("\n");
        (*numSubjects)++;
    }

    return images;

}

/**
 * This function returns the count of all images in an ImageList
 * takes the image filenames and reads in every file.
 *
 * @param srt An image list
 * @returns The count of images
 */
int numImageInImageList(ImageList *srt) {
    int num = 0;
    ImageList *subject, *replicate;

    for (subject = srt; subject; subject = subject->next_subject) {
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            num++;
        }
    }
    return num;
}

/**
 * This function is supposed to free an image list but is not implemented.
 * I put this in as a placeholder.
 *
 * @param srt An image list
 */
void freeImageNames(ImageList *srt) {
  /* Not implemented */
}

/*------------------------------------------------------------------------
Utilities integrated directly into this source from elsewhere in FERET
code distribution.
------------------------------------------------------------------------*/

/**
 * Reads a FERET nrm file
 *
 * @param fn Filename
 * @param numpix Number of pixels to read
 * @returns An malloc'd array of floats
 */
float *readFeretRaster(const char *fn,  int numpix)
{
    FILE *fp;
    float* data;

    fp = fopen(fn, "rb");
    if (fp == NULL)
      {
        fprintf (stderr, "failed to open %s", fn);
	exit(0);
      }

    data = (float*)malloc(sizeof(float)*numpix);
    DEBUG_CHECK (data, "malloc failed");

    if (!fread(data, sizeof(float), numpix, fp))
      {
        fprintf (stderr, "fread in readFeretRaster failed");
	exit(0);
      }

    if (isMachineLittleEndian()) byteswap_4(data, numpix);

    fclose(fp);
    return data;
}

/**
 * Writes a FERET nrm file
 *
 * @param fn Filename
 * @param data Pointer to an array of floats
 * @param numpix Number of pixels to read
 * @returns Whatever was passed in as data
 */
float *writeFeretRaster(const char *fn, float *data, int numpix)
{
    FILE *fp;

    fp = fopen(fn, "wb");
    if (fp == NULL)
      {
        fprintf (stderr, "failed to open %s", fn);
	exit(0);
      }

    if (isMachineLittleEndian()) byteswap_4(data, numpix);

    if (numpix != fwrite(data, sizeof(float), numpix, fp))
      {
        fprintf (stderr, "fwrite in writeFeretRaster failed");
	exit(0);
      }

    fclose(fp);
    return data;
}

/**
 * Reads PGM file
 *
 * @param filename The name of the file to read
 * @param w Pointer to an integer which will receive the width of the image
 * @param h Pointer to an integer which will receive the height of the image
 * @param verbose When true, we print status information
 * @returns A pointer to a malloc'd array of bytes
 */
unsigned char *readImagePGM(const char *filename, int *w, int *h, int verbose)
{
    int  width, height, max, i;
    int  val;
    char fchar;
    char line[100];
    char ftype[16];
    FILE *infile;
    unsigned char *im;

    /* Read first line, and test if it is propoer PNM type */
    if (verbose) fprintf(stdout,"Going to open file %s\n", filename);
    infile = fopen(filename, "rb");
    if (infile == NULL)
      {
        fprintf (stderr, "failed to open %s", filename);
	exit(0);
      }
    fgets(line,100,infile);
    sscanf(line,"%s",ftype);
    if (verbose) fprintf(stdout,"File Type is %s.\n", ftype);

    if (strcmp(ftype,"P5") != 0)
      {
	fprintf (stderr, "Currently only binary pgm files, type P5, supported");
	exit(0);
      }

    /* Read lines, ignoring those starting with Comment Character, until the
        Image Dimensions are read. */
    fchar = '#';
    while (fchar == '#') {
        fgets(line,100,infile);
        sscanf(line, " %c", &fchar);
    }
    if (verbose) fprintf(stdout,"Second non-comment line of image file %s.\n", line);
    sscanf(line, " %d %d", &width, &height);
    *w = width;
    *h = height;
    if (verbose) fprintf(stdout,"The width,  height and size are: %d %d %d\n", width, height, width * height);

    /* Read lines, ignoring those starting with Comment Character, until the
        maximum pixel value is read. */
    fchar = '#';
    while (fchar == '#') {
        fgets(line,100,infile);
        sscanf(line, " %c", &fchar);
    }
    sscanf(line, "%d", &max);
    if (verbose) fprintf(stdout,"The max value for the pixels is: %d\n", max);
    if (! (max == 255)) {
        fprintf(stdout,"readImagePGM: Warning, max value %d for pixels in image %s is not 255\n", max, filename);
    }

    im = (unsigned char*) malloc(sizeof(unsigned char)*width*height);
    DEBUG_CHECK (im, "malloc failed");

    i = 0;
    val = fgetc(infile);
    while (!(val == EOF) && i < width*height) {
        im[i] = (unsigned char) val;
        i++;
        val = fgetc(infile);
    }
    if (verbose) fprintf(stdout,"Read in %d Pixel Values\n", i);
    fclose(infile);
    return( im );
}

/**
 * Writes a PGM file
 *
 * @param fn The name of the file to write
 * @param data An array of floats containing the image data
 * @param numpix Number of pixels. Must be w * h
 * @param w Pointer to an integer which will receive the width of the image
 * @param h Pointer to an integer which will receive the height of the image
 */
void writeImagePGM(const char *fn, float *data, int numpix,int w, int h)
{
    float min, max, sum, scale;
    int  i, val;
    FILE *fp;

    min = data[0];
    max = data[0];
    sum = 0.0;

    for (i = 1; i < numpix; i++) {
        if (data[i] < min) min = data[i];
        if (data[i] > max) max = data[i];
        sum = sum + data[i];
    }

    scale = 255.0 / (max - min);

    fp = fopen(fn, "wb");
    if (fp == NULL)
      {
        fprintf (stderr, "failed to open %s", fn);
	exit(0);
      }

    fprintf(fp,"P5\n");
    fprintf(fp,"%d %d\n", w, h);
    fprintf(fp,"255\n");
    for (i = 0; i < numpix; i++) {
        val = (int) ((data[i] - min) * scale);
        fputc(val,fp);
    }
    fclose(fp);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
File: csuFileCommon.c                                                       
Authors: J. Ross Beveridge, David Bolme and Kai She                        
Date:    March 15, 2002                                                     
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_FILE_COMMON_INCLUDED
#define CSU_FILE_COMMON_INCLUDED

#include "csuCommon.h"

/* A ListOfStrings is simply an array of char pointers. */

typedef char** ListOfStrings;

/**
  image_list
  
  This is a data structure that sorts the images by the subject and replicates. s inticates
  a subject or paticular person and r indicates a replicate of that person.  The final data
  structure should look like this:
    s1r1-s1r2-s1r3-...-NULL
     |
    s2r1-s2r2-s3r3-...-NULL
     |
    ...
     |
    NULL
  
  This list is to allow for different sized classes for use in the LDA training.
  
  Node fields:
    filename:        name of file image was read from.
    image_number:    index to image in the data matrix
    next_replicate:  pointer to node containing the next replicate
    next_subject:    pointer to node contianing the next subject
*/

typedef struct image_list_node {
    char* filename;
    int imageIndex;
    struct image_list_node* next_replicate;
    struct image_list_node* next_subject;
}
ImageList;

/* Function Prototypes */

/* Low level binary I/O */
void writeInt(FILE* file, int);
void writeFloat(FILE* file, float);
void writeDouble(FILE* file, double);

void readInt(FILE* file, int*);
void readFloat(FILE* file, float*);
void readDouble(FILE* file, double*);


char *makePath (const char *directoryName, const char *fileName);
void checkWriteableDirectory (const char *directory, const char *message);
void checkReadableDirectory (const char *directory, const char *message);
void checkReadableFile (const char *file, const char *message);

ListOfStrings readListOfStrings (const char *fileName, int *nStrings);
void freeListOfStrings (ListOfStrings list);

void sortSubjectsBySimilarityToProbe (char *probe, ListOfStrings subjects, char *distanceMatrix, int *indices);

void readFile(const char *fname, int n, Matrix images);
#ifdef THRD
ImageList* getImageNames(char* imageNamesFile, int *numImages, int* numSub);
#else
ImageList* getImageNames(char* imageNamesFile, int *numImages);
#endif
void freeImageNames (ImageList *list);
Matrix readImages(char *imageNamesFile, char *imageDirectory, int *numPixels, int *numImages, int *numSubjects, ImageList **srt);
void readFile(const char *fname, int n, Matrix images);

int numImageInImageList(ImageList *srt);
int autoFileLength(const char* imageName);

float *readFeretRaster(const char *fn, int numpix);
float *writeFeretRaster(const char *fn, float *data, int numpix);

unsigned char *readImagePGM(const char *filename, int *w, int *h, int verbose);
void writeImagePGM(const char *fn, float *data, int numpix, int w, int h);

#endif /* CSU_FILE_COMMON_INCLUDED */




/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_COMMON_INCLUDED
#define CSU_COMMON_INCLUDED

#include "csuCommonUtil.h"
#include "csuCommonMatrix.h"
#include "csuCommonImage.h"
#include "csuCommonFile.h"
#include "csuCommonCommandLine.h"
#include "csuCommonSubspace.h"

#define CHECK_VALS

#define STANDARD_IMAGE_DIRECTORY "./data/normSep2002sfi"
#define BASE_RESULTS_DIRECTORY   "./results"

#define VERSION  "Version 5.0, released Apr 30, 2003."

#endif

#ifndef USING_ICC
#define __declspec(x) 
#define align(x)
#define _mm_malloc(x,y) malloc(x)
#define _mm_free(x)     free(x)
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "csuCommon.h"
#include <math.h>

/******************************* Local Fucntions ********************8******/

/* checks to see if the machine is Little Endian
*  this is used to determine if byte reversal is
*  needed when reading or writing data files in
*  sun byte order.
*/
int ImageIsMachineLittleEndian() {
    int flag;
    char magic[4] = {0x01, 0x02, 0x03, 0x04};
    unsigned long *longMagic = (unsigned long *) magic;
    if (*longMagic == 0x01020304) {
        flag = 0;
    } else if (*longMagic == 0x04030201) {
        flag = 1;
    } else {
        fprintf(stderr, "Funky Byte Order, I give Up!!\n");
        exit(1);
    }
    return flag;
}


/**
 * Normally distrubuted random number using the Box-Muller Transformation
 */
double randBM(){
    static int iset = 0;
    static double gset;
    double v1, v2, fac, rsq;
    if(iset == 0){

        /* Pick a point in the unit circle */
        do{
            v1 = 2.0*RANDOM-1.0;
            v2 = 2.0*RANDOM-1.0;
            rsq = SQR(v1) + SQR(v2);
        } while (rsq >= 1.0 || rsq == 0);

        /* Perform the Box-Muller transformation */
        fac = sqrt(-2*log(rsq)/rsq);
        gset = v1*fac;
        iset = 1;
        return v2*fac;
    }
    else {
        /* Return the deviate that was not returned last time */
        iset = 0;
        return gset;
    }
}


/******************************* Image Fucntions ********************8******/

Image makeImage(int width,int height,int channels){
    int x,y;
    Image i = (Image)malloc(sizeof(image));
    assert(i);
    i->data = (PIX_TYPE***)malloc(sizeof(PIX_TYPE**)*width);
    assert(i->data);

    for(x = 0; x < width; x++){
        i->data[x] = (PIX_TYPE**)malloc(sizeof(PIX_TYPE*)*height);
        assert(i->data[x]);
        for(y = 0; y < height; y++){
            i->data[x][y] = (PIX_TYPE*)malloc(sizeof(PIX_TYPE)*channels);
            assert(i->data[x][y]);
        }
    }
    
    i->width = width;
    i->height = height;
    i->channels = channels;

    return i;
}


Image makeZeroImage(int width,int height,int channels){
    Image im = makeImage( width, height, channels);
    int i,j,c;

    for(i=0;i<im->width;i++){
        for(j=0;j<im->height;j++){
            for(c=0;c<im->channels;c++){
                IE(im,i,j,c) = 0.0;
            }
        }
    }
    return im;
}


Image duplicateImage(Image im){
    Image output = makeImage(im->width,im->height,im->channels);
    int i, j, c;

    for(j = 0; j < output->height; j++){
        for(i = 0; i < output->width; i++){
            for(c = 0; c < output->channels; c++){
                IE(output,i,j,c) = IE(im,i,j,c);
            }
        }
    }

    return output;

}

/* Safe read-only/range-checked implementation of IE - returns 0.0 if off image. */
#if(!INTERPOLATE_FAST)
PIX_TYPE ie(Image im, int x, int y, int c){
    double out = ((x < im->width && y < im->height && c < im->channels && x >= 0 && y >=  0 && c >= 0) ? IE(im, x, y, c) : 0.0 );

    return out;
}
#endif


#if(!INTERPOLATE_FAST)
#define INT_FLOOR(a) ((int)(a))
#define INT_CEIL(a)  ((int)(a)+1)

/* interpolate a pixel value at a point */
PIX_TYPE interpLinear(Image img, PIX_TYPE x, PIX_TYPE y, int c){
    PIX_TYPE xfrac = (x - floor(x));
    PIX_TYPE yfrac = (y - floor(y));
    int xLower = INT_FLOOR(x);
    int xUpper = INT_CEIL(x);
    int yLower = INT_FLOOR(y);
    int yUpper = INT_CEIL(y);
    PIX_TYPE valUpper, valLower;

    valUpper = ie(img,xLower,yUpper,c)*(1.0-xfrac) + ie(img,xUpper,yUpper,c)*(xfrac);
    valLower = ie(img,xLower,yLower,c)*(1.0-xfrac) + ie(img,xUpper,yLower,c)*(xfrac);

    return valLower*(1.0-yfrac) + valUpper*(yfrac);
}
#endif

void freeImage(Image i){
    int x, y;
    if(i == 0){
        printf("Warning: free null image\n");
        return;
    }
    for(x = 0; x < i->width; x++){
        for(y = 0; y < i->height; y++){
            free(i->data[x][y]);
        }
        free(i->data[x]);
    }
    free(i->data);
    free(i);
}




Image readPGMImage(const char* filename){
    int  width, height, max, x, y;
    unsigned  val;
    char fchar;
    char line[100];
    char ftype[16];
    FILE *infile;
    Image im;

    /* Read first line, and test if it is propoer PNM type */

    infile = (FILE*) fopen(filename, "rb");
    assert(infile);

    fgets(line,100,infile);
    sscanf(line," %s",ftype);

    if (! (strcmp(ftype,"P5") == 0)) {
        printf("Error <%s,%d>: Currenlty only binary pgm files, type P5, supported",__FILE__,__LINE__);fflush(stdout);
        exit(1);
    }

    /* Read lines, ignoring those starting with Comment Character, until the
        Image Dimensions are read. */
    fchar = '#';
    while (fchar == '#') {
        fgets(line,100,infile);
        sscanf(line, " %c", &fchar);
    }
    sscanf(line, " %d %d", &width, &height);

    /* Read lines, ignoring those starting with Comment Character, until the
        maximum pixel value is read. */
    fchar = '#';
    while (fchar == '#') {
        fgets(line,100,infile);
        sscanf(line, " %c", &fchar);
    }
    sscanf(line, "%d", &max);

    if (! (max == 255)) {
        fprintf(stdout,"readImagePGM: Warning, max value %d for pixels in image %s is not 255\n", max, filename); fflush(stdout);
    }

    im = makeImage(width,height,1);

    val = fgetc(infile);
    for(y = 0; y < height; y++){
        for(x = 0; x < width; x++){
            if(val == EOF){
                printf("Error <%s,%d>: Unexpected end of file: %s",__FILE__,__LINE__,filename);fflush(stdout);
                exit(1);
            }

            IE(im,x,y,0) = (unsigned char)val;
            val = fgetc(infile);
        }
    }

    fclose(infile);

    return( im );
}

/* ---------------------------------------------------------------------------- */
/*  Read a binary image from a file where the pixels are stored as 32 bit
*   floating point numbers using Sun byte order.  The compiler directive WINDOWS
*   is used to control how the byte order is interpreted when storing the pixels
*   into the data structure images. images is a one dimensional array of floats
*   that contains each successive image in sequence, where each image has in turn
*   been unrolled into a 1 dimensional vector.
*
*   INPUT:  fname   is the name of the file from which to read the image.
*           n       is the index of this image in the images array.
*	    images  is the size of the vectors or number of pixels of the image
*/

/* EL and NUM are used to read binary dataand convert to proper internal float representation */
typedef struct {char a,b,c,d;} EL;
typedef union {float f; EL elem;} NUM;

Image readRawImage(const char *fname){
    int i,j,c;
    FILE *f;

    NUM junk;
    char firstline[1000];
    char ftype[1000];

    Image im;

    f = fopen( fname, "rb" );
    if ( !f ) { printf("Can't open %s\n", fname); exit(1); }

    fgets(firstline,1000,f);
    sscanf(firstline,"%s %d %d %d", ftype,&i, &j, &c);

    if( !(strcmp(ftype,RASTER_ID) == 0 || strcmp(ftype,"CSU_RASTER") == 0)){
        printf("Error<%s,%d>: Do not recognize file type '%s'\n",__FILE__,__LINE__, ftype);
        exit(1);
    }

    im = makeImage(i,j,c);

    for(j=0;j<im->height;j++){
        for(i=0;i<im->width;i++){
            for(c=0;c<im->channels;c++){
                /* read in the correct byte order for floating point values */
                if(ImageIsMachineLittleEndian()){
                    fread(&(junk.elem.d),1,1,f);
                    fread(&(junk.elem.c),1,1,f);
                    fread(&(junk.elem.b),1,1,f);
                    fread(&(junk.elem.a),1,1,f);
                }
                else{
                    fread(&(junk.elem.a),1,1,f);
                    fread(&(junk.elem.b),1,1,f);
                    fread(&(junk.elem.c),1,1,f);
                    fread(&(junk.elem.d),1,1,f);
                }

#ifdef RANGE_CHECK
                /* Check values to make sure they are real */
                FINITE( junk.f );
#endif

                /* Save value to images */
                IE(im,i,j,c) = (PIX_TYPE)junk.f;
            }
        }
    }
    fclose(f);

    return im;
}


void  writePGMImage(const Image im, const char* filename,int channel){
    FILE* outfile = fopen(filename,"wb");
    unsigned char pixel;
    double pmax, pmin;
    int x, y;

    assert(im);
    if(!outfile){
        printf("could not open %s for writing.\n",filename);
        exit(1);
    }
    fprintf(outfile,"P5\n");
    fprintf(outfile,"%d %d\n",im->width, im->height);
    fprintf(outfile,"%d\n",255);

    pmax = IE(im,0,0,channel);
    pmin = IE(im,0,0,channel);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            pmax = MAX(IE(im,x,y,channel), pmax);
            pmin = MIN(IE(im,x,y,channel), pmin);
        }
    }
    /*printf(" Min:%f Max:%f \n", pmin, pmax);*/

    for(y = 0; y < im->height; y++){
        for(x = 0; x < im->width; x++){
            if(pmax-pmin <= 0){
                pixel = 0;
            }
            else{
                int tmp = ROUND(255*(IE(im,x,y,channel)-pmin)/(pmax-pmin));
                if(tmp < 0) tmp = 0;
                if(tmp > 255) tmp = 255;
                pixel = (unsigned char)tmp;
            }
            fputc(pixel,outfile);
        }
    }


    fclose(outfile);
}

void  writePPMImage(const Image im, const char* filename){
    FILE* outfile = fopen(filename,"wb");
    unsigned char pixel;
    double pmax, pmin;
    int x, y, c;

    assert(im);
    assert(im->channels == 3);
    if(!outfile){
        printf("could not open %s for writing.\n",filename);
        exit(1);
    }
    fprintf(outfile,"P6\n");
    fprintf(outfile,"%d %d\n",im->width, im->height);
    fprintf(outfile,"%d\n",255);

    pmax = IE(im,0,0,0);
    pmin = IE(im,0,0,0);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                pmax = MAX(IE(im,x,y,c), pmax);
                pmin = MIN(IE(im,x,y,c), pmin);
            }
        }
    }

    for(y = 0; y < im->height; y++){
        for(x = 0; x < im->width; x++){
            for(c = 0; c < im->channels; c++){
                if(pmax-pmin <= 0){
                    pixel = 0;
                }
                else{
                    int tmp = ROUND(255*(IE(im,x,y,c)-pmin)/(pmax-pmin));
                    if(tmp < 0) tmp = 0;
                    if(tmp > 255) tmp = 255;
                    pixel = (unsigned char)tmp;
                }
                fputc(pixel,outfile);
            }
        }
    }


    fclose(outfile);
}

void writeRawImage(const Image im, const char *fname){
    int i,j,c;
    FILE *f;

    NUM junk;

    f = fopen( fname, "wb" );
    if ( !f ) { printf("Can't open %s\n", fname); exit(1); }

    fprintf(f,"%s %d %d %d\n", RASTER_ID ,im->width, im->height, im->channels);


    for(j=0;j<im->height;j++){
        for(i=0;i<im->width;i++){
            for(c=0;c<im->channels;c++){
                /* read in the correct byte order for floating point values */
                junk.f = IE(im,i,j,c);

#ifdef RANGE_CHECK
                /* Check values to make sure they are real */
                if(isnan( junk.f)){
                    printf("Error: nan value in file: %s", fname);
                    exit(1);
                }
                if(isinf( junk.f)){
                    printf("Error: inf value in file: %s", fname);
                    exit(1);
                }
#endif

                if(ImageIsMachineLittleEndian()){
                    fwrite(&(junk.elem.d),1,1,f);
                    fwrite(&(junk.elem.c),1,1,f);
                    fwrite(&(junk.elem.b),1,1,f);
                    fwrite(&(junk.elem.a),1,1,f);
                }
                else{
                    fwrite(&(junk.elem.a),1,1,f);
                    fwrite(&(junk.elem.b),1,1,f);
                    fwrite(&(junk.elem.c),1,1,f);
                    fwrite(&(junk.elem.d),1,1,f);
                }

            }
        }
    }
    fclose(f);

}


Image readFeretImage(const char *fname, int width, int height,int channels){
    int i,j,c;
    FILE *f;

    NUM junk;

    Image im;

    f = fopen( fname, "rb" );
    if ( !f ) { printf("Can't open %s\n", fname); exit(1); }

    im = makeImage(width,height,channels);

    for(j=0;j<im->height;j++){
        for(i=0;i<im->width;i++){
            for(c=0;c<im->channels;c++){
                /* read in the correct byte order for floating point values */
                if(ImageIsMachineLittleEndian()){
                    fread(&(junk.elem.d),1,1,f);
                    fread(&(junk.elem.c),1,1,f);
                    fread(&(junk.elem.b),1,1,f);
                    fread(&(junk.elem.a),1,1,f);
                }
                else{
                    fread(&(junk.elem.a),1,1,f);
                    fread(&(junk.elem.b),1,1,f);
                    fread(&(junk.elem.c),1,1,f);
                    fread(&(junk.elem.d),1,1,f);
                }

#ifdef RANGE_CHECK
                /* Check values to make sure they are real */
                FINITE( junk.f);
#endif

                /* Save value to images */
                IE(im,i,j,c) = (PIX_TYPE)junk.f;
            }
        }
    }
    fclose(f);

    return im;
}


void writeFeretImage(const Image im, const char *fname){
    int i,j,c;
    FILE *f;

    NUM junk;

    f = fopen( fname, "wb" );
    if ( !f ) { printf("Can't open %s\n", fname); exit(1); }

    for(j=0;j<im->height;j++){
        for(i=0;i<im->width;i++){
            for(c=0;c<im->channels;c++){
                /* read in the correct byte order for floating point values */
                junk.f = IE(im,i,j,c);

#ifdef RANGE_CHECK
                /* Check values to make sure they are real */
                if(isnan( junk.f)){
                    printf("Error: nan value in file: %s", fname);
                    exit(1);
                }

                if(isinf( junk.f)){
                    printf("Error: inf value in file: %s", fname);
                    exit(1);
		    }
#endif

                if(ImageIsMachineLittleEndian()){
                    fwrite(&(junk.elem.d),1,1,f);
                    fwrite(&(junk.elem.c),1,1,f);
                    fwrite(&(junk.elem.b),1,1,f);
                    fwrite(&(junk.elem.a),1,1,f);
                }
                else{
                    fwrite(&(junk.elem.a),1,1,f);
                    fwrite(&(junk.elem.b),1,1,f);
                    fwrite(&(junk.elem.c),1,1,f);
                    fwrite(&(junk.elem.d),1,1,f);
                }

            }
        }
    }
    fclose(f);

}

double convolvePoint(PIX_TYPE x, PIX_TYPE y, int c, Image im, Image mask){
    int i, j;
    PIX_TYPE mysum = 0;
    PIX_TYPE offsetx = x - mask->width/2.0  - 0.5;
    PIX_TYPE offsety = y - mask->height/2.0 - 0.5;

    if(EQUAL_ZERO(offsetx - TRUNC(offsetx),.01) && EQUAL_ZERO(offsetx - TRUNC(offsetx),.01)){
        mysum = 0;
        for(j = 0; j < mask->height; j++){
            for(i = 0; i < mask->width; i++){
                mysum += ie(im,i+TRUNC(offsetx),j+TRUNC(offsety),c) * IE(mask,i,j,c);
            }
        }
    }
    else{
        mysum = 0;
        for(j = 0; j < mask->height; j++){
            for(i = 0; i < mask->width; i++){
               mysum += interpLinear(im,i+offsetx,j+offsety,c) * IE(mask,i,j,c);
            }
        }
    }
#ifdef RANGE_CHECK
    FINITE(offsetx);
    FINITE(offsety);

    FINITE(mysum);
#endif
    return mysum;
}




Image convolveImage(Image im, Image mask){
    Image output = makeImage(im->width,im->height,im->channels);
    int x,y,c;

    for(y = 0; y < output->height; y++){
        for(x = 0; x < output->width; x++){
            for(c = 0; c < output->channels;c++){
                IE(output,x,y,c) = convolvePoint(x,y,c,im,mask);
            }
        }
    }

    return output;
}



void contrastImage(Image im, double scalar){
    int i, j, c;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                IE(im,i,j,c) = IE(im,i,j,c)*scalar;
            }
        }
    }

}

void brightnessImage(Image im, double scalar){
    int i, j, c;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                IE(im,i,j,c) = IE(im,i,j,c)+scalar;
            }
        }
    }

}


void ZeroMeanUnitLength(Image im){
    int i, j, c;

    double mean = 0; double sqrsum = 0; double invlength = 0;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                mean += IE(im,i,j,c);
            }
        }
    }

    mean = mean / ( im->height*im->width*im->channels );
    /* printf("mean: %f\n",mean); */

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                IE(im,i,j,c) = IE(im,i,j,c)-mean;
                sqrsum += SQR(IE(im,i,j,c));
            }
        }
    }

    /* printf("sqrsum: %f\n",sqrsum); */
    if(sqrsum != 0){
        invlength = 1.0/sqrt(sqrsum);
    } else {
        invlength = 1.0;
    }

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                IE(im,i,j,c) *= invlength;
            }
        }
    }

}



void ZeroMeanUnitLengthMasked(Image im, const char** mask){
/* scales the pixel so that they have zero mean and the image is unit length*/
    int i, j, c;

    double mean = 0; double sqrsum = 0; double invlength = 0;
    int pixels = 0;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[i][j]){
                    mean += IE(im,i,j,c);
                    pixels++;
                }
            }
        }
    }

    mean = mean / ( pixels );

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[i][j]){
                    IE(im,i,j,c) = IE(im,i,j,c)-mean;
                    sqrsum += SQR(IE(im,i,j,c));
                }
            }
        }
    }

    if(sqrsum != 0){
        invlength = 1.0/sqrt(sqrsum);
    } else {
        invlength = 1.0;
    }

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[i][j]){
                    IE(im,i,j,c) *= invlength;
                }
                else{
                    IE(im,i,j,c) = 0.0;
                }
            }
        }
    }
}

void smoothImageEdge(Image im, int width){
    int i, x, y ,c ;
    for(i = 0; i < width; i++ ){
        double scale = ((double)i)/width;

        /* Scale the horizontal lines */
        for(x = 0; x < im->width; x++){
            for( c = 0; c < im->channels; c++){
                IE(im, x, i, c) *= scale;
                IE(im, x, im->height - i - 1, c) *= scale;
            }
        }
        /* Scale the vertical lines */
        for(y = 0; y < im->height; y++){
            for( c = 0; c < im->channels; c++){
                IE(im, i, y, c) *= scale;
                IE(im, im->width - i - 1, y, c) *= scale;
            }
        }
    }

}


void ZeroMeanOneStdDev(Image im){
    ZeroMeanOneStdDevMasked(im,NULL);
}


void ZeroMeanOneStdDevMasked(Image im, const char** mask){
    /* scales the pixel so that they have zero mean and the image is unit length*/
    int i, j, c;

    double sum = 0.0;
    double sqsum = 0.0;
    double mean;
    double vari;
    double stddev;
    double invlength;
    int pixels = 0;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[i][j]){
                    sum   += IE(im,i,j,c);
                    sqsum += SQR(IE(im,i,j,c));
                    pixels++;
                }
            }
        }
    }

    mean = sum / pixels;
    vari = sqsum / pixels - SQR(mean);
    stddev = sqrt(vari);

    invlength = 1.0/stddev;

    for(j = 0; j < im->height; j++){
        for(i = 0; i < im->width; i++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[i][j]){
                    IE(im,i,j,c) = (IE(im,i,j,c) - mean) * invlength;
                }
                else{
                    IE(im,i,j,c) = 0.0;
                }
            }
        }
    }
}


double dotImages(const Image i1, const Image i2){
    double dot = 0;
    int i,j,c;

    assert(i1->height == i2->height);
    assert(i1->width == i2->width);
    assert(i1->channels == i2->channels);

    for(j = 0; j < i1->height; j++){
        for(i = 0; i < i1->width; i++){
            for(c = 0; c < i1->channels; c++){
                dot += IE(i1,i,j,c)*IE(i2,i,j,c);
            }
        }
    }

    return dot;

}


double correlateImages(const Image i1, const Image i2){
    int i, j, c;

    double correlation = 0.0;
    double i1mean = 0.0, i2mean = 0.0;
    double i1scale = 0.0, i2scale = 0.0;

    assert(i1->height == i2->height);
    assert(i1->width == i2->width);
    assert(i1->channels == i2->channels);

    /* Pass one: compute the pixel mean. */
    for(j = 0; j < i1->height; j++){
        for(i = 0; i < i1->width; i++){
            for(c = 0; c < i1->channels; c++){
                i1mean += IE(i1,i,j,c);
                i2mean += IE(i2,i,j,c);
            }
        }
    }
    i1mean = i1mean/(i1->height*i1->width*i1->channels);
    i2mean = i2mean/(i2->height*i2->width*i2->channels);

    printf("i1mean:  %f\n",i1mean);
    printf("i2mean:  %f\n",i2mean);
    /* Pass two: compute the unscaled correlation value and the associated scale parameter. */
    for(i = 0; i < i1->width; i++){
        for(j = 0; j < i1->height; j++){
            for(c = 0; c < i1->channels; c++){
                correlation += (IE(i1,i,j,c)-i1mean)*(IE(i2,i,j,c)-i2mean);
                i1scale     += (IE(i1,i,j,c)-i1mean)*(IE(i1,i,j,c)-i1mean);
                i2scale     += (IE(i2,i,j,c)-i2mean)*(IE(i2,i,j,c)-i2mean);
            }
        }
    }

    printf("i1scale: %f\n",i1scale);
    printf("i2scale: %f\n",i2scale);
    correlation = correlation / (sqrt(i1scale)*sqrt(i2scale));

    return correlation;
}



Image accumulateChannels(const Image im){
    int x, y, c;
    Image accum = makeZeroImage(im->width,im->height,1);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                IE(accum,x,y,0)+=IE(im,x,y,c);
            }
        }
    }

    return accum;
}

void accumulateImages(Image i1, const Image i2){
    /* inplace adds image i2 to image i1 */
    int x, y, c;

    assert(i1->height == i2->height);
    assert(i1->width == i2->width);
    assert(i1->channels == i2->channels);

    for(x = 0; x < i1->width; x++){
        for(y = 0; y < i1->height; y++){
            for(c = 0; c < i1->channels; c++){
                IE(i1,x,y,c)+=IE(i2,x,y,c);
            }
        }
    }
}



/*
 * histEqual
 *
 * Performs an aproximate histogram equalization function.
 * (Multichannel images are supported, however design was for single
 * channel images.)
 *
 * This version of histogram equalization is optimized for use
 * with image based on floating point values.  The output image
 * is a histogram normalized version of the image where pixel values
 * are in the range 0 to 1.
 *
 * ALGORITHM:
 *   1. Determine the range of the pixel values.  And divide that
 *      range into N bins.
 *   2. Treverse the pixels and accumulate pixel counts in appropreate
 *      bins.
 *   3. Equalize the histogram by assigning a range to each bin which
 *      will equalize the probablility distribution
 *   4. For each pixel in the old image look up the apropreate bin and
 *      interpalate its new value based on the range of the bin.
 *
 * Things to note about this algorithm:
 *   1. Pixel values retain there relative ordering because the output
 *      values are interpalated.
 *   2. The algorithm can be used iteritivly to improve equalization.
 *      With enough bins the equalization will be perfict.
 *   3. Bin allocation should be robust to small changes in N.
 *   4. Selecting a small number of bins will act like a smoothing
 *      operator on the histogram.
 */
typedef struct hist_bin{
    int count;
    PIX_TYPE rangeStart;
    PIX_TYPE rangeEnd;
} HistogramBin;

void histEqual(Image im, int N){
    HistogramBin *bins = (HistogramBin*)malloc(sizeof(HistogramBin)*N);
    PIX_TYPE minVal, maxVal, binSize;
    PIX_TYPE totalPixels = im->width*im->height*im->channels;
    int x, y, c;

    assert(bins);

    /*************** find the minimum and maximum values ***************/
    minVal = IE(im,0,0,0);
    maxVal = IE(im,0,0,0);
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                minVal = MIN(minVal,IE(im,x,y,c));
                maxVal = MAX(maxVal,IE(im,x,y,c));
            }
        }
    }

    /********************** determine the bin size ********************/
    binSize = (maxVal - minVal) / N;

    /*************** Find probablity distribution ***************/
    /* initialize counts to zero */
    for(x = 0; x < N; x++){ bins[x].count = 0; }

    /* count individual pixels */
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */
                bins[bin].count++;
            }
        }
    }

    /***************** Distribute bins *****************/
    c = 0; /* c is an accumulated count value */
    for(x = 0; x < N; x++){
        bins[x].rangeStart = c/totalPixels;
        c += bins[x].count;
        bins[x].rangeEnd = c/totalPixels;
    }

    /***************** create equalized image *************/
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                PIX_TYPE frac = ((IE(im,x,y,c)-minVal)/binSize) - tmp;
                int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */

                /* compute the linear interpolation for the final pixel value */
                IE(im,x,y,c) = bins[bin].rangeStart*(1.0-frac) + bins[bin].rangeEnd*(frac);
            }
        }
    }

    free(bins);
}


void histEqualMask(Image im, int N, const char **mask){
    HistogramBin *bins = (HistogramBin*)malloc(sizeof(HistogramBin)*N);
    PIX_TYPE minVal, maxVal, binSize;
    PIX_TYPE totalPixels = 0.0;
    int x, y, c;

    assert(bins);

    /*************** find the minimum and maximum values ***************/
    minVal = IE(im,0,0,0);
    maxVal = IE(im,0,0,0);
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[x][y]){
                    minVal = MIN(minVal,IE(im,x,y,c));
                    maxVal = MAX(maxVal,IE(im,x,y,c));
                    totalPixels+=1;
                }
            }
        }
    }

    /********************** determine the bin size ********************/
    binSize = (maxVal - minVal) / N;

    /*************** Find probablity distribution ***************/
    /* initialize counts to zero */
    for(x = 0; x < N; x++){ bins[x].count = 0; }

    /* count individual pixels */
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[x][y]){
                    int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                    int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */
                    bins[bin].count++;
                }
            }
        }
    }

    /***************** Distribute bins *****************/
    c = 0; /* c is an accumulated count value */
    for(x = 0; x < N; x++){
        bins[x].rangeStart = c/totalPixels;
        c += bins[x].count;
        bins[x].rangeEnd = c/totalPixels;
    }

    /***************** create equalized image *************/
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                if(!mask || mask[x][y]){
                    int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                    PIX_TYPE frac = ((IE(im,x,y,c)-minVal)/binSize) - tmp;
                    int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */

                    /* compute the linear interpolation for the final pixel value */
                    IE(im,x,y,c) = bins[bin].rangeStart*(1.0-frac) + bins[bin].rangeEnd*(frac);
                }
                else{
                    IE(im,x,y,c) = 0;
                }
            }
        }
    }

    free(bins);
}

void histEqualRect(Image im, int N, int top, int left, int bottom, int right){
    HistogramBin *bins = (HistogramBin*)malloc(sizeof(HistogramBin)*N);
    PIX_TYPE minVal, maxVal, binSize;
    PIX_TYPE totalPixels = im->width*im->height*im->channels;
    int x, y, c;

    assert(bins);
    assert(top >= 0);
    assert(left >= 0);
    assert(bottom <= im->height);
    assert(right <= im->width);
    /*************** find the minimum and maximum values ***************/
    minVal = IE(im,0,0,0);
    maxVal = IE(im,0,0,0);
    for(x = left; x < right; x++){
        for(y = top; y < bottom; y++){
            for(c = 0; c < im->channels; c++){
                minVal = MIN(minVal,IE(im,x,y,c));
                maxVal = MAX(maxVal,IE(im,x,y,c));
            }
        }
    }

    /********************** determine the bin size ********************/
    binSize = (maxVal - minVal) / N;

    /*************** Find probablity distribution ***************/
    /* initialize counts to zero */
    for(x = 0; x < N; x++){ bins[x].count = 0; }

    /* count individual pixels */
    for(x = left; x < right; x++){
        for(y = top; y < bottom; y++){
            for(c = 0; c < im->channels; c++){
                int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */
                bins[bin].count++;
            }
        }
    }

    /***************** Distribute bins *****************/
    c = 0; /* c is an accumulated count value */
    for(x = 0; x < N; x++){
        bins[x].rangeStart = c/totalPixels;
        c += bins[x].count;
        bins[x].rangeEnd = c/totalPixels;
    }

     /***************** Zero Center bins *****************/
    for(x = 0; x < N; x++){
        int tmp = TRUNC((0.0-minVal)/binSize); /* select bin */
        PIX_TYPE frac = ((0.0-minVal)/binSize) - tmp;
        int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */
        double zeroshift;
        zeroshift = bins[bin].rangeStart*(1.0-frac) + bins[bin].rangeEnd*(frac);

        bins[x].rangeStart -= zeroshift;
        bins[x].rangeEnd   -= zeroshift;
    }

   /***************** create equalized image *************/
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                int tmp = TRUNC((IE(im,x,y,c)-minVal)/binSize); /* select bin */
                PIX_TYPE frac = ((IE(im,x,y,c)-minVal)/binSize) - tmp;
                int bin = MAX(0, MIN(N-1, tmp)); /* Make sure value is in range */

                /* crop frac if it is out of bounds */
                /* compute the linear interpolation for the final pixel value */
                IE(im,x,y,c) = bins[bin].rangeStart*(1.0-frac) + bins[bin].rangeEnd*(frac);
            }
        }
    }

    free(bins);
}

/* shift the pixel values such that the pixels on the left top and right average 0.0 */
void ZeroBorder(Image im){
    int x; int y; int c;
    PIX_TYPE sum = 0.0;
    int count = 0;
    PIX_TYPE zero;

    assert(im);
    assert(im->width > 0);
    assert(im->height > 0);
    for(x = 0; x < im->width; x++){
        for(c = 0; c < im->channels; c++){
            sum += IE(im,x,0,c);
            count++;
        }
    }

    /* start from 1 so that the corners are not counted twice */
    for(y = 1; y < im->height; y++){
        for(c = 0; c < im->channels; c++){
            sum += IE(im,0,y,c);
            sum += IE(im,im->width - 1,y,c);
            count += 2;
        }
    }

    zero = sum / count;
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                IE(im,x,y,c) -= zero;
            }
        }
    }


}

/*	The gaussianNoise function will add zero mean Gaussian
	Random noise to each pixel. The second argument, noise,
	sets the standard deviation. Specifically, the standard
	deviation will be a fraction of the full dynamic range
	of the image where that fraction is determined by the
	noise arguement. Hence, a value of "0.1" for noise will
	set the standard deviation to be 10 percent of the total
	dynamic range in the image.
	*/

double gaussianNoise(Image im, double noise){
    double max;
    double min;
    double stddev;
    int x, y, c;

    /* compute the image range */
    max = IE(im,0,0,0);
    min = IE(im,0,0,0);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                max = MAX(IE(im,x,y,c), max);
                min = MIN(IE(im,x,y,c), min);
            }
        }
    }

    stddev = noise*(max-min);
    /* Add gaussian noise */
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                double tmp = randBM()*stddev;
                IE(im,x,y,c) += tmp;
            }
        }
    }
    return stddev;
}


void applyMask(Image im, const char **mask){
    int x,y,c;

    if(!mask) return;

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                if(mask[x][y]){
                    /* do nothing */
                }
                else{
                    IE(im,x,y,c) = 0.0;
                }
            }
        }
    }

}

/**
 * Converts a grayscale image into a binary mask.
 * The pixel value midway between the minimum
 * and maximum in the source image is taken as
 * a cutoff. Values above this become 1 in the
 * mask, values below this become 0.
 *
 * @param im Source grayscale image
 * @param c Channel in source image to convert into mask
 * @returns The mask
 */
char**
imageToMask(Image im, int c){
  double max = imageMax(im,NULL);
  double min = imageMin(im,NULL);
  double threshold = (max + min)/2;
  char **mask;
  int i,j;

  mask = (char**) malloc(sizeof(char*)*im->width);
  assert(mask); /* problem allocating space for mask */
  
  for(i = 0; i < im->width; i++){
    mask[i] = (char*) malloc(sizeof(char)*im->height);
    assert(mask[i]); /* problem allocating space for mask */
  }
  
  for(j = 0; j < im->height; j++){
      for(i = 0; i < im->width; i++){
	if (IE(im,i,j,c) >= threshold)
	  mask[i][j] = 1;
	else
	  mask[i][j] = 0;
      }
  }
  
  return mask;
}

void markPoint(Image im, PIX_TYPE X, PIX_TYPE Y){
    PIX_TYPE mx = imageMax(im,NULL);
    /* PIX_TYPE mn = imageMin(im,NULL); */
    int x = ROUND(X);
    int y = ROUND(Y);
    int c;

    if(x - 4 < 0 || x + 4 >= im->width) return;
    if(y - 4 < 0 || y + 4 >= im->height) return;

    for(c = 0; c < im->channels; c++){
        IE(im,x-2,y,c) = mx;
        IE(im,x+2,y,c) = mx;
        IE(im,x-3,y,c) = mx;
        IE(im,x+3,y,c) = mx;
        IE(im,x-4,y,c) = mx;
        IE(im,x+4,y,c) = mx;
        IE(im,x,y-2,c) = mx;
        IE(im,x,y+2,c) = mx;
        IE(im,x,y-3,c) = mx;
        IE(im,x,y+3,c) = mx;
        IE(im,x,y-4,c) = mx;
        IE(im,x,y+4,c) = mx;
    }
}


Image makeThermalColorImage(Image im){
    int x, y;
    PIX_TYPE mx = imageMax(im,NULL);
    PIX_TYPE mn = imageMin(im,NULL);
    Image Thermal = makeImage(im->width, im->height, 3);
    assert(im->channels == 1);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            PIX_TYPE value = (IE(im,x,y,0) - mn)/(mx-mn);
            if(value < 0.60){
                IE(Thermal,x,y,0) = 0;
                IE(Thermal,x,y,1) = 0;
                IE(Thermal,x,y,2) = exp(-50*(SQR(value-0.60)));
            } else if (value < 0.70){
                IE(Thermal,x,y,0) = 0;
                IE(Thermal,x,y,1) = (value-.60)/.10;
                IE(Thermal,x,y,2) = 1;
            } else if (value < 0.80){
                IE(Thermal,x,y,0) = 0;
                IE(Thermal,x,y,1) = 1;
                IE(Thermal,x,y,2) = (0.80-value)/.10;
            } else if (value < 0.90){
                IE(Thermal,x,y,0) = (value-.80)/.10;
                IE(Thermal,x,y,1) = 1;
                IE(Thermal,x,y,2) = 0;
            } else if (value < 1.0){
                IE(Thermal,x,y,0) = 1;
                IE(Thermal,x,y,1) = (1.0-value)/.10;
                IE(Thermal,x,y,2) = 0;
            } else {
                IE(Thermal,x,y,0) = 1;
                IE(Thermal,x,y,1) = 0;
                IE(Thermal,x,y,2) = 0;
            }
        }
    }
    return Thermal;
}

Image makeThermalComboImage(Image thrm, Image bw){
    int x, y, c;
    PIX_TYPE mxthrm = imageMax(thrm, NULL);
    PIX_TYPE mnthrm = imageMin(thrm, NULL);
    PIX_TYPE mxbw = imageMax(bw, NULL);
    PIX_TYPE mnbw = imageMin(bw, NULL);
    Image combo = makeImage(bw->width, bw->height, 3);

    assert(bw->channels == 1);
    assert(thrm->channels == 3);
    assert(thrm->width == bw->width);
    assert(thrm->height == bw->height);

    for(x = 0; x < bw->width; x++){
        for(y = 0; y < bw->height; y++){
            for(c = 0; c < 3; c++){
                IE(combo,x,y,c) = .5*(IE(thrm,x,y,c) - mnthrm)/(mxthrm-mnthrm)+.5*(IE(bw,x,y,0) - mnbw)/(mxbw-mnbw);
            }
        }
    }
    return combo;
}

/**
 Computes the maximum value of the pixels in an image. If a mask is
 provided only masked values are considered. If mask is NULL, all
 pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The maximum pixel value
*/
PIX_TYPE
imageMax(Image im, const char **mask)
{
    PIX_TYPE m = 0;
    int x, y = 0, c = 0;

    for(x = 0; x < im->width; x++)
      for(y = 0; y < im->height; y++)
	for(c = 0; c < im->channels; c++)
	  if ((!mask) || mask[x][y])
	    {
	      m = IE(im,x,y,c);
	      goto MAX_LOOP; /* Oh no! A goto! */
	    }

    DEBUG (1,"Warning: All pixels masked!");

    for (x = 0 ;x < im->width; x++)
      for (y = 0;y < im->height; y++)
	for (c = 0;c < im->channels; c++)
	  {
	  MAX_LOOP:
	    m = MAX (m,IE(im,x,y,c));
	  }

    return m;
}

/**
 Computes the minium value of the pixels in an image. If a mask is
 provided only masked values are considered. If mask is NULL, all
 pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The minimum pixel value
*/
PIX_TYPE
imageMin(Image im, const char **mask)
{
    PIX_TYPE m = 0;
    int x, y = 0, c = 0;

    for(x = 0; x < im->width; x++)
      for(y = 0; y < im->height; y++)
	for(c = 0; c < im->channels; c++)
	  if ((!mask) || mask[x][y])
	    {
	      m = IE(im,x,y,c);
	      goto MIN_LOOP; /* Argh! A goto! */
	    }

    DEBUG (1, "Warning: All pixels masked!");

    for (x = 0;x < im->width; x++)
        for (y = 0;y < im->height; y++)
            for (c = 0 ;c < im->channels; c++)
	      if ((!mask) || mask[x][y])
		{
		MIN_LOOP:
		  m = MIN (m,IE(im,x,y,c));
		}

    return m;
}

/**
 Computes the mean value of the pixels in an image. If a mask is
 provided only masked values are considered. If mask is NULL, all
 pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The mean pixel value
*/
PIX_TYPE
imageMean (Image im, const char **mask)
{
  int x, y, c, nPix = 0;
  PIX_TYPE sum = 0;

  for (x = 0; x < im->width; x++)
    for (y = 0; y < im->height; y++)
      for (c = 0; c < im->channels; c++)
	if ((!mask) || mask[x][y])
	  {
	    sum += IE(im,x,y,c);
	    nPix++;
	  }

  return sum / nPix;
}

/**
 Computes the variance of the value of the pixels in an image. If
 a mask is provided only masked values are considered. If mask is
 NULL, all pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The mean pixel value
*/
PIX_TYPE
imageVariance (Image im, const char **mask)
{
  int x, y, c, nPix = 0;
  PIX_TYPE sqsum = 0, mean = imageMean (im, mask);
  
  for (x = 0; x < im->width; x++)
    for (y = 0; y < im->height; y++)
      for (c = 0; c < im->channels; c++)
	if ((!mask) || mask[x][y])
	  {
	    nPix++;
	    sqsum += SQR (IE(im,x,y,c) - mean);
	  }

  return sqsum/(nPix - 1);
}

/**
 Computes the standard deviation of the values of the pixels in an
 image. If a mask is provided only masked values are considered.
 If mask is NULL, all pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The std-dev (square root of the variance) of the pixel values.
*/
PIX_TYPE
imageStdDev (Image im, const char **mask)
{
  return sqrt (imageVariance (im, mask));
}

/*
Helper function used by imageMedian
*/

int
pixelComparator (const void *aV, const void *bV)
{
  const PIX_TYPE *a = (const PIX_TYPE*) aV;
  const PIX_TYPE *b = (const PIX_TYPE*) bV;

  if (*a < *b) return -1;
  if (*a > *b) return 1;
  return 0;
}

/**
 Computes the median of the values of the pixels in an
 image. If a mask is provided only masked values are considered.
 If mask is NULL, all pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The median of the pixel values
*/
PIX_TYPE
imageMedian (Image im, const char **mask)
{
  int x, y, c, nPix = imageNumOfPixels (im, mask);
  PIX_TYPE *sortedPixels, *pp, median;

  /* Copy the pixel values into a big array */

  sortedPixels = (PIX_TYPE*) malloc (sizeof (PIX_TYPE) * nPix);

  pp = sortedPixels;
  for (x = 0; x < im->width; x++)
    for (y = 0; y < im->height; y++)
      for (c = 0; c < im->channels; c++)
	if ((!mask) || mask[x][y])
	  *pp++ = IE(im,x,y,c);

  /* Sort the result */

  qsort (sortedPixels, nPix, sizeof (PIX_TYPE), pixelComparator);

  median = sortedPixels [nPix/2];

  free (sortedPixels);

  return median;
}

/**
 Computes the MAD (median absolute deviation) of the values of
 the pixels in an image:

   median (abs (Y[i] - median (Y)))

 If a mask is provided only masked values
 are considered. If mask is NULL, all pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The MAD of the pixel values
*/
PIX_TYPE
imageMad (Image im, const char **mask)
{
  int x, y, c, nPix = imageNumOfPixels (im, mask);
  PIX_TYPE *sortedPixels, *pp, median, mad;

  /* Copy the pixel values into a big array */

  sortedPixels = (PIX_TYPE*) malloc (sizeof (PIX_TYPE) * nPix);

  pp = sortedPixels;
  for (x = 0; x < im->width; x++)
    for (y = 0; y < im->height; y++)
      for (c = 0; c < im->channels; c++)
	if ((!mask) || mask[x][y])
	  *pp++ = IE(im,x,y,c);

  /* Sort the result */

  qsort (sortedPixels, nPix, sizeof (PIX_TYPE), pixelComparator);

  median = sortedPixels [nPix/2];

  /* Now, subtract the median from the original pixel values */

  pp = sortedPixels;
  for (x = 0; x < im->width; x++)
    for (y = 0; y < im->height; y++)
      for (c = 0; c < im->channels; c++)
	if ((!mask) || mask[x][y])
	  *pp++ = fabs(IE(im,x,y,c) - median); 

  /* Sort the result */

  qsort (sortedPixels, nPix, sizeof (PIX_TYPE), pixelComparator);

  mad = sortedPixels [nPix/2];

  free (sortedPixels);

  return mad;
}

/**
 Computes the number of pixels in an image. If a mask is
 provided only masked values are considered. If mask is
 NULL, all pixels are counted.
 
 @param im An image
 @param mask A mask, or NULL
 @returns The number of pixel values in an image.
*/
int
imageNumOfPixels (Image im, const char **mask)
{
  int x, y, nPix = 0;

  if (!mask)
    nPix = im->width * im->height * im->channels;
  else
    {
      for (x = 0; x < im->width; x++)
	for (y = 0; y < im->height; y++)
	  if (mask[x][y])
	    nPix++;
      nPix *= im->channels;
    }

  return nPix;
}


void computeImageStatistics(ImageStatistics *is, Image im){
    int x,y,c;
    PIX_TYPE sum = 0, sqsum = 0;
    assert(is);

    is->min = is->max = IE(im, 0, 0, 0);
    is->min_x = is->min_y = is->min_c = is->max_x = is->max_y = is->max_c = 0;
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                sum += IE(im,x,y,c);

                if(is->min > IE(im,x,y,c)){
                    is->min = IE(im,x,y,c);
                    is->min_x = x; is->min_y = y; is->min_c = c;
                }
                if(is->max < IE(im,x,y,c)){
                    is->max = IE(im,x,y,c);
                    is->max_x = x; is->max_y = y; is->max_c = c;
                }
            }
        }
    }

    is->mean = sum/(im->width*im->height*im->channels);

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
                sqsum += SQR(IE(im,x,y,c)-is->mean);
            }
        }
    }

    is->variance = sqsum/(im->width*im->height*im->channels - 1);
    is->stddev   = sqrt(is->variance);
}

void computeImageStatisticsMask(ImageStatistics *is, Image im, const char **mask){
    int x,y,c, first = 1;
    PIX_TYPE sum = 0, sqsum = 0, nPix = 0;
    assert(is);

    is->min = is->max = IE(im, 0, 0, 0);
    is->min_x = is->min_y = is->min_c = is->max_x = is->max_y = is->max_c = 0;
    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
	      if(!mask || mask[x][y]){
                sum += IE(im,x,y,c);
		nPix++;
		
                if(first || is->min > IE(im,x,y,c)){
		  is->min = IE(im,x,y,c);
		  is->min_x = x; is->min_y = y; is->min_c = c;
                }
                if(first || is->max < IE(im,x,y,c)){
		  is->max = IE(im,x,y,c);
		  is->max_x = x; is->max_y = y; is->max_c = c;
                }
		first = 0;
	      }
            }
        }
    }

    is->mean = sum/nPix;

    for(x = 0; x < im->width; x++){
        for(y = 0; y < im->height; y++){
            for(c = 0; c < im->channels; c++){
	       if(!mask || mask[x][y]){
		 sqsum += SQR(IE(im,x,y,c) - is->mean);
	       }
            }
        }
    }

    is->variance = sqsum/(nPix - 1);
    is->stddev   = sqrt(is->variance);
}


void computeImageStatisticsLocal(ImageStatistics *is, Image im, int xt, int yt, int dist){
    int x,y,c;
    PIX_TYPE sum = 0, sqsum = 0;
    assert(is);

    dist = ABS(dist);
    is->min = is->max = ie(im, xt, yt, 0);
    is->min_x = is->max_x = xt;
    is->min_y = is->max_y = yt;
    is->min_c = is->max_c = 0;
    for(x = MAX(xt - dist,0); x <= MIN(xt+dist,im->width-1); x++){
        for(y = MAX(yt-dist,0); y <= MIN(yt+dist,im->height-1); y++){
            for(c = 0; c < im->channels; c++){
                sum += ie(im,x,y,c);

                if(is->min > ie(im,x,y,c)){
                    is->min = ie(im,x,y,c);
                    is->min_x = x; is->min_y = y; is->min_c = c;
                }
                if(is->max < ie(im,x,y,c)){
                    is->max = ie(im,x,y,c);
                    is->max_x = x; is->max_y = y; is->max_c = c;
                }
            }
        }
    }

    is->mean = sum/(2*dist*2*dist);

    for(x = MAX(xt - dist,0); x <= MIN(xt+dist,im->width-1); x++){
        for(y = MAX(yt-dist,0); y <= MIN(yt+dist,im->height-1); y++){
            for(c = 0; c < im->channels; c++){
                sqsum += SQR(ie(im,x,y,c)-is->mean);
            }
        }
    }

    is->variance = sqsum/(2*dist*2*dist-1);
    is->stddev   = sqrt(is->variance);
}




/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_IMAGE_INCLUDED
#define CSU_IMAGE_INCLUDED

#define PIX_TYPE double
#define RASTER_ID "CSU_SFI"

/* #define INTERPOLATE_FAST 1 */

typedef struct{
    int width;
    int height;
    int channels;
    PIX_TYPE*** data;
} image;

typedef image* Image;

Image makeImage(int width,int height,int channels);
Image makeZeroImage(int width,int height,int channels);
void freeImage(Image i);

Image duplicateImage(Image im);



/********************* Image Access Functions *******************/

double randBM();

/* Access a single image element using dope vector expantion. symantics: img[x,y,c] */
#define IE( img , x , y , c ) 	( (img)->data[(x)][(y)][(c)] )

/* Safe read-only/range-checked implementation of IE - returns 0.0 if off image. */
#if(!INTERPOLATE_FAST)
PIX_TYPE ie(Image img, int x, int y, int c);
#else
#define ie( img , x , y , c ) ((x < img->width && y < img->height && c < img->channels && x >= 0 && y >=  0 && c >= 0) ? IE(img, x, y, c) : 0.0 )
#endif
/* interpolate a pixel value at a point */


#if(!INTERPOLATE_FAST)
PIX_TYPE interpLinear(Image img, PIX_TYPE x, PIX_TYPE y, int c);
#else
/* Error in Code #define interpLinear(img, x, y, c) ; */
#endif

/********************* Image Manipulation Functions *******************/

Image convolveImage(const Image im, const Image mask);

double convolvePoint(PIX_TYPE x, PIX_TYPE y, int c, const Image im, const Image mask);

void contrastImage(Image im, double scalar);
    /* Multiplies everyvalue in im by scalar */

void brightnessImage(Image im, double scalar);
    /* Adds scalar to every value in im */

void ZeroMeanUnitLength(Image im);
/* scales the pixel so that they have zero mean and the image is unit length*/
void ZeroMeanUnitLengthMasked(Image im, const char **mask);
/* scales the pixel so that they have zero mean and the image is unit length*/

void ZeroMeanOneStdDev(Image im);
/* scales the pixel so that they have zero mean and the image is unit length*/
void ZeroMeanOneStdDevMasked(Image im, const char **mask);
/* scales the pixel so that they have zero mean and the image is unit length*/

double correlateImages(const Image i1, const Image i2);
/* findes the correlation between two images */
double dotImages(const Image i1, const Image i2);
/* find the correlation for images that have zero mean and unit length */

Image computeMeanImage(Image* images, int count);
/* takes an array of images and returns the mean of those images.*/

Image accumulateChannels(const Image im);
/* generates a new image that is the sum of all channels. */

void accumulateImages(Image i1, const Image i2);
/* inplace adds image i2 to image i1 */

void gaussianBlur(Image im, double sigma);

/* Add gausian noise to the image. s is the standard
 * deviation relative to the total image range returns the actual standard deviation
 * of the applied noise
 */
double gaussianNoise(Image im, double s);

/* Performs a histogram equalization function.  Output values are in the range 0 to 1 */

void histEqual(Image i, int num_bins);
void histEqualMask(Image i, int num_bins, const char **mask);
void histEqualRect(Image geo, int num_bins, int top, int left, int bottom, int right);

/* shift the pixel values such that the pixels on the left top and right average 0.0 */
void ZeroBorder(Image im);

/* Smooth image borders */
void smoothImageEdge(Image i, int width);

/* Zero all pixels not in a mask */
void applyMask(Image im, const char **mask);

/* Converts a grayscale image into a mask */
char** imageToMask(Image im, int c);

PIX_TYPE imageMax(Image im, const char **mask);
PIX_TYPE imageMin(Image im, const char **mask);
PIX_TYPE imageMean (Image im, const char **mask);
PIX_TYPE imageVariance (Image im, const char **mask);
PIX_TYPE imageStdDev (Image im, const char **mask);
PIX_TYPE imageMedian (Image im, const char **mask);
PIX_TYPE imageMad (Image im, const char **mask);
int imageNumOfPixels (Image im, const char **mask);

void markPoint(Image im, PIX_TYPE x, PIX_TYPE y);

Image makeThermalColorImage(Image im);

Image makeThermalComboImage(Image thrm, Image bw);


/********************* Image File I/O Functions *******************/

Image readPGMImage(const char*);
Image readRawImage(const char*);
Image readFeretImage(const char *fname, int width, int height,int channels);

void  writePGMImage(const Image, const char*,int channel);
void  writePPMImage(const Image, const char*);
void  writeRawImage(const Image, const char*);
void  writeFeretImage(const Image im, const char *fname);

/********************* Image Statistics ************************************/

typedef struct{
    PIX_TYPE max, min, mean, variance, stddev;
    int max_x, max_y, max_c, min_x, min_y, min_c;
} ImageStatistics;

void computeImageStatistics(ImageStatistics *is, Image im);
void computeImageStatisticsMask(ImageStatistics *is, Image im, const char **mask);
void computeImageStatisticsLocal(ImageStatistics *is, Image im, int x, int y, int dist);

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "csuCommon.h"

int alloc_matrix = 0;

Matrix makeMatrix(int row_dim, int col_dim) {
    /** creates and allocates memory for a matrix */
    int i;
#ifdef SSE2
    int new_row = (row_dim%2)?row_dim+1:row_dim;
#endif
    
    /* Allocate a matrix header */
    Matrix A = (Matrix)malloc(sizeof(matrix));
    assert(A);

    /* keep track of the number of matricies allcoated */
    alloc_matrix++;

    DEBUG(10, "Allocating Matrix");

    /** Set the matrix dimensions */
    A->row_dim = row_dim;
    A->col_dim = col_dim;

    /** Allocate the data section of the matrix */
#ifdef SSE2
    A->data = (FTYPE*)_mm_malloc(sizeof(FTYPE) * new_row * col_dim,16);
#else
    A->data = (FTYPE*)malloc(sizeof(FTYPE) * row_dim * col_dim);
#endif


    if (!A->data) {
        fprintf(stderr, "Matrix Size: %d X %d\n", A->row_dim, A->col_dim);
        fflush(stderr);
    }
    assert(A->data);
    A->cols = (FTYPE**)malloc(sizeof(FTYPE*)*col_dim);
    assert(A->cols);	

    for(i = 0; i < col_dim; i++){
#ifdef SSE2
      A->cols[i] = A->data + i*new_row;/*row_dim;*/
#else
      A->cols[i] = A->data + i*row_dim;
#endif
    }

    return A;
}

Matrix makeZeroMatrix(int row_dim, int col_dim) {
    /** creates and allocates memory for a matrix */
    int i, j;
    Matrix A = makeMatrix(row_dim, col_dim);


    for (i = 0; i < row_dim; i++) {
        for (j = 0; j < col_dim; j++) {
            ME(A, i, j) = 0;
        }
    }
    return A;
}



void freeMatrix(Matrix A) {
    /** frees the area allocated to a matrix */

    /*MESSAGE("Free matrix called - We should NOT do this");*/	
    
    /* keep track of the number of matricies allcoated */
    alloc_matrix--;
    DEBUG(10, "Freeing Matrix");
#ifdef SSE2
    _mm_free(A->data);
#else
    free(A->data);
#endif
    free(A->cols);
    free(A);
}

Matrix makeIdentityMatrix(int dim) {
    /** creates and allocates memory for an identity matrix */
    Matrix I;
    int i, j;

    DEBUG(10, "Creating identity matrix");

    I = makeMatrix(dim, dim);
    for (i = 0; i < dim; i++) {
        for (j = 0; j < dim; j++) {
            ME(I, i, j) = (i == j);
        }
    }

    return I;
}

Matrix duplicateMatrix(const Matrix mat) {
    Matrix dup = makeMatrix(mat->row_dim, mat->col_dim);
    int i, j;
    for (i = 0; i < mat->row_dim; i++) {
        for (j = 0; j < mat->col_dim; j++) {
            ME(dup, i, j) = ME(mat, i, j);
        }
    }

    return dup;
}

Matrix multiplyMatrix(const Matrix A, const Matrix B) {
    /** creates a new matrix that is the product of A and B */

    int i, j, k;                                   /* Variables used as indices */
    Matrix P = makeMatrix(A->row_dim, B->col_dim); /* Product A * B */

    DEBUG(10, "Multiplying Matrix");

    assert(A->col_dim == B->row_dim); /* Verify that the Matrices can be multiplied */

    /** Build the product matrix P */
    for ( j = 0; j < B->col_dim; j++) {
        for ( i = 0; i < A->row_dim; i++) {
            ME( P, i, j) = 0;
            for (k = 0; k < A->col_dim; k++) {
                ME( P, i, j) += ME(A, i, k) * ME(B, k, j);
            }
        }
    }

    return P;
}


Matrix transposeMultiplyMatrixL(const Matrix A, const Matrix B) {
    /** creates a new matrix that is the product of (A transpose) and B */

    int i, j, k;                                   /* Variables used as indices */
    Matrix P = makeMatrix(A->col_dim, B->col_dim); /* Product A * B */

    DEBUG(10, "Multiplying Matrix");

    assert(A->row_dim == B->row_dim); /* Verify that the Matrices can be multiplied */

    /** Build the product matrix P */

    /** Optimized code */
    for ( j = 0; j < B->col_dim; j++) {
        for ( i = 0; i < A->col_dim; i++) {
            ME( P, i, j) = 0;
        }
    }
    for ( j = 0; j < B->col_dim; j++) {
        for ( i = 0; i < A->col_dim; i++) {
            for (k = 0; k < A->row_dim; k++) {
                ME( P, i, j) += ME(A, k, i) * ME(B, k, j);
            }
        }
    }

    return P;
}

Matrix transposeMultiplyMatrixR(const Matrix A, const Matrix B) {
    /** creates a new matrix that is the product of the A and (B transpose) */

    int i, j, k;                                   /* Variables used as indices */
    Matrix P = makeMatrix(A->row_dim, B->row_dim); /* Product A * B */

    DEBUG(10, "Multiplying Matrix");

    assert(A->row_dim == B->row_dim); /* Verify that the Matrices can be multiplied */

    /* Optimized code */
    for ( i = 0; i < A->row_dim; i++) {
        for ( j = 0; j < B->row_dim; j++) {
            ME( P, i, j) = 0;
        }
    }

    for (k = 0; k < A->col_dim; k++) {
        for ( i = 0; i < A->row_dim; i++) {
            for ( j = 0; j < B->row_dim; j++) {
                ME( P, i, j) += ME(A, i, k) * ME(B, j, k);
            }
        }
    }

    return P;
}


Matrix transposeMatrix(const Matrix A) {
    /* creates a new matrix that is the transpose of A */
    int i, j;                                      /* Variables used as indices */
    Matrix T = makeMatrix(A->col_dim, A->row_dim); /* Transpose of A */

    DEBUG(10, "Transposing Matrix");

    /** Transpose data */
    for ( i = 0; i < A->row_dim; i++) {
        for ( j = 0; j < A->col_dim; j++) {
            ME(T, j, i) = ME(A, i, j);
        }
    }

    return T;
}

void rowSwap(Matrix m, int rSrc, int rDest){
    int col = 0;
    FTYPE tmp;
    
    for(col = 0; col < m->col_dim; col++){
        tmp = ME(m,rSrc,col);
        ME(m,rSrc,col) = ME(m,rDest,col);
        ME(m,rDest,col) = tmp;
    }
}

void rowMult(Matrix m, int rSrc, FTYPE value){
    int col = 0;

    for(col = 0; col < m->col_dim; col++){
        ME(m,rSrc,col) *= value;
    }
}

void rowMultAdd(Matrix m, int rSrc, int rDest, FTYPE value){
    int col = 0;

    for(col = 0; col < m->col_dim; col++){
        ME(m,rDest,col) += value*ME(m,rSrc,col);
    }
}

void matrixRREF(Matrix m){
    int prealloc = alloc_matrix;
    int pivotCol = 0;
    int pivotRow = 0;
    int row;
    FTYPE absVal;
    int tmp = 0;

    while(1){
        /* Select the row with the largest absolute value, or move to the next row
        if there is no value int the column */
        absVal = 0.0;
        while( absVal == 0.0 && pivotCol < m->col_dim){
            absVal = ABS(ME(m,pivotRow,pivotCol));
            tmp = pivotRow;

            for(row = pivotRow+1; row < m->row_dim; row++){
                if( ABS(ME(m,row,pivotCol)) > absVal ){
                    absVal = ABS(ME(m,row,pivotCol));
                    tmp = row;
                }
            }
            if(absVal == 0){
                pivotCol++;
            }
        }

        /* return if the RREF has been found */
        if( pivotCol >= m->col_dim || pivotRow >= m->row_dim) return; 

        /* make sure that the pivot row is in the correct position */
        if(pivotRow != tmp) rowSwap(m,tmp,pivotRow);

        /* rescale the Pivot Row */
        rowMult( m, pivotRow,1.0/ME(m,pivotRow,pivotCol) );
        
        /* This part of the algorithm is not as effecent as it could be,
            but it works for now. */
        for(row = 0; row < m->row_dim; row++){
            if(row != pivotRow) {
                rowMultAdd(m,pivotRow,row,-ME(m,row,pivotCol));
            }
        }
        pivotRow++;
        pivotCol++;
    }

    if(prealloc != alloc_matrix){
        printf("Error deallocating matricies <%s>: pre=%d post=%d",__FUNCTION__, prealloc, alloc_matrix);
        exit(1);
    }
}

/* invert a matrix using Gaussian Elimination */
Matrix invertRREF(Matrix m){
    int prealloc = alloc_matrix;
    int i,j;
    Matrix tmp = makeZeroMatrix(m->row_dim, m->col_dim*2);
    Matrix inverse = makeMatrix(m->row_dim, m->col_dim);
    DEBUG_CHECK(m->row_dim == m->col_dim,"Matrix can only be inverted if it is square");
    /* build the tmp Matrix which will be passed to RREF */
    for( i = 0; i < m->row_dim; i++){
        for( j = 0; j < m->col_dim; j++){
            ME(tmp,i,j) = ME(m,i,j); 
            if(i == j){ 
                ME(tmp,i,j+m->col_dim) = 1;
            }
        }
    }
    matrixRREF(tmp);

    for( i = 0; i < m->row_dim; i++){
        for( j = 0; j < m->col_dim; j++){
            ME(inverse,i,j) = ME(tmp,i,j+m->col_dim);
        }
    }

    freeMatrix(tmp);
    
    if(prealloc != alloc_matrix - 1){
        printf("Error deallocating matricies <%s>: pre=%d post=%d",__FUNCTION__, prealloc, alloc_matrix);
        exit(1);
    }
    return inverse;
}

Matrix leastSquares(Matrix A, Matrix b){
    int prealloc = alloc_matrix;
    Matrix At = transposeMatrix(A);
    Matrix AtA = transposeMultiplyMatrixL(A,A);
    Matrix AtAi = invertRREF(AtA);
    Matrix Atb = multiplyMatrix(At,b);
    Matrix a = multiplyMatrix(AtAi,Atb);

    freeMatrix(At);
    freeMatrix(AtA);
    freeMatrix(AtAi);
    freeMatrix(Atb);

    if(prealloc != alloc_matrix - 1){
        printf("Error deallocating matricies <%s>: pre=%d post=%d",__FUNCTION__, prealloc, alloc_matrix);
        exit(1);
    }
    return a;
}

Matrix weightedLeastSquares(Matrix A, Matrix b, Matrix W){
    int prealloc = alloc_matrix;

    Matrix WA = multiplyMatrix(W,A);
    Matrix WAt = transposeMatrix(WA);
    Matrix WAtW = multiplyMatrix(WAt,W);
    Matrix WAtWA = multiplyMatrix(WAtW,A);
    Matrix WAtWAi = invertRREF(WAtWA);
    Matrix WAtWAiWAt = multiplyMatrix(WAtWAi,WAt);
    Matrix WAtWAiWAtW = multiplyMatrix(WAtWAiWAt,W);
    Matrix a = multiplyMatrix(WAtWAiWAtW,b);

    freeMatrix(WA);
    freeMatrix(WAt);
    freeMatrix(WAtW);
    freeMatrix(WAtWA);
    freeMatrix(WAtWAi);
    freeMatrix(WAtWAiWAt);
    freeMatrix(WAtWAiWAtW);

    if(prealloc != alloc_matrix - 1){
        printf("Error deallocating matricies <%s>: pre=%d post=%d",__FUNCTION__, prealloc, alloc_matrix);
        exit(1);
    }
    return a;
}

Matrix subtractMatrix(const Matrix A, const Matrix B) {
    /** output A - B */
    Matrix diff = makeMatrix(A->row_dim, A->col_dim);
    int i, j;
    DEBUG(10, "Subtracting Matrix");

    assert(A->row_dim == B->row_dim);
    assert(A->col_dim == B->col_dim);

    for (i = 0; i < A->row_dim; i++) {
        for (j = 0; j < A->col_dim; j++) {
            ME(diff, i, j) = ME(A, i, j) - ME(B, i, j);
        }
    }

    return diff;
}


Matrix addMatrix( const Matrix A, const Matrix B) {
    /** output A + B */
    Matrix sum = makeMatrix(A->row_dim, A->col_dim);
    int i, j;
    DEBUG(10, "Adding Matrix");

    assert(A->row_dim == B->row_dim);
    assert(A->col_dim == B->col_dim);

    for (i = 0; i < A->row_dim; i++) {
        for (j = 0; j < A->col_dim; j++) {
            ME(sum, i, j) = ME(A, i, j) + ME(B, i, j);
        }
    }

    return sum;
}

void addMatrixEquals(Matrix A, const Matrix B) {
    /** output A += B */
    int i, j;
    DEBUG(10, "Adding Matrix");

    assert(A->row_dim == B->row_dim);
    assert(A->col_dim == B->col_dim);

    for (i = 0; i < A->row_dim; i++) {
        for (j = 0; j < A->col_dim; j++) {
            ME(A, i, j) += ME(B, i, j);
        }
    }
}

Matrix matrixCols( const Matrix mat, int col1, int col2) {
    Matrix cols = makeMatrix(mat->row_dim, col2 - col1 + 1);
    int i, j;

    DEBUG_CHECK(col1 <= col2 && col2 < mat->col_dim, "Poorly chosen columns for extract columns operation");
    
    for (i = col1; i <= col2; i++) {
        for (j = 0; j < mat->row_dim; j++) {
            ME(cols, j, i - col1) = ME(mat, j, i);
        }
    }

    return cols;
}


Matrix rangeCheck(Matrix mat, int i, int j, const char* file_name,
                  const char* func_name, int line_num, const char* mat_name) {
    if (i >= 0 && i < mat->row_dim && j >= 0 && j < mat->col_dim)
        return mat;

    printf("*********************  ERROR  *********************\n");
    printf("Error: Matrix bounds out of range     \n");
    printf("  in function: %s  Matrix: %s     \n", func_name, mat_name);
    printf("        Index: (%d,%d)  Size: (%dX%d) \n", i, j, mat->row_dim, mat->col_dim);
    printf("                     file: %s         \n", file_name);
    printf("                     line: %d         \n", line_num );
    printf("***************************************************\n");

    exit(1);
    return mat;
}


/*
  This is useful for debugging. It prints a matrix to standard out
*/

void printMatrix(const char* label, Matrix m) {
    int i, j;

    printf("%s = dimentions: %dX%d\n", label, m->row_dim, m->col_dim);
    for (i = 0; i < m->row_dim; i++) {
        for (j = 0; j < m->col_dim; j++) {
            printf("%6.12f ", ME(m, i, j));
        }
        printf("\n");
    }

} 


MatrixSaveMode asciiFormat = octaveFormat;

void saveMatrixAscii(const char *fname, const char* label, const Matrix m, MatrixSaveMode mode) {
    /* saves a matrix to an octave/matlab compatible ascii file */
    FILE* matfile;
    int i, j;
    char filename[1024];

    DEBUG_CHECK (!(((mode & formatMask) == matlabFormat) && (mode & appendToFile)),
		 "Writing multiple matrices to an ascii file not supported by Matlab");

    if (fname == NULL) {
      if ((mode & formatMask) == octaveFormat) {
	sprintf(filename, "%s.mat", label[0] == '*' ? label + 1 : label );
      } else {
	sprintf(filename, "%s.txt", label[0] == '*' ? label + 1 : label );
      }
      fname = filename;
    }

    matfile = fopen(fname, (mode & appendToFile) ? "a" : "w");

    if (!matfile) {
        printf("Error could not open file: \"%s\" for writing.\n", fname);
        exit(1);
    }

    /*  The following lines are incompatible with matlab but
        neccessary for octave.  */

    if ((mode & formatMask) == octaveFormat) { /* save to octave format */
        fprintf(matfile, "# name: %s\n", label[0] == '*' ? label + 1 : label);
        fprintf(matfile, "# type: matrix\n");
        fprintf(matfile, "# rows: %d\n", m->row_dim);
        fprintf(matfile, "# columns: %d\n", m->col_dim);
    }


    for (i = 0; i < m->row_dim; i++) {
        for (j = 0; j < m->col_dim; j++) {
            fprintf(matfile, " %e", ME(m, i, j));
        }
        fprintf(matfile, "\n");
    }

    fclose(matfile);

}

/* Return a matrix of random elements (from 0.0 to 1.0)
 */
Matrix
makeRandomMatrix (int row_dim, int col_dim)
{
  int i,j;
  Matrix m = makeMatrix(row_dim,col_dim);
  for (i = 0; i < m->row_dim; i++) {
      for (j = 0; j < m->col_dim; j++) {
	  ME(m,i,j) = RANDOM;
      }
  }
  return m;
}

/* Return the sum of the squares of the elements of a matrix.
 * The square-root of this quantity is the L2 norm of the matrix.
 */
FTYPE
matrixSumOfSquares (Matrix m)
{
  FTYPE sumOfSquares = 0.0;
  int i, j;
  for (i = 0; i < m->row_dim; i++) {
    for (j = 0; j < m->col_dim; j++) {
      sumOfSquares += SQR(ME(m, i, j));
    }
  }
  return sumOfSquares;
}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef MATRIX_INCLUDED
#define MATRIX_INCLUDED

#include "csuCommon.h"

typedef struct {
    int row_dim;  /* Number of rows    */
    int col_dim;  /* Number of columns */
    FTYPE *data;    /* Data stored in standard form: column major */
    FTYPE **cols;
}
matrix;

typedef matrix* Matrix;

Matrix makeMatrix(int row_dim, int col_dim);        /* creates and allocates memory for a matrix */
void freeMatrix(Matrix A);                        /* frees the area allocated to a matrix      */

Matrix makeZeroMatrix(int row_dim, int col_dim);       /* creates, allocates, and initailizes memory for a matrix */
Matrix makeIdentityMatrix(int dim);           /* creates and allocates memory for an identity matrix */

/* ME (Matrix Element) is used to access a matrix element:
*     implements dope vector expansion
*     Remember that a matrix is stored by columns.
*
*  There are two versions of ME avaible and they are toggled with the
*  range check definition below (MATRIX_RANGE_CHECK).  When MATRIX_RANGE_CHECK
*  is enabled it will cause a function to be called that will check that the
*  element to be accessed is in the correct range (determined by ->row_dim
*  and ->col_dim) if it is not a nice error message will be printed indicating
*  file, function and line number where the error occurred and the program will
*  exit.  Range checking is great for debugging however it is also rather expensive
*  (function call and compares) especially within the nested loops of a matrix multiply.
*
*     Matrix A; index i,j
*/

/* #define MATRIX_RANGE_CHECK */
#ifdef MATRIX_RANGE_CHECK
#define  ME( mat , i , j )  ( ( rangeCheck(mat,i,j,__FILE__,__FUNCTION__,__LINE__,#mat))->cols[j][i] )
#else
#define  ME( mat , i , j )  ( (mat)->cols[j][i] )
#endif

Matrix rangeCheck(Matrix mat, int i, int j, const char* file_name, const char* func_name, int line_num, const char* mat_name);

/* creates a new matrix that is the product of A and B */
Matrix multiplyMatrix (const Matrix A, const Matrix B);
/* creates a new matrix that is the product of (A transpose) and B */
Matrix transposeMultiplyMatrixL (const Matrix A, const Matrix B);
/* creates a new matrix that is the product of A and (B transpose) */
Matrix transposeMultiplyMatrixR (const Matrix A, const Matrix B);

/* A - B */
Matrix subtractMatrix (const Matrix A, const Matrix B);
/* A + B */
Matrix addMatrix (const Matrix A, const Matrix B);
/* A += B */
void addMatrixEquals ( Matrix A, const Matrix B);

/* creates a new matrix that is the transpose of A     */
Matrix transposeMatrix(const Matrix A);

/* invert a matrix */
Matrix invertRREF(Matrix);

/* solve a least squares problem - This function returns the solution vector a */
Matrix leastSquares(Matrix A, Matrix b);
Matrix weightedLeastSquares(Matrix A, Matrix b, Matrix W);

/* creates a matrix of consisting of columns col1 to col2 of matrix mat */
Matrix matrixCols(const Matrix mat, int col1, int col2);

/* alocates and fills a duplicate matrix */
Matrix duplicateMatrix(const Matrix mat);

typedef enum {
  octaveFormat = 0x00,
  matlabFormat = 0x01,
  appendToFile = 0x02,

  formatMask   = 0x01
} MatrixSaveMode;

extern MatrixSaveMode asciiFormat;  /* set to zero for octive format otherwize use matlab */
#define  SAVE_MATRIX( mat )  saveMatrixAscii(NULL, #mat, mat, asciiFormat) 
/* saves a matrix to an octive file */
void saveMatrixAscii(const char *fname, const char* label, const Matrix m, MatrixSaveMode format);

/* return a matrix of random elements (from 0.0 to 1.0) */
Matrix makeRandomMatrix (int row_dim, int col_dim);

/* return the sum of the squares of the matrix elements */
FTYPE matrixSumOfSquares (Matrix mat);

void printMatrix(const char* label, Matrix m);

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 *  csuCommonSubspace.c
 *
 * Authors: Kai She, J. Ross Beveridge, David Bolme and Marcio Teixeira    
 *
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "csuCommon.h"

#if defined(THRD)
#include <pthread.h>
#endif


/* How many lines in the training file header have useful text */
#define TRAINING_HEADER_ENTRIES 10

void
subspaceTrain (Subspace *s, Matrix images, ImageList *srt, int numSubjects, int dropNVectors, CutOffMode cutOffMode, double cutOff, int useLDA, int writeTextInterm)
{
  int i;
  Matrix m;
  int n = 0;    /* The number of eigen vectors to keep */
  double total_energy, energy;
  Matrix tmp;

  /* Initialize structure */

  s->useLDA         = useLDA;
  s->cutOffMode     = cutOffMode;
  s->cutOff         = cutOff;
  s->dropNVectors   = dropNVectors;

  s->numSubjects    = numSubjects;
  s->numPixels      = images->row_dim;

  /*********************************************************************
   * STEP ONE: Calculate the eigenbasis
   ********************************************************************/

  /* Compute the Eigenvalues and Eigenvectors for the covariance matrix
     derived from the images data matrix. The image data is "centered", meaning
     the mean image is subtracted from all images before PCA is performed.
     This centering is done in place, so after this call images are centered. */

  MESSAGE("Computing the PCA eigenspace.");

  eigentrain (&s->mean, &s->values, &s->basis, images);

  MESSAGE("Finished computing eigenspace.");

  /* Numerical roundoff errors may lead to small negative values.
     Strip those before saving the matrix. */

  m = s->values;
  for (i = 0; i < m->row_dim; i++)
    {
      if (ME(m,i,0) < 0) {
	if (ME(m,i,0) < -1e-10)
	  printf("WARNING: Large negative eigenvalue found %f. Truncating to zero.\n", ME(m,i,0));
	ME(m,i,0) = 0;
      }
    }
  
  /*********************************************************************
   * STEP TWO: Drop eigenvectors from the front or truncate them from
   * the back
   ********************************************************************/

  /* 
     The following is used to filter the vectors that are retained after PCA
     training.  The function first optionally removes the vectors from the matrix
     based on the argument -dropNVectors. This argument is always intrepreted in
     terms of absolute numbers, i.e. a value of 1 means drop the first vector, a
     value of 3 means drop the first three. The function then drops vectors from the
     tail based on -cutOffMode and -cutOff arguments. Here, the mode controls how the
     cutoff is performed. The possible modes are:
     
     NONE:    Keep all remaining eigenvectors.
     SIMPLE:  Keep a percentage where the percentage is specified by cutOff.
     ENERGY:  Keep the fewest vectors are such that the sum of energy for them just
     exceeds cutOff times the total energy. 
     STRETCH: Keep all eigenvectors that have eigenvalues greater than a percentage 
     of the largest, where the percentage is specied by cutOff. 
     CLASSES: Keep as many eigenvectors as there are LDA classes.
     
     For both Energy and Stretch, if eigen values/vectors are dropped from the front, 
     these are not included in the determination of the total energy or the max
     eigen value. 
  */

  /* Drop the first vectors  */
    
  DEBUG_CHECK (s->dropNVectors < (s->basis)->col_dim, "Number of vectors to drop must be less than the number of the eigen vectors");

  /* transpose eigenValues for use in this function */
    
  tmp = transposeMatrix (s->values);
  freeMatrix (s->values);
  s->values = tmp;
    
  if (s->dropNVectors && (s->dropNVectors < (s->values)->col_dim))
    {
      tmp = matrixCols (s->basis, s->dropNVectors, (s->basis)->col_dim-1);
      freeMatrix (s->basis);
      s->basis = tmp;

      tmp = matrixCols (s->values, s->dropNVectors, (s->values)->col_dim-1);
      freeMatrix (s->values);
      s->values = tmp;
    }

  /* transpose the eigenValues back to the original order. */
 
  tmp = transposeMatrix (s->values);
  freeMatrix (s->values);
  s->values = tmp;
    
  DEBUG_CHECK((s->values)->row_dim - s->dropNVectors > 0, "Too many eigen vectors droped from front. Can not proceed.");

  switch (s->cutOffMode)
    {
    case CUTOFF_NONE:
      n = (s->basis)->col_dim;
      break;

    case CUTOFF_SIMPLE:
      n = (int)((s->basis)->col_dim * s->cutOff / 100.0);
      break;

    case CUTOFF_ENERGY:
      /* compute total energy - this will not include vectors/values dropped from front. */
      total_energy = 0;
      for (i = 0; i < (s->values)->row_dim; i++) {
	total_energy += ME(s->values, i, 0);
      }

      /* compute cutoff point */
      i = 0;
      energy = 0;
      while ((i < (s->values)->row_dim) && (energy < total_energy * s->cutOff / 100.0)) {
	energy += ME(s->values, i, 0);
	i++;
      }
      n = i;
      break;

    case CUTOFF_STRETCH:
      i = 1;
      while ((i < (s->values)->row_dim) &&
	     (100.0*(ME(s->values, i, 0) / ME(s->values, s->dropNVectors, 0)) > cutOff )) {
	i++;
      }
      n = i;
      break;

    case CUTOFF_CLASSES:
      n = s->numSubjects;
      break;

    default:
      n = 0;
      DEBUG_CHECK (0, "ERROR: Unkown cutoff type");
      break;
    };

  /* Never set the dimensionality of the PCA subspace below the number of
     LDA classes when LDA is being used. Doing so creates a horrible problem
     for LDA: too fee dimensions */
    
  if (s->useLDA && (n < s->numSubjects))
    n = s->numSubjects;
  
  DEBUG_CHECK (n <= (s->basis)->col_dim, "Tried to expand, not contract, PCA space.");
  
  MESSAGE1ARG ("Retaining %d eigen vectors.",n);

  tmp = matrixCols ( s->basis, 0 , n-1);
  freeMatrix (s->basis);
  s->basis = tmp;

  DEBUG_INT (1, "Number of eigen vectors kept.", n);

  DEBUG_CHECK ((s->basis)->col_dim > 0, "All basis vectors deleted after cutoff "
	       "and vector drop was processed.");

  MESSAGE2ARG("Truncating PCA Space. Subspace projection expressed "
	      "as %d by %d matrix.", s->basis->row_dim, s->basis->col_dim);

  /*********************************************************************
   * STEP THREE: Do the LDA if specified
   ********************************************************************/

  if (s->useLDA)
    {
      /* Need to project original images into PCA space */

      Matrix fisherBasis, fisherValues, combinedBasis;
      Matrix imspca = transposeMultiplyMatrixL (s->basis, images);
      
      MESSAGE("Computing Fisher Linear Discriminants for "
	      "training images projected into PCA subspace.");

      fisherTrain (imspca, srt, &fisherBasis, &fisherValues, writeTextInterm);

      combinedBasis = multiplyMatrix (s->basis, fisherBasis);
      basis_normalize (combinedBasis);

      MESSAGE2ARG ("PCA and LDA Combined. Combined projection expressed as %d by "
		   "%d matrix.", combinedBasis->row_dim, combinedBasis->col_dim);

      s->values = fisherValues;
      s->basis  = combinedBasis;
    }
}

/**
   writeSubspace
 
   Writes out a training discription file that includes important
   parameters and command line options and all eigenvectors and eigenvalues
 
   format:
   text: 256 lines reserved
   line1: TRAINING_COMMAND = commandline
   line2: DATE = <training date>
   line3: FILE_LIST = <file contianing the list of images used for training>
   line4: VECTOR_LENGTH = <number of values in each file>
   line5: USE_LDA = <true if lda was turned on>
   line6: PCA_CUTOFF = <Percentage of eigenvectors retianed>
   line7: BASIS_VALUE_COUNT = <number of eigen values>
   line8: BASIS_VECTOR_COUNT = <number of eigen vectors>
   line9: DROPPED_FROM_FRONT = <zero or more dropped from front>
   line10 -> line256: RESERVED
 
   If the additional entries are added to the header, increment the variable
   TRAINING_HEADER_ENTRIES
*/

void
writeSubspace (Subspace *s, char *training_filename, char *imageList, int argc, char**argv)
{
  int i, j;
  FILE* file;
  char *cutOffModeStr;
  time_t ttt = time(0);

  switch (s->cutOffMode)
    {
    case CUTOFF_NONE:    cutOffModeStr = "NONE";    break;
    case CUTOFF_SIMPLE:  cutOffModeStr = "SIMPLE";  break;
    case CUTOFF_ENERGY:  cutOffModeStr = "ENERGY";  break;
    case CUTOFF_STRETCH: cutOffModeStr = "STRETCH"; break;
    default:             cutOffModeStr = "UNKNOWN"; break;
    }
  
  MESSAGE1ARG ("Saving trianing information to file %s", training_filename);

  file = fopen (training_filename, "wb");
  if (!file) {
    printf ("Error: could not open file <%s>\n", training_filename);
    exit (1);
  }
  
  fprintf (file, "TRAINING_COMMAND =");
  
  for (i = 0; i < argc; i++)
    fprintf (file, " %s", argv[i]);

  fprintf (file, "\n");
  fprintf (file, "DATE          = %s", ctime(&ttt));
  fprintf (file, "FILE_LIST     = %s\n", imageList);
  fprintf (file, "VECTOR_LENGTH = %d\n", s->basis->row_dim); /* numPixels */
  fprintf (file, "USE_LDA       = %s\n", s->useLDA ? "YES" : "NO" );

  fprintf (file, "CUTOFF_MODE   = %s\n", cutOffModeStr);
  fprintf (file, "CUTOFF_PERCENTAGE  = %f\n", s->cutOff);
  fprintf (file, "BASIS_VALUE_COUNT  = %d\n", s->values->row_dim);   /* basisDim */
  fprintf (file, "BASIS_VECTOR_COUNT = %d\n", s->basis->col_dim);
  fprintf (file, "DROPPED_FROM_FRONT = %d\n", s->dropNVectors);

  for (i = 11; i < 256; i++){
    fprintf (file, "\n");
  }

  /* write out the pixel count */
  writeInt (file, s->mean->row_dim);

  /* write out the mean vector */
  for (i = 0; i < s->mean->row_dim; i++) {
    writeDouble (file, ME(s->mean,i,0));
  }

  /* write out the number of eigen values */
  writeInt (file, s->values->row_dim);
  
  /* write out the eigen values */
  for (i = 0; i < s->values->row_dim; i++) {
    writeDouble (file, ME(s->values,i,0));
  }

  /* write out the number of basis vectors */
  writeInt (file,s->basis->col_dim);
  
  /* write out the eigen basis.  the size is "pixelcount"X"number of vectors"*/
  for (i = 0; i < s->basis->col_dim; i++) {
    for (j = 0; j < s->basis->row_dim; j++) {
      writeDouble (file, ME(s->basis, j, i));
    }
  }
  fclose (file);
}

/* The contents of the training file are described in csuSupbspaceTrain.c above
 the definition of writeTrainingFile.  This companion function reads one of these
 files and creates the subspace basis vectors and eigenvalues. In the case of PCA+LDA,
 the eigenvalues are for the transformed, or second, of the two symmetric eigenvector
 problems solved. The variable TRAINING_HEADER_ENTRIES defined at the top of this file
 is used to control how many header lines are printed to standard out. It needs to be 
 adjusted if new entries are added to the header. 
*/

void
readSubspace (Subspace *s, const char* trainingFile, int quiet)
{
    int i, j, headerSize, rowDim, colDim;
    char junk[FILE_LINE_LENGTH], text[FILE_LINE_LENGTH];
    char** header;
    FILE* file;

    headerSize = 255;
    header = (char**) malloc (sizeof(char*) * headerSize);
    assert (header);
    for (i = 0; i < headerSize; i++) {
        header[i] = (char*) malloc(sizeof(char) * FILE_LINE_LENGTH);
        assert (header[i]);
    }

    file = fopen (trainingFile, "rb");

    if (!file) {
        printf("Error: could not open file <%s>\n", trainingFile);
        exit(1);
    }

    for (i = 0; i < headerSize; i++)
        fgets(header[i], FILE_LINE_LENGTH, file);

    if (!quiet) {
        printf("\nTraining Header File is:\n");
        for (i = 0; i < TRAINING_HEADER_ENTRIES; i++)
            printf("   Line %d: %s", i, header[i]);
    }

    sscanf(header[7], "%s%s%d", junk, junk, &s->basisDim);
    sscanf(header[4], "%s%*s%s", junk, text);
    
    if (strcmp(text, "NO") == 0)
      s->useLDA = 0;
    else
      s->useLDA = 1;

    readInt (file,&rowDim);
    s->numPixels = rowDim;
    DEBUG_INT (3, "Vector size", rowDim);
    s->mean = makeMatrix(rowDim, 1);
    for (i = 0; i < (s->mean)->row_dim; i++) {
        readDouble (file, &ME(s->mean,i,0));
    }

    readInt (file,&rowDim);
    s->values = makeMatrix (rowDim, 1);
    for (i = 0; i < (s->values)->row_dim; i++) {
        readDouble (file, &ME(s->values,i,0));
    }

    rowDim = s->numPixels;
    readInt (file,&colDim);
    s->basis = makeMatrix (rowDim, colDim);
    for (i = 0; i < (s->basis)->col_dim; i++) {
        for (j = 0; j < (s->basis)->row_dim; j++) {
            readDouble (file, &ME(s->basis, j, i));
        }
    }

    fclose(file);
}

void
validateBasisIsOrthonormal (Matrix basis, int printlevel)
{
  int i, j;
  FTYPE tolerance = 0.000001;
  Matrix test = transposeMultiplyMatrixL(basis, basis);

  for (i = 0; i < test->row_dim; i++) {
    for (j = 0; j < test->col_dim; j++) {
      if (i == j) {
	if (ABS(ME(test, i, j) - 1.0) > tolerance) {
	  fprintf(stderr, "WARNING: Subspace basis failed orthonormality check at (%d, %d) value: %f\n", i, j, ME(test, i, j));
	}
      } else {
	if (ABS(ME(test, i, j)) > tolerance) {
	  fprintf(stderr, "WARNING: Subspace basis failed orthonormality check at (%d, %d) value: %f\n", i, j, ME(test, i, j));
	}
      }
    }
  }
  if (printlevel > 0)
    printf("\nSubspace Basis Passed Orthonormality Check");
}

Matrix
centerThenProjectImages (Subspace *s, Matrix images)
{
    Matrix subspims;

    mean_subtract_images (images, s->mean);
    subspims = transposeMultiplyMatrixL (s->basis, images);
    return subspims;
}
#ifdef THRD
void *thread_work(void* thrd_args) 
{
  struct thread_args *my_data = (struct thread_args*) thrd_args;
  Subspace *s;
  char * imageDirectory;
  ImageList *start_sub, *stop_sub, *subject, *replicate;
  int i, j;
  Matrix images, vector, smallVector;
  char name[FILE_LINE_LENGTH];

  s = my_data->s;
  imageDirectory = my_data->imageDirectory;
  start_sub = my_data->start_sub;
  stop_sub = my_data->stop_sub;
  images = my_data->images;
  vector = makeMatrix(s->numPixels, 1);
  /*vector = my_data->vector;*/
  /*name = my_data->name;*/

  i = start_sub->imageIndex;
  for (subject = start_sub; subject!=stop_sub; subject = subject->next_subject) {
    for (replicate = subject; replicate; replicate = replicate->next_replicate) {
      if (debuglevel > 0)
        printf("%s ", replicate->filename);
      sprintf(name, "%s/%s", imageDirectory, replicate->filename);
      
      /*printf("replicate orignal %d now %d\n",replicate->imageIndex, i);*/
      replicate->imageIndex = i;
      readFile(name, 0, vector);
      
      /*writeProgress("Reading images", i,*numImages);*/

      smallVector = centerThenProjectImages(s, vector);

      /* Copy the smaller vector into the image matrix*/
      for (j = 0; j < smallVector->row_dim; j++) {
	ME(images, j, i) = ME(smallVector, j, 0);
      }
      freeMatrix(smallVector);

      i++;  /* increament the image index */
    }
    if (debuglevel > 0)
      printf("\n");
  }

  return NULL;
}
#endif
/*
 This function reads images in to a vector.  That vector is then mean subtracted
 and then projected onto an optimal basis (PCA or LDA).  Returned is a matrix that
 contains the images after they have been projected onto the subspace.
 */
Matrix
readAndProjectImages (Subspace *s, char *imageNamesFile, char *imageDirectory, int *numImages, ImageList **srt)
{
  int i, j;
  Matrix images, vector, smallVector;
  char name[FILE_LINE_LENGTH];
  ImageList *subject, *replicate;
#ifdef THRD
  int numSubj, ns_per_thread, extra_subj,status;
  struct thread_args thread_data[NUM_THREADS];

  pthread_attr_t attr;
  pthread_t thread[NUM_THREADS];

#endif

  DEBUG(1, "Reading training file names from file");

#ifdef THRD
  *srt = getImageNames(imageNamesFile, numImages, &numSubj);
#else
  *srt = getImageNames(imageNamesFile, numImages);
#endif

  DEBUG_CHECK(*srt, "Error: header no imagenames found in file image list file");

  /* Automatically determine number of pixels in images    */
  sprintf(name, "%s/%s", imageDirectory, (*srt)->filename);
  DEBUG(1, "Autodetecting number of pixels, i.e. vector length based on the size of image 0.");
  DEBUG_CHECK (autoFileLength(name) == s->numPixels, "Images sizes do not match subspace basis vector size");
  DEBUG_INT(1, "Vector length", s->numPixels);
  DEBUG_CHECK(s->numPixels > 0, "Error positive value required for a Vector Length");

  /*Images stored in the columns of a matrix */
  DEBUG(1, "Allocating image matrix");

  images = makeMatrix(s->basis->col_dim, *numImages+1);

#ifdef THRD
  ns_per_thread = numSubj/NUM_THREADS;
  extra_subj = numSubj % NUM_THREADS;

  i=0;
  thread_data[0].start_sub = *srt;
  thread_data[NUM_THREADS-1].stop_sub = NULL;
  j = 0;
  for (subject = *srt; j<NUM_THREADS-1; subject = subject->next_subject) {
    i++;
    if (i==ns_per_thread+((extra_subj)? 1:0)) {
      j++;
      i = 0;
      extra_subj = (extra_subj)? extra_subj-1 : 0;
      thread_data[j-1].stop_sub = thread_data[j].start_sub = subject;
    }
  }
#if (NUM_THREADS>1)
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
#endif

  for(i=0;i < NUM_THREADS;i++)
  {
    int pid=0;
    thread_data[i].s = s;
    thread_data[i].imageDirectory = imageDirectory;
    thread_data[i].images = images;
    thread_data[i].vector = vector;
    thread_data[i].name = name;


#if (NUM_THREADS>1)
    if (i<NUM_THREADS-1) {
      
      /* create threads */
      if (pthread_create(&thread[i], &attr, thread_work,
                       (void*) &thread_data[i]))
        {
          printf("ERROR; return code from pthread_create() is \n");
          exit(-1);
        }
    }
#endif

  }

  /* Free attribute and wait for the other threads */
#if (NUM_THREADS >1)
  pthread_attr_destroy(&attr);
#endif

  thread_work((void*) &thread_data[NUM_THREADS-1]);

#if (NUM_THREADS >1)
  for(i=0;i < NUM_THREADS-1;i++)
  {
    if (pthread_join(thread[i], (void **)&status))
      {
        printf("ERROR; return code from pthread_join() is \n");
        exit(-1);
      }
  }
#endif

#else /* not THRD */
  i = 0;
  vector = makeMatrix(s->numPixels, 1);
  for (subject = *srt; subject; subject = subject->next_subject) {
    for (replicate = subject; replicate; replicate = replicate->next_replicate) {
      if (debuglevel > 0)
        printf("%s ", replicate->filename);
      sprintf(name, "%s/%s", imageDirectory, replicate->filename);
      replicate->imageIndex = i;
      readFile(name, 0, vector);

      writeProgress("Reading images", i,*numImages);
      smallVector = centerThenProjectImages(s, vector);

      /* Copy the smaller vector into the image matrix*/
      for (j = 0; j < smallVector->row_dim; j++) {
	ME(images, j, i) = ME(smallVector, j, 0);
      }
      freeMatrix(smallVector);
      i++;  /* increament the image index */
    }
    if (debuglevel > 0)
      printf("\n");
  }
#endif
    
  return images;
}

/* basis_normalize

Using the snapshot method, the Eigenvectors of the original problem are
derived from the eigenvectors of the smaller covariance matrix by
premultiplying the original eigenvectors by the data matrix. This operation
give Eigenvectors that point in the proper direction, but that are not yet of
unit length. So, we normalize them.
*/
void
basis_normalize(Matrix eigenvectors)
{
    int i, j;
    FTYPE sumsqr, inv_len;
    for (i = 0; i < eigenvectors->col_dim; i++)
      {
        sumsqr = 0.0;
        for (j = 0; j < eigenvectors->row_dim; j++)
	  sumsqr += ME(eigenvectors, j, i) * ME(eigenvectors, j, i);
        if (sumsqr != 0)
	  inv_len = 1.0 / sqrt(sumsqr);
        else
	  inv_len = 0;
        for (j = 0; j < eigenvectors->row_dim; j++)
	  ME(eigenvectors, j, i) *= inv_len;
      }
}


/* mean_subtract_images

This function subtracts a mean image from a set of images
in matrix images
*/

#if 0 /* original code */

void
mean_subtract_images (Matrix images, Matrix mean)
{ 

int i, j;
  for (i = 0; i < images->row_dim; i++) {
    for (j = 0; j < images->col_dim; j++) {
      ME(images, i, j) -= ME(mean, i, 0);
    }
  }
}

#else /* unrolled code */

void
mean_subtract_images (Matrix images, Matrix mean)
{
  int i, j;

  assert(!(images->row_dim %2)  && "unrolled twice");

  for (i = 0; i < images->row_dim; i+=2) {

    for (j = 0; j < images->col_dim; j++) {
      ME(images, i, j) -= ME(mean, i, 0);
      ME(images, i+1, j) -= ME(mean, i+1, 0);
    }
  }
}


#endif /* end unrolled code */



/* get_mean_image

This function takes a matrix of images and returns the mean of
all of the images in the matrix.
*/
Matrix
get_mean_image (Matrix images)
{
  int i, j;
  Matrix mean = makeMatrix(images->row_dim, 1);

  for (i = 0; i < images->row_dim; i++)
    {
      ME(mean, i, 0) = 0.0;
      for (j = 0; j < images->col_dim; j++)
	ME(mean, i, 0) += ME(images, i, j);
      ME(mean, i, 0) = ME(mean, i, 0) / images->col_dim;
    }

  return mean;
}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 *  csuCommonSubspace.h
 *
 *  Created by Marcio L. Teixeira on Tue Jun 19 2002.
 *
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_COMMON_SUBSPACE_INCLUDED
#define CSU_COMMON_SUBSPACE_INCLUDED

#include "csuCommon.h"

typedef enum {
  CUTOFF_NONE    = 0,
  CUTOFF_SIMPLE  = 1,
  CUTOFF_ENERGY  = 2,
  CUTOFF_STRETCH = 3,
  CUTOFF_CLASSES = 4
} CutOffMode;

#define DEFAULT_CUTOFF_PERCENT_SIMPLE  60.0
#define DEFAULT_CUTOFF_PERCENT_ENERGY  90.0
#define DEFAULT_CUTOFF_PERCENT_STRETCH 1.0

typedef struct
{
  int numSubjects;
  int numPixels;
  int basisDim;

  Matrix values;
  Matrix basis;
  Matrix mean;

  int useLDA;
  CutOffMode cutOffMode;
  double cutOff;
  int dropNVectors;
} Subspace;

#ifdef THRD
/*#define NUM_THREADS 2*/

struct thread_args {
  Subspace *s;
  ImageList *start_sub;
  ImageList *stop_sub;
  char* imageDirectory;
  Matrix images, vector, smallVector;
  char* name;
  int myid;
  FILE *dbgfile;
};
#endif

void subspaceTrain (Subspace *s, Matrix images, ImageList *srt, int numSubjects, int dropNVectors, CutOffMode cutOffMode, double cutOff, int useLDA, int writeTextInterm);
void writeSubspace (Subspace *s, char *training_filename, char *imageList, int argc, char**argv);
void readSubspace (Subspace *s, const char* trainingFile, int quiet);

void validateBasisIsOrthonormal (Matrix basis, int printlevel);

Matrix centerThenProjectImages (Subspace *s, Matrix images);

void readSubspace (Subspace *s, const char *trainingFile, int quiet);
Matrix readAndProjectImages (Subspace *s, char *imageNamesFile, char *imageDirectory, int *numImages, ImageList **srt);

/* The following are prototypes for functions found in the csuSubspace files. */

/* eigensolvers found in csuSubspaceCVEigen */
int  cvJacobiEigens_32f ( float* A, float* V, float* E, int n, float eps );
int  cvJacobiEigens_64d ( double* A, double* V, double* E, int n, double eps );

/* basis manipulation */
void basis_normalize (Matrix eigenvectors);
void mean_subtract_images (Matrix images, Matrix mean);
Matrix get_mean_image (Matrix images);

/* subspace training functions */
void eigentrain (Matrix *mean, Matrix *eigen_vals, Matrix *eigen_base, Matrix images);
void fisherTrain (Matrix imspca, ImageList *srt, Matrix *fisherBasis, Matrix *fisherValues, int writeTextInterm);

#endif /* CSU_COMMON_SUBSPACE_INCLUDED */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
File: csuCommonUtil.c
Authors: J. Ross Beveridge, David Bolme, Kai She, Marcio Teixeira                         
Date:    June 11, 2002                                                     
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/** @file
 Purpose: This file contains common utilities
*/


/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

#include "csuCommon.h"
#include <ctype.h>


/* This function computes the area under the standard normal curve
   from -infinity to a.  This can be used to compute statistical
   significance of a test.  This basically is used like a z curve
   lookup table.
*/
double probNormal(double a){
    int i; double j; double sum; double term;

    j = 1;
    sum = 0;

    for(i = 1; i < 200; i += 2){
        j = j*i;
        term = pow(a,i)/j;
        sum = sum + term;
    }

    return sum*exp(-pow(a,2)/2)/sqrt(2*PI)+0.5;
}

/*
 Shuffle returns an array with integers between 0 and size-1 where their
 order is randomized but there are no duplicates */
int* shuffle(int size) {
    int *vec;
    int *temp;    /* Temporary list of integers to be randomly inserted into vec */
    int bound;    /* The upper bound on indices in temp still to consider */
    int place;    /* Position in temp randomly chosen between zero and bound - 1 */
    int i, j;
    vec = (int*) malloc(sizeof(int) * size);
    assert(vec);
    temp = (int*) malloc(sizeof(int) * size);
    assert(temp);
    for (i = 0; i < size; i++) {
        temp[i] = i;
    }
    /* Starting with bound equal to size, pick a random position in
     temp, copy that value into the next position of the result
     vector, then copy all values above that place in temp down one
     position. This effectively removes the value copied into vector
     from further consideration. In other words, there will be not
     duplicate integers in the resulting vector */
    bound = size;
    for (i = 0; i < size; i++) {

        /* the next line was replaced by DSB to use high order bits - man 3 rand */
        /* place = (int) ((rand() % ((long) bound))); */
        place = (int) (((double)bound)*rand()/(RAND_MAX+1.0));
        
        vec[i] = temp[place];
        for (j = place; j < bound - 1; j++) {
            temp[j] = temp[j + 1];
        }
        bound = bound - 1;
    }
    free(temp);
    return vec;
}

void* csu_allocate(const char* type, int sof, int num, const char* file, int line){
    void* tmp = (void*) malloc(sof*num);
    if(tmp == NULL){
        printf("ERROR: failed to allocate memory.\n"
               "       type: %s - number: %d\n"
               "       in <%s:%d>\n", type, num, file, line);
        exit(1);
    }
    return tmp;
}

/******************************************************************************
*                               TOKENIZER                                     *
******************************************************************************/

/**
 * Initializes an instance of the tokenizer. The 'source' argument is a
 * pointer to a function which returns data. Currently two functions are
 * provided:
 *
 * @param tokenizerStringReader Obtains characters from a null terminated
 *                              string specified by 'arg'
 * @param tokenizerStreamReader Obtains characters from a FILE* specified
 *                              by 'arg'
 */
void
tokenizerInit (Tokenizer * tok, TokenizerDataSourceProc source, void *arg)
{
  tok->i_ptr = tok->in_buff;
  tok->endOfLine = 0;
  tok->endOfFile = 0;
  tok->state = 0;
  tok->availChars = 0;
  tok->dataSource = source;
  tok->dataSrcArg = arg;
}

/**
 * Data source procedure for reading data from a file. This function is
 * provided as an argument to 'tokenizerInit'.
 */
int
tokenizerStreamReader (char *buff, size_t nChars, void **arg)
{
  return fread (buff, sizeof (char), nChars, (FILE *) * arg);
}

/**
 * Data source function for reading data from a null terminated string.
 * This function is provided as an argument to 'tokenizerInit'.
 */
int
tokenizerStringReader (char *buff, size_t nChars, void **arg)
{
  char *c = (char*)*arg;
  int n;

  for (n = 0; (n < nChars) && (*c != '\0'); n++)
    *buff++ = *c++;

  *arg = c;
  return n;
}

/**
 * Reads a single word from the stream. The pointer returned by this
 * function is guaranteed to be valid only until the next invocation
 * of 'tokenizerGetWord'.
 *
 * The tokenizer has the following properties:
 *
 *     - Blank lines are ignored
 *     - Whitespace before or after words are ignored
 *     - Comments can be introduced by a '#' sign
 *     - 'tokenizerEndOfLine' can be used to test whether the word
 *       was the last word of a line
 *     - 'tokenizerEndOfFile' is guaranteed to return true if there
 *       are no other words in the file and the next call to
 *       'tokenizerGetWord' would fail
 */
char *
tokenizerGetWord (Tokenizer * tok)
{
  char c;
  int charClass, emitWord, saveChar;

  /* The tokenizer is implemented as a seven state state machine. State
   * zero is the inital state, state six is the exit state. The states
   * are roughly described as follows:
   *
   *    0 - Inital state: Eat whitespace
   *    1 - Eat comments #1
   *    2 - Save word characters
   *    3 - Eat whitespace
   *    4 - Eat whitespace and newlines
   *    5 - Eat comments #2
   *    6 - End-of-file reached
   *
   * States 1 and 5 are subtely different and represent knowledge about
   * whether there is a word in the word buffer which is waiting to be
   * returned. In general, the state machine can only return a word after
   * it has examined all the characters preceeding the starting character
   * of the next word. This is because the tokenizer must properly
   * indicate that a word is the last valid word in the stream even if
   * that word happens to be followed by several empty lines and/or
   * comments. The need to defer this decision accounts for much of the
   * complexity of the state machine.
   *
   * The rows of the state transition table represent states while the
   * columns corresponds to one of five character classes:
   *
   *    0 - Eof reached        (not a character)
   *    1 - whitespace         (' '  or '\t')
   *    2 - newlines           ('\n' or '\r')
   *    3 - Comment initiator  ('#')
   *    4 - Word char          (everything else)
   */

  static int stateTransitionTable[7][5] = {
    {6, 0, 0, 1, 2},	/* State 0 */
    {6, 1, 0, 1, 1},		/* State 1 */
    {6, 3, 4, 5, 2},		/* State 2 */
    {6, 3, 4, 5, 2},		/* State 3 */
    {6, 4, 4, 5, 2},		/* State 4 */
    {6, 5, 4, 5, 5},		/* State 5 */
    {6, 6, 6, 6, 6}		/* State 6 */
  };

  /* Each state transition may be associated with one or more actions,
   * defined by these bits:
   *
   *   0x1 = CPY: Copy the current char to the word buffer
   *   0x2 = RET: Exit from loop and return contents of word buffer
   *   0x4 = EOF: Assert end-of-file flag
   *   0x8 = EOL: Assert end-of-line flag
   *
   * These actions may be combined:
   *
   *   0x3 = CPY + RET
   *   0x6 = RET + EOF
   *   0xB = CPY + RET + EOL
   *   0xE = RET + EOF + EOL
   */

  static int stateActionTable[7][5] = {
    {0x6, 0x0, 0x0, 0x0, 0x1},	/* State 0 */
    {0x6, 0x0, 0x0, 0x0, 0x0},	/* State 1 */
    {0xE, 0x0, 0x0, 0x0, 0x1},	/* State 2 */
    {0xE, 0x0, 0x0, 0x0, 0x3},	/* State 3 */
    {0xE, 0x0, 0x0, 0x0, 0xB},	/* State 4 */
    {0xE, 0x0, 0x0, 0x0, 0x0},	/* State 5 */
    {0x6, 0x6, 0x6, 0x6, 0x6}	/* State 6 */
  };

  /* Prepare to read new word into word_buff */

  tok->w_ptr = tok->word_buff;

  /* Begin processing characters according to
   * the transition rules */

  while (1)
    {
      /* Read in a new chunk of data, if needed */

      if (tok->availChars == 0)
	{
	  tok->availChars =
	    (*tok->dataSource) (tok->in_buff, NELEM (tok->in_buff),
				&tok->dataSrcArg);
	  tok->i_ptr = tok->in_buff;
	}

      /* Look at the current character and find its character class */

      c = *tok->i_ptr;

      if (tok->availChars == 0)
	charClass = 0;
      else if (c == ' ' || c == '\t')
	charClass = 1;
      else if (c == '\n' || c == '\r')
	charClass = 2;
      else if (c == '#')
	charClass = 3;
      else
	charClass = 4;

      /* Transition to next state based on the character on input */

      saveChar = (stateActionTable[tok->state][charClass] & 0x01);
      emitWord = (stateActionTable[tok->state][charClass] & 0x02);
      tok->endOfFile = (stateActionTable[tok->state][charClass] & 0x04);
      tok->endOfLine = (stateActionTable[tok->state][charClass] & 0x08);
      tok->state = stateTransitionTable[tok->state][charClass];

      /* If we transitioned to an accepting state, break out
       * of the loop so that we can return the token to the caller
       */

      if (emitWord)
	break;

      /* If the transition requires it, copy the character into the
       * word buffer */

      if (saveChar)
	*tok->w_ptr++ = c;

      /* Advance to the next character in the stream */

      tok->i_ptr++;
      tok->availChars--;
    }

  /* Add a NULL terminator, then return the contents of the word
   * buffer to the caller */

  *tok->w_ptr = '\0';
  return tok->word_buff;
}

/* Queries whether the last call to 'tokenizerGetWord' returned the last
 * valid word of the file or stream */
int
tokenizerEndOfFile (Tokenizer * tok)
{
  return tok->endOfFile;
}

/**
 * Queries whether the last call to tokenizerGetWord returned the last
 * word on a line (the last word of the file is always said to be on the
 * end of the line, whether or not that line is followed by a newline) */
int
tokenizerEndOfLine (Tokenizer * tok)
{
  return tok->endOfLine;
}

/**
 * This function tests some of the key functionality of the tokenizer.
 * It aborts the program is something goes awry, but has no side
 * effects if everything checks out */

void
tokenizerTestSuite (Tokenizer * tok)
{
    char *msg = "Tokenizer test failed";
    char* test = "Hello, World!";

    tokenizerInit (tok, tokenizerStringReader, test);
    DEBUG_CHECK (!strcmp ("Hello,", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (!tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (!tokenizerEndOfFile (tok), msg);
    DEBUG_CHECK (!strcmp ("World!", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (tokenizerEndOfFile (tok), msg);

    test = "\n\nYogi # Bear ";
    tokenizerInit (tok, tokenizerStringReader, test);
    DEBUG_CHECK (!strcmp ("Yogi", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (tokenizerEndOfFile (tok), msg);

    test = "";
    tokenizerInit (tok, tokenizerStringReader, test);
    DEBUG_CHECK (!strcmp ("", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (!tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (tokenizerEndOfFile (tok), msg);

    test = "\n  \na\tb##b\n#d";
    tokenizerInit (tok, tokenizerStringReader, test);
    DEBUG_CHECK (!strcmp ("a", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (!tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (!tokenizerEndOfFile (tok), msg);
    DEBUG_CHECK (!strcmp ("b", tokenizerGetWord (tok)), msg);
    DEBUG_CHECK (tokenizerEndOfLine (tok), msg);
    DEBUG_CHECK (tokenizerEndOfFile (tok), msg);
}

/******************************************************************************
*                               LIST FUNCTIONS                                *
******************************************************************************/

/** Accumulates data into a list.
 *  This function accumulates data into a dynamic data structure.
 *  Once all data has been read, it can efficiently be converted
 *  into an an appropriately sized array by the function
 *  listToArray.
 * 
 *  The first argument is a pointer to a pointer that keeps track
 *  of the first element in the list. This argument ought to be
 *  a pointer to a void pointer initialized to NULL. The second
 *  argument is a pointer to data to insert into the list and the
 *  third argument is the size of that data.
*/

void
listAccumulate (void **base, void *data, size_t size)
{
  typedef struct linkedListNode {
    struct linkedListNode* link;
    char *data;
  } *LinkedListNode;
  
  LinkedListNode node = (LinkedListNode)
    malloc(sizeof(LinkedListNode) + size);
  memcpy (&node->data, data, size);
  node->link = (LinkedListNode) *base;
  *base = node;
}

/**
 * This function packages data that was accumulated by
 * listAccumulate into an array. The first two arguments
 * ought to match the ones passed to listAccumulate. The
 * last argument points to a value where the number of
 * elements will be recorded (this argument may be NULL). 
 */
void *
listToArray (void **base, size_t size, size_t *nelems)
{
  typedef struct linkedListNode {
    struct linkedListNode* link;
	char *data;
  } *LinkedListNode;

  int nItems;
  LinkedListNode node, nextNode;
  void *array, *a_dest;

  /* Count up the number of elements in the list */

  nItems = 0;
  node = (LinkedListNode) *base;
  while(node)
    {
      nItems++;
      node = node->link;
    }

  /* Allocate an array big enough to store the data */

  array = malloc( size * nItems );
  
  /* Copy the data over into the array, freeing the list
     nodes as we go along */

  node = (LinkedListNode) * base;
  a_dest = (void*) ((char *) array + (size * nItems));
  while(node)
    {
      a_dest = (void *) ( (char*) a_dest - size);
      memcpy (a_dest, &node->data, size);
      nextNode = node->link;
      free (node);
      node = nextNode;
    }

  /* Return nelems and result */

  if (nelems != NULL)
    *nelems = nItems;

  return array;
}

/**
 * Same as listToArray, but packs an extra NULL pointer to the end of the
 * array. This is useful for constructing NULL-terminated lists of pointers
 * (such as ListOfStrings).
 */
void *
listToNullTerminatedArray (void **base, size_t size, size_t *nelems)
{
  void *res;

  /* Add NULL-termination */

  char *s = NULL;
  listAccumulate (base, &s, size);
  
  res = listToArray (base, size, nelems);
  if(nelems != NULL)
    (*nelems)--; /* Don't count NULL-termination */

  return res;
}

/******************************************************************************
*                               PERMUTATION FUNCTIONS                         *
******************************************************************************/

/**
 * A data structure for associating a pair of integers.
 *
 * This structure is used internally by "shuffledNumbers"
 */
typedef struct {
  long key;
  long index;
} Pair;

/**
 * A qsort helper function for sorting Pairs.
 *
 * This function is used internally by "shuffledNumbers"
 *
 * @param a The first object in the pair to compare
 * @param b The second object in the pair to compare
 */

int
pairComparator (const void *a, const void *b)
{
  const Pair *p1= (Pair *)a;
  const Pair *p2 = (Pair *)b;

  if (p1->key < p2->key)
    return -1;
  if (p1->key > p2->key)
    return 1;
  return 0;
}

/**
 * Return a shuffled list of number from 0 to max.
 */
int *shuffledNumbers (int max)
{
  int *indices, i;
  Pair *toSort = (Pair*) malloc (max * sizeof (Pair));

  for (i = 0; i < max; i++)
    {
      toSort[i].key   = random();
      toSort[i].index = i;
    }

  qsort (toSort, max, sizeof (Pair), pairComparator);

  indices = (int*) malloc (max * sizeof (int));

  for (i = 0; i < max; i++) {
    indices[i] = toSort[i].index;
  } 

  free (toSort);

  return indices;
}

/******************************************************************************
*                               PROGRESS INDICATOR                            *
******************************************************************************/

/**
 * Writes out a progress indicator to the screen.
 *
 * @param message A message to display on the screen
 * @param value   A value which is used to compute the percent
 * @param max     The maximum value which value can reach, or zero if unknown
 */
void
writeProgress (char *what, int value, int max)
{
  char *symbols = "\\|/-";
  static char *sym = "";

  if (*sym == '\0')
    sym = symbols;

  if (max)
    fprintf (stdout, "%s: %c Processed: %d (%d%%)   \r", what, *sym++, value, 100 * value / max);
  else
    fprintf (stdout, "%s: %c Processed: %d          \r", what, *sym++, value);

  fflush (stdout);
}


/* checks to see if the machine is Little Endian
*  this is used to determine if byte reversal is
*  needed when reading or writing data files in
*  sun byte order.
*/
int isMachineLittleEndian(){
    static int flag = -1;
    if(flag == -1){
        char magic[4] = {0x01, 0x02, 0x03, 0x04};
        unsigned long *longMagic = (unsigned long *) magic;
        if (*longMagic == 0x01020304) {
            flag = 0;
        } else if (*longMagic == 0x04030201) {
            flag = 1;
        } else {
            fprintf(stderr, "Funky Byte Order, I give Up!!\n");
            exit(1);
        }
    }
    return flag;
}

void byteswap_4(void *data, const int numfourbyteelements)
{
    int i;
    int *d4 = (int *)data;
    unsigned char *d1 = (unsigned char *)data;

    if (!(isMachineLittleEndian()))	/* i.e. BIG_ENDIAN */
    {
        for (i = 0 ; i < numfourbyteelements ; i++, d1 += 4 )
            d4[i] = ((int)d1[3] << 24) | ((int)d1[2] << 16) |
                ((int)d1[1] <<  8) |  (int)d1[0];
    }
    else				/* i.e. LITTLE_ENDIAN */
    {
        for (i = 0 ; i < numfourbyteelements ; i++, d1 += 4 )
            d4[i] = ((int)d1[0] << 24) | ((int)d1[1] << 16) |
                ((int)d1[2] <<  8) |  (int)d1[3];
    }
}

/*
 *make a stand alone concatenation of s1+s2
 */
char *strconc(const char *s1, const char *s2)
{
    char *result = (char*) malloc (sizeof(char)*(strlen(s1)+strlen(s2)+1));
    DEBUG_CHECK (result, "malloc failed");

    strcpy (result, s1);
    strcat (result, s2);
    return result;
}

char *strclone(const char *si)
{
    char *so = strdup (si);
    DEBUG_CHECK (so, "malloc failed");
    return so;
}

/*
 * make all the characters of the input string lower case, if applicable
 * changes the input string
 */
char *strlower(char *x)
{
    char *result = x ;
    for (; (*x = (char)tolower((int)*x)); x++);
    return result;
}

/*
 * make all the characters of the input string lower case, if applicable
 * changes the input string
 */
char *strupper(char *x)
{
    char *result = x ;
    for (; (*x = (char)toupper((int)*x)) ; x++);
    return result;
}

/*
 * take two strings: strip the final extension from the first
 * if any then add the second to the first.
 * note the first string's address is altered, it's memory is
 * freed and it points to newly allocated memory afterwards.
 */
char *newextlong(char **filename, const char *extension)
{
    if (extension)
    {
        char *result = 0;
        char *finalperiod = strrchr(*filename, '.');

        if (!finalperiod)	 /* add an extension where there wasn't one */
        {
            char *periodized = strconc(".", extension);
            result = strconc(*filename, periodized);
            free(periodized);
        }
        else
        {				/* replace the existing extension */
            finalperiod[1] = '\0';	/* NULL terminate the string */
            result = strconc(*filename, extension);
        }

        free(*filename);
        *filename = result;
    }
return *filename;
}

/******************************************************************************
*                               MATHEMATICS FUNCTIONS                         *
******************************************************************************/


/*********************** Debug Information **********************/
int debuglevel = 0;
int quiet = 0;

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 *  csuUtilities.h
 *  GaborGUI
 *
 *  Created by David  Bolme on Sun Jun 09 2002.
 *
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_COMMON_UTIL_INCLUDED
#define CSU_COMMON_UTIL_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/*
 *  This file was created to contian simple commonly used macros
 *  and functions so that they don't have to be rewritten at every
 *  use.
 */ 

/******************************************************************************
*                           GLOBAL VARIABLES AND CONSTANTS                    *
******************************************************************************/

#include <assert.h>

/* The csu codes are setup to use double floats */
#define FTYPE double

/* First guess at the line length for an image list file */
#define FILE_LINE_LENGTH 512

/* Max length of a filename */
#define MAX_FILENAME_LENGTH 2048

/******************************************************************************
*                           NUMERICAL MACROS                                  *
******************************************************************************/

/*************** Commonly used numerical macros ***************/

#define MIN(v1, v2) 		( ((v1) > (v2)) ? (v2) : (v1) )
#define MAX(v1, v2) 		( ((v1) < (v2)) ? (v2) : (v1) )
#define ABS(v)      		( ((v) < 0)     ? -(v) : (v)  )
#define SQR(v)      		( (v) * (v) )
#define ROUND(v)    		( (int) ((v)+0.5) )
#define TRUNC(v)    		( (int) (v) )
#define EQUAL_ZERO(v,tol)  	( ABS(v) < tol )
#define DIST_2D(x1, y1, x2, y2) (sqrt(SQR((x1)-(x2))+SQR((y1)-(y2)))) 
#define FINITE(n) if(!finite(n)) printf("ERROR: Not Finite - %10s:%5f <%10s,%10s,%3d>\n",#n,n,__FILE__,__FUNCTION__,__LINE__);

#define PI          3.141592654
    /* Random number between 0 and 1 */
#define RANDOM   (fabs(((double)random())/RAND_MAX))

/* This function computes the area under the standard normal curve
   from -infinity to a.  This can be used to compute statistical
   significance of a test.  This basically is used like a z curve
   lookup table.
*/
double probNormal(double a);

/*
 Shuffle returns an array with integers between 0 and size-1 where their
 order is randomized but there are no duplicates */
int* shuffle(int size);

/*************** Commonly used utility macros ****************/

/* This macro will allocate space for an N legth array of type */
/* to allocate just one do ALLOCATE(type,1) */
#define ALLOCATE( type , number ) ( (type*)csu_allocate(#type, sizeof(type),(number), __FILE__, __LINE__) )
void* csu_allocate(const char*, int sof, int num, const char* file, int line);

    /* Number of elements in an array */
#define NELEM(v) (sizeof(v)/sizeof(v[0]))

/*************** Commonly used string macros *****************/
/*#define STRING_TO_DOUBLE(s, d) {                               \
    char* test;                                                \
    (d) = strtod((s),&test);                                   \
    if(test == (s)){                                           \
        printf("Error converting string to double: %s",(s));   \
        exit(1);                                               \
    }                                                         \
}*/

/*#define STRING_TO_INT(s, i) {                                 \
    char* test;                                               \
    (i) = strtod((s),&test);                                  \
    if(test == (s)){                                          \
        printf("Error converting string to int: %s",(s));     \
        exit(1);                                              \
    }                                                         \
}*/

/******************************************************************************
*                           TOKENIZER OBJECT                                  *
******************************************************************************/

typedef int (*TokenizerDataSourceProc) (char *buff, size_t nChars,
					void **arg);

typedef struct
{
  int state;
  char in_buff[512];
  char *i_ptr;
  char word_buff[100];
  char *w_ptr;
  int endOfLine;
  int endOfFile;
  int availChars;
  TokenizerDataSourceProc dataSource;
  void *dataSrcArg;
}
Tokenizer;

/* Tokenizer methods */


void tokenizerInit (Tokenizer * tok, TokenizerDataSourceProc source, void *arg);
char *tokenizerGetWord (Tokenizer * tok);
int tokenizerEndOfFile (Tokenizer * tok);
int tokenizerEndOfLine (Tokenizer * tok);
void tokenizerTestSuite (Tokenizer * tok);

/* The following two functions aren't to be used directly. They are used
 * as the "source" parameter to "tokenizerInit" */

int tokenizerStreamReader (char *buff, size_t nChars, void **arg);
int tokenizerStringReader (char *buff, size_t nChars, void **arg);

/******************************************************************************
*                           UTILITY FUNCTIONS                                 *
******************************************************************************/

/* List functions */

void listAccumulate (void **base, void *data, size_t size);
void * listToArray (void **base, size_t size, size_t *nelems);
void * listToNullTerminatedArray (void **base, size_t size, size_t *nelems);

/* Permutation functions */

int *shuffledNumbers (int max);

/* Progress indicator */

void writeProgress (char *what, int value, int max);

/* Used in several places to see how double floats represented on this machine */
int isMachineLittleEndian();

void byteswap_4(void *data, const int numfourbyteelements);

/* Mathematics functions */

/* String functions */

char *strconc(const char *s1, const char *s2);
char *strclone(const char *si);
char *strlower(char *x);
char *strupper(char *x);
char *newextlong(char **filename, const char *extension);

/******************************************************************************
*                            DEBUGGING ROUTINES                               *
******************************************************************************/

#include <time.h>
#include <stdio.h>
extern int debuglevel;
extern int quiet;

#define MESSAGE( message ) \
    { \
        time_t tttt = time(0); \
        if(quiet == 0 || debuglevel != 0) printf(message); \
        if(quiet == 0 || debuglevel != 0) printf("\n"); \
        if(debuglevel > 0) printf("    [%s]<%s():line %u> %s\n", __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout); \
    }

#define MESSAGE1ARG( message, arg1 ) \
    { \
        time_t tttt = time(0); \
        if(quiet == 0 || debuglevel != 0) printf(message, arg1); \
        if(quiet == 0 || debuglevel != 0) printf("\n"); \
        if(debuglevel > 0) printf("    [%s]<%s():line %u> %s\n", __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout); \
    }

#define MESSAGE2ARG( message, arg1, arg2 ) \
    { \
        time_t tttt = time(0); \
        if(quiet == 0 || debuglevel != 0) printf(message, arg1, arg2); \
        if(quiet == 0 || debuglevel != 0) printf("\n"); \
        if(debuglevel > 0) printf("    [%s]<%s():line %u> %s\n", __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout); \
    }


#define DEBUG( level , message ) \
    if( level == -1 || level <= debuglevel ){ \
        time_t tttt = time(0); \
        printf( "**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n", level, message , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout); \
    }

#define DEBUG_FLOAT( level , message , value) \
    if( level == -1 || level <= debuglevel ){\
        time_t tttt = time(0); \
        printf( "**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n", level, message, #value , value , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout);\
    }

#define DEBUG_DOUBLE( level , message , value) \
    if( level == -1 || level <= debuglevel ){\
        time_t tttt = time(0); \
        printf( "**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n", level, message, #value , value , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt)); \
        fflush(stdout); \
    }

#define DEBUG_INT( level , message , value) \
    if( level == -1 || level <= debuglevel ){\
        time_t tttt = time(0); \
        printf( "**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n", level, message, #value , value , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt));\
        fflush(stdout); \
    }

#define DEBUG_STRING( level , message , value) \
    if( level == -1 || level <= debuglevel ){\
        time_t tttt = time(0); \
        printf( "**DEBUG %d** \"%s\" %s=\"%s\"\n             at [%s]<%s():line %u>\n             %s\n", level, message , #value,value , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt));\
        fflush(stdout);\
    }

#define DEBUG_CHECK( condition , message) \
if( !(condition) ){\
    time_t tttt = time(0); \
        printf( "**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n", #condition, message , __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt));\
            fflush(stdout); \
                exit(1);\
}

#define DEBUG_CHECK_1ARG( condition , message, arg) \
if( !(condition) ){\
    time_t tttt = time(0); \
        printf( "**DEBUG CHECK** Failed check (%s) \"",#condition);\
            printf( message, arg);\
                printf("\"\n             at [%s]<%s():line %u>\n             %s\n", __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt));\
                    fflush(stdout); \
                        exit(1);\
}

#define DEBUG_CHECK_2ARG( condition , message, arg1, arg2 ) \
if( !(condition) ){\
    time_t tttt = time(0); \
    printf( "**DEBUG CHECK** Failed check (%s) \"",#condition);\
    printf( message, arg1, arg2);\
    printf("\"\n             at [%s]<%s():line %u>\n             %s\n", __FILE__ , __FUNCTION__ , __LINE__, ctime(&tttt));\
    fflush(stdout); \
    exit(1);\
}

#define NOT_IMPLEMENTED  DEBUG_CHECK(0,"This function has not yet been implemented");


#endif /*CSU_COMMON_UTIL_INCLUDED*/
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMFaceGraph.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <stdio.h>
#include <stdlib.h>
#include <csuCommon.h>
#include <csuEBGMUtil.h>


typedef struct {
    char* imageFile;
    char* masksFile;

    char* imageDir;
    char* graphDir;
    char* outputDir;
} Arguments;

void usage( const char* name){
    printf("Usage: %s image_list.srt image_dir training_graph_dir gabor_file output_graph_dir\n\n", name);

    printf("**************************** DISCRIPTION ****************************\n");
    printf("* csuGaborFaceGraph                                                 *\n");
    printf("*                                                                   *\n");
    printf("* The purpose of this exicutable is to read a set of model images   *\n");
    printf("* and their graph discription and build graph discriptions for      *\n");
    printf("* novel images.  This program performes different variations of the *\n");
    printf("* face bunch graph matching algorithm to locate points on a face.   *\n");
    printf("*                                                                   *\n");
    printf("*********************************************************************\n");
    printf("\n");
    printf("Arguments:\n");
    printf("  image_list.srt   - image list that contains all images that need\n");
    printf("                     face graphs.\n");
    printf("  image_dir        - directory containing test imagry.\n");
    printf("  novel_graph_dir  - the directory that contains the graph\n");
    printf("                     generated by csuGaborGraphFit.\n");
    printf("  wavelet_file     - gabor wavelet discription file.\n");
    printf("  facegraph_dir    - output directory where face graphs are stored.\n");
    printf("\n");
    exit(1);
}

void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    /******* Set up default values *******/

    args->imageDir     = NULL;
    args->graphDir     = NULL;
    args->outputDir    = NULL;
    args->imageFile       = NULL;
    args->masksFile       = NULL;

    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        /* other flags */
        else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
        else if (readOption    (argc, argv, &i, "-dcfree")) { WiskottDCFree = 1.0; }
        else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */
        else if (param_num == 0) {
            args->imageFile = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->imageDir = argv[i];
            param_num++;
        }
        else if (param_num == 2) {
            args->graphDir = argv[i];
            param_num++;
        }
        else if (param_num == 3) {
            args->masksFile = argv[i];
            param_num++;
        }
        else if (param_num == 4) {
            args->outputDir = argv[i];
            param_num++;
        }
        else{ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    }

    /* make sure that there are the proper number of required arguments */
    if (param_num != 5){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    DEBUG(1,"Debuging enabled");
}


int main(int argc, char** argv){
    Arguments args;
    ImageList *imagenames, *subject, *replicate;
    JetMasks masks;
    GraphDiscription gd;
    Image face;
    FaceGraph graph;
    int i;
    int imagenum = 0, numImage;
    
    processCommand(argc,argv, &args);

    masks = readMasksFile(args.masksFile);
    imagenames = getImageNames(args.imageFile, &numImage);
    
    for(subject = imagenames; subject != NULL; subject = subject->next_subject){
        for(replicate = subject; replicate != NULL; replicate = replicate->next_replicate){
            imagenum++;
            printf("Processing: %s (%5d of %5d) %5.2f%%   \n" , replicate->filename, imagenum, numImage, imagenum*100.0/numImage); fflush(stdout);

            gd = readGraphDiscription(makePath(args.graphDir,replicate->filename));
            face = readRawImage(makePath(args.imageDir,replicate->filename));
            graph = makeFaceGraph(gd->numVert, gd->numVert+gd->numEdge);
            graph->params =masks->params;

            for( i = 0; i < gd->numVert; i++){
                graph->jets[i] = extractJet(gd->verts[i].x,gd->verts[i].y,face,masks);
            }

            for( i = 0; i < gd->numEdge; i++){

                double x = 0.5*(gd->verts[gd->edges[i].vert1].x + gd->verts[gd->edges[i].vert1].x);
                double y = 0.5*(gd->verts[gd->edges[i].vert1].y + gd->verts[gd->edges[i].vert1].y);

                graph->jets[ gd->numVert + i ] = extractJet(x,y,face,masks);
            }

            saveFaceGraph(makePath(args.outputDir,replicate->filename),graph);
            freeImage(face);
            freeGraphDiscription(gd);
            freeFaceGraph(graph);
        }
    }
    printf("\n");

    return 0;
}


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMGraphFit.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/* csuGaborGraphFit */
#include <stdio.h>
#include <stdlib.h>
#include <csuEBGMUtil.h>
#include <csuEBGMSimilarity.h>
#include <csuCommon.h>

typedef struct {
    char* modelFile;
    char* novelFile;
    char* masksFile;

    char* imageDir;
    char* graphDir;
    char* outputDir;

    int bunchSize;

    JetDisplacementEstimator dispEst; 
}
Arguments;
/*
 * Process the command line and initialize the variables
 */

void usage( const char* name){
    printf("usage: %s [OPITIONS] modelImages.srt novelImage.srt wavelet_file image_dir model_graph_dir displace_estimator outputDir\n\n", name);
    printf("\n**************************** DISCRIPTION ****************************\n");
    printf("* csuGaborGraphFit                                                  *\n");
    printf("*                                                                   *\n");
    printf("* The purpose of this exicutable to to read a set of training images*\n");
    printf("* and their graph discription and build graph discriptions for      *\n");
    printf("* novel images.  This program performes different variations of the *\n");
    printf("* face bunch graph matching algorithm to locate points on a face.   *\n");
    printf("*                                                                   *\n");
    printf("*********************************************************************\n");
    printf("\n");
    printf("  ARGUMENTS:\n");
    printf("      model_images.srt  -   A list of images with user built graphs\n");
    printf("      novel_images.srt  -   A list of images to generate graphs\n");
    printf("      wavelet_file      -   A gabor jet discription file\n");
    printf("      image_dir         -   A directory containing images\n");
    printf("      model_graph_dir   -   A directory containing model graphs\n");
    printf("      displaceEstimator -   The name of the algorithm to use for displacement estimation\n");
    printf("      outputDir         -   A directory to store the new graphs discriptions\n");
    printf("\n");

    exit(1);
}

void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    /******* Set up default values *******/

    args->imageDir     = NULL;
    args->graphDir     = NULL;
    args->outputDir    = NULL;
    args->modelFile       = NULL;
    args->novelFile       = NULL;
    args->masksFile       = NULL;

    args->bunchSize       = 70;

    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        else if (readOptionInt (argc, argv, &i, "-bunchSize", &args->bunchSize)) {}
        /* other flags */
        else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
         else if (readOption    (argc, argv, &i, "-dcfree")) { WiskottDCFree = 1.0; }
       else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */
        else if (param_num == 0) {
            args->modelFile = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->novelFile = argv[i];
            param_num++;
        }
        else if (param_num == 2) {
            args->masksFile = argv[i];
            param_num++;
        }
        else if (param_num == 3) {
            args->imageDir = argv[i];
            param_num++;
        }
        else if (param_num == 4) {
            args->graphDir = argv[i];
            param_num++;
        }
        else if (param_num == 5) {
            if      (strcasecmp(argv[i],"DEGridSample") == 0) { args->dispEst = DEGridSample; }
            else if (strcasecmp(argv[i],"DEPredictiveStep") == 0) { args->dispEst = DEPredictiveStep; }
            else if (strcasecmp(argv[i],"DEPredictiveIter") == 0) { args->dispEst = DEPredictiveIter; }
            else if (strcasecmp(argv[i],"DEFixedLocalSearch") == 0) { args->dispEst = DEFixedLocalSearch; }
            else if (strcasecmp(argv[i],"DENarrowingLocalSearch") == 0) { args->dispEst = DENarrowingLocalSearch; }
            else{ clParseError(argc,argv,i,"Unknown Distance Estimator"); }
            param_num++;
        }
        else if (param_num == 6) {
            args->outputDir = argv[i];
            param_num++;
        }
        else{ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    }

    /* make sure that there are the proper number of required arguments */
    if (param_num != 7){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    DEBUG(1,"Debuging enabled");
}


GraphDiscription extractModelJets(ImageList* modelImages, char* imageDir, char* graphDir, JetMasks masks){
    ImageList *subject, *replicate;
    GraphDiscription mj = NULL;
    int count = 0, i;

    for(subject = modelImages; subject != NULL; subject = subject->next_subject){
        for(replicate = subject; replicate != NULL; replicate = replicate->next_replicate){
            /* load the model graph */
            GraphDiscription gd = readGraphDiscription(makePath(graphDir,replicate->filename));

            /* Load the model image */
            Image model = readRawImage(makePath(imageDir,replicate->filename));

            /*MESSAGE2ARG("Extracting Jets From Image #%d.  <%s>", count, replicate->filename);*/
            if(count == 0){
                /* load up a default graph */
                mj = readGraphDiscription(makePath(graphDir,replicate->filename));
            }
            else{
                assert(mj->numVert == gd->numVert);
                for(i = 0; i < mj->numVert; i++){
                    /* Accumulate mean locations */
                    mj->verts[i].x += gd->verts[i].x;
                    mj->verts[i].y += gd->verts[i].y;
                }
            }

            /* extract jets */
                printf("Extracting jets from model image #%03d.  <%s>  |", count, replicate->filename); fflush(stdout);
            for(i = 0; i < gd->numVert; i++){
                printf("#"); fflush(stdout);
                addJetToBunch( mj->bunch[i],
                    extractJet(gd->verts[i].x, gd->verts[i].y, model, masks));
            }
            printf("|\n");

            freeImage(model);
            freeGraphDiscription(gd);
            count++;
        }
    }

    for(i = 0; i < mj->numVert; i++){
        /* Accumulate mean locations */
        mj->verts[i].x /= count;
        mj->verts[i].y /= count;
    }

    return mj;
}

GraphDiscription buildBunchGraph(GraphDiscription modelJets, JetSimilarityMeasure jetSim, int bunchsize){
    int vert;

    assert(bunchsize > 1);
    for(vert = 0; vert < modelJets->numVert; vert++){
        Matrix dist;
        int size, i, j;
        FTYPE maxsim, minsim, smallest;
        int minjet;
        JetBunch finalBunch = makeJetBunch();

        MESSAGE1ARG("Selecting jets for point: %s",modelJets->vertLabels[vert]);

        size = modelJets->bunch[vert]->size;
        assert(bunchsize <= size);
        assert(size > 0);

        dist = makeZeroMatrix(size, size);

        smallest = maxsim = jetSim(modelJets->bunch[vert]->jets[0],modelJets->bunch[vert]->jets[0]);
        for(i = 0; i < size; i++){
            for(j = 0; j < size; j++){
                ME(dist,i,j) = jetSim(modelJets->bunch[vert]->jets[i],modelJets->bunch[vert]->jets[j]);
                maxsim = MAX( maxsim, ME(dist,i,j) );
                smallest = MIN(smallest, ME(dist,i,j));
            }
        }

        /* find the minimum similarity */
        minsim = 0.0;
        minjet = -1;
        for(i = 0; i < size; i++){
            for(j = 0; j < size; j++){
                if(minjet < 0 || minsim > ME(dist,i,j) ){
                    minsim = ME(dist,i,j);
                    minjet = i;
                }
            }
        }

        while(1){
            /* MESSAGE2ARG("    Adding jet %03d to final bunch. sim=%+f",minjet,minsim); */
            /* add that jet to the final bunch */
            addJetToBunch(finalBunch, modelJets->bunch[vert]->jets[minjet]);
            /* eleminate the newly added jet from the old bunch and the distance matrix */
            modelJets->bunch[vert]->jets[minjet] = NULL;
            for( i = 0; i < size; i++){
                /* Make sure new value is greater that the maximum similarity */
                ME(dist,i,minjet) = 2*ABS(maxsim);
            }

            if(finalBunch->size >= bunchsize) break;

            minsim = 0.0;
            minjet = -1;
            for(j = 0; j < size; j++){
                FTYPE locmax = smallest;
                for(i = 0; i < size; i++){
                    /* compute the best similarity to the jets in the data set */
                    if(modelJets->bunch[vert]->jets[i] == NULL){
                        locmax = MAX(locmax,ME(dist,i,j));
                    }
                }
                if(minjet < 0 || minsim > locmax ){
                    minsim = locmax;
                    minjet = j;
                }
            }
        }

        freeJetBunch(modelJets->bunch[vert]);
        modelJets->bunch[vert] = finalBunch;
        freeMatrix(dist);
    }
    return modelJets;
}

/* performs a weighted estimation of the location of the vertex location. */
void guessVertexLocation(int vert, int maxvert, GraphDiscription graphTemplate, GraphDiscription bunchGraph){
    FTYPE locx = 0.0, locy = 0.0, tw = 0.0;
    int i;

    if(vert < 6){
        /* Little basis for an estimate so just return guess
           -- assume these are eye coordiantates. */
        graphTemplate->verts[vert].x = bunchGraph->verts[vert].x;
        graphTemplate->verts[vert].y = bunchGraph->verts[vert].y;
        return;
    }
    for(i = 0; i < maxvert; i++){
        if(i != vert){
            /* compute the displacement in the bunch graph */
            FTYPE dx = -bunchGraph->verts[i].x + bunchGraph->verts[vert].x;
            FTYPE dy = -bunchGraph->verts[i].y + bunchGraph->verts[vert].y;
            /* compute the distance */
            FTYPE dist = sqrt(SQR(dx)+SQR(dy));
            /* compute the wieght */
            FTYPE w = exp(-dist);

            /* compute the sum of the location */
            locx += w*(graphTemplate->verts[i].x + dx);
            locy += w*(graphTemplate->verts[i].y + dy);
            tw += w;
        }
    }
    
    /* compute the final vert location */
    graphTemplate->verts[vert].x = locx/tw;
    graphTemplate->verts[vert].y = locy/tw;
}


void LocatePoint( FTYPE *x, FTYPE *y, JetBunch bunch, Image novel, JetMasks masks, JetDisplacementEstimator dispEst){
    int i, best = 0;
    FTYPE dx = 0.0, dy = 0.0;
    FTYPE bestsim = -1.0e300;
    /* Extract Gabor Jet from image*/
    GaborJet njet = extractJet(*x, *y, novel, masks);

    /* Select the closest matching training jet */
    for(i = 0; i < bunch->size; i++){
        FTYPE sim;
        dx = 0.0; dy = 0.0;
        sim = dispEst( bunch->jets[i], njet, &dx, &dy);

        if(sim > bestsim){
            bestsim = sim;
            best = i;
        }
    }

    /* Compute the new x and y */
    dispEst( bunch->jets[best], njet, &dx, &dy);
    
    *x += dx;
    *y += dy;

    /* Free the jet */
    freeGaborJet( njet );
}

void permuteArray(int arr[], int size){
    int i;
    for(i = 0; i < size*2; i++){
        int x = rand()%size;
        int y = rand()%size;
        int tmp = arr[x];
        arr[x] = arr[y];
        arr[y] = tmp;
    }
}
void locateNovelFeatures(ImageList* novelImages, GraphDiscription graphTemplate, GraphDiscription bunchGraph, JetMasks masks, char* imageDir, char* outputDir, JetDisplacementEstimator dispEst){
    ImageList *subject, *replicate;
    int i;

    for(subject = novelImages; subject != NULL; subject = subject->next_subject){
        for(replicate = subject; replicate != NULL; replicate = replicate->next_replicate){
            Image novel = readRawImage(makePath(imageDir,replicate->filename));
            int *verts = (int*)malloc(sizeof(int)*bunchGraph->numVert);
            printf("Fitting graph for image: %s |", replicate->filename); fflush(stdout);
            for(i = 0; i < bunchGraph->numVert; i++){
                printf("#"); fflush(stdout);
                guessVertexLocation(i, i, graphTemplate, bunchGraph);

                graphTemplate->verts[i].x = graphTemplate->verts[i].x;
                graphTemplate->verts[i].y = graphTemplate->verts[i].y;

                LocatePoint( &(graphTemplate->verts[i].x),  &(graphTemplate->verts[i].y), bunchGraph->bunch[i], novel, masks, dispEst);
                verts[i] = i;
            }
            printf("|\n"); fflush(stdout);

            permuteArray(verts, bunchGraph->numVert);
            freeImage(novel);
            saveGraphDiscription(makePath(outputDir,replicate->filename),graphTemplate);
        }
    }
}


int main(int argc, char** argv){
    GraphDiscription modelJets, bunchGraph, graphTemplate;
    ImageList *modelImages, *novelImages;
    JetMasks masks;
    Arguments args;

    srand(time(NULL));

    processCommand(argc, argv, &args);

    /* build masks */
    masks = readMasksFile(args.masksFile);
    modelImages = getImageNames(args.modelFile, NULL);
    novelImages = getImageNames(args.novelFile, NULL);
    graphTemplate = readGraphDiscription(makePath(args.graphDir,modelImages->filename));

    /* extract model jets */
    modelJets = extractModelJets(modelImages, args.imageDir, args.graphDir, masks);

    /* build jet bunch */
    /* bunchGraph = buildBunchGraph(modelJets, args.distance, args.bunchSize); */
    bunchGraph = modelJets;

    /* locate features in novel image */
    locateNovelFeatures(novelImages, graphTemplate, bunchGraph, masks, args.imageDir, args.outputDir, args.dispEst);

    return 0;
}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMGrid.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>
#include <csuEBGMUtil.h>


#define  GRID_START_X 4
#define  GRID_START_Y 9
#define  GRID_SPACE_X 5
#define  GRID_SPACE_Y 5

typedef struct {
    char* inputDir;
    char* sfiDir;
    char* pgmDir;

    char* imageList;

    char* maskFile;

    int saveMasks;

    int gridStartX;
    int gridStartY;
    int gridSpaceX;
    int gridSpaceY;
}
Arguments;

/*
 * usage
 *
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name){
    printf("Usage: %s [OPTIONS] input_dir imagelist output_dir mask_file\n",name);
    printf("  Computes Gabor Jets at a regular interval and outputs the values in sfi format\n");
    printf("  OPTIONS:\n");
    printf("    -gridStart x y          - Choose start location for the grid.\n");
    printf("                              Defaults to %d, %d \n", GRID_START_X, GRID_START_Y);
    printf("    -gridSpace x y          - Choose x and y spacing for the grid.\n");
    printf("                              Defaults to %d, %d \n", GRID_SPACE_X, GRID_SPACE_Y);
    printf("  OTHER OPTIONS:\n");
    printf("    -quiet                  - Turns off all messages.\n");
    printf("    -debuglevel <int>       - Turns turns on debuging output.\n");
    exit(1);
}


void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    args->imageList      = NULL;
    args->maskFile       = NULL;
    args->inputDir       = NULL;
    args->sfiDir         = NULL;
    
    args->gridStartX     = GRID_START_X;
    args->gridStartY     = GRID_START_Y;
    args->gridSpaceX     = GRID_SPACE_X;
    args->gridSpaceY     = GRID_SPACE_Y;

    args->saveMasks      = 1;

    quiet = 0;
    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        /* size parameters */
        else if (readOptionInt2(argc, argv, &i, "-gridStart",&(args->gridStartX),&(args->gridStartY))) { }
        else if (readOptionInt2(argc, argv, &i, "-gridSpace",&(args->gridSpaceX),&(args->gridSpaceY))) { }

        /* other flags */
        else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
        else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */
        else if (param_num == 0) {
            args->inputDir = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->imageList = argv[i];
            param_num++;
        }
        else if (param_num == 2) {
            args->sfiDir = argv[i];
            param_num++;
        }
        else if (param_num == 3) {
            args->maskFile = argv[i];
            param_num++;
        }
        else{ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    }

    /* make sure that there are the proper number of required arguments */
    if (param_num != 4){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    /* Print out the program parameters for appropreate debug level */

    DEBUG(1,"Debuging enabled");
}

void convertImages(Arguments* args){
    FILE* list;
    JetMasks masks;
    int x, y,i,j;
    char imagename[MAX_FILENAME_LENGTH];
    char filename[MAX_FILENAME_LENGTH];
    
    MESSAGE("Creating gabor masks.");
    masks = readMasksFile(args->maskFile);

    if(args->saveMasks){
        for(y = 0; y < masks->size; y++){
            char outname[MAX_FILENAME_LENGTH];
            sprintf(outname, "mask%03d.pgm",y);
            writePGMImage(masks->masks[y],outname,0);
        }
    }

       
    list = fopen(args->imageList,"r");
    if(!list){
        printf("Error opening file: %s\n", args->imageList);
        exit(1);
    }

    while(fscanf(list, "%s", imagename) == 1){
        Image im;
        Image grid;
        
        sprintf(filename, "%s/%s", args->inputDir, imagename);
        im = readRawImage(filename);
        MESSAGE1ARG("Processing file: %s",filename);

        /* Find the number of points in the grid */
        
        i = 0;
        for( x = args->gridStartX; x < im->width; x += args->gridSpaceX){
            for( y = args->gridStartY; y < im->height; y+= args->gridSpaceY){
                i++;
            }
        }
        
        grid = makeImage(i,masks->size,1);

        /* Compute convolutions */
        i = 0;
        for( x = args->gridStartX; x < im->width; x += args->gridSpaceX){
            for( y = args->gridStartY; y < im->height; y+= args->gridSpaceY){
                for(j = 0; j < masks->size; j++){
                    if( i < grid->width )
                        IE(grid,i,j,0) = convolvePoint(x, y, 0, im, masks->masks[j]);
                }
                i++;
            }
            
        }

        sprintf(filename, "%s/%s", args->sfiDir, imagename);
        writeRawImage(grid,filename);

        freeImage(grid);
        freeImage(im);

    }

    
    fclose(list);
   
}

int main(int argc, char** argv){
    Arguments args;

    processCommand(argc, argv, &args);

    convertImages(&args);

    return 0;
}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMLocalization.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>
#include <csuEBGMUtil.h>
#include <csuEBGMSimilarity.h>

#define NUM_MEASURES 7
#define NUM_DISPLACE 4

struct {
    char* expSpec;
    char* imageDir;
    char* graphDir;
    char* outputDir;
    char* maskFile;

    JetSimilarityMeasure* measures;
    JetDisplacementEstimator* estimators;
    char** simLabels;
    char** disLabels;

    JetMasks masks;
} globals;



void usage(const char* progname){
    printf("usage: %s Experimentspecification gaborimagedir graph_directory output_directory maskfile\n", progname);
    exit(1);
}



void process_command(int argc, char** argv) {
    int i;
    int param_num;

    param_num = 0;

    if (argc < 3)
        usage(argv[0]);
    for (i = 0; i < argc; i++) {
        if (strcmp(argv[i], "-help") == 0) { usage(argv[0]); exit(1); }
    }


    quiet = 0;
    debuglevel = 0;

    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-debuglevel") == 0) {
            DEBUG_CHECK(++i < argc, "Bad parameter list");
            debuglevel = atoi(argv[i]);
        } else if (strcmp(argv[i], "-quiet") == 0) {
            quiet = 1;
        } else if (argv[i][0] == '-') {
            printf("Unknown option: %s\n", argv[i]);
            usage(argv[0]);
        } else if (param_num == 0) {
            globals.expSpec = argv[i];
            param_num++;
        } else if (param_num == 1) {
            globals.imageDir = argv[i];
            param_num++;
        } else if (param_num == 2) {
            globals.graphDir = argv[i];
            param_num++;
        } else if (param_num == 3) {
            globals.outputDir = argv[i];
            param_num++;
        } else if (param_num == 4) {
            globals.maskFile = argv[i];
            param_num++;
        } else {
            printf("Unknown parameter: %s\n", argv[i]);
            usage(argv[0]);
        }
    }

    if (param_num != 5)
        usage(argv[0]);
}


void printHtmlHeader(FILE* rFile){
    time_t t = time(0);
    fprintf(rFile,"<HTML>\n<HEAD>\n<TITLE>");
    fprintf(rFile,"Gabor Localization Study");
    fprintf(rFile,"</TITLE>\n</HEAD>\n<BODY>\n");
    fprintf(rFile,"<H1><CENTER>Gabor Localization Study</CENTER></H1>\n");
    fprintf(rFile,"<CENTER>Date: %s</CENTER><br>\n",ctime(&t));
    fprintf(rFile,"<CENTER>Masks: %s</CENTER><br>\n",globals.maskFile);
    fprintf(rFile,"<p>These are the results of the gabor localization study. \n"
                  "The purpose of this file is to study the ability of gabor \n"
                  "jets to localized points on a face.  The images shown here \n"
                  "are created by measuring the similarity of jets from each \n"
                  "point in the image to the a selected jet.\n"
                  "\n"
                  "<p>Idealy the images should show a good basin of attraction\n"
                  "around the correctly matched points.  This study is investigates\n"
                  "different facal features and similarity measures.\n<p>\n"
    );
    fflush(rFile);
}

void printExp1Header(FILE* rFile){
    fprintf(rFile,"<HR><H2>Experiment 1: Show the similarity for jets taken from the same image.</H2>\n");
    fprintf(rFile,"<p>This experiment shows the results when a jet is taken from \n"
                  "the same image that is used for testing.  For this reason the\n"
                  "correct match should always be found.\n<p>\n"
    );
    fflush(rFile);
}

void printExp2Header(FILE* rFile){
    fprintf(rFile,"<HR><H2>Experiment 2: Show the similarity for jets taken from the same subject but different images.</H2>\n");
    fprintf(rFile,"<p>This experiment shows the results when a jet is taken from \n"
                  "the same subject that is used for testing, however the jets are\n"
                  "taken from different images.  This experiment will hopfully show\n"
                  "that jets taken from the same subject are similar enough to find\n"
                  "the same point for an unseen image of the same person.<p>\n"
    );
    fflush(rFile);
}


void printExp3Header(FILE* rFile){
    fprintf(rFile,"<HR><H2>Experiment 3: Show the similarity jets across subjects.</H2>\n");
    fprintf(rFile,"<p>This experiment shows the results when a jet is taken from one \n"
                  "is compared to a jet taken from another subject.  This experiment \n"
                  "will show how well the Jets can localize points for subjects it has\n"
                  "never seen before.<p>\n"
    );
    fflush(rFile);
}

void printHtmlFooter(FILE* rFile){
    fprintf(rFile,"</BODY>\n</HTML>\n");
    fflush(rFile);
}


/* Save a color image into a specific format of file */
void saveColorImage(char *filename, Image im){
    char* command = (char*)malloc(sizeof(char)*4096);
    char* ppmname = (char*)malloc(sizeof(char)*4096);

    assert(im->channels == 3);

    /* Save image to a ppm file */
    sprintf(ppmname,"%s.ppm",filename);
    writePPMImage(im,ppmname);

    /* Let convert figure out how to save the file in the requested format */
    sprintf(command,"convert %s %s", ppmname, filename);
    system(command);

    /* remove the ppm file leaving only the requested image */
    sprintf(command,"rm %s", ppmname);
    system(command);

    free(command);
    free(ppmname);
}


/* Save a gray image into a specific format of file */
void saveBWImage(char *filename, Image im){
    char* command = (char*)malloc(sizeof(char)*4096);
    char* pgmname = (char*)malloc(sizeof(char)*4096);

    assert(im->channels == 1);

    /* Save image to a pgm file */
    sprintf(pgmname,"%s.pgm",filename);
    writePGMImage(im,pgmname,0);

    /* Let convert figure out how to save the file in the requested format */
    sprintf(command,"convert %s %s", pgmname, filename);
    system(command);

    /* remove the ppm file leaving only the requested image */
    sprintf(command,"rm %s", pgmname);
    system(command);

    free(command);
    free(pgmname);
}


/* Save a gray image into a specific format of file */
void saveThermalImage(char *filename, Image im){
    char* command = (char*)malloc(sizeof(char)*4096);
    char* ppmname = (char*)malloc(sizeof(char)*4096);
    Image therm = makeThermalColorImage(im);

    assert(im->channels == 1);

    /* Save image to a pgm file */
    sprintf(ppmname,"%s.ppm",filename);
    writePPMImage(therm,ppmname);

    /* Let convert figure out how to save the file in the requested format */
    sprintf(command,"convert %s %s", ppmname, filename);
    system(command);

    /* remove the ppm file leaving only the requested image */
    sprintf(command,"rm %s", ppmname);
    system(command);

    free(command);
    free(ppmname);
    freeImage(therm);
}

/* Save a gray image into a specific format of file */
void saveThermalImageMark(char *filename, Image im, FTYPE x, FTYPE y){
    char* command = (char*)malloc(sizeof(char)*4096);
    char* ppmname = (char*)malloc(sizeof(char)*4096);
    Image therm = makeThermalColorImage(im);

    assert(im->channels == 1);
    
    markPoint(therm,x,y);

    /* Save image to a pgm file */
    sprintf(ppmname,"%s.ppm",filename);
    writePPMImage(therm,ppmname);

    /* Let convert figure out how to save the file in the requested format */
    sprintf(command,"convert %s %s", ppmname, filename);
    system(command);

    /* remove the ppm file leaving only the requested image */
    sprintf(command,"rm %s", ppmname);
    system(command);

    free(command);
    free(ppmname);
    freeImage(therm);
}





void plotHist(char* filename, char* distMes, int* counts, int maxIndex){
    int i;
    FILE* histfile = fopen(makePath(globals.outputDir,"tmp.dat"),"w");
    FILE* gnuplot  = popen("gnuplot","w");

    printf("Outputing histogram: %s\n",filename);
    assert(gnuplot);
    assert(histfile);
    for(i = 0; i < 25; i++){
        fprintf(histfile,"%d %d\n",i, i < maxIndex ? counts[i] : 0);
    }
    fclose(histfile);

    fprintf(gnuplot,"set xlabel \'Distance\'\n");
    fprintf(gnuplot,"set ylabel \'Count\'\n");
    fprintf(gnuplot,"set xtics 5\n");
    fprintf(gnuplot,"set term png color\n");
    fprintf(gnuplot,"set output \'%s\'\n",makePath(globals.outputDir,filename));
    fprintf(gnuplot,"set title \'%s Distances\'\n",distMes);
    fprintf(gnuplot,"show title\n");
    fprintf(gnuplot,"plot [0:25] \'%s\' with steps\n",makePath(globals.outputDir,"tmp.dat"));
    fclose(gnuplot);
}



void plotVectorFieldPNG(char* filename, char* title, Image displacementImage, int expNum, FTYPE x, FTYPE y){
    int i,j;
    FILE* gnuplot  = popen("gnuplot","w");

    printf("Outputing Vector Field: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'X Displacement\'\n");
    fprintf(gnuplot,"set ylabel \'Y Displacement\'\n");
    fprintf(gnuplot,"set xtics 5\n");
    fprintf(gnuplot,"set term png color\n");
/* fprintf(gnuplot,"set size square\n"); */
    fprintf(gnuplot,"set size .75,1.05\n");
    fprintf(gnuplot,"set size ratio -1\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
/*     fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     fprintf(gnuplot,"set notitle \n"); */
/*     fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [-8:8] [8:-8] \'-\' notitle with vector\n");
    for(j = 0; j < displacementImage->height; j++){
        for(i = 0; i < displacementImage->width; i++){
            fprintf(gnuplot,"%f %f %f %f\n",(double)i - x,(double)j-y,-ie(displacementImage,i,j,0),-ie(displacementImage,i,j,1));
        }
    }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}


void plotVectorFieldEPS(char* filename, char* title, Image displacementImage, int expNum, FTYPE x, FTYPE y){
    int i,j;
    FILE* gnuplot  = popen("gnuplot","w");

    printf("Outputing Vector Field: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'X Displacement\'\n");
    fprintf(gnuplot,"set ylabel \'Y Displacement\'\n");
    fprintf(gnuplot,"set xtics 5\n");
    fprintf(gnuplot,"set term postscript eps monochrome\n");
/*     //fprintf(gnuplot,"set size .5..5\n"); */
    fprintf(gnuplot,"set size 0.5,0.7\n");
    fprintf(gnuplot,"set size ratio -1\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
/*     //fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     //fprintf(gnuplot,"set notitle \n"); */
/*     //fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [-8:8] [8:-8] \'-\' notitle with vector\n");
    for(j = 0; j < displacementImage->height; j++){
        for(i = 0; i < displacementImage->width; i++){
            fprintf(gnuplot,"%f %f %f %f\n",(double)i - x,(double)j-y,-ie(displacementImage,i,j,0),-ie(displacementImage,i,j,1));
        }
    }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}



void plotDisplaceErrorPNG(char* filename, char* title, Image displacementImage, int expNum, FTYPE x, FTYPE y){
    int i,j;
    FILE* gnuplot  = popen("gnuplot","w");
    FTYPE aError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };
    FTYPE cError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };

    printf("Outputing histogram: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'Jet Distance\'\n");
    fprintf(gnuplot,"set ylabel \'Displacement Error\'\n");
    fprintf(gnuplot,"set xtics 2\n");
    fprintf(gnuplot,"set ytics 2\n");
/*     //fprintf(gnuplot,"set term postscript eps color\n"); */
    fprintf(gnuplot,"set term png color\n");
    fprintf(gnuplot,"set size .75,1.05\n");
    fprintf(gnuplot,"set size ratio -1\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
/*     //fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     //fprintf(gnuplot,"set notitle \n"); */
/*     //fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [0:12] [0:12] \'-\' notitle with points lt -1 pt 7 ps 0.2, \'-\' notitle with lines lt 1 lw 3\n");
/*     //for(point = 0; point < novelGraph->numVert; point++){ */
/*         //double x = novelGraph->verts[point].x; */
/*         //double y = novelGraph->verts[point].y; */
        for(j = 0; j < displacementImage->height; j++){
            for(i = 0; i < displacementImage->width; i++){
                double ptdist = sqrt(SQR(x-i) + SQR(y-j));
                double estx = i-ie(displacementImage,i,j,0);
                double esty = j-ie(displacementImage,i,j,1);
                double errordist = sqrt(SQR(estx - x) + SQR(esty - y));
                int index = ROUND(ptdist);

                fprintf(gnuplot,"%f %f\n",ptdist,errordist);

                if( index < 13){
                    aError[index] += errordist;
                    cError[index] += 1.0;
                }
            }
        }
/*     //} */

    fprintf(gnuplot,"e\n");
    for(i = 0; i < 13; i++){
        if(cError[i] != 0.0){
            fprintf(gnuplot,"%f %f\n", (FTYPE)i, aError[i]/cError[i]);
        } else {
/*             //fprintf(gnuplot,"%f 0.0\n", (FTYPE)i); */
        }
    }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}



void plotDisplaceErrorEPS(char* filename, char* title, Image displacementImage,int expNum, FTYPE x, FTYPE y){
    int i,j;
    FILE* gnuplot  = popen("gnuplot","w");
    FTYPE aError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };
    FTYPE cError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };

    printf("Outputing histogram: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'Jet Distance\'\n");
    fprintf(gnuplot,"set ylabel \'Displacement Error\'\n");
    fprintf(gnuplot,"set xtics 2\n");
    fprintf(gnuplot,"set ytics 2\n");
    fprintf(gnuplot,"set term postscript eps color \"Helvetica\" 10\n");
/*     //fprintf(gnuplot,"set term png color\n"); */
    fprintf(gnuplot,"set size 0.5,0.7\n");
    fprintf(gnuplot,"set size ratio -1\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
/*     //fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     //fprintf(gnuplot,"set notitle \n"); */
/*     //fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [0:12] [0:12] \'-\' notitle with points lt 9 pt 7 ps 0.2, \'-\' notitle with lines lt 1 lw 3\n");
/*     //for(point = 0; point < novelGraph->numVert; point++){ */
/*         //double x = novelGraph->verts[point].x; */
/*         //double y = novelGraph->verts[point].y; */
        for(j = 0; j < displacementImage->height; j++){
            for(i = 0; i < displacementImage->width; i++){
                double ptdist = sqrt(SQR(x-i) + SQR(y-j));
                double estx = i-ie(displacementImage,i,j,0);
                double esty = j-ie(displacementImage,i,j,1);
                double errordist = sqrt(SQR(estx - x) + SQR(esty - y));
                int index = ROUND(ptdist);

                fprintf(gnuplot,"%f %f\n",ptdist,errordist);

                if( index < 13){
                    aError[index] += errordist;
                    cError[index] += 1.0;
                }
            }
        }
/*     //} */

    fprintf(gnuplot,"e\n");
    for(i = 0; i < 13; i++){
        if(cError[i] != 0.0){
            fprintf(gnuplot,"%f %f\n", (FTYPE)i, aError[i]/cError[i]);
        } else {
/*             //fprintf(gnuplot,"%f 0.0\n", (FTYPE)i); */
        }
    }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}


void plotTotalDisplaceErrorPNG(char* filename, char* title, Image*  displacementImage, GraphDiscription novelGraph,int expNum){
    int i,j, point;
    FILE* gnuplot  = popen("gnuplot","w");
    FTYPE aError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };
    FTYPE cError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };

    printf("Outputing histogram: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'Jet Distance\'\n");
    fprintf(gnuplot,"set ylabel \'Displacement Error\'\n");
    fprintf(gnuplot,"set xtics 2\n");
    fprintf(gnuplot,"set ytics 2\n");
/*     //fprintf(gnuplot,"set term postscript eps color\n"); */
    fprintf(gnuplot,"set term png color\n");
    fprintf(gnuplot,"set size .75,1.05\n");
    fprintf(gnuplot,"set size ratio -1\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
/*     //fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     //fprintf(gnuplot,"set notitle \n"); */
/*     //fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [0:12] [0:12] \'-\' notitle with points lt -1 pt 7 ps 0.2, \'-\' notitle with lines lt 1 lw 3\n");
    for(point = 0; point < novelGraph->numVert; point++){
        double x = novelGraph->verts[point].x;
        double y = novelGraph->verts[point].y;
        for(j = 0; j < displacementImage[point]->height; j++){
            for(i = 0; i < displacementImage[point]->width; i++){
                double ptdist = sqrt(SQR(x-i) + SQR(y-j));
                double estx = i-ie(displacementImage[point],i,j,0);
                double esty = j-ie(displacementImage[point],i,j,1);
                double errordist = sqrt(SQR(estx - x) + SQR(esty - y));
                int index = ROUND(ptdist);

                fprintf(gnuplot,"%f %f\n",ptdist,errordist);

                if( index < 13){
                    aError[index] += errordist;
                    cError[index] += 1.0;
                }
            }
        }
    }

    fprintf(gnuplot,"e\n");
/*     //fprintf(gnuplot,"replot \'-\' notitle with lines\n"); */
    for(i = 0; i < 13; i++){
        if(cError[i] != 0.0){
            fprintf(gnuplot,"%f %f\n", (FTYPE)i, aError[i]/cError[i]);
        } else {
/*             //fprintf(gnuplot,"%f 0.0\n", (FTYPE)i); */
        }
     }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}



void plotTotalDisplaceErrorEPS(char* filename, char* title, Image*  displacementImage, GraphDiscription novelGraph,int expNum){
    int i,j, point;
    FILE* gnuplot  = popen("gnuplot","w");
    FTYPE aError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };
    FTYPE cError[13] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 , 0.0 };

    printf("Outputing histogram: %s\n",filename);
    assert(gnuplot);

    fprintf(gnuplot,"set xlabel \'Jet Distance\'\n");
    fprintf(gnuplot,"set ylabel \'Displacement Error\'\n");
    fprintf(gnuplot,"set xtics 2\n");
    fprintf(gnuplot,"set ytics 2\n");
    fprintf(gnuplot,"set term postscript eps color \"Helvetica\" 10\n");
/*     //fprintf(gnuplot,"set term png color\n"); */
    fprintf(gnuplot,"set size 0.5,0.5\n");
    fprintf(gnuplot,"set output \'%s\'\n",filename);
    fprintf(gnuplot,"set size 0.5,0.7\n");
    fprintf(gnuplot,"set size ratio -1\n");
/*     //fprintf(gnuplot,"set title \'%s\'\n",title); */
/*     //fprintf(gnuplot,"set notitle \n"); */
/*     //fprintf(gnuplot,"show title\n"); */
    fprintf(gnuplot,"plot [0:12] [0:12] \'-\' notitle with points lt 9 pt 7 ps 0.2, \'-\' notitle with lines lt 1 lw 3\n");
    for(point = 0; point < novelGraph->numVert; point++){
        double x = novelGraph->verts[point].x;
        double y = novelGraph->verts[point].y;
        for(j = 0; j < displacementImage[point]->height; j++){
            for(i = 0; i < displacementImage[point]->width; i++){
                double ptdist = sqrt(SQR(x-i) + SQR(y-j));
                double estx = i-ie(displacementImage[point],i,j,0);
                double esty = j-ie(displacementImage[point],i,j,1);
                double errordist = sqrt(SQR(estx - x) + SQR(esty - y));
                int index = ROUND(ptdist);

                fprintf(gnuplot,"%f %f\n",ptdist,errordist);

                if( index < 13){
                    aError[index] += errordist;
                    cError[index] += 1.0;
                }
            }
        }
    }

    fprintf(gnuplot,"e\n");
    for(i = 0; i < 13; i++){
        if(cError[i] != 0.0){
            fprintf(gnuplot,"%f %f\n", (FTYPE)i, aError[i]/cError[i]);
        } else {
/*             //fprintf(gnuplot,"%f 0.0\n", (FTYPE)i); */
        }
    }
    fprintf(gnuplot,"e\n");
    fprintf(gnuplot,"quit\n");
    fclose(gnuplot);
}




void ComputeSimilarityAndDisplacementImages(Image probe, GraphDiscription bunchGraph, Image** similarityImages, Image** displacementImages){
    int x, y;

    /* for each pixel in the new image */
    for(x = 0; x < probe->width; x++){
        for(y = 0; y < probe->height; y++){
            int point, mes, est, jet;

            /* extract a gabor jet */
            GaborJet probeJet = extractJet(x,y,probe,globals.masks);

            /* Compute all the nessesary similarity images */
            for(point = 0; point < bunchGraph->numVert; point++){
                for(mes = 0; mes < NUM_MEASURES; mes++){
                    assert(bunchGraph->bunch[point]->size > 0);
                    IE(similarityImages[mes][point],x,y,0) = globals.measures[mes](probeJet,bunchGraph->bunch[point]->jets[0]);
                    for(jet = 1; jet < bunchGraph->bunch[point]->size; jet++){
                        IE(similarityImages[mes][point],x,y,0) = MAX(IE(similarityImages[mes][point],x,y,0), globals.measures[mes](probeJet,bunchGraph->bunch[point]->jets[jet]) );
                    }
                }
            }

            /* Compute the displacement vector image */
            for(point = 0; point < bunchGraph->numVert; point++){
                for(est = 0; est < NUM_DISPLACE; est++){
                    double dx, dy, sim, bestsim;
                    assert(bunchGraph->bunch[point]->size > 0);

                    bestsim = sim = globals.estimators[est](probeJet,bunchGraph->bunch[point]->jets[0],&dx,&dy);
                    IE(displacementImages[est][point],x,y,0) = dx;
                    IE(displacementImages[est][point],x,y,1) = dy;
                    for(jet = 1; jet < bunchGraph->bunch[point]->size; jet++){
                        bestsim = sim = globals.estimators[est](probeJet,bunchGraph->bunch[point]->jets[jet],&dx,&dy);
                        if(sim > bestsim){
                            bestsim = sim;
                            IE(displacementImages[est][point],x,y,0) = dx;
                            IE(displacementImages[est][point],x,y,1) = dy;
                        }
                    }
                }
            }


            /* Free the Gabor jet */
            freeGaborJet(probeJet);

            /* Write out the progress */
            if((x*probe->height+y) % 20 == 0){
                writeProgress ("Computing Similarity and Displacement images", x*probe->height+y, probe->width*probe->height);
            }
        }
    }
}

void saveAngleAndDisplacement(Image** displacementImages, GraphDiscription bunchGraph,int expNum){
    int point,est,x,y;
    for(point = 0; point < bunchGraph->numVert; point++){
        for(est = 0; est < NUM_DISPLACE; est++){
            char imName[1024];
            Image angle = makeImage(displacementImages[est][point]->width, displacementImages[est][point]->height, 1);
            Image dist  = makeImage(displacementImages[est][point]->width, displacementImages[est][point]->height, 1);
            
            writeProgress ("Computing angle and distance images", est+point*NUM_DISPLACE, NUM_DISPLACE*bunchGraph->numVert);

            for(x = 0; x < angle->width; x++){
                for(y = 0; y < angle->height; y++){
                    FTYPE dx = bunchGraph->verts[point].x - x;
                    FTYPE dy = bunchGraph->verts[point].y - y;
                    FTYPE dl = sqrt(dx*dx + dy*dy);
                    FTYPE ex = -IE(displacementImages[est][point],x,y,0);
                    FTYPE ey = -IE(displacementImages[est][point],x,y,1);
                    FTYPE el = sqrt(ex*ex + ey*ey);
                    FTYPE l = dl*el;
                    FTYPE distx = bunchGraph->verts[point].x - (x + ex);
                    FTYPE disty = bunchGraph->verts[point].y - (y + ey);
                    FTYPE distt = sqrt(distx*distx + disty*disty);
                    IE(angle,x,y,0) = (dx*ex+dy*ey)/l;
                    IE(dist,x,y,0) = -distt < -16.0 ? -16.0 : -distt;
                }
            }
            /* make sure that the value scale is correct */
            IE(angle,0,0,0) = -1.0;
            IE(angle,1,0,0) = 1.0;
            IE(dist,0,0,0) = -16.0 ;
            IE(dist,1,0,0) = 0.0 ;
            
            /* save out images */
            sprintf(imName, "%s/exp%03d_%s_%s_ang.png", globals.outputDir, expNum, globals.disLabels[est], bunchGraph->vertLabels[point]);
            saveThermalImageMark(imName,angle,
                    bunchGraph->verts[point].x,bunchGraph->verts[point].y);

            sprintf(imName, "%s/exp%03d_%s_%s_angbw.png", globals.outputDir, expNum, globals.disLabels[est], bunchGraph->vertLabels[point]);
            saveBWImage(imName,angle);

            
            sprintf(imName, "%s/exp%03d_%s_%s_dist.png", globals.outputDir, expNum, globals.disLabels[est], bunchGraph->vertLabels[point]);
            saveThermalImageMark(imName,dist,
                    bunchGraph->verts[point].x,bunchGraph->verts[point].y);

            sprintf(imName, "%s/exp%03d_%s_%s_distbw.png", globals.outputDir, expNum, globals.disLabels[est], bunchGraph->vertLabels[point]);
            saveBWImage(imName,dist);

            freeImage(angle);
            freeImage(dist);
        }
    }
}

void runImageLocalizationExperiement(ImageList* line){
    Image novelImage;
    GraphDiscription novelGraph;
    ImageList* model;
    int i,mes,est,point;
    Image** similarityImages;
    Image** displacementImages;
    static int expNum = 0;

    printf("Running experiment for image %s\n",line->filename);
    /* read in the "novel" image */
    novelImage = readRawImage(makePath(globals.imageDir,line->filename));

    /* read in GraphDiscription for the novel image (first image in the line) */
    novelGraph = readGraphDiscription(makePath(globals.graphDir,line->filename));

    novelGraph->numVert = 17;
    /* for each of the rest of the images read them in and form the bunch graph. */
    for(model = line->next_replicate; model != NULL; model = model->next_replicate){
        Image mi = readRawImage(makePath(globals.imageDir,model->filename));
        GraphDiscription mg = readGraphDiscription(makePath(globals.graphDir,model->filename));
        for(i = 0; i < novelGraph->numVert; i++){
            GaborJet modelJet = extractJet(mg->verts[i].x,mg->verts[i].y,mi,globals.masks);
            printf("\rBuilding bunch graph from image %s (%d)    ",model->filename, i); fflush(stdout);
            addJetToBunch(novelGraph->bunch[i], modelJet);
        }
        freeImage(mi);
        freeGraphDiscription(mg);
    }
    printf("\n");

    /* Compute the similarity and displacement images */
    printf("Computing similarity and displacement images\n");

    similarityImages = malloc(sizeof(Image*)*NUM_MEASURES);
    for(mes = 0; mes < NUM_MEASURES; mes++){
        similarityImages[mes] = malloc(sizeof(Image)*novelGraph->numVert);
        for(point = 0; point < novelGraph->numVert; point++){
            similarityImages[mes][point] = duplicateImage(novelImage);
        }
    }

    displacementImages = malloc(sizeof(Image*)*NUM_DISPLACE);
    for(est = 0; est < NUM_DISPLACE; est++){
        displacementImages[est] = malloc(sizeof(Image)*novelGraph->numVert);
        for(point = 0; point < novelGraph->numVert; point++){
            displacementImages[est][point] = makeImage(novelImage->width,novelImage->height,2);
        }
    }

    ComputeSimilarityAndDisplacementImages(novelImage, novelGraph, similarityImages, displacementImages);

    /* save the similarity images */
    for(mes = 0; mes < NUM_MEASURES; mes++){
        for(point = 0; point < novelGraph->numVert; point++){
            char imName[1024];
            sprintf(imName, "%s/exp%03d_%s_%s_th.png", globals.outputDir, expNum, globals.simLabels[mes], novelGraph->vertLabels[point]);
            saveThermalImageMark(imName,similarityImages[mes][point],novelGraph->verts[point].x,novelGraph->verts[point].y);
            sprintf(imName, "%s/exp%03d_%s_%s_bw.png", globals.outputDir, expNum, globals.simLabels[mes], novelGraph->vertLabels[point]);
            saveBWImage(imName,similarityImages[mes][point]);
        }
    }

    /* compute the angle and negtive distance image */
    saveAngleAndDisplacement(displacementImages,novelGraph,expNum);

    /* plot the local vector field */
    for(est = 0; est < NUM_DISPLACE; est++){
        char imName[1024];
        for(point = 0; point < novelGraph->numVert; point++){
            sprintf(imName, "%s/exp%03d_%s_%s_vector.png", globals.outputDir, expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            plotVectorFieldPNG(imName, "Estimated Displacement Vector Field", displacementImages[est][point], expNum, novelGraph->verts[point].x, novelGraph->verts[point].y);
            sprintf(imName, "%s/exp%03d_%s_%s_vector.eps", globals.outputDir, expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            plotVectorFieldEPS(imName, "Estimated Displacement Vector Field", displacementImages[est][point], expNum, novelGraph->verts[point].x, novelGraph->verts[point].y);
            sprintf(imName, "%s/exp%03d_%s_%s_error.png", globals.outputDir, expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            plotDisplaceErrorPNG(imName, "Estimated Displacement Vector Field", displacementImages[est][point], expNum, novelGraph->verts[point].x, novelGraph->verts[point].y);
            sprintf(imName, "%s/exp%03d_%s_%s_error.eps", globals.outputDir, expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            plotDisplaceErrorEPS(imName, "Estimated Displacement Vector Field", displacementImages[est][point], expNum, novelGraph->verts[point].x, novelGraph->verts[point].y);
        }
        sprintf(imName, "%s/01exp%03d_%s_Total_error.png", globals.outputDir, expNum, globals.disLabels[est]);
        plotTotalDisplaceErrorPNG(imName, "Estimated Displacement Vector Field", displacementImages[est], novelGraph,expNum);
        sprintf(imName, "%s/01exp%03d_%s_Total_error.eps", globals.outputDir, expNum, globals.disLabels[est]);
        plotTotalDisplaceErrorEPS(imName, "Estimated Displacement Vector Field", displacementImages[est], novelGraph,expNum);
    }

    /* Output the web pages source for this experiment */
    for(point = 0; point < novelGraph->numVert; point++){
        char htmlName[1024];
        FILE* expfile;
        time_t t = time(0);
        sprintf(htmlName, "%s/00exp%03d_%s.html", globals.outputDir, expNum, novelGraph->vertLabels[point]);
        expfile = fopen(htmlName,"w");
        
        fprintf(expfile,"<HTML><HEAD><TITLE>Experiment %d: %s</TITLE></HEAD>\n<BODY>\n",expNum,novelGraph->vertLabels[point]);
        fprintf(expfile,"<H1>Experiment %d: %s</H1><BR>\n",expNum,novelGraph->vertLabels[point]);
        fprintf(expfile,"<H2>Date: %s</H1><BR>\n",ctime(&t));

        fprintf(expfile,"<HR><H3>Jet Similarity Measures</H3><BR>\n");
        fprintf(expfile,"<TABLE BORDER=2>\n");
        fprintf(expfile,"<TR>\n");
        for(mes = 0; mes < NUM_MEASURES; mes++){
            fprintf(expfile,"<TH>%s</TH>\n",globals.simLabels[mes]);
        }
        fprintf(expfile,"</TR>\n");

        fprintf(expfile,"<TR>\n");
        for(mes = 0; mes < NUM_MEASURES; mes++){
            char imName[1024];
            sprintf(imName, "exp%03d_%s_%s_bw.png", expNum, globals.simLabels[mes], novelGraph->vertLabels[point]);
            fprintf(expfile,"<TD><IMG SRC=\"%s\" WIDTH=%d HEIGHT=%d ></TD>\n",imName,novelImage->width*2, novelImage->height*2);
        }
        fprintf(expfile,"</TR><TR>\n");
        for(mes = 0; mes < NUM_MEASURES; mes++){
            char imName[1024];
            sprintf(imName, "exp%03d_%s_%s_th.png", expNum, globals.simLabels[mes], novelGraph->vertLabels[point]);
            fprintf(expfile,"<TD><IMG SRC=\"%s\" WIDTH=%d HEIGHT=%d ></TD>\n",imName,novelImage->width*2, novelImage->height*2);
        }
        fprintf(expfile,"</TR></TABLE>\n");

        
        fprintf(expfile,"<HR><H3>Jet Displacement</H3><BR>\n");
        fprintf(expfile,"<TABLE BORDER=2>\n");
        fprintf(expfile,"<TR>\n");
        for(est = 0; est < NUM_DISPLACE; est++){
            fprintf(expfile,"<TH>%s</TH>\n",globals.disLabels[est]);
        }
        fprintf(expfile,"</TR>\n");

        fprintf(expfile,"<TR>\n");
        for(est = 0; est < NUM_DISPLACE; est++){
            char imName[1024];
            fprintf(expfile,"<TD>");
            sprintf(imName, "exp%03d_%s_%s_ang.png", expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            fprintf(expfile,"<IMG SRC=\"%s\" WIDTH=%d HEIGHT=%d ><BR>",imName,novelImage->width*2, novelImage->height*2);
            sprintf(imName, "exp%03d_%s_%s_dist.png", expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            fprintf(expfile,"<IMG SRC=\"%s\" WIDTH=%d HEIGHT=%d ><BR>",imName,novelImage->width*2, novelImage->height*2);
            sprintf(imName, "exp%03d_%s_%s_vector.png", expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            fprintf(expfile,"<IMG SRC=\"%s\"><BR>",imName);
            sprintf(imName, "exp%03d_%s_%s_error.png", expNum, globals.disLabels[est], novelGraph->vertLabels[point]);
            fprintf(expfile,"<IMG SRC=\"%s\"><BR>",imName);
            fprintf(expfile,"</TD>\n");
        }
        fprintf(expfile,"</TR></TABLE>\n");
        fprintf(expfile,"</BODY></HTML>\n");
        fclose(expfile);
    }

    /* Add this experiment to the final web page list */

    /* Free image memory */
    
    freeGraphDiscription(novelGraph);
    freeImage(novelImage);
    expNum++;

}


int main(int argc,char** argv){
    ImageList* expList;
    ImageList* line;
    JetSimilarityMeasure distanceMeasures[NUM_MEASURES] = {
      &JetSimilarityMag,
      &JetSimilarityPhase,
      &JetSimilarityDEPredictiveStep,
      &JetSimilarityDEPredictiveIter,
      &JetSimilarityDEFixedLocalSearch,
      &JetSimilarityDENarrowingLocalSearch,
      &JetSimilarityCorrelation,
    };

    JetDisplacementEstimator displacementEstimators[NUM_DISPLACE] = {
        &DEPredictiveStep,
        &DEPredictiveIter,
        &DEFixedLocalSearch,
        &DENarrowingLocalSearch,
    };

    char* simLabels[NUM_MEASURES] = {
      "JetSimilarityMag",
      "JetSimilarityPhase",
      "JetSimilarityDEPredictiveStep",
      "JetSimilarityDEPredictiveIter",
      "JetSimilarityDEFixedLocalSearch",
      "JetSimilarityDENarrowingLocalSearch",
      "JetSimilarityCorrelation",
    };

    char* disLabels[NUM_DISPLACE] = {
        "DEPredictiveStep",
        "DEPredictiveIter",
        "DEFixedLocalSearch",
        "DENarrowingLocalSearch",
    };

    process_command(argc,argv);
    
    /* Set up global variables */
    globals.measures = distanceMeasures;
    globals.estimators = displacementEstimators;
    globals.simLabels = simLabels;
    globals.disLabels = disLabels;

    globals.masks = readMasksFile(globals.maskFile);


    /* Read in experiment image list */
    expList = getImageNames(globals.expSpec, NULL);
    
    /* For each line in the imagelist file conduct an experiment */
    for( line = expList; line != NULL; line = line->next_subject){
        runImageLocalizationExperiement(line);
    };

    return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMMasks.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>
#include <csuEBGMUtil.h>


typedef struct {
    char* maskFile;
    char* outputDir;
}
Arguments;

/*
 * usage
 *
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name){
    printf("Usage: %s mask_file outputdir\n",name);
    exit(1);
}


void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */
        else if (param_num == 0) {
            args->maskFile = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->outputDir = argv[i];
            param_num++;
        }
        else{ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    }

    /* make sure that there are the proper number of required arguments */
    if (param_num != 2){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    /* Print out the program parameters for appropreate debug level */

    DEBUG(1,"Debuging enabled");
}

void outputMasks(Arguments* args){
    JetMasks masks;
    int y;

    MESSAGE("Creating gabor masks.");
    masks = readMasksFile(args->maskFile);

    MESSAGE("Saving Masks to files");
    for(y = 0; y < masks->size; y++){
        char outname[MAX_FILENAME_LENGTH];
        sprintf(outname, "%s/mask%03d.pgm", args->outputDir,y);
        writePGMImage(masks->masks[y],outname,0);
    }



}

int main(int argc, char** argv){
    Arguments args;

    processCommand(argc, argv, &args);

    outputMasks(&args);

    return 0;
}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMMeasure.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/* csuGaborGraphFit */
#include <stdio.h>
#include <stdlib.h>
#include <csuCommon.h>
#include <csuEBGMUtil.h>
#include <csuEBGMSimilarity.h>

/* Recursive block size to optimize cache in distance matrix calculations */
#define MAX_BLOCK_SIZE 8

time_t start_time;

typedef struct distDirNode {
    struct distDirNode *next;
    char* distDirectory;
    FaceGraphSimilarity distMeasure;
}
DistDirNode;


typedef struct {
    char* imageNamesFile;
    char* faceGraphDir;
    DistDirNode* distList;
    int argc;
    char **argv;
}
Arguments;



int completed = 0;
int total = 0;

/* Displays the useage information for this program and information about what the 
   program does. */
void usage( const char* name){
    printf("useage: %s imagelist.srt face_graph_dir dist_measure distance_dir\n\n",name);

    printf("**************************** DISCRIPTION ****************************\n");
    printf("* csuGaborMeasure                                                   *\n");
    printf("*                                                                   *\n");
    printf("* This program reads face graphs from a directory and computes the  *\n");
    printf("* similarity matrix between those graphs.  The matrix is saved to   *\n");
    printf("* the specified distance directory for use with the analysis tools. *\n");
    printf("*                                                                   *\n");
    printf("*********************************************************************\n");
    printf("\n");
    printf("Arguments:\n");
    printf("imagelist.srt  - This is the list of faces for which the image\n");
    printf("                 distances are computed.\n");
    printf("face_graph_dir - The directory that contains the face graphs,\n");
    printf("                 produced by csuGaborFaceGraph.\n");
    printf("dist_measure   - A label specifying the distance measure to be used\n");
    printf("distance_dir   - The output directory that will contain distance\n");
    printf("                 files that can be used by the csuAnalysis tools.\n");
    printf("\n");
    printf("Distance Measure is one of the following options:\n");
    printf("        FGMagnitude\n");
    printf("        FGPhase\n");
    printf("        FGGridSample\n");
    printf("        FGPredictiveStep\n");
    printf("        FGPredictiveIter\n");
    printf("        FGFixedLocalSearch\n");
    printf("        FGNarrowingLocalSearch\n");
    printf("        GeoSimL2\n");
    printf("        GeoSimCorrelation\n");
    printf("        GeoSimLeastSquares\n");
    printf("        GeoSimLeastSquaresPS\n");
    printf("        GeoSimLeastSquaresPI\n");
    printf("        GeoSimLeastSquaresFLS\n");
    printf("        GeoSimLeastSquaresNLS\n");
    printf("\n");
    exit(1);
}
  
        
        
void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    /******* Set up default values *******/

    args->argv         	 = argv;
    args->argc         	 = argc;
    args->imageNamesFile = NULL;
    args->faceGraphDir   = NULL;
    args->distList       = NULL;

    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        /* other flags */
        else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
        else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */
        else if (param_num == 0) {
            args->imageNamesFile = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->faceGraphDir = argv[i];
            param_num++;
        }
        else if (param_num > 1) {
            DistDirNode* tmp = (DistDirNode*) malloc(sizeof(DistDirNode));
            tmp->next = args->distList;
            if      ( strcasecmp(argv[i], "FGMagnitude") == 0 )           { tmp->distMeasure = fgSimMagnitude; }
            else if ( strcasecmp(argv[i], "FGPhase") == 0 )               { tmp->distMeasure = fgSimPhase; }
            else if ( strcasecmp(argv[i], "FGGridSample") == 0 )          { tmp->distMeasure = fgSimPhaseGridSample; }
            else if ( strcasecmp(argv[i], "FGPredictiveStep") == 0 )      { tmp->distMeasure = fgSimPhasePredictiveStep; }
            else if ( strcasecmp(argv[i], "FGPredictiveIter") == 0 )      { tmp->distMeasure = fgSimPhasePredictiveIter; }
            else if ( strcasecmp(argv[i], "FGFixedLocalSearch") == 0 )    { tmp->distMeasure = fgSimPhaseFixedLocalSearch; }
            else if ( strcasecmp(argv[i], "FGNarrowingLocalSearch") == 0 ){ tmp->distMeasure = fgSimPhaseNarrowingLocalSearch; }
            else if ( strcasecmp(argv[i], "GeoSimL2") == 0 )              { tmp->distMeasure = GeometrySimL2; }
            else if ( strcasecmp(argv[i], "GeoSimCorrelation") == 0 )     { tmp->distMeasure = GeometrySimCorrelation; }
            else if ( strcasecmp(argv[i], "GeoSimLeastSquares") == 0 )    { tmp->distMeasure = GeometrySimLeastSquares; }
            else if ( strcasecmp(argv[i], "GeoSimLeastSquaresPS") == 0 )  { tmp->distMeasure = GeometrySimLeastSquaresPS; }
            else if ( strcasecmp(argv[i], "GeoSimLeastSquaresPI") == 0 )  { tmp->distMeasure = GeometrySimLeastSquaresPI; }
            else if ( strcasecmp(argv[i], "GeoSimLeastSquaresFLS") == 0 ) { tmp->distMeasure = GeometrySimLeastSquaresFLS; }
            else if ( strcasecmp(argv[i], "GeoSimLeastSquaresNLS") == 0 ) { tmp->distMeasure = GeometrySimLeastSquaresNLS; }
            else{ clParseError(argc,argv,i,"Unrecognized FaceGraph Similarity function"); }

            i++;
            DEBUG_CHECK( i < argc , "Distance directory expected at end of argument list.");
            tmp->distDirectory = strdup (argv[i]);
            args->distList = tmp;
            param_num++;
        }

    }

    /* make sure that there are the proper number of required arguments */
    if (param_num < 2){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    DEBUG(1,"Debuging enabled");
}



void NormalizeGeometry(FaceGraph f1){
    int i;
    FTYPE sum1 = 0.0;
    FTYPE mean1 = 0.0;
    FTYPE len1 = 0.0;
    FTYPE sqsum1 = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) = (i%2) ? f1->jets[i/2]->y : f1->jets[i/2]->x ;
    }

    for (i = 0; i < g1->row_dim; i++) {
        sum1 += ME(g1,i,0);
    }

    mean1 = sum1 / g1->row_dim;

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) -= mean1;
        sqsum1 += ME(g1,i,0)*ME(g1,i,0);
    }

    len1 = 1.0/sqrt(sqsum1);

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) = ME(g1,i,0)*len1;
    }

    for (i = 0; i < f1->geosize; i++) {
        f1->jets[i]->x = ME(g1, 2*i  , 0);
        f1->jets[i]->y = ME(g1, 2*i+1, 0);
    }

    freeMatrix(g1);
}


void computeDistanceMatrix(Matrix distance, FaceGraph* graphs, int mini, int maxi, int minj, int maxj, FaceGraphSimilarity distMeasure){
    int i,j;
    static time_t current_time = 0;
    
    if( (maxi - mini > MAX_BLOCK_SIZE) || (maxi - mini > MAX_BLOCK_SIZE) ){
        int sizei = maxi - mini;
        int sizej = maxj - minj;
        computeDistanceMatrix(distance, graphs, mini, mini+sizei/2, minj, minj+sizej/2, distMeasure);
        computeDistanceMatrix(distance, graphs, mini+sizei/2, maxi, minj, minj+sizej/2, distMeasure);
        computeDistanceMatrix(distance, graphs, mini, mini+sizei/2, minj+sizej/2, maxj, distMeasure);
        computeDistanceMatrix(distance, graphs, mini+sizei/2, maxi, minj+sizej/2, maxj, distMeasure);
        if(current_time + 10 < time(NULL)) {
        	/* Estimate the remaining time and print status report */
            int hour, min, sec;
            double remaining_time;
            current_time = time(NULL);
            remaining_time = ((double)total - completed)*((double)current_time - start_time) / completed;
            hour = ((int)remaining_time)/3600;
            min = (((int)remaining_time)%3600)/60;
            sec = ((int)remaining_time)%60;
            printf("Measuring: %010d of %010d  (%5.2f%%)  ETR = %02dh %02dm %02ds\r",completed, total, completed*100.0/total, hour, min, sec);
            fflush(stdout);
        }
        return;
    }

    for(i = mini; i < maxi; i++){
        for(j = minj; j < maxj; j++){
            ME(distance,i,j) = distMeasure(graphs[i], graphs[j]);
            completed++;
        }
    }

}


int main(int argc, char** argv){
    ImageList *imagenames, *subject, *replicate;
    int imageCount;
    Matrix distance;
    FaceGraph* graphs;
    char** names;
    int i, j;
    Arguments args;
    DistDirNode* distrec;
    
    processCommand(argc, argv, &args);
    
    MESSAGE("Reading in image names");
    imagenames = getImageNames(args.imageNamesFile, &imageCount);

    MESSAGE1ARG("Reading in graph files %d",imageCount);

    /* Allocate space for imagenames, face graphs and distance matrix */
    names = ALLOCATE(char*,imageCount);
    graphs = ALLOCATE(FaceGraph, imageCount);
    distance = makeZeroMatrix(imageCount,imageCount);


    MESSAGE("Reading in graph files");
    i = 0;
    for(subject = imagenames; subject != NULL; subject = subject->next_subject){
        for( replicate = subject; replicate != NULL; replicate = replicate->next_replicate){
            printf("Reading in graph: %s\n", replicate->filename); fflush(stdout);
            names[i] = strdup(replicate->filename);
            graphs[i] = loadFaceGraph(makePath(args.faceGraphDir,replicate->filename));
            i++;
        }
    }

    for(distrec = args.distList; distrec != NULL; distrec = distrec->next){
        /* Create distance matrix */
        completed = 0;
        total = imageCount*imageCount;
        
        MESSAGE("Computing Distance Matrix");
        start_time = time(NULL);

        computeDistanceMatrix(distance, graphs, 0, imageCount, 0, imageCount, distrec->distMeasure);

        /* Print out distance files to the distance directory */
        for(i = 0; i < imageCount; i++){
            FILE* distfile = fopen(makePath(distrec->distDirectory,names[i]), "w");

            if(!distfile){
                printf("Error opening distance file: %s\n",makePath(distrec->distDirectory,names[i]));
                exit(1);
            }

            printf("Saving distances for image: %s\n",names[i]); fflush(stdout);

            for(j = 0; j < imageCount; j++){
                fprintf(distfile,"%s\t%16e\n",names[j], ME(distance,i,j));
            }
            fclose(distfile);
        }
    }

    return 0;
}


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMSimilarity.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuEBGMSimilarity.h>
#include <csuEBGMUtil.h>

/********************** Compute the similarity between jets *****************/


/* Compute a phase invariant corrilation like similarity */
FTYPE JetSimilarityMag(GaborJet j1, GaborJet j2){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i;

    assert(j1 && j2 && j1->length && j1->length==j2->length);
    
    for(i = 0; i < j1->length; i++){
        j12 += j1->mag[i]*j2->mag[i];
        j11 += j1->mag[i]*j1->mag[i];
        j22 += j2->mag[i]*j2->mag[i];
    }

    return j12/sqrt(j11*j22);
}

/* Compute a similarity score as above only with a term
   added for the cos(Phase) */
FTYPE JetSimilarityPhase(GaborJet j1, GaborJet j2){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i;

    assert(j1 && j2 && j1->length && j1->length==j2->length);
    
    for(i = 0; i < j1->length; i++){
        j12 += j1->mag[i]*j2->mag[i]*cos(j1->ang[i] - j2->ang[i]);
        j11 += j1->mag[i]*j1->mag[i];
        j22 += j2->mag[i]*j2->mag[i];
    }

    return j12/sqrt(j11*j22);

}


FTYPE JetSimilarityDEGridSample(GaborJet j1, GaborJet j2){
    FTYPE dx = 0, dy = 0;
    return DEGridSample(j1, j2, &dx, &dy);
}

FTYPE JetSimilarityDEPredictiveStep(GaborJet j1, GaborJet j2){
    FTYPE dx = 0.0, dy = 0.0;
    return DEPredictiveStep(j1, j2, &dx, &dy);
}


FTYPE JetSimilarityDEPredictiveIter(GaborJet j1, GaborJet j2){
    FTYPE dx = 0.0, dy = 0.0;
    return DEPredictiveIter(j1, j2, &dx, &dy);
}


FTYPE SIM_DISPLACE(GaborJet j1, GaborJet  j2, FTYPE dx, FTYPE dy) {
    FTYPE j12 = 0.0;                                                    
    FTYPE j11 = 0.0;                                                    
    FTYPE j22 = 0.0;                                                    
    int i;                                                              
    for(i = 0; i < j1->length; i++){                                    
        j12 += j1->mag[i]*j2->mag[i]*                                   
	       cos(j1->ang[i] - j2->ang[i] -                            
	       (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));  
        j11 += j1->mag[i]*j1->mag[i];                                   
        j22 += j2->mag[i]*j2->mag[i];                                   
    }                                                                   
    return j12/sqrt(j11*j22);                                            
}                                  


/* Compute a similarity score as above only with phase
   using an exaustive estimated displacement to correct
   for phase  - similar to Auto Correlation (i.e. search
   a displacemet grid for peaks) */
FTYPE JetSimilarityDEFixedLocalSearch(GaborJet j1, GaborJet j2){
    FTYPE dx = 0.0, dy = 0.0;
    return DEFixedLocalSearch(j1, j2, &dx, &dy);
}


/* Compute a similarity score as above only with phase
   using a fast estimated displacement to correct for
   phase - similar to Wiscott*/
FTYPE JetSimilarityDENarrowingLocalSearch(GaborJet j1, GaborJet j2){
    FTYPE dx = 0, dy = 0;
    return DENarrowingLocalSearch(j1, j2, &dx, &dy);
}


/* Compute a similarity score based on the City Block
   distance measure */
FTYPE JetSimilarityCityBlock(GaborJet j1, GaborJet j2){
    FTYPE sim = 0;
    int i;

    assert(j1 && j2 && j1->length && j1->length==j2->length);

    for(i = 0; i < j1->length; i++){
        /* compute the negitive so that greater values are more simillar */
        sim -= ABS(j1->realPart[i]-j2->realPart[i]);
        sim -= ABS(j1->imagPart[i]-j2->imagPart[i]);
    }
    return sim;
}

/* Compute a similarity score based on the Correlation
   distance measure */
FTYPE JetSimilarityCorrelation(GaborJet j1, GaborJet j2){
    int i;

    double corrilation = 0.0;
    double j1mean = 0.0, j2mean = 0.0;
    double j1scale = 0.0, j2scale = 0.0;

    assert(j1 && j2 && j1->length && j1->length == j2->length);
    
    /* Pass one: compute the pixel mean. */
    for(i = 0; i < j1->length; i++){
        j1mean += j1->realPart[i];
        j1mean += j1->imagPart[i];
        j2mean += j2->realPart[i];
        j2mean += j2->imagPart[i];
    }

    j1mean = j1mean/(2*j1->length);
    j2mean = j2mean/(2*j1->length);

    /* Pass two: compute the unscaled corrilation value and the associated scale parameter. */
    for(i = 0; i < j1->length; i++){
        corrilation += (j1->realPart[i]-j1mean)*(j2->realPart[i]-j2mean);
        corrilation += (j1->imagPart[i]-j1mean)*(j2->imagPart[i]-j2mean);
        j1scale     += SQR(j1->realPart[i]-j1mean);
        j1scale     += SQR(j1->imagPart[i]-j1mean);
        j2scale     += SQR(j2->realPart[i]-j2mean);
        j2scale     += SQR(j2->imagPart[i]-j2mean);
    }

    corrilation = corrilation / (sqrt(j1scale)*sqrt(j2scale));

    return corrilation;

}

/* Compute a similarity score based on the Covariance
   distance measure */
FTYPE JetSimilarityCovariance(GaborJet j1, GaborJet j2){
    int i;
    FTYPE magi = 0.0,
          magj = 0.0,
          dot = 0.0;

    assert(j1 && j2 && j1->length && j1->length==j2->length);
    
    for (i = 0; i < j1->length; i++) {
        magi += SQR(j1->realPart[i]) + SQR(j1->imagPart[i]);
        magj += SQR(j2->realPart[i]) + SQR(j2->imagPart[i]);
        dot  += j1->realPart[i] * j2->realPart[i];
        dot  += j1->imagPart[i] * j2->imagPart[i];
    }
    return (dot / (sqrt(magi) * sqrt(magj)));
}


FTYPE JetSimilarityDisplacementCheckMag(GaborJet j1, GaborJet j2){
    FTYPE sim = 0.0;
    int i;

    for(i = 0; i < j1->length; i++){
        sim += exp(-0.1*SQR(j1->mag[i]-j2->mag[i]));
    }

    return sim;
}

FTYPE JetSimilarityDisplacementCheckPhase(GaborJet j1, GaborJet j2){
    FTYPE sim = 0.0;
    FTYPE dx = j1->x - j2->x;
    FTYPE dy = j1->y - j2->y;
    int i;

    for(i = 0; i < j1->length; i++){
        sim += cos(j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));
    }

    return sim;
}

FTYPE JetSimilarityResponseMag(GaborJet j1, GaborJet j2){
    FTYPE sim = 0.0;
    int i;

    for(i = 0; i < j1->length; i++){
        sim += j1->mag[i];
    }

    return sim;
}

FTYPE JetSimilarityResponsePhase(GaborJet j1, GaborJet j2){
    FTYPE sim = 0.0;
    int i;

    for(i = 0; i < j1->length; i++){
        sim += j1->ang[i];
    }

    return sim;
}

/*****************************************************************************
    Displacement estimators are used to find the displacement between two
    jets.  These functions optimize a similarity function for a displacement
    vector. For more info see DSB.
*****************************************************************************/


/* This displacement estimator uses the taylor expansion method. Wiskott 96 */
double estimateDisplacementRandom(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i;
    FTYPE sim = 0.0;
    FTYPE dx  = randBM(),
          dy  = randBM();

    assert(j1 &&  j1->length && j2 && j1->length==j2->length);

    /* Compute the similarity with the estimated displacement. */
    j12 = 0.0;
    j11 = 0.0;
    j22 = 0.0;
    for(i = 0; i < j1->length; i++){
        j12 += j1->mag[i]*j2->mag[i]*cos(j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));
        j11 += j1->mag[i]*j1->mag[i];
        j22 += j2->mag[i]*j2->mag[i];
    }
    sim = j12/sqrt(j11*j22);

    /* Return the proper values */
    *tdx = dx;
    *tdy = dy;

    return sim;
}



double DEGridSample(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i;
    int first = 1;
    FTYPE sim = 0.0;
    FTYPE dx, dy;

    assert(j1 && j1->length && j2 && j1->length==j2->length);
    for(dx = -16.0; dx < 16.0; dx += 0.5){
        for(dy = -16.0; dy < 16.0; dy += 0.5){
            j12 = 0.0;
            j11 = 0.0;
            j22 = 0.0;
            for(i = 0; i < j1->length; i++){
                j12 += j1->mag[i]*j2->mag[i]*cos(j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));
                j11 += j1->mag[i]*j1->mag[i];
                j22 += j2->mag[i]*j2->mag[i];
            }
            if(first || sim < j12/sqrt(j11*j22)){
                sim = j12/sqrt(j11*j22);
                *tdx = dx;
                *tdy = dy;
                first = 0;
            }
        }
    }
    return sim;
}





double DEPredictiveStep(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i;
    FTYPE sim = 0.0;
    FTYPE dx  = 0.0,
          dy  = 0.0;
    FTYPE Gxx, Gxy, Gyx, Gyy;
    FTYPE Px, Py;

    assert(j1 &&  j1->length && j2 && j1->length==j2->length);

    Gxx = 0;
    Gxy = 0;
    Gyx = 0;
    Gyy = 0;

    Px  = 0;
    Py  = 0;

    for(i = 0; i < j1->length; i++){
        double ang = j1->ang[i] - j2->ang[i];

        /* Scale the angle such that it is closest to zero displacement. */
        while(ang >  PI){ ang -= 2*PI; }
        while(ang < -PI){ ang += 2*PI; }

        Gxx += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->kx[2*i];
        Gxy += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->ky[2*i];
        Gyx += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->ky[2*i];
        Gyy += j1->mag[i]*j2->mag[i]*j1->params->ky[2*i]*j1->params->ky[2*i];

        Px  += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*(ang);
        Py  += j1->mag[i]*j2->mag[i]*j1->params->ky[2*i]*(ang);
    }

    /* Catch any divide by zero errors */
    if(Gxx*Gyy-Gxy*Gyx != 0.0){
        dx = (Gyy*Px-Gyx*Py)/(Gxx*Gyy-Gxy*Gyx);
        dy = (-Gxy*Px+Gxx*Py)/(Gxx*Gyy-Gxy*Gyx);
    } else {
        /* Divide by zero occured - display warning */
        DEBUG(-1, "Warning: Divide by zero -- Attempting to recover");
        dx = 0.0;
        dy = 0.0;
    }

    /* Compute the similarity with the estimated displacement. */
    j12 = 0.0;
    j11 = 0.0;
    j22 = 0.0;
    for(i = 0; i < j1->length; i++){
        j12 += j1->mag[i]*j2->mag[i]*cos(j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));
        j11 += j1->mag[i]*j1->mag[i];
        j22 += j2->mag[i]*j2->mag[i];
    }
    sim = j12/sqrt(j11*j22);

    /* Return the proper values */
    *tdx = dx;
    *tdy = dy;

    return sim;
}




double DEPredictiveIter(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE j12 = 0;
    FTYPE j11 = 0;
    FTYPE j22 = 0;
    int i,n;
    FTYPE sim = 0.0;
    FTYPE dx  = 0.0,
          dy  = 0.0;
    FTYPE ddx, ddy;
    FTYPE Gxx, Gxy, Gyx, Gyy;
    FTYPE Px, Py;

    assert(j1 &&  j1->length && j2 && j1->length==j2->length);

    for(n = 0; n < 10; n++){

        Gxx = 0;
        Gxy = 0;
        Gyx = 0;
        Gyy = 0;

        Px  = 0;
        Py  = 0;
        
        for(i = 0; i < j1->length; i++){
            double ang = j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]);

            /* Scale the angle such that it is closest to zero displacement. */
            while(ang >  PI){ ang -= 2*PI; }
            while(ang < -PI){ ang += 2*PI; }

            Gxx += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->kx[2*i];
            Gxy += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->ky[2*i];
            Gyx += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*j1->params->ky[2*i];
            Gyy += j1->mag[i]*j2->mag[i]*j1->params->ky[2*i]*j1->params->ky[2*i];

            Px  += j1->mag[i]*j2->mag[i]*j1->params->kx[2*i]*(ang);
            Py  += j1->mag[i]*j2->mag[i]*j1->params->ky[2*i]*(ang);
        }

        /* Catch any divide by zero errors */
        if(Gxx*Gyy-Gxy*Gyx != 0.0){
            ddx = (Gyy*Px-Gyx*Py)/(Gxx*Gyy-Gxy*Gyx);
            ddy = (-Gxy*Px+Gxx*Py)/(Gxx*Gyy-Gxy*Gyx);
            dx += ddx;
            dy += ddy;
            if( (ddx*ddx+ddy+ddy < .001) ) break;
        } else {
            /* Divide by zero occured - display warning */
            DEBUG(-1, "Warning: Divide by zero -- Attempting to recover");
            dx += 0.0;
            dy += 0.0;
        }
    }
    
    /* Compute the similarity with the estimated displacement. */
    j12 = 0.0;
    j11 = 0.0;
    j22 = 0.0;
    for(i = 0; i < j1->length; i++){
        j12 += j1->mag[i]*j2->mag[i]*cos(j1->ang[i] - j2->ang[i] - (dx * j1->params->kx[2*i] + dy * j1->params->ky[2*i]));
        j11 += j1->mag[i]*j1->mag[i];
        j22 += j2->mag[i]*j2->mag[i];
    }
    sim = j12/sqrt(j11*j22);

    /* Return the proper values */
    *tdx = dx;
    *tdy = dy;

    return sim;
}





/* This displacement estimator performs a nearest neighbor search for the maximum similarity. */
double DEFixedLocalSearch(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE sim  = 0.0;
    FTYPE dx   = 0.0,
          dy   = 0.0;
    int change = 1,
        iter   = 50;
    FTYPE nextx, nexty;
    FTYPE bestsim = 0.0;

    assert(j1 && j1->length && j2 && j1->length==j2->length);


    sim = SIM_DISPLACE(j1, j2, dx,dy);
    bestsim = sim;

    nextx = dx;
    nexty = dy;
    while(change && iter--){
        dx = nextx;
        dy = nexty;
        change = 0;

        sim = SIM_DISPLACE(j1, j2, dx+0.5,dy+0.5);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx+0.5;
            nexty = dy+0.5;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx+0.5,dy-0.5);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx+0.5;
            nexty = dy-0.5;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx-0.5,dy-0.5);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx-0.5;
            nexty = dy-0.5;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx-0.5,dy+0.5);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx-0.5;
            nexty = dy+0.5;
            change = 1;
        }
        dx = nextx;
        dy = nexty;
    }

    *tdx = dx;
    *tdy = dy;

    return bestsim;
}

double DENarrowingLocalSearch(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy){
    FTYPE sim  = 0.0;
    FTYPE dx   = 0.0,
          dy   = 0.0;
    int change = 1,
        iter   = 50;
    FTYPE nextx, nexty;
    FTYPE bestsim = 0.0;
    FTYPE tol  = .2;
    FTYPE step = 1.0;


    assert(j1 && j1->length  && j2 && j1->length==j2->length);

    sim = SIM_DISPLACE(j1, j2, dx,dy);
    bestsim = sim;
    *tdx = 0.0;
    *tdy = 0.0;

    change = 1;
    sim = SIM_DISPLACE(j1, j2, dx,dy);
    bestsim = sim;

    nextx = dx;
    nexty = dy;
    while(change && iter--){
        dx = nextx;
        dy = nexty;
        change = 0;

        sim = SIM_DISPLACE(j1, j2, dx+step,dy+step);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx+step;
            nexty = dy+step;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx+step,dy-step);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx+step;
            nexty = dy-step;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx-step,dy-step);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx-step;
            nexty = dy-step;
            change = 1;
        }

        sim = SIM_DISPLACE(j1, j2, dx-step,dy+step);
        if( bestsim < sim ){
            bestsim = sim;
            nextx = dx-step;
            nexty = dy+step;
            change = 1;
        }
        dx = nextx;
        dy = nexty;

        if(change == 0 && step > tol){
            change = 1;
            step = step * 0.5;
        }
    }

    *tdx = dx;
    *tdy = dy;
    
    /*printf("BestSim: %f\n",bestsim); */
    return bestsim;
}


/* This function performs a simple L2 distance
   measurement on the geometry of the face graph */
FTYPE GeometrySimL2(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->geosize; i++){
        totalSim += sqrt(SQR(f1->jets[i]->x - f2->jets[i]->x)+SQR(f1->jets[i]->y - f2->jets[i]->y));
    }
    return totalSim;
}

/* This function performs a correlation based distance
   measurement on the geometry of the face graph */
FTYPE GeometrySimCorrelation(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE sum1 = 0.0, sum2 = 0.0;
    FTYPE mean1 = 0.0, mean2 = 0.0;
    FTYPE len1 = 0.0, len2 = 0.0;
    FTYPE sqsum1 = 0.0, sqsum2 = 0.0;
    FTYPE corr = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    NOT_IMPLEMENTED;

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) = (i%2) ? f1->jets[i/2]->y : f1->jets[i/2]->x ;
        ME(g2,i,0) = (i%2) ? f2->jets[i/2]->y : f2->jets[i/2]->x ;
    }

    for (i = 0; i < g1->row_dim; i++) {
        sum1 += ME(g1,i,0);
        sum2 += ME(g2,i,0);
    }

    mean1 = sum1 / g1->row_dim;
    mean2 = sum2 / g2->row_dim;

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) -= mean1;
        ME(g2,i,0) -= mean2;
        sqsum1 += ME(g1,i,0)*ME(g1,i,0);
        sqsum2 += ME(g2,i,0)*ME(g2,i,0);
    }

    len1 = 1.0/sqrt(sqsum1);
    len2 = 1.0/sqrt(sqsum2);

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) = ME(g1,i,0)*len1;
        ME(g2,i,0) = ME(g2,i,0)*len2;
        corr += ME(g1,i,0)*ME(g2,i,0);
    }

    freeMatrix(g1);
    freeMatrix(g2);
    return (- corr);
}


/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
void TransformLeastSquares(Matrix g1, Matrix g2){
    int i;
    FTYPE dist = 0.0;

    Matrix  A = makeMatrix(g1->row_dim,4);
    Matrix v;
    FTYPE b, a, dx, dy;

    dist = 0.0;

    for (i = 0; i < g1->row_dim/2; i++) {
        ME(A,2*i,0  ) =  ME(g1,2*i,0);
        ME(A,2*i,1  ) = -ME(g1,2*i+1,0);
        ME(A,2*i,2  ) =  1;
        ME(A,2*i,3  ) =  0;

        ME(A,2*i+1,0) =  ME(g1,2*i+1,0);
        ME(A,2*i+1,1) =  ME(g1,2*i,0);
        ME(A,2*i+1,2) =  0;
        ME(A,2*i+1,3) =  1;
    }

    v = leastSquares(A, g2);

    a = ME(v,0,0);
    b = ME(v,1,0);
    dx    = ME(v,2,0);
    dy    = ME(v,3,0);

    dist = 0.0;
    for (i = 0; i < g1->row_dim/2; i++) {
        FTYPE x = ME(g1,2*i  ,0);
        FTYPE y = ME(g1,2*i+1,0);

        ME(g1,2*i  ,0) = a*x - b*y + dx;
        ME(g1,2*i+1,0) = b*x + a*y + dy;
    }


    freeMatrix(v);
    freeMatrix(A);
}

FTYPE L2Dist(Matrix g1, Matrix g2){
    FTYPE dist = 0.0;
    int i;

    for (i = 0; i < g1->row_dim/2; i++) {
        dist += SQR(ME(g1,2*i,0) - ME(g2,2*i,0));
        dist += SQR(ME(g1,2*i+1,0) - ME(g2,2*i+1,0));
    }

    return sqrt(dist);
}


/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
FTYPE GeometrySimLeastSquares(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE dist = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < g1->row_dim; i++) {
        ME(g1,i,0) = (i%2) ? f1->jets[i/2]->y : f1->jets[i/2]->x ;
        ME(g2,i,0) = (i%2) ? f2->jets[i/2]->y : f2->jets[i/2]->x ;
    }

    TransformLeastSquares(g1,g2);

    dist = L2Dist(g1, g2);

    freeMatrix(g1);
    freeMatrix(g2);

    return dist;
}

/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
FTYPE GeometrySimLeastSquaresPS(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE dist = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < f1->geosize; i++) {
        FTYPE dedx=0, dedy=0;
        DEPredictiveStep(f1->jets[i],f2->jets[i],&dedx,&dedy);

        ME(g1,2*i,0)   = f1->jets[i]->x ;
        ME(g1,2*i+1,0) = f1->jets[i]->y ;
        ME(g2,2*i,0)   = f2->jets[i]->x + dedx;
        ME(g2,2*i+1,0) = f2->jets[i]->y + dedy;
    }

    TransformLeastSquares(g1,g2);

    dist = L2Dist(g1, g2);

    freeMatrix(g1);
    freeMatrix(g2);

    return dist;
}


/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
FTYPE GeometrySimLeastSquaresPI(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE dist = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < f1->geosize; i++) {
        FTYPE dedx=0, dedy=0;
        DEPredictiveIter(f1->jets[i],f2->jets[i],&dedx,&dedy);

        ME(g1,2*i,0)   = f1->jets[i]->x ;
        ME(g1,2*i+1,0) = f1->jets[i]->y ;
        ME(g2,2*i,0)   = f2->jets[i]->x + dedx;
        ME(g2,2*i+1,0) = f2->jets[i]->y + dedy;
    }

    TransformLeastSquares(g1,g2);

    dist = L2Dist(g1, g2);

    freeMatrix(g1);
    freeMatrix(g2);

    return dist;
}


/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
FTYPE GeometrySimLeastSquaresFLS(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE dist = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < f1->geosize; i++) {
        FTYPE dedx=0, dedy=0;
        DEFixedLocalSearch(f1->jets[i],f2->jets[i],&dedx,&dedy);

        ME(g1,2*i,0)   = f1->jets[i]->x ;
        ME(g1,2*i+1,0) = f1->jets[i]->y ;
        ME(g2,2*i,0)   = f2->jets[i]->x + dedx;
        ME(g2,2*i+1,0) = f2->jets[i]->y + dedy;
    }

    TransformLeastSquares(g1,g2);

    dist = L2Dist(g1, g2);

    freeMatrix(g1);
    freeMatrix(g2);

    return dist;
}


/* This method performs an L2 based distance measure
after solving for a best fit transformation.  The
best fit transformation is a combination of a 2D
scale, rotation and translation.  The algorithm
solves for this transformation using a least squares
solution to a set of transformation aproximations. */
FTYPE GeometrySimLeastSquaresNLS(FaceGraph f1, FaceGraph f2){
    int i;
    FTYPE dist = 0.0;

    Matrix g1 = makeMatrix(f1->geosize*2,1);
    Matrix g2 = makeMatrix(f1->geosize*2,1);

    for (i = 0; i < f1->geosize; i++) {
        FTYPE dedx=0, dedy=0;
        DENarrowingLocalSearch(f1->jets[i],f2->jets[i],&dedx,&dedy);

        ME(g1,2*i,0)   = f1->jets[i]->x ;
        ME(g1,2*i+1,0) = f1->jets[i]->y ;
        ME(g2,2*i,0)   = f2->jets[i]->x + dedx;
        ME(g2,2*i+1,0) = f2->jets[i]->y + dedy;
    }

    TransformLeastSquares(g1,g2);

    dist = L2Dist(g1, g2);

    freeMatrix(g1);
    freeMatrix(g2);

    return dist;
}




/*****************************************************************************
    Face graph similarity measures determine the similarity between face
    graphs.  The similarity measures are based on the geometry of the
    graph and the values of the Gabor Jets.
*****************************************************************************/

/* Magnitude only similarity measure */
FTYPE fgSimMagnitude(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityMag( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

/* Phase based similarity measure */
FTYPE fgSimPhase01(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityPhase( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

/* Phase with displacement estimation */
FTYPE fgSimPhase02(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEPredictiveStep( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

/* Phase with displacement estimation */
FTYPE fgSimPhase03(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEGridSample( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

/* Phase with displacement estimation */
FTYPE fgSimPhase04(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEFixedLocalSearch( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

/* Phase with displacement estimation */
FTYPE fgSimPhase05(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDENarrowingLocalSearch( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}


/* Phase with displacement estimation */
FTYPE fgSimPhase06(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEPredictiveIter( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;
}

FTYPE fgSimPhase(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityPhase( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}


FTYPE fgSimPhaseGridSample(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEGridSample( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}



FTYPE fgSimPhasePredictiveStep(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEPredictiveStep( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}



FTYPE fgSimPhasePredictiveIter(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEPredictiveIter( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}



FTYPE fgSimPhaseFixedLocalSearch(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDEFixedLocalSearch( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}



FTYPE fgSimPhaseNarrowingLocalSearch(FaceGraph f1, FaceGraph f2){
    FTYPE totalSim = 0.0;
    int i;

    for(i = 0; i < f1->totalsize; i++){
        totalSim += JetSimilarityDENarrowingLocalSearch( f1->jets[i], f2->jets[i] );
    }
    totalSim = totalSim / f1->totalsize;

    return -totalSim;

}




/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMSimilarity.h,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef EBGM_SIMILARITY
#define EBGM_SIMILARITY

#include <csuEBGMUtil.h>
/************************ Jet Similarity Functions *************************/

/* The following functions compute similarity between two
 * Gabor Jets.  They are described in detail csuGaborJets.c
 */
typedef FTYPE (*JetSimilarityMeasure)(GaborJet j1, GaborJet j2);

FTYPE JetSimilarityMag(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityPhase(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDEGridSample(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDEPredictiveStep(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDEPredictiveIter(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDEFixedLocalSearch(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDENarrowingLocalSearch(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityCityBlock(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityCorrelation(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityCovariance(GaborJet j1, GaborJet j2);

/* These similarty measures are discussed in David Bolme's thesis.
   Results were generated using csuEBGMLocalization */
FTYPE JetSimilarityResponseMag(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityResponsePhase(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDisplacementCheckMag(GaborJet j1, GaborJet j2);
FTYPE JetSimilarityDisplacementCheckPhase(GaborJet j1, GaborJet j2);

/********************** Jet Displacement Estimation ************************/

/* This function estimates the displacement of gabor jet
 * relative to a sample jet.  The method that is used is
 * simmillar to auto correlation.  Also look at the similarity
 * function for phase 1 and 3 for related code. */
typedef FTYPE (*JetDisplacementEstimator)(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);

FTYPE estimateDisplacementRandom (GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);
FTYPE DEGridSample(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);
FTYPE DEPredictiveStep(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);
FTYPE DEPredictiveIter(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);
FTYPE DEFixedLocalSearch(GaborJet j1, GaborJet j2, FTYPE *tdx, FTYPE *tdy);
FTYPE DENarrowingLocalSearch(GaborJet j1, GaborJet j2, FTYPE *dx, FTYPE *dy);

/********************** Face Graph Similarity ************************/
typedef FTYPE (*FaceGraphSimilarity)(FaceGraph, FaceGraph);

FTYPE GeometrySimL2(FaceGraph, FaceGraph);
FTYPE GeometrySimCorrelation(FaceGraph, FaceGraph);
FTYPE GeometrySimLeastSquares(FaceGraph, FaceGraph);
FTYPE GeometrySimLeastSquaresPS(FaceGraph f1, FaceGraph f2);
FTYPE GeometrySimLeastSquaresPI(FaceGraph f1, FaceGraph f2);
FTYPE GeometrySimLeastSquaresFLS(FaceGraph f1, FaceGraph f2);
FTYPE GeometrySimLeastSquaresNLS(FaceGraph f1, FaceGraph f2);
FTYPE GeometrySimWLeastSquaresPI(FaceGraph f1, FaceGraph f2);

FTYPE fgSimMagnitude(FaceGraph, FaceGraph);
FTYPE fgSimPhase(FaceGraph, FaceGraph);
FTYPE fgSimPhaseGridSample(FaceGraph, FaceGraph);
FTYPE fgSimPhasePredictiveStep(FaceGraph, FaceGraph);
FTYPE fgSimPhasePredictiveIter(FaceGraph, FaceGraph);
FTYPE fgSimPhaseFixedLocalSearch(FaceGraph, FaceGraph);
FTYPE fgSimPhaseNarrowingLocalSearch(FaceGraph, FaceGraph);

#endif



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMUtil.c,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/* CSU INCLUDES */
#include <csuEBGMUtil.h>

/*
 *  GaborJets.c
 *  csuEvalFaceRec
 *
 *  Created by David Bolme on Sat Jul 06 2002.
 *  Copyright (c) 2001 __MyCompanyName__. All rights reserved.
 *
 */


/* Allocate memory for the gabor jet */
GaborJet makeGaborJet(int length){
    GaborJet jet = (GaborJet)malloc(sizeof(gabor_jet));
    assert(jet);

    if(length ){
        jet->length   = length;

        jet->realPart = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
        assert(jet->realPart);
        jet->imagPart = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
        assert(jet->imagPart);
        jet->mag      = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
        assert(jet->mag);
        jet->ang      = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
        assert(jet->ang);
    } else {
        length = 0;
    }

    jet->params = NULL;

    return jet;
}

/* Free memory for the gabor jet */
void     freeGaborJet(GaborJet jet){
    if(jet->length){
        free( jet->realPart );
        free( jet->imagPart );
        free( jet->mag );
        free( jet->ang );
    }

    free(jet);
}

/*
This is a utility function that computes the polar coordinage transform
for the values in a gabor jet.
*/
void computePolar(GaborJet jet){
    int i;

    for( i = 0; i < jet->length; i++){
        /* Find the magnitude of the imaginary points */
        jet->mag[i] = sqrt(SQR(jet->realPart[i])+SQR(jet->imagPart[i]));
        /* Find the angle of the imaginary points */
        if(jet->realPart[i] != 0){
            /* determine which quadrint the point lies in */
            if(jet->realPart[i] >= 0){
                jet->ang[i] = atan(jet->imagPart[i]/jet->realPart[i]);
            }
            else{
                jet->ang[i] = PI + atan(jet->imagPart[i]/jet->realPart[i]);
            }
        }
        else{
	        if(jet->imagPart[i] >= 0){
                jet->ang[i] = PI/2;
            }
            else{
                jet->ang[i] = -PI/2;
            }
        }
    }
}


/* Extract a jet from an image at a paticular location */
GaborJet extractJet(GFTYPE x, GFTYPE y, Image im, JetMasks masks){
    GaborJet jet = NULL;
    if( masks->size ){
        /* This algrithm aproximates the gabor parameters at a location in continuous space
        By computing the gabor convoluation at an integer location close to the contiuous
        point and then shifting the phase parameters the apropreate amount. It is much faster
        then using linear interpolation and it is probably more accurate. */
        int i;
        float rx = ROUND(x);
        float ry = ROUND(y);
        float dx = x - rx;
        float dy = y - ry;
        jet = makeGaborJet(masks->size/2);

        /* Add a pointer to the mask parameters for future use */
        jet->params = masks->params;


        /* Compute the jet coeffecents */
        for( i = 0; i < jet->length; i++){
            jet->realPart[i] = convolvePoint(rx, ry, 0, im, masks->masks[2*i]);
            jet->imagPart[i] = convolvePoint(rx, ry, 0, im, masks->masks[2*i+1]);
            FINITE(jet->realPart[i]);
            FINITE(jet->imagPart[i]);
        }
        computePolar(jet);

        /* Adjust phase coordinates */
        for( i = 0; i < jet->length; i++){
            jet->ang[i] +=  dx * jet->params->kx[2*i] + dy * jet->params->ky[2*i];
        }

        /* Recompute coeffecents based on phase change */
        for( i = 0; i < jet->length; i++){
            jet->realPart[i] = jet->mag[i] * cos(jet->ang[i]);
            jet->imagPart[i] = jet->mag[i] * sin(jet->ang[i]);
        }
    }
    else{
        jet = makeGaborJet(0);
    }

    /* Save the jet location */
    jet->x = x;
    jet->y = y;

    return jet;
}



/* Allocate/Free space for the Jet Params */
GaborJetParams makeJetParams(int length){
    GaborJetParams params = (GaborJetParams)malloc(sizeof(gabor_jet_params));
    assert( params );

    params->length     = length;

    params->wavelength = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->angle      = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->phase      = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->aspect     = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->radius     = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->kx         = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->ky         = (GFTYPE*)malloc(sizeof(GFTYPE)*length);
    params->size       = (int*)malloc(sizeof(int)*length);

    return params;
}


void freeJetParams(GaborJetParams params){

    free( params->wavelength );
    free( params->angle      );
    free( params->phase      );
    free( params->aspect     );
    free( params->radius     );
    free( params->size       );
    free( params->kx         );
    free( params->ky         );

    free( params );
}

/* This function alocates space for gabor masks */
JetMasks makeJetMasks(int size){
    JetMasks masks = (JetMasks)malloc(sizeof(jet_masks));
    assert(masks);

    masks->size = size;
    masks->masks = (Image*)malloc(sizeof(Image)*size);
    masks->params = makeJetParams(size);
    assert(masks->masks);

    return masks;
}

/* This function frees space that was used to hold on to gabor
 * masks */
void freeJetMasks(JetMasks masks){
    int n;

    for(n = 0; n < masks->size; n++){
        freeImage( masks->masks[n] );
    }
    freeJetParams( masks->params );
    free( masks->masks );
    free( masks );
}


/*
    This function creates an image to be used as a convolution mask with a gabor kernel
*/
double WiskottDCFree = 0.0;

Image makeGaborMask(FTYPE lambda, FTYPE theta, FTYPE phi,
                    FTYPE gamma, FTYPE sigma,int size)
{
    Image mask = makeImage(size,size,1);
    int i, j;


    for(j = 0; j < size; j++){
        for(i = 0; i < size; i++){
            FTYPE x = size/2.0 - size + i;
            FTYPE y = size/2.0 - size + j;
            FTYPE xp =  x*cos(theta)+y*sin(theta);
            FTYPE yp = -x*sin(theta)+y*cos(theta);
            FTYPE tmp1 = -(xp*xp+gamma*gamma*yp*yp)/(2*sigma*sigma);
            FTYPE tmp2 = (2*PI*xp/lambda)+phi;
            IE(mask,i,j,0) = exp(tmp1)*(cos(tmp2)-(phi == 0.0)*(WiskottDCFree)*exp(-sigma*sigma*0.5));
        }
    }

    /* Rescale the pixel values to have a standard total length */
    ZeroMeanUnitLength(mask);

    return mask;
}


JetMasks readMasksFile(const char* filename){
    JetMasks masks = NULL;
    int maskCount;
    double lambda, angle, phase, gama, sigma; int maskSize;
    int i;
    FILE* file = fopen(filename,"r");

    if(!file){
        printf("Error opening file: %s",filename);
        exit(1);
    }

    /* Read in the number of Masks. */
    fscanf(file, "%d",&maskCount);
    masks = makeJetMasks(maskCount);

    /* Read in mask parameters and create masks. */

    for(i = 0; i < maskCount; i++){
        if(fscanf(file, "%lf %lf %lf %lf %lf %d", &lambda, &angle, &phase, &gama, &sigma, &maskSize) != 6){
            printf("Error reading mask file: %s line: %d", filename, i);
            exit(1);
        }
        masks->params->wavelength[i] = lambda;
        masks->params->angle[i]      = angle;
        masks->params->phase[i]      = phase;
        masks->params->aspect[i]     = gama;
        masks->params->radius[i]     = sigma;
        masks->params->kx[i]         = 2.0*PI*cos(angle)/lambda;
        masks->params->ky[i]         = 2.0*PI*sin(angle)/lambda;
        masks->params->size[i]       = maskSize;

        masks->masks[i] = makeGaborMask(lambda, angle, phase, gama, sigma, maskSize);
        ZeroMeanUnitLength(masks->masks[i]);
    }

    fclose( file );

    return masks;
}




/* This function reads in a discription of a graph and loads it into
 * a graph discription structure.  The file format is asci were the
 * first token is the number of vericies followed by verticy labels
 * and guess x, y coordinates.  This is followed by the number of edges
 * and the indexes of the vericies that they connect.
 */
GraphDiscription readGraphDiscription(const char* filename){
    FILE* file;
    int i;
    GraphDiscription gd = ALLOCATE(graph_discription,1);
    DEBUG_CHECK(gd,"Error allocating memory");

    file = fopen(filename,"r");
    DEBUG_CHECK_1ARG(file,"Error opening file: %s", filename);

    /* Read the number of vericies in the file */
    DEBUG_CHECK_1ARG(fscanf(file,"%d",&(gd->numVert)) == 1, "Error: could not determin the number of verticies in file %s", filename);

    /* allocate space for vericies and load discriptions */
    gd->verts = ALLOCATE(Vert,gd->numVert);
    gd->vertLabels = ALLOCATE(char*,gd->numVert);
    gd->bunch = ALLOCATE(JetBunch,gd->numVert);
    for(i = 0; i < gd->numVert; i++){
        gd->vertLabels[i] = ALLOCATE(char,LABELMAX);
        DEBUG_CHECK_2ARG(fscanf(file, "%s %lf %lf",  gd->vertLabels[i], &(gd->verts[i].x), &(gd->verts[i].y)) == 3,
                         "Error Parsing vertex %d in file: %s", i, filename);
        gd->bunch[i] = makeJetBunch();

    }

    /* Read the number of edges in the file */
    DEBUG_CHECK_1ARG(fscanf(file,"%d",&(gd->numEdge)) == 1, "Error: could not determin the number of edges in file %s", filename);

    /* allocate space for vericies and load discriptions */
    gd->edges = ALLOCATE(Edge,gd->numEdge);
    for(i = 0; i < gd->numEdge; i++){
        DEBUG_CHECK_2ARG(fscanf(file, "%d %d",&(gd->edges[i].vert1), &(gd->edges[i].vert2)) == 2,
                         "Error Parsing vertex %d in file: %s", i, filename);
    }
    fclose(file);

    return gd;
}

/* This function reads in a discription of a graph and loads it into
 * a graph discription structure.  The file format is asci were the
 * first token is the number of vericies followed by verticy labels
 * and guess x, y coordinates.  This is followed by the number of edges
 * and the indexes of the vericies that they connect.
 */
void saveGraphDiscription(const char* filename, GraphDiscription gd){
    FILE* file;
    int i;

    file = fopen(filename,"w");
    DEBUG_CHECK_1ARG(file,"Error opening file: %s", filename);

    /* Read the number of vericies in the file */
    fprintf(file,"%d\n",(gd->numVert));

    /* allocate space for vericies and load discriptions */
    for(i = 0; i < gd->numVert; i++){
        fprintf(file, "%s %f %f\n",  gd->vertLabels[i], (gd->verts[i].x), (gd->verts[i].y));
    }

    /* Read the number of edges in the file */
    fprintf(file,"%d\n",(gd->numEdge));

    /* allocate space for vericies and load discriptions */
    for(i = 0; i < gd->numEdge; i++){
        fprintf(file, "%d %d\n",(gd->edges[i].vert1), (gd->edges[i].vert2));
    }

    fclose(file);
}

void freeGraphDiscription(GraphDiscription gd){
    int i;

    for(i = 0; i < gd->numVert; i++){
        free(gd->vertLabels[i]);
        freeJetBunch(gd->bunch[i]);
    }

    free(gd->bunch);
    free(gd->verts);
    free(gd->vertLabels);
    free(gd->edges);
    free(gd);
}



Image makeComplexImage(const Image jetImage){
    Image complexImage = makeImage(jetImage->width, jetImage->height, jetImage->channels/2);
    int x,y,c;

    DEBUG_CHECK(jetImage->channels%2 == 0,"jetImage must have an even number of channels");

    for(x = 0; x < complexImage->width; x++){
        for(y = 0; y < complexImage->height; y++){
            for(c = 0; c < complexImage->channels; c++){
                IE(complexImage,x,y,c) =
                sqrt(SQR(IE(jetImage,x,y,c*2))+
                     SQR(IE(jetImage,x,y,c*2+1)));
            }
        }
    }
    return complexImage;
}


Image makeJetImage(const JetMasks masks, Image im){

    Image jets = makeImage(im->width,im->height,im->channels*(masks->size));
    int n,x,y,c;
    for(y = 0; y < im->height; y++){
        for(x = 0; x < im->width; x++){
            for(c = 0; c < im->channels;c++){
                for(n = 0; n < masks->size; n++){
                    IE(jets,x,y,c*masks->size+n) = convolvePoint(x,y,c,im,masks->masks[n]);
                }
            }
        }
    }

    return jets;
}

/**************************** Jet Bunch Code *******************************/

#define JET_BUNCH_DEFAULT_SIZE 32

JetBunch makeJetBunch(){
    JetBunch jb = ALLOCATE(jet_bunch,1);
    jb->allocsize = 0; /* only allocate memory if a jet is added. */
    jb->size = 0;

    jb->jets = ALLOCATE(GaborJet,jb->allocsize);
    return jb;
}

void freeJetBunch(JetBunch jb){
    int i;
    for(i = 0; i < jb->size; i++){
        if(jb->jets[i]) freeGaborJet(jb->jets[i]);
    }
    free(jb->jets);
    free(jb);
}


int addJetToBunch(JetBunch bunch, GaborJet jet){
    if(bunch->size >= bunch->allocsize){
        int i;
        GaborJet* tmpjets = ALLOCATE(GaborJet, bunch->allocsize + JET_BUNCH_DEFAULT_SIZE);
        bunch->allocsize = bunch->allocsize + JET_BUNCH_DEFAULT_SIZE;
        for(i = 0; i < bunch->size; i++){
            tmpjets[i] = bunch->jets[i];
        }
        free(bunch->jets);
        bunch->jets = tmpjets;
    }
    bunch->jets[bunch->size] = jet;
    bunch->size++;
    return bunch->size - 1;
}


/******************************* Face Graph ********************************/

int alloc_faceGraph = 0;

FaceGraph makeFaceGraph( int geosize, int totalsize ){
    int i;
    FaceGraph fg = ALLOCATE(face_graph,1);
    assert(fg);
    fg->geosize = geosize;
    fg->totalsize = totalsize;
    fg->params = NULL;
    fg->jets = ALLOCATE(GaborJet,totalsize);
    for(i = 0; i < totalsize; i++){
        fg->jets[i] = NULL;
    }
    
    alloc_faceGraph++;
    return fg;
}

void freeFaceGraph( FaceGraph fg ){
    int i;
    for(i = 0; i < fg->totalsize; i++){
        if(fg->jets[i] != NULL){
            freeGaborJet(fg->jets[i]);
        }
    }
    free(fg->jets);
    free(fg);
    alloc_faceGraph--;
}

void  writeint(FILE* file, int i){
    fprintf(file,"%d\n",i);
}

void  writereal(FILE* file, FTYPE r){
    fprintf(file,"%e\n",r);
}

int  readint(FILE* file){
    int i;
    fscanf(file,"%d",&i);
    return i;
}

FTYPE  readreal(FILE* file){
    float f;
    fscanf(file,"%f",&f);
    return f;
}

FaceGraph loadFaceGraph(char *filename){
    int i, j;
    int totalsize, geosize, params;
    FaceGraph fg;
    FILE* file = fopen(filename,"rb");
    printf("Loading Graph: %s   \r", filename); fflush(stdout);
    assert(file);
    /* Write out the size */
    geosize = readint(file);
    totalsize = readint(file);

    fg = makeFaceGraph(geosize, totalsize);

    params = readint(file);
    if(params) {

        int gaborsize = readint (file);
        fg->params = makeJetParams(gaborsize);
        for(i = 0; i < fg->params->length; i++){
            fg->params->wavelength[i] = readreal(file);
            fg->params->angle[i] = readreal(file);
            fg->params->phase[i] = readreal(file);
            fg->params->aspect[i] = readreal(file);
            fg->params->radius[i] = readreal(file);
            fg->params->size[i] = readint (file);
            fg->params->kx[i] = readreal(file);
            fg->params->ky[i] = readreal(file);
        }
    }

    for(i = 0; i < fg->totalsize; i++){
        int length;
        /* write out jet i */
        length = readint(file);
        fg->jets[i] = makeGaborJet(length);
        fg->jets[i]->params = fg->params;
        fg->jets[i]->x = readreal(file);
        fg->jets[i]->y = readreal(file);
        for(j = 0; j < fg->jets[i]->length; j++){
            fg->jets[i]->realPart[j] = readreal(file);
            fg->jets[i]->imagPart[j] = readreal(file);
            fg->jets[i]->mag[j] = readreal(file);
            fg->jets[i]->ang[j] = readreal(file);
        }
    }
    fclose(file);
    return fg;
}

void saveFaceGraph(char *filename, FaceGraph fg){
    int i, j;
    FILE* file = fopen(filename,"wb");
    assert(file);
    /* Write out the size */
    writeint(file, fg->geosize);
    writeint(file, fg->totalsize);
    writeint(file, fg->params != NULL);
    if(fg->params) {
        writeint (file, fg->params->length);
        for(i = 0; i < fg->params->length; i++){
            writereal(file, fg->params->wavelength[i]);
            writereal(file, fg->params->angle[i]);
            writereal(file, fg->params->phase[i]);
            writereal(file, fg->params->aspect[i]);
            writereal(file, fg->params->radius[i]);
            writeint (file, fg->params->size[i]);
            writereal(file, fg->params->kx[i]);
            writereal(file, fg->params->ky[i]);
        }
    }

    for(i = 0; i < fg->totalsize; i++){
        /* write out jet i */
        writeint(file, fg->jets[i]->length);
        writereal(file, fg->jets[i]->x);
        writereal(file, fg->jets[i]->y);
        for(j = 0; j < fg->jets[i]->length; j++){
            writereal(file, fg->jets[i]->realPart[j]);
            writereal(file, fg->jets[i]->imagPart[j]);
            writereal(file, fg->jets[i]->mag[j]);
            writereal(file, fg->jets[i]->ang[j]);
        }
    }
    
    fclose(file);
}






/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
$RCSfile: csuEBGMUtil.h,v $
$Author: teixeira $
$Date: 2003/04/23 14:02:31 $
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef CSU_GABOR_INCLUDED
#define CSU_GABOR_INCLUDED

#include <csuCommon.h>

#define LABELMAX 100

#define GFTYPE FTYPE

double WiskottDCFree;

/*************************** Gabor Parameters ******************************/

/* These parameters hold on to the information
 * needed for the gabor kernel.  For many
 * applications, it is assumed that every other
 * gabor kernel is identical but out of phase by
 * 90 degrees (even and odd).  Jets assume this
 * structure and store complex values.  Therefore
 * a jet stores length/2 complex values. */
typedef struct{
    int length;

    GFTYPE* wavelength;
    GFTYPE* angle;
    GFTYPE* phase;
    GFTYPE* aspect;
    GFTYPE* radius;
    int*    size;

    /* Precomputed parameters for displacement estimation */
    GFTYPE* kx;
    GFTYPE* ky;
} gabor_jet_params;

typedef gabor_jet_params *GaborJetParams;

/* Allocate/Free space for the Jet Params */
GaborJetParams makeJetParams(int size);
void freeJetParams(GaborJetParams params);


/******************************** Gabor Mask *******************************/

/* This structure holds on to images of gabor kernels that
 * are used in convolution to determine the gabor coeffecents
 */
typedef struct{
    int size;
    Image *masks;

    GaborJetParams params;
} jet_masks;

typedef jet_masks* JetMasks;

/* Allocate/Free space for the Jet Masks */
JetMasks makeJetMasks(int size);
void     freeJetMasks(JetMasks masks);

Image makeGaborMask(FTYPE wavelength, FTYPE angle, FTYPE phase, FTYPE aspect, FTYPE radius, int size);

JetMasks readMasksFile(const char* filename);

/******************************* Gabor Jets ********************************/
/* Gabor Jet Structure
*
* This structure uses containes the convolution values for a set
* of gabor filters at a paticular location.  Structure elements
* include the location x,y and length of the jet, and the values.
* see Wiskott (Sec. 2.1.1)
*/

typedef struct{
    int length;
    GFTYPE x, y;

    /* Complex specification for the coeffiecients */
    GFTYPE* realPart;
    GFTYPE* imagPart;

    /* Polar transformation of the above complex numbers*/
    GFTYPE* mag;
    GFTYPE* ang;

    /* Parameters used to generate gabor kernels */
    GaborJetParams params;
} gabor_jet;

typedef gabor_jet *GaborJet;

GaborJet makeGaborJet(int length);
void     freeGaborJet(GaborJet jet);
GaborJet extractJet(GFTYPE x, GFTYPE y, Image im, JetMasks masks);

/******************************* Jet Bunch *********************************/

/*
A Jet bunch is a collection of gabor jets that have been extracted from the
same facidual point on the face.  The idea is to form a "bunch" (collection)
of example jets that represent that point.  When trying to localize a point
in a novel image the code can choose a jet that is more similar to the image
being matched.
*/

typedef struct{
    int allocsize;
    int size;

    GaborJet* jets;
} jet_bunch;

typedef jet_bunch *JetBunch;


JetBunch makeJetBunch();
void freeJetBunch(JetBunch bunch);
int addJetToBunch(JetBunch bunch, GaborJet jet);


/************************* Gabor Graph Discription *************************/

typedef struct{
    int vert1, vert2;
} Edge;

typedef struct{
    FTYPE x, y;
} Vert;

typedef struct{
    int numVert;
    int numEdge;
    Vert* verts;
    Edge* edges;
    char** vertLabels;

    JetBunch* bunch;
} graph_discription;

typedef graph_discription *GraphDiscription;

/* This function reads in a discription of a graph and loads it into
 * a graph discription structure.  The file format is asci were the
 * first token is the number of vericies followed by verticy labels
 * and guess x, y coordinates.  This is followed by the number of edges
 * and the indexes of the vericies that they connect.
 */
GraphDiscription readGraphDiscription(const char* filename);
void             saveGraphDiscription(const char* filename,GraphDiscription);
void             freeGraphDiscription(GraphDiscription gd);


/******************************* Face Graph ********************************/

typedef struct{
    int geosize; /* numbers of the located point. */
    int totalsize; /* number fo the located points and interpolated points */
    GaborJetParams params;
    GaborJet* jets;
} face_graph;

typedef face_graph* FaceGraph;

FaceGraph makeFaceGraph( int geosize, int totalsize );
void freeFaceGraph( FaceGraph );

FaceGraph loadFaceGraph(char *filename);
void saveFaceGraph(char *filename, FaceGraph);



/*********************** Extra Utility Functions ***************************/
Image makeJetImage(const JetMasks masks, const Image im);
Image makeComplexImage(const Image jetImage);
JetMasks readMasksFile(const char* filename);




#endif



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
 *  csuFace2Norm.c
 *  csuFace2Norm
 *
 *  Created by David  Bolme on Sun Jun 09 2002.
 *
 */

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>

#define OPENING "csuFace2Norm - Normalize face data from pgm files"

/* default normalization parameters */
#define ELLIPSE_X    65.0
#define ELLIPSE_Y    50.0
#define ELLIPSE_A    64.0
#define ELLIPSE_B    118.0

#define EDGE_PRE     0
#define EDGE_POST    0

#define EYE_LX       30.0
#define EYE_LY       45.0
#define EYE_RX       100.0
#define EYE_RY       45.0

#define SIZE_WIDTH   130
#define SIZE_HEIGHT  150

#define NOISE        0.0
#define SCALE        1.0
#define SHIFT_X      0.0
#define SHIFT_Y      0.0

#define HIST_NONE    0
#define HIST_PRE     1
#define HIST_POST    2


typedef struct {
    char* eyeFile;
    char* inputDir;
    char* nrmDir;
    char* sfiDir;
    char* pgmDir;

    int geoType;
    int histType;
    int nrmType;
    int preNormType;
    int maskType;
    int preEdge;
    int postEdge;

    int sizeWidth;
    int sizeHeight;

    double scale;
    double noise;
    double shiftX;
    double shiftY;
    int reflect;
    int configSuffix;
    
    double eyeLx;
    double eyeLy;
    double eyeRx;
    double eyeRy;

    double ellipseX;
    double ellipseY;
    double ellipseA;
    double ellipseB;
}
Arguments;

/*
 * usage
 *
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void usage(const char* name){
    printf("Usage: %s [OPTIONS] eye_coordinate_file input_dir\n",name);
    printf("  OUTPUT OPTIONS:  (You must specify at least one output directory)\n");
    printf("    -nrm <DIR_NAME>         - Directory to store images in nrm format (feret\n"
           "                              compatible)\n");
    printf("    -sfi <DIR_NAME>         - Directory to store images in raw format (gabor\n"
           "                              compatible)\n");
    printf("    -pgm <DIR_NAME>         - Directory to store images in pgm format ()\n");
    printf("  NORMALIZATION OPTIONS:\n");
    printf("    -mask <YES/NO>          - Specify an ellipse that defines a mask.\n"); 
    printf("                              Defaults to \"Yes\".\n");
    printf("    -mask-param x y a b     - Specify an ellipse that defines a mask. \n");
    printf("                              Defaults to FERET Standard, %0.1f, %0.1f, %0.1f, %0.1f \n", 
                                          ELLIPSE_X, ELLIPSE_Y, ELLIPSE_A, ELLIPSE_B);
    printf("    -hist <TYPE>            - Select the type of histogram equalization.\n");
    printf("                              Default is \"POST\", Options are \"PRE\", \"POST\", \"NONE\". \n");
    printf("                              \"PRE\"  - equalize raw 0-255 pixels, like original NIST code.\n");
    printf("                              \"POST\" - pixels under mask only after geometric normalization.\n");
    printf("    -geometric <YES/NO>     - Turns on/off geometric normalization. Defaults to \"Yes\".\n");
    printf("    -eye-target lx ly rx ry - Choose the target eye coordinates.\n");
    printf("                              Defaults to FERET Standard, %0.1f, %0.1f, %0.1f, %0.1f \n", 
                                          EYE_LX, EYE_LY, EYE_RX, EYE_RY);
    printf("    -size width height      - Choose the target size for the images.\n");
    printf("                              Defaults to %d, %d \n", SIZE_WIDTH, SIZE_HEIGHT);
    printf("    -pixelNorm <YES/NO>     - Turns on/off pixel value normalization. Defaults to \"Yes\"\n");
    printf("    -postNorm <YES/NO>      - Turns on/off pixel value normalization. Defaults to \"Yes\"\n");
    printf("    -preNorm <YES/NO>       - Turns on a pixel normalization before geometric normalization. Defaults to \"NO\"\n");
    printf("    -preEdge <INT>          - Blends the edge of the image (INT pixels wide) before geometric normalization. Defaults to \"0\"\n");
    printf("    -postEdge <INT>         - Blends the edge of the image (INT pixels wide) after normalization. Defaults to \"NO\"\n");
    printf("    -noise <double>         - Add zero mean Gausian noise to each pixel.\n");
    printf("                              The Standard Deviation is set to argument value times the dynamic\n");
    printf("                              range of the image. Defaults to %f indicating zero noise added.\n", NOISE);
    printf("    -reflect <YES/NO>       - Reflect the image down the center of the face.\n");
    printf("    -half                   - Easy way to produce half sized images.\n");
    printf("    -scale f                - Easy way to produce scaled images.\n");
    printf("    -shift dx dy            - Shift all eye targets by dx and dy.\n");
    printf("							  Default is no shift, i.e. 0 0.\n");
    printf("                              Postive dx moves the face to the left. Postive dy moves the face up.\n");
    printf("  OTHER OPTIONS:\n");
    printf("    -configSuffix           - Normalization configuration encoded in new image file names.\n");
    printf("    -quiet                  - Turns off all messages.\n");
    printf("    -debuglevel <int>       - Turns turns on debuging output.\n");
    exit(1);
}

/*
 * Process the command line and initialize the variables
 */

void processCommand(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    /******* Set up default values *******/
    args->geoType      = CL_YES;
    args->histType     = HIST_POST;
    args->nrmType      = CL_YES;
    args->preNormType  = CL_NO;
    args->maskType     = CL_YES;
    args->preEdge      = EDGE_PRE;
    args->postEdge     = EDGE_POST;

    args->sizeWidth    = SIZE_WIDTH;
    args->sizeHeight   = SIZE_HEIGHT;

    args->eyeLx        = EYE_LX;
    args->eyeLy        = EYE_LY;
    args->eyeRx        = EYE_RX;
    args->eyeRy        = EYE_RY;

    args->scale        = SCALE;
    args->noise        = NOISE;
    args->shiftX       = SHIFT_X;
    args->shiftY       = SHIFT_Y;
    args->reflect      = CL_NO;
    args->configSuffix = CL_NO;

    args->ellipseX     = ELLIPSE_X;
    args->ellipseY     = ELLIPSE_Y;
    args->ellipseA     = ELLIPSE_A;
    args->ellipseB     = ELLIPSE_B;

    args->inputDir     = NULL;
    args->nrmDir       = NULL;
    args->sfiDir       = NULL;
    args->pgmDir       = NULL;

    debuglevel = 0;

    /******* Read command line arguments *******/

    for (i = 1;i < argc;i++) {

        /* Catch common help requests */
        if      (readOption      (argc, argv, &i, "-help" )) { usage(argv[0]); }
        else if (readOption      (argc, argv, &i, "--help")) { usage(argv[0]); }

        /******* Read in output directories *******/
        else if (readOptionString(argc, argv, &i, "-nrm", &(args->nrmDir))){ }
        else if (readOptionString(argc, argv, &i, "-sfi", &(args->sfiDir))){ }
        else if (readOptionString(argc, argv, &i, "-pgm", &(args->pgmDir))){ }

        /* read in shift option */
        else if (readOptionDouble2(argc, argv, &i, "-shift", &(args->shiftX), &(args->shiftY))) { }
        /******* Read in normalization options *******/
        /* Mask parameters */
        else if (readOptionDouble4(argc, argv, &i, "-mask-param", &(args->ellipseX), &(args->ellipseY), &(args->ellipseA), &(args->ellipseB))) { }
        else if (readOptionYesNo(argc, argv, &i, "-mask", &(args->maskType))) { }

        /* size parameters */
        else if (readOptionInt2(argc, argv, &i, "-size",&(args->sizeWidth),&(args->sizeHeight))) { }
        
        /* geometric parameters */
        else if (readOptionDouble4(argc, argv, &i, "-eye-target", &(args->eyeLx), &(args->eyeLy),  &(args->eyeRx), &(args->eyeRy))) { }
        else if (readOptionYesNo  (argc, argv, &i, "-geometric",&(args->geoType))) { }
        else if (readOptionYesNo  (argc, argv, &i, "-reflect"  ,&(args->reflect))) { }
        else if (readOption       (argc, argv, &i, "-half")) { args->scale = 0.5; }
        else if (readOptionDouble (argc, argv, &i, "-scale", &(args->scale))) { }        
        
        /* histogram parameters */
        else if (readOptionMatch(argc, argv, &i, "-hist", "NONE")) { args->histType   = HIST_NONE; }
        else if (readOptionMatch(argc, argv, &i, "-hist", "PRE" )) { args->histType   = HIST_PRE;  }
        else if (readOptionMatch(argc, argv, &i, "-hist", "POST")) { args->histType   = HIST_POST; }

        /* Image Edge Smoothing */
        else if (readOptionInt (argc, argv, &i, "-preEdge", &args->preEdge)) {}
        else if (readOptionInt (argc, argv, &i, "-postEdge", &args->postEdge)) {}
        
        /* Turn on noise */
        else if (readOptionDouble(argc, argv, &i, "-noise", &(args->noise))) { }
        
        /* Turn of ZeroMeanOneStdDev */
        else if (readOptionYesNo(argc, argv, &i, "-pixelNorm", &args->nrmType)) { }

        /* Turn of ZeroMeanOneStdDev */
        else if (readOptionYesNo(argc, argv, &i, "-preNorm", &args->preNormType)) { }

        /* Turn on file name configuration encoding */
        else if (readOption(argc, argv, &i, "-configSuffix")) { args->configSuffix = CL_YES; }

        /* other flags */
        else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
        else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

        /* check if the current argument is an unparsed option */
        else if (checkBadOption(argc,argv,&i)) {}

        /* read required arguments */ 
        else if (param_num == 0) {
            args->eyeFile = argv[i];
            param_num++;
        }
        else if (param_num == 1) {
            args->inputDir = argv[i];
            param_num++;
        }
        else{ clParseError(argc,argv,i,"Wrong number of required arguments"); }
        
    }

    /* make sure that there are the proper number of required arguments */
    if (param_num != 2){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

    /* Print out the program parameters for appropreate debug level */
    DEBUG_CHECK(args->nrmDir || args->pgmDir || args->sfiDir,"You must specify at least one output directory.");

    DEBUG(1,"Debuging enabled");
    if(debuglevel > 0){
        printf("***************** Program Parameters *********************\n");
        printf("Eye coordinates file: %s\n", args->eyeFile ? args->eyeFile : "NONE");
        printf("Input directory:      %s\n", args->inputDir ? args->inputDir : "NONE");
        printf("nrm   directory:      %s\n", args->nrmDir ? args->nrmDir : "NONE");
        printf("sfi   directory:      %s\n", args->sfiDir ? args->sfiDir : "NONE");
        printf("pgm   directory:      %s\n", args->pgmDir ? args->pgmDir : "NONE");
        printf("Output Size:          %dX%d\n", args->sizeWidth, args->sizeHeight);
        printf("Geometric Norm:       %s\n", args->geoType ? "YES" : "NO");
        printf("Eye Target:           (%0.2f %0.2f %0.2f %0.2f)\n", args->eyeLx, args->eyeLy, args->eyeRx, args->eyeRy);
        printf("Histogram Norm:       %d\n", args->histType);
        printf("Value Norm:           %s\n", args->nrmType ? "YES" : "NO");
        printf("Apply Mask:           %s\n", args->maskType ? "YES" : "NO");
        printf("Mirror Reflect:       %s\n", args->reflect ? "YES" : "NO");
        printf("Config Suffix:        %s\n", args->configSuffix ? "YES" : "NO");
        printf("Mask Parameters:      (%0.2f %0.2f %0.2f %0.2f)\n", args->ellipseX, args->ellipseY, args->ellipseA, args->ellipseB);
    }    
}


/* Masks are no longer read from a file.  It is created by scan converting an ellipse. */
double ellipseFunc( double i, double j, double x, double y, double a, double b){
    return 1 - (SQR(x-i)/SQR(a) + SQR(y-j)/SQR(b));
}

char** generateMask(int width, int height, double x, double y, double a, double b){
    char **mask;
    int i,j;

    mask = (char**) malloc(sizeof(char*)*width);
    assert(mask); /* problem allocating space for mask */

    for(i = 0; i < width; i++){
        mask[i] = (char*) malloc(sizeof(char)*height);
        assert(mask[i]); /* problem allocating space for mask */
    }

    for(j = 0; j < height; j++){
        for(i = 0; i < width; i++){
            if(ellipseFunc(i,j,x,y,a,b) > 0){
                mask[i][j] = 1;
            }
            else{
                mask[i][j] = 0;                
            }
        }
    }

    return mask;
}


/********************* Geometric Transformation Code *************************/

/* This function performs a 3X3 two dimentional perspective transform to an image
This is used to perform geomentric normalization */
Image transformImage(Image source, int newWidth, int newHeight, const Matrix m){
    Image dest = makeImage(newWidth, newHeight, source->channels);
    Matrix point = makeMatrix(3,1);
    Matrix inv;
    Matrix pt;
    int x, y, c;

    assert(m->row_dim == 3);
    assert(m->col_dim == 3);

    /* initialize homogenius point */
    ME(point,2,0) = 1;

    /* find the inverse transformation to convert from dest to source */
    inv = invertRREF(m);

    for(x = 0; x < dest->width; x++){
        for(y = 0; y < dest->height; y++){
            /* calculate source point */
            ME(point,0,0) = x;
            ME(point,1,0) = y;
            ME(point,2,0) = 1.0;
            pt = multiplyMatrix(inv, point);
            ME(pt,0,0) = ME(pt,0,0) / ME(pt,2,0);
            ME(pt,1,0) = ME(pt,1,0) / ME(pt,2,0);

            for(c = 0; c < dest->channels; c++){
                /* interpolate value */
                IE(dest,x,y,c) = interpLinear(source, ME(pt,0,0),ME(pt,1,0),c);
            }
            /* clean up */
            freeMatrix(pt);
        }
    }
    freeMatrix(point);
    freeMatrix(inv);

    return dest;
}

/* Return a translation matrix */
Matrix translateMatrix(double dx, double dy){
    Matrix transform = makeIdentityMatrix(3);

    ME(transform,0,2) = dx;
    ME(transform,1,2) = dy;

    return transform;
}

/* Return a scale Matrix */
Matrix scaleMatrix(double s){
    Matrix transform = makeIdentityMatrix(3);
    ME(transform,0,0) = s;
    ME(transform,1,1) = s;

    return transform;
}

/* Return a rotation matrix */
Matrix rotateMatrix(double theta){
    Matrix transform = makeIdentityMatrix(3);

    ME(transform,0,0) = cos(theta);
    ME(transform,1,1) = cos(theta);
    ME(transform,0,1) = -sin(theta);
    ME(transform,1,0) = sin(theta);

    return transform;
}

Matrix reflectMatrix(int bool_x, int bool_y){
    Matrix transform = makeIdentityMatrix(3);

    if(bool_x) ME(transform,0,0) = -1;
    if(bool_y) ME(transform,1,1) = -1;
    return transform;
}


typedef struct {
    FTYPE x1, y1, x2, y2;
} TwoPoints;

Matrix generateTransform(const TwoPoints *source, const TwoPoints *dest, int reflect){
    double sourceMidX = (source->x1 + source->x2)*0.5;
    double sourceMidY = (source->y1 + source->y2)*0.5;
    double destMidX = (dest->x1 + dest->x2)*0.5;
    double destMidY = (dest->y1 + dest->y2)*0.5;
    Matrix translate1 = translateMatrix(-sourceMidX, -sourceMidY); /* translate the left point to the origin */
    Matrix translate2 = translateMatrix(destMidX, destMidY); /* translate the origin to the left destination */

    /* compute the scale that needs to be applyed to the image */
    double sdist = sqrt(SQR(source->x1 - source->x2) + SQR(source->y1 - source->y2));
    double ddist = sqrt(SQR(dest->x1 - dest->x2) + SQR(dest->y1 - dest->y2));
    double s = ddist/sdist; 
    Matrix scale = scaleMatrix(s);

    /* compute the rotation that needs to be applyed to the image */
    double stheta = atan((source->y2 -source->y1)/(source->x2 - source->x1));
    double dtheta = atan((dest->y2 -dest->y1)/(dest->x2 - dest->x1));
    double theta  = dtheta - stheta;
    Matrix rotate = rotateMatrix(theta);

    /* compute the reflection if nessicary */
    Matrix reflection = reflectMatrix(reflect,0);

    /* build the final transformation */
    Matrix tmp1 = multiplyMatrix(scale, translate1);
    Matrix tmp2 = multiplyMatrix(rotate, tmp1);
    Matrix tmp3 = multiplyMatrix(reflection, tmp2);
    Matrix transform = multiplyMatrix(translate2,tmp3);

    /* free temporary matricies */
    freeMatrix(translate1);
    freeMatrix(translate2);
    freeMatrix(scale);
    freeMatrix(rotate);
    freeMatrix(reflection);
    freeMatrix(tmp1);
    freeMatrix(tmp2);
    freeMatrix(tmp3);

    /* return final transformation */
    return transform;
}

void scaleArgs(Arguments* args, double scale){
    args->eyeLx *= scale;
    args->eyeLy *= scale;
    args->eyeRx *= scale;
    args->eyeRy *= scale;

    args->ellipseX *= scale;
    args->ellipseY *= scale;
    args->ellipseA *= scale;
    args->ellipseB *= scale;

    args->sizeWidth  = ROUND(args->sizeWidth*scale);
    args->sizeHeight = ROUND(args->sizeHeight*scale);
}

/*	The code to generate a file suffix will build a string that is
	compact and easily selected for using standard unix "ls". However,
	it is not obvious. Here is the encoding:
		c<0/1>			Apply mask, 0=no, 1=yes	
		f<0/1>			Pixel Value Normalization, 0=no, 1=yes	
		g<0/1>			Geometric Normalization, 0=no, 1=yes
		h<0/1/2>		Histogram Equalization, 0=no, 1=pre, 2=post
		n<0/1>			Indepenent Pixel Gaussian Noise, 0=no, 1=yes
		x<0/1>			Reduce image size by half, 0=no, 1=yes
		m<0/1>          Mirror reflect the image, 0=no, 1=yes
		<l/r/u/d><#>	Shift source image left, right, up or down by amount #	
		or t0           If there is no translational shift.
		
	All but the last are always included in a file name. The shift tag only 
	appears if an image is shifted.
	
	Normal defaulst will produce suffix "c1f1g1h2n0x0"
	*/

char* imageSuffix(Arguments* args) {
	const int len = 32; /* large enough to include shift indicators plus slack */
	char* s       = (char*) malloc(sizeof(char)*len);
	strcpy(s,"c0f0g0h0n0x0m0");  /* Starts out with zeroes as default settings */
	if (args->maskType == CL_YES) 		s[1]  = '1';
	if (args->nrmType  == CL_YES) 		s[3]  = '1';
	if (args->geoType  == CL_YES)		s[5]  = '1';
	if (args->histType == HIST_PRE)  	s[7]  = '1';
	if (args->histType == HIST_POST) 	s[7]  = '2';
	if (args->noise    != 0.0)			s[9]  = '1';
	if (args->scale    == 0.5)			s[11] = '1';
	if (args->reflect  == CL_YES)	    s[13] = '1';					
	if (args->shiftX < 0.0) 			sprintf(s,"%s%s%d", s, "r", (int) ceil(-args->shiftX));
	if (args->shiftX > 0.0) 			sprintf(s,"%s%s%d", s, "l", (int) ceil( args->shiftX));
	if (args->shiftY < 0.0) 			sprintf(s,"%s%s%d", s, "d", (int) ceil(-args->shiftY));
	if (args->shiftY > 0.0) 			sprintf(s,"%s%s%d", s, "u", (int) ceil( args->shiftY));		
	if (args->shiftX == 0.0 && args->shiftY == 0.0) sprintf(s,"%s%s", s, "t0");
	return s;
}

void convertImages(Arguments* args){
    char** mask = NULL;
    TwoPoints source, dest;
    FILE* eyeList;
    char line[ FILE_LINE_LENGTH ];
    char filename[MAX_FILENAME_LENGTH];
    char imagename[MAX_FILENAME_LENGTH];
    char suffix[MAX_FILENAME_LENGTH];
    int i;

    scaleArgs(args, args->scale);
    
    dest.x1 = args->eyeLx;
    dest.y1 = args->eyeLy;
    dest.x2 = args->eyeRx;
    dest.y2 = args->eyeRy;
    
	/* Prepare file suffix encoding preprocessing settings, blank if not requested */
	if (args->configSuffix) {
		sprintf(suffix,"_%s", imageSuffix(args)); }
	else {
		suffix[1] = '\0'; }	

    if(args->maskType == CL_YES){
        MESSAGE("Creating Mask.");
        mask = generateMask(args->sizeWidth, args->sizeHeight, args->ellipseX, args->ellipseY, args->ellipseA, args->ellipseB);
    }

    eyeList = fopen(args->eyeFile,"r");
    DEBUG_CHECK(eyeList,"Error opening eye coordinates file");

    for(i = 1;;i++){
        Image pgm;
        Image geo;
        Matrix transform;
        
        fgets(line, FILE_LINE_LENGTH, eyeList);
        if(feof(eyeList)) break;

        if(sscanf(line,"%s %lf %lf %lf %lf",filename, &(source.x1), &(source.y1), &(source.x2), &(source.y2)) != 5){
            printf("Error parsing line %d of eye coordinate file. Exiting...",i);
            exit(1);
        }

        /* shift the eye coordinates if neccessary */
        source.x1 += args->shiftX;
        source.y1 += args->shiftY;
        source.x2 += args->shiftX;
        source.y2 += args->shiftY;

        sprintf(imagename,"%s/%s.pgm",args->inputDir,filename);

        MESSAGE1ARG("Processing image: %s",filename);
        
        pgm = readPGMImage(imagename);

        if(args->histType == HIST_PRE){
            DEBUG(1,"   Performing Pre Histogram Equalization.");
            histEqual(pgm,256);
        }

        if(args->preNormType == CL_YES){
            DEBUG(1,"   Performing Pre Pixel Normalization.");
            ZeroMeanOneStdDev(pgm);
        }
        
        if(args->preEdge){
            smoothImageEdge(pgm, args->preEdge);
        }

        if(args->geoType == CL_YES){
            DEBUG(1,"   Performing Geometric Normalization.");
            transform = generateTransform(&source,&dest,args->reflect);
            geo = transformImage(pgm,args->sizeWidth,args->sizeHeight,transform);
        }
        else{
            transform = makeIdentityMatrix(3);
            geo = transformImage(pgm,args->sizeWidth,args->sizeHeight,transform);
        }

        if(args->noise != 0.0){
            DEBUG(1,"   Adding Gausian Noise.");
            gaussianNoise(geo,args->noise);
        }
            

        if(args->histType == HIST_POST){
            DEBUG(1,"   Performing Post Histogram Equalization.");
            histEqualMask(geo,256, (const char**) mask);
        }

        if(args->nrmType == CL_YES){
            DEBUG(1,"   Performing final value normalization and Applying Mask.");
            ZeroMeanOneStdDevMasked(geo, (const char **) mask);
        }
        else{
            DEBUG(1,"   No Value Normalization. Just Applying Mask.");
            applyMask(geo, (const char **) mask);
        }

        if(args->postEdge){
            smoothImageEdge(geo, args->postEdge);
        }
        
        if(args->nrmDir){
            sprintf(imagename,"%s/%s%s.nrm", args->nrmDir, filename, suffix);
            DEBUG_STRING(1,"   Saving nrm: %s",imagename);
            writeFeretImage(geo,imagename);
        }
        if(args->pgmDir){
            sprintf(imagename,"%s/%s%s.pgm", args->pgmDir, filename, suffix);
            DEBUG_STRING(1,"   Saving pgm: %s",imagename);
            writePGMImage(geo,imagename,0);
        }
        if(args->sfiDir){
            sprintf(imagename,"%s/%s%s.sfi", args->sfiDir, filename, suffix);
            DEBUG_STRING(1,"   Saving sfi: %s",imagename);
            writeRawImage(geo,imagename);
        }

        freeImage(geo);
        freeImage(pgm);
        freeMatrix(transform);
    }

    fclose(eyeList);
    
}

int main(int argc, char** argv){
    Arguments args;
    processCommand(argc, argv, &args);
    MESSAGE(OPENING);
    MESSAGE(VERSION);

    MESSAGE("Converting Images...");
    convertImages(&args);

    return 0;
}






/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*///////////////////////////////////////////////////////////////////////////////////////
//  
//                      INTEL CORPORATION PROPRIETARY INFORMATION              
//         This software is supplied under the terms of a license agreement or 
//         nondisclosure agreement with Intel Corporation and may not be copied
//         or disclosed except in accordance with the terms of that agreement. 
//               Copyright (c) 1999 Intel Corporation. All Rights Reserved.    
//  
//    RCS:
//       $Source: /s/parsons/i/proj/vision5/HumanID/cvsroot/csuFaceIdEval.4.0/src/csuSubspaceCVEigen.c,v $
//       $Revision: 1.1.1.1 $
//      Purpose: 
//      Contents:
//      Authors:
//        Dmitry Abrosimov
//*/

#include <math.h>

/*///////////////////////////////////////////////////////////////////////////////////////
//    Names:      cvJacobiEigens_32f, cvJacobiEigens_64d
//    Purpose:    Eigenvalues & eigenvectors calculation of a symmetric matrix:
//                A Vi  =  Ei Vi
//    Context:   
//    Parameters: A(n, n) - source symmetric matrix (n - rows & columns number),
//                V(n, n) - matrix of its eigenvectors 
//                          (i-th row is an eigenvector Vi),
//                E(n)    - vector of its eigenvalues
//                          (i-th element is an eigenvalue Ei),
//                eps     - accuracy of diagonalization.
//               
//    Returns:
//    CV_NO_ERROR or error code     
//    Notes:
//        1. The functions destroy source matrix A, so if you need it after
//           running cvJacobiEigens_???, you must copy it before.
//        2. Eigenvalies and eigenvectors are sorted in Ei absolute value descending.
//        3. Calculation time depends on eps value. If the time isn't very important,
//           we recommend to set eps = 0.
//*/

/*=========================== Single precision function ================================*/

int cvJacobiEigens_32f ( float* A,
                     float* V,
                     float* E,
                     int n,
                     float eps ) {
    int i, j, k, ind;
    float *AA = A, *VV = V;
    double Amax, anorm = 0, ax;

    /*if ( A == NULL || V == NULL || E == NULL ) return CV_NULLPTR_ERR;*/
    /*if ( n <= 0 )                              return CV_BADSIZE_ERR;*/
    if (eps < 1.0e-7f )
        eps = 1.0e-7f;

    /*-------- Prepare --------*/
    for (i = 0; i < n; i++, VV += n, AA += n) {
        for (j = 0; j < i; j++) {
            double Am = AA[j];
            anorm += Am * Am;
        }
        for (j = 0; j < n; j++)
            VV[j] = 0.f;
        VV[i] = 1.f;
    }

    anorm = sqrt( anorm + anorm );
    ax = anorm * eps / n;
    Amax = anorm;

    while ( Amax > ax ) {
        Amax /= n;
        do  /* while (ind) */
        {
            int p, q;
            float *V1 = V, *A1 = A;
            ind = 0;
            for (p = 0; p < n - 1; p++, A1 += n, V1 += n) {
                float * A2 = A + n * (p + 1), *V2 = V + n * (p + 1);
                for (q = p + 1; q < n; q++, A2 += n, V2 += n) {
                    double x, y, c, s, c2, s2, a;
                    float *A3, Apq = A1[q], App, Aqq, Aip, Aiq, Vpi, Vqi;
                    if ( fabs( Apq ) < Amax )
                        continue;

                    ind = 1;

                    /*---- Calculation of rotation angle's sine & cosine ----*/
                    App = A1[p];
                    Aqq = A2[q];
                    y = 5.0e-1 * (App - Aqq);
                    x = -Apq / sqrt(Apq * Apq + y * y);
                    if (y < 0.0)
                        x = -x;
                    s = x / sqrt(2.0 * (1.0 + sqrt(1.0 - x * x)));
                    s2 = s * s;
                    c = sqrt(1.0 - s2);
                    c2 = c * c;
                    a = 2.0 * Apq * c * s;

                    /*---- Apq annulation ----*/
                    A3 = A;
                    for (i = 0; i < p; i++, A3 += n) {
                        Aip = A3[p];
                        Aiq = A3[q];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A3[p] = (float)(Aip * c - Aiq * s);
                        A3[q] = (float)(Aiq * c + Aip * s);
                        V1[i] = (float)(Vpi * c - Vqi * s);
                        V2[i] = (float)(Vqi * c + Vpi * s);
                    }
                    for (; i < q; i++, A3 += n) {
                        Aip = A1[i];
                        Aiq = A3[q];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A1[i] = (float)(Aip * c - Aiq * s);
                        A3[q] = (float)(Aiq * c + Aip * s);
                        V1[i] = (float)(Vpi * c - Vqi * s);
                        V2[i] = (float)(Vqi * c + Vpi * s);
                    }
                    for (; i < n; i++) {
                        Aip = A1[i];
                        Aiq = A2[i];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A1[i] = (float)(Aip * c - Aiq * s);
                        A2[i] = (float)(Aiq * c + Aip * s);
                        V1[i] = (float)(Vpi * c - Vqi * s);
                        V2[i] = (float)(Vqi * c + Vpi * s);
                    }
                    A1[p] = (float)(App * c2 + Aqq * s2 - a);
                    A2[q] = (float)(App * s2 + Aqq * c2 + a);
                    A1[q] = A2[p] = 0.0f;
                } /*q*/
            }     /*p*/
        } while (ind);
        Amax /= n;
    }   /* while ( Amax > ax ) */

    for (i = 0, k = 0; i < n; i++, k += n + 1)
        E[i] = A[k];
    /*printf(" M = %d\n", M);*/

    /* -------- ordering --------*/
    for (i = 0; i < n; i++) {
        int m = i;
        float Em = (float)fabs(E[i]);
        for (j = i + 1; j < n; j++) {
            float Ej = (float)fabs(E[j]);
            m = ( Em < Ej ) ? j : m;
            Em = ( Em < Ej ) ? Ej : Em;
        }
        if ( m != i ) {
            int l;
            float b = E[i];
            E[i] = E[m];
            E[m] = b;
            for (j = 0, k = i * n, l = m * n; j < n; j++, k++, l++) {
                b = V[k];
                V[k] = V[l];
                V[l] = b;
            }
        }
    }

    return 0;
}

/*=========================== Double precision function ================================*/

int cvJacobiEigens_64d( double* A,
                    double* V,
                    double* E,
                    int n,
                    double eps ) {
    int i, j, k, p, q, ind;
    double *A1 = A, *V1 = V, *A2 = A, *V2 = V;
    double Amax = 0.0, anorm = 0.0, ax, deps;

    /*if ( A == NULL || V == NULL || E == NULL ) return CV_NULLPTR_ERR;*/
    /*if ( n <= 0 )                              return CV_BADSIZE_ERR;*/
    if (eps < 1.0e-15 )
        eps = 1.0e-15;
    deps = eps / (double)n;

    /*-------- Prepare --------*/
    for (i = 0; i < n; i++, V1 += n, A1 += n) {
        for (j = 0; j < i; j++) {
            double Am = A1[j];
            anorm += Am * Am;
        }
        for (j = 0; j < n; j++)
            V1[j] = 0.0;
        V1[i] = 1.0;
    }

    anorm = sqrt( anorm + anorm );
    ax = anorm * eps / n;
    Amax = anorm;

    while ( Amax > ax ) {
        Amax /= n;
        do  /* while (ind) */
        {
            ind = 0;
            A1 = A;
            V1 = V;
            for (p = 0; p < n - 1; p++, A1 += n, V1 += n) {
                A2 = A + n * (p + 1);
                V2 = V + n * (p + 1);
                for (q = p + 1; q < n; q++, A2 += n, V2 += n) {
                    double x, y, c, s, c2, s2, a;
                    double *A3, Apq, App, Aqq, App2, Aqq2, Aip, Aiq, Vpi, Vqi;
                    if ( fabs( A1[q] ) < Amax )
                        continue;
                    Apq = A1[q];

                    ind = 1;

                    /*---- Calculation of rotation angle's sine & cosine ----*/
                    App = A1[p];
                    Aqq = A2[q];
                    y = 5.0e-1 * (App - Aqq);
                    x = -Apq / sqrt(Apq * Apq + y * y);
                    if (y < 0.0)
                        x = -x;
                    s = x / sqrt(2.0 * (1.0 + sqrt(1.0 - x * x)));
                    s2 = s * s;
                    c = sqrt(1.0 - s2);
                    c2 = c * c;
                    a = 2.0 * Apq * c * s;

                    /*---- Apq annulation ----*/
                    A3 = A;
                    for (i = 0; i < p; i++, A3 += n) {
                        Aip = A3[p];
                        Aiq = A3[q];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A3[p] = Aip * c - Aiq * s;
                        A3[q] = Aiq * c + Aip * s;
                        V1[i] = Vpi * c - Vqi * s;
                        V2[i] = Vqi * c + Vpi * s;
                    }
                    for (; i < q; i++, A3 += n) {
                        Aip = A1[i];
                        Aiq = A3[q];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A1[i] = Aip * c - Aiq * s;
                        A3[q] = Aiq * c + Aip * s;
                        V1[i] = Vpi * c - Vqi * s;
                        V2[i] = Vqi * c + Vpi * s;
                    }
                    for (; i < n; i++) {
                        Aip = A1[i];
                        Aiq = A2[i];
                        Vpi = V1[i];
                        Vqi = V2[i];
                        A1[i] = Aip * c - Aiq * s;
                        A2[i] = Aiq * c + Aip * s;
                        V1[i] = Vpi * c - Vqi * s;
                        V2[i] = Vqi * c + Vpi * s;
                    }
                    App2 = App * c2 + Aqq * s2 - a;
                    Aqq2 = App * s2 + Aqq * c2 + a;
                    A1[p] = App2;
                    A2[q] = Aqq2;
                    A1[q] = A2[p] = 0.0;
                } /*q*/
            }     /*p*/
        } while (ind);
    }   /* while ( Amax > ax ) */

    for (i = 0, k = 0; i < n; i++, k += n + 1)
        E[i] = A[k];

    /* -------- ordering --------*/
    for (i = 0; i < n; i++) {
        int m = i;
        double Em = fabs(E[i]);
        for (j = i + 1; j < n; j++) {
            double Ej = fabs(E[j]);
            m = ( Em < Ej ) ? j : m;
            Em = ( Em < Ej ) ? Ej : Em;
        }
        if ( m != i ) {
            int l;
            double b = E[i];
            E[i] = E[m];
            E[m] = b;
            for (j = 0, k = i * n, l = m * n; j < n; j++, k++, l++) {
                b = V[k];
                V[k] = V[l];
                V[l] = b;
            }
        }
    }

    return 0;
}

/* End of file */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "csuCommon.h"

/*
  eigen_verify
 
  Verify properties of the eigen vectors.
 
  The eigenbasis should be ortonormal: R'*R - I == 0
  The basis should be decomposed such that: MR - RD == 0
  returns true if tests fail.
*/
int eigen_verify(Matrix M, Matrix lambda, Matrix R) {
    Matrix RtR = transposeMultiplyMatrixL(R, R);
    Matrix identity = makeIdentityMatrix(R->col_dim);

    Matrix MR = multiplyMatrix(M, R);
    Matrix D = makeIdentityMatrix(lambda->row_dim);
    Matrix RD;
    Matrix test;
    int i, j;
    int failed = 0;
    const double tol = 1.0e-7;

    for (i = 0; i < lambda->row_dim; i++) {
        ME(D, i, i) = ME(lambda, i, 0);
    }
    RD = multiplyMatrix(R, D);
    freeMatrix(D);

    DEBUG(2, "Checking orthogonality of eigenvectors");
    test = subtractMatrix(RtR, identity);
    freeMatrix(RtR);
    freeMatrix(identity);

    for (i = 0; i < test->row_dim; i++) {
        for (j = 0; j < test->col_dim; j++) {
            if (!EQUAL_ZERO(ME(test, i, j), tol)) {
                failed = 1;
                MESSAGE("Eigenvectors are not orthogonal to within tolerance.");
                DEBUG_DOUBLE(1, "Matrix Element", ME(test, i, j));
                DEBUG_DOUBLE(1, "Tolerance", tol);
                exit(1);
            }
        }
    }
    freeMatrix(test);

    DEBUG(2, "Checking reconstruction property of eigensystem");
    test = subtractMatrix(MR, RD);
    freeMatrix(MR);
    freeMatrix(RD);

    for (i = 0; i < test->row_dim; i++) {
        for (j = 0; j < test->col_dim; j++) {
            if (!EQUAL_ZERO(ME(test, i, j), tol)) {
                failed = 1;
                MESSAGE("Covariance matrix is not reconstructable to within tolerance.");
                DEBUG_DOUBLE(1, "Matrix Element", ME(test, i, j));
                DEBUG_DOUBLE(1, "Tolerance", tol);
                exit(1);
            }
        }
    }
    freeMatrix(test);

    return failed;
}


/**
  Verify properties of the eigen basis used for pca.
 
  The eigenbasis should be ortonormal: U'*U - I == 0
  The basis should be decomposed such that: X == U*D*V'
 
  returns true if tests fail.
*/
int basis_verify(Matrix X, Matrix U) {
    Matrix UtX = transposeMultiplyMatrixL(U, X);
    Matrix UUtX = multiplyMatrix(U, UtX);
    Matrix UtU = transposeMultiplyMatrixL(U, U);
    Matrix identity = makeIdentityMatrix(U->col_dim);
    Matrix test;
    int i, j;
    int failed = 0;
    const double tol = 1.0e-7;

    freeMatrix(UtX);

    DEBUG(2, "Checking orthogonality of eigenbasis");
    test = subtractMatrix(UtU, identity);
    freeMatrix(UtU);
    freeMatrix(identity);

    for (i = 0; i < test->row_dim; i++) {
        for (j = 0; j < test->col_dim; j++) {
            if (!EQUAL_ZERO(ME(test, i, j), tol)) {
                failed = 1;
                MESSAGE("Eigenbasis is not orthogonal to within tolerance.");
                DEBUG_DOUBLE(1, "Matrix Element", ME(test, i, j));
                DEBUG_DOUBLE(1, "Tolerance", tol);
                exit(1);
            }
        }
    }
    freeMatrix(test);

    DEBUG(2, "Checking reconstruction property of the eigen decomposition");
    test = subtractMatrix(X, UUtX);
    freeMatrix(UUtX);

    for (i = 0; i < test->row_dim; i++) {
        for (j = 0; j < test->col_dim; j++) {
            if (!EQUAL_ZERO(ME(test, i, j), tol)) {
                failed = 1;
                MESSAGE("Data matrix is not reconstructable to within tolerance.");
                DEBUG_DOUBLE(1, "Matrix Element", ME(test, i, j));
                DEBUG_DOUBLE(1, "Tolarence", tol);
                exit(1);
            }
        }
    }
    freeMatrix(test);

    return failed;


}

/**
eigentrain
 
computes the eigen space for matrix images.
 
  This function is used in the training procedure of the face recognition pca
   algorithm.
   INPUT:  the data matrix of images
   OUTPUT: mean: the mean value of the images
           eigen_values: eigenvalues
           eigen_base: eigenvectors
           
   The data matrix is mean centered, and this is a side effect.
*/
void eigentrain(Matrix *mean, Matrix *eigen_vals,
                Matrix *eigen_base, Matrix images) {
    FTYPE p = 0.0;
    Matrix M, eigenvectors;

    DEBUG(1, "Calculating mean image.");
    *mean = get_mean_image(images);

    DEBUG(1, "Calculating the mean centered images for the training set.");
    mean_subtract_images(images, *mean);

    MESSAGE2ARG("Calculating Covariance Matrix: M = images' * images. M is a %d by %d Matrix.", images->col_dim, images->col_dim);
    M = transposeMultiplyMatrixL(images, images);
    DEBUG_INT(3, "Covariance Matrix Rows", M->row_dim);
    DEBUG_INT(3, "Covariance Matrix Cols", M->col_dim);

    DEBUG(2, "Allocating memory for eigenvectors and eigenvalues.");
    eigenvectors = makeMatrix(M->row_dim, M->col_dim);
    *eigen_vals = makeMatrix(M->row_dim, 1);

    MESSAGE("Computing snap shot eigen vectors using the double precision cv eigensolver.");
    cvJacobiEigens_64d(M->data, eigenvectors->data, (*eigen_vals)->data, images->col_dim, p);
    freeMatrix(M);

    DEBUG(1, "Verifying the eigen vectors");
    /* Reconstruct M because it is destroyed in cvJacobiEigens */
    M = transposeMultiplyMatrixL(images, images);
    if (debuglevel >= 3)
        eigen_verify(M, *eigen_vals, eigenvectors);
    freeMatrix(M);

    *eigen_base = multiplyMatrix(images, eigenvectors);
    MESSAGE2ARG("Recovered the %d by %d high resolution eigen basis.", (*eigen_base)->row_dim, (*eigen_base)->col_dim);

    DEBUG(1, "Normalizing eigen basis");
    basis_normalize(*eigen_base);

    /*Remove last elements because they are unneeded.  Mean centering the image
      guarantees that the data points define a hyperplane that passes through
      the origin. Therefore all points are in a k - 1 dimensional subspace.
    */
    (*eigen_base)->col_dim -= 1;
    (*eigen_vals)->row_dim -= 1;
    eigenvectors->col_dim -= 1;

    DEBUG(1, "Verifying eigenbasis");
    if (debuglevel >= 3)
        basis_verify(images, *eigen_base);

    /* The eigenvectors for the smaller covariance (snap shot) are not needed */
    freeMatrix(eigenvectors);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/* CSU Headers */
#include "csuCommon.h"

/*
  subtractClassMean
  
  This function is used to subtract a mean vector from a class of images.
  The class is stored in contiguous vectors in the class matrix.  classStart
  and classEnd are the first and last vectors in the class.  The vectors in
  classmatrix are subtracted in place.  This function is expected to be called
  one time for each class.
 */
void subtractClassMean(Matrix classmatrix, int classStart, int classEnd) {
    int i, j;
    Matrix mean = makeMatrix(classmatrix->row_dim, 1);


    for (i = 0; i < classmatrix->row_dim; i++) {
        ME(mean, i, 0) = 0.0;
        for (j = classStart; j <= classEnd; j++)
            ME(mean, i, 0) += ME(classmatrix, i, j);
        ME(mean, i, 0) = ME(mean, i, 0) / (classEnd - classStart + 1);
    }
    for (i = 0; i < classmatrix->row_dim; i++) {
        for (j = classStart; j <= classEnd; j++) {
            ME(classmatrix, i, j) -= ME(mean, i, 0);
        }
    }
    freeMatrix(mean);
}


void fisherVerify(Matrix fisherBasis, Matrix fisherValues, Matrix Sw, Matrix Sb) {
    Matrix SbW = multiplyMatrix(Sb, fisherBasis);
    Matrix SwW = multiplyMatrix(Sw, fisherBasis);
    Matrix D = makeIdentityMatrix(fisherBasis->row_dim);
    Matrix DSwW;
    Matrix zeroMat;
    int i, j;


    MESSAGE("Verifying Fisher Basis.");

    for (i = 0; i < D->row_dim; i++) {
        ME(D, i, i) = ME(fisherValues, i, 0);
    }

    DSwW = multiplyMatrix(D, SwW);
    zeroMat = subtractMatrix(SbW, DSwW);

    for (i = 0; i < zeroMat->row_dim; i++) {
        for (j = 0; j < zeroMat->col_dim; j++) {
            if (!EQUAL_ZERO(ME(zeroMat, i, j), 0.000001)) {
                DEBUG( -1, "Fisher validation failed.");
                printf("Element: (%d,%d) value = %f", i, j, ME(zeroMat, i, j));
                exit(1);
            }
        }
    }
}



/*  findWCSMatrix
  
   This function creates the within-class scatter matrix 'Sw' as
   described in Duda, "Pattern Classification", p.121.
   
   This function takes advantage of the fact that the images for each class 
   are stored in consecutive columns of the data matrix. There is an outer 
   loop through the classes, i.e. subjects, and for each subject, the start
   and finish column indices are determined. Then the data columns for just that 
   class are mean centered. From this, the portion of the scatter
   matrix contributed by this class is created by the outer product of the 
   data matrix with itself, and this is in turn, added into the within 
   class scatter matrix. When done iterating over the classes, the results
   is the final within class scatter matrix.
 */

Matrix findWCSMatrix(Matrix imspca, ImageList* srt, int *numberOfClasses, int writeTextInterm) {
    Matrix Sw;
    Matrix classmatrix = duplicateMatrix(imspca);
    ImageList *subject, *replicate;
    int maxClassSize = 0;
    int repCount;

    *numberOfClasses = 0;
    MESSAGE("Finding within-class scatter matrix.");
    for (subject = srt; subject; subject = subject->next_subject) {
        int classStart, classEnd;
        (*numberOfClasses)++;  /* Count the number of classes */

        DEBUG(3, "Finding the class indexes.");
        classStart = classEnd = subject->imageIndex;
        repCount = 0;
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            repCount ++;
            classEnd = replicate->imageIndex;
        }

        if (repCount > maxClassSize) { maxClassSize = repCount; }

        if (repCount == 1 && !quiet) {
            printf("WARNING: class %d only contains one image.\n", *numberOfClasses);
        }

        DEBUG_INT(4, "Lower limit on class.", classStart);
        DEBUG_INT(4, "Upper limit on class.", classEnd);
        DEBUG(3, "Mean centering the class.");
        subtractClassMean(classmatrix, classStart, classEnd);

    }

    DEBUG_CHECK(maxClassSize > 1, "ERROR: at least one class must have more than one replicate.  Make sure your image list is not flat.");

    if (debuglevel > 3)
        printMatrix("classmatrix", classmatrix);

    if (writeTextInterm) { SAVE_MATRIX(classmatrix); } /* output textfiles of intermediate matrices */

    DEBUG(3, "Creating the class scatter matrix.");
    Sw = transposeMultiplyMatrixR(classmatrix, classmatrix);

    if (debuglevel > 3)
        printMatrix("Sw", Sw);
    return Sw;
}


/*  findBCSMatrix
 
 The approach here is to use equation 116 on p. 122 of
 Duda, "Pattern Classification" to solve for the between
 class scatter matrix. The equation reads:
 
 St = Sw + Sb  (St is total scatter matrix)
 
 Solving for Sb,  Sb = St - Sw. Note Sw is computed above.
 
 The total scatter matrix is easy to compute, it is what we
 think of as the covariance matrix when the points have been
 centered.
 */
Matrix findBCSMatrix(Matrix imspca, Matrix Sw) {
    Matrix Sb;
    Matrix St;
    Matrix mean;

    MESSAGE("Finding between-class scatter matrix.");

    mean = get_mean_image(imspca);
    mean_subtract_images(imspca, mean);

    DEBUG(3, "Producing total scatter matrix");
    St = transposeMultiplyMatrixR(imspca, imspca);

    DEBUG(2, "Producing between-class scatter matrix");
    Sb = subtractMatrix(St, Sw);

    freeMatrix(St);
    freeMatrix(mean);

    return Sb;
}

/*  Rw will be the eigenvectors for the within class scatter matrix
    Sw will be the square roots of the eigenvalues for the within class scatter matrix
    These are thought of in terms of a rotation (and reflection) and scale change operator
    that tranforms the imspca points into a new space the within class variance is equal
    in all dimensions.
 
    The between class scatter matrix is transformed into this new space and then its
    eigenvectors and values are determined. The fisher basis vectors are then derived
    by backward mapping the resulting eigen vectors into the original space. If this is
    not clear, and it probably is not, see the paper: "The Geometry of LDA nad PCA
    classifiers Illustrated with 3D Examples, J. Ross Beveridge, CSU Technical Report
    01-101". It is available under papers at
    http://www.cs.colostate.edu/evalfacerec/index.html
 
     */

void fisherTrain(Matrix imspca, ImageList *srt, Matrix *fisherBasis, Matrix *fisherValues, int writeTextInterm) {
    int i;
    int numberOfClasses;
    Matrix G, N, Tmp;
    Matrix Rw = makeIdentityMatrix(imspca->row_dim);
    Matrix Siw = makeIdentityMatrix(imspca->row_dim);
    Matrix Ev = makeMatrix(imspca->row_dim, 1);
    Matrix Evecs = makeMatrix(imspca->row_dim, imspca->row_dim);
    Matrix Mw = findWCSMatrix(imspca, srt, &numberOfClasses, writeTextInterm);
    Matrix Mb = findBCSMatrix(imspca, Mw);
    *fisherValues = makeMatrix(imspca->row_dim, 1);

    MESSAGE2ARG("LDA Training started with %d classes and %d total training images.", numberOfClasses, imspca->col_dim);

    if (writeTextInterm) { SAVE_MATRIX(Mw); SAVE_MATRIX(Mb); } /* output textfiles of intermediate matrices */


    MESSAGE("Computing eigenspace decomposition of within class scatter matrix.");
    cvJacobiEigens_64d(Mw->data, Rw->data, Ev->data, Mw->row_dim, 0.0);

    MESSAGE("Computing the inverse scale matrix derived from eigenvalues and transformed scatter matrix.");
    for (i = 0; i < Ev->row_dim; i++)
        ME(Siw, i, i) = (ME(Ev, i, 0) <= 0.0) ? 0.0 : 1 / ( sqrt( ME(Ev, i, 0) ) );

    G = transposeMultiplyMatrixR(Siw, Rw);
    Tmp = transposeMultiplyMatrixR(Mb, G);
    N = multiplyMatrix(G, Tmp);
    freeMatrix(Tmp);

    if (writeTextInterm) {
        SAVE_MATRIX(Rw);
        SAVE_MATRIX(Ev);
        SAVE_MATRIX(N);
        SAVE_MATRIX(G);
        SAVE_MATRIX(Siw);
    } /* output textfiles of intermediate matrices */

    MESSAGE("Computing eigenspace of transformed between class scatter matrix.");
    cvJacobiEigens_64d(N->data, Evecs->data, (*fisherValues)->data, N->row_dim, 0.0);
    DEBUG(3, "FINSISHED");

    Tmp = multiplyMatrix(Siw, Evecs);
    DEBUG(1, "Calculating fisher basis");
    *fisherBasis = multiplyMatrix(Rw, Tmp);

    if (writeTextInterm) { SAVE_MATRIX(*fisherBasis); SAVE_MATRIX(*fisherValues); SAVE_MATRIX(Evecs); } /* output textfiles of intermediate matrices */

    /* The following verification code does not seem to work so it has been commented out. */
    /* fisherVerify(*fisherBasis, *fisherValues, Mw, Mb); */

    /* Crop the basis to the proper number of vectors */
    (*fisherBasis)->col_dim = numberOfClasses - 1;
    (*fisherValues)->row_dim = numberOfClasses - 1;

    basis_normalize(*fisherBasis);

    MESSAGE2ARG("Completed LDA Training. Fisher basis projection matrix has dimensions %d by %d.", (*fisherBasis)->row_dim, (*fisherBasis)->col_dim);

    /*Freeing memory allocated during LDA Training. */
    freeMatrix(Tmp);
    freeMatrix(Rw);
    freeMatrix(Siw);
    freeMatrix(Ev);
    freeMatrix(Mw);
    freeMatrix(Mb);
    freeMatrix(G);
    freeMatrix(N);
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
File: csuSubspaceProject.c                                                     
Authors: J. Ross Beveridge, David Bolme, Kai She                            
Date: May 24, 2002                                                       
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#define OPENING  "Project Test Images int Subspace and Compute Pairwise Distances."
#define PRINT_MAT_DIM 0
/*
 Purpose: This program projects face images into a subspace and then
 computes the distances between faces with one of several alternative
 distance measures. The subspace is defined in a training file produced
 by csuSubspaceTrain.  The subspace may be either a simple PCA
 subspace, or it may be a PCA followed by LDA subspace. The images are
 specified in a file of image names. These may be grouped either as one
 name per line or several, although for this program there is no
 difference between the two in terms of what is done.  The resulting
 distances are written out to a series of files, one per image, all
 placed in a user specified directory.
*/

/*  CSU INCLUDES */
#include "csuCommon.h"

#if defined(THRD) 
#include "threading.h"
#include <pthread.h>
#endif

/*
 The command line arguments are managed by a single structure.
*/
typedef struct distDirNode {
    struct distDirNode *next;
    char* distDirectory;
    char* distName;
}
DistDirNode;

typedef struct {
    char* trainingFile;
    char* imageNamesFile;
    char* imageDirectory;
    DistDirNode* distList;
    int argc;
    char **argv;
    int lastphase;
    char* ind_name;
    char* of_name;
    char* of_dir;
    char* subspace_name;
}
Arguments;

#ifdef THRD
typedef struct {
  int id;
  Matrix ims;
  Matrix values;
  Matrix distances;
  Matrix optVals;
  int numImages;
  char* distName;
  int startj, endj;
} dist_thrd_args;
#endif

/* ----------------------------------------------------------------------------------- */
/* Remind the user the usage of running this program.
   The command of running the program should be: run and the index of the training sets. 
   All the other sets except the training sets will go to testing sets automatically.
   INPUT:  prog is the excutable program name.
*/
void usage(const char* prog) {
    printf("Usage: %s [OPTIONS] trianingFile imageNamesFile.[list/srt] [distanceDirectory distName]+\n", prog);
    printf("  Parameters:\n");
    printf("     trainingFile ....  Name of file containing subspace generated by training.\n");
    printf("     imageNamesFile...  Name of file containing test images: union of possible probe and gallery sets.\n");
    printf("  List of distance measures and corresponding distance directories: \n");
    printf("     distDirectory ...  Directory where distances files are to be written\n");
    printf("     distName ........  The distance measure to use, must be one of:\n");
    printf("        Euclidean ....  Standard Euclidean Distance, i.e. L2 norm.\n");
    printf("        Cityblock ....  Standard L1 norm.\n");
    printf("        Covariance ...  Sometimes called angle in FERET: dot product after unit normalization.\n");
    printf("        Correlation ..  Normalize images to mean zero and standard deviation one, then take dot product.\n");
    printf("        MahCosine ....  This measure is the cosine of the angle between the two feature vectors in Mahlinobis space.\n");
    printf("        MahL1 ........  L1 norm distance in Mahalanobis space.\n");
    printf("        MahL2 ........  L2 norm distance in Mahalanobis space.\n");
    printf("        YamborAngle ..  This is the same measure as \"MahAngle\" in \n"
           "                        version 4.0 and before.  It has been depricated \n"
	   "                        because the measure is not properly formulated.  \n"
	   "                        MahCosine has replaced it in newer versions. \n");
    printf("        YamborDist ...  This is the distance measure presented as \n"
           "                        \"Mahalinobis Distance\" in Wendy Yambor's \n"
	   "                        Thesis.  It is included here for completness.\n");
    printf("        ldaSoft ......  For LDA only, a variant of L2 use by Wenyi Zhao that weights dimensions by lambda.\n");
    printf("    -imDir <dir>:       image directory. DEFAULT = \".\"\n");
    printf("    -debuglevel <int>:  Level of debug information to display. DEFAULT = 0\n");
    printf("    -quiet:             Turn off all messages. DEFAULT = messages on\n");

    exit(1);
}

void process_command(int argc, char** argv, Arguments* args) {
    int i;
    int param_num = 0;

    /******* Set up default values *******/

    args->argc = argc;
    args->argv = argv;

    args->imageDirectory = strdup (".");

    args->distList = NULL;

    quiet = 0;
    debuglevel = 0;
    args->lastphase = 0;
    args->ind_name = strdup (".");
    args->of_name = strdup (".");
    args->of_dir = strdup (".");
    args->subspace_name=strdup (".");

    for (i = 1; i < argc; i++) {

      /* Catch common help requests */
      if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
      else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

      /* Read in input directories */
      else if (readOptionString (argc, argv, &i, "-imDir", &(args->imageDirectory)));

      /* other flags */
      else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
      else if (readOption       (argc, argv, &i, "-lastphase")) { args->lastphase = 1; }
      else if (readOptionString (argc, argv, &i, "-infile", &(args->ind_name)));
      else if (readOptionString (argc, argv, &i, "-outfile", &(args->of_name)));
      else if (readOptionString (argc, argv, &i, "-outdir", &(args->of_dir )));
      else if (readOptionString (argc, argv, &i, "-subspace", &(args->subspace_name)));
      else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));

      else if (param_num == 0) {
	args->trainingFile = strdup (argv[i]);
	param_num++;
      } else if (param_num == 1) {
	args->imageNamesFile = strdup (argv[i]);
	param_num++;
      } else if (param_num > 1) {
	DistDirNode* tmp = (DistDirNode*) malloc(sizeof(DistDirNode));
	tmp->next = args->distList;
	tmp->distDirectory = strdup (argv[i]);
	i++;
	tmp->distName = strdup (argv[i]);
	args->distList = tmp;
	param_num++;
      }
    }
    /*printf("in %s ofn %s ofd %s ss %s\n",args->ind_name, args->of_name, args->of_dir, args->subspace_name);*/
    if (param_num < 3)
        usage(argv[0]);

    
    /* Print out the program parameters for appropriate debug level */
    
    DEBUG_INT (1, "Debuging enabled", debuglevel);

    MESSAGE("bef print\n");


  if (debuglevel > 0) 
    {
      printf ("***************** Program Parameters *********************\n");

    MESSAGE("aft 1st msg print\n");

      printf ("imageNamesFile: %s\n", args->imageNamesFile);
      printf ("imageDirectory: %s\n", args->imageDirectory);
    }

    MESSAGE("after all msgs\n");
   
}

/* ===========================================================================
 New distance measure functions. These functions take a single matrix of
 column vectors, each column representing a different image after projection
 into subspace. They also take the column indices of the two images to be
 compared. 
 
 All of these functions return "distances" in the sense that smaller is better.
 So, for example, covariance and correlation are flipped and shifted so that
 zero is the best score between two images.
 
 The last measures also take the variance estimates for the subspace dimension,
 in other words the eigenvalues from the subspace decomposition. These are used
 to normalize measures by variance along the dimensions.
*/

/*  The L1 norm and L2 norms are standard. This code actually does the square root
 for L2, not strictly speaking necessary for a nearest neighbor classifier.
*/
FTYPE distanceCityBlock(const Matrix ims, int i, int j) {
    int k;
    FTYPE sum = 0.0;
    for (k = 0; k < ims->row_dim; k++) {
        sum += ABS((ME(ims, k, i) - ME(ims, k, j)));
    }
    return sum;
}

FTYPE distanceEuclidean(const Matrix ims, int i, int j) {
    int k;
    FTYPE sum = 0.0;
    for (k = 0; k < ims->row_dim; k++) {
        sum += (ME(ims, k, i) - ME(ims, k, j)) * (ME(ims, k, i) - ME(ims, k, j));
    }
    return sqrt(sum) ;
}


/* This is the standard covariance definition, it is the cosine
 of the angle between the two vectors. When the vectors are 
 identical, it is 1.0, when they are orthogonal, it is zero. 
 
 However, in order produce a distance, this function returns
 one minus the covariance. 
*/

FTYPE distanceCovariance(const Matrix ims, int i, int j) {
    int k;
    FTYPE magi = 0.0, magj = 0.0, dot = 0.0;

    for (k = 0; k < ims->row_dim; k++) {
        magi += ME(ims, k, i) * ME(ims, k, i);
        magj += ME(ims, k, j) * ME(ims, k, j);
        dot += ME(ims, k, i) * ME(ims, k, j);
    }
    return (1.0 - (dot / (sqrt(magi) * sqrt(magj))));
}

/**
    This is a standard correlation measure between two vectors with
 one major caveat.  Because all subsequent processing treats these
 measures as distance, the correlation mapped into the range 0 to 2
 as follows:
  correlation  1  goes to 0
  correlation -1  goes to 2.
*/

FTYPE distanceCorrelation(const Matrix ims, int i, int j) {
    int k;
    FTYPE n;
    FTYPE mui = 0.0, muj = 0.0, stdi = 0.0, stdj = 0.0, dot = 0.0, corr;

    n = (FTYPE) ims->row_dim;
    for (k = 0; k < n; k++) {
        mui += ME(ims, k, i);
        muj += ME(ims, k, j);
    }
    mui = mui / n;
    muj = muj / n;

    for (k = 0; k < n; k++) {
        stdi += (ME(ims, k, i) - mui) * (ME(ims, k, i) - mui);
        stdj += (ME(ims, k, j) - muj) * (ME(ims, k, j) - muj);
        dot += (ME(ims, k, i) - mui) * (ME(ims, k, j) - muj);
    }
    stdi = sqrt((1.0 / (n - 1.0)) * stdi);
    stdj = sqrt((1.0 / (n - 1.0)) * stdj);

    corr = ( 1.0 / (n - 1.0)) * (dot / (stdi * stdj));

    return ( 1.0 - corr);
}

/* This is what gets called Mahalanobis distance in the FERET evaluations. It
 is somewhat ill named. It is closer to a covariance without normalization
 by length and with a correction applied to each dimension. The correction
 is indeed the scale factor required to tranform into the space of unit
 variance in all dimensions. Hence, lacking a better shorthand term, this
 is called Mahalanobis Angle.
*/
FTYPE distanceYamborAngle(Matrix ims, int i, int j, Matrix values) {
    int k;
    FTYPE sum = 0.0;
    FTYPE sum_i = 0.0;
    FTYPE sum_j = 0.0;
    for (k = 0;k < ims->row_dim;k++) {
        sum_i += ME(ims, k, i) * ME(ims, k, i);
        sum_j += ME(ims, k, j) * ME(ims, k, j);
    }
    for (k = 0; k < ims->row_dim; k++) {
        sum -= ME(ims, k, i) / sqrt(sum_i) * (ME(ims, k, j) / sqrt(sum_j)) * (1 / (sqrt(ME(values, k, 0))));
    }
    return sum;
}

/* This is what gets called Mahalanobis distance in the FERET evaluations. It
 is somewhat ill named. It is closer to a covariance without normalization
 by length and with a correction applied to each dimension. The correction
 is indeed the scale factor required to tranform into the space of unit
 variance in all dimensions. Hence, lacking a better shorthand term, this
 is called Mahalanobis Angle.
*/

#if 1

/* The number of parameters is changed to serve multithreading purposes */
#ifdef SSE2

FTYPE distanceMahCosine(Matrix ims, int i, int j, Matrix values,
			Matrix vi, Matrix vj, Matrix optVals) {

    /*static Matrix optVals = NULL;*/
    int k;
    FTYPE sum_i = 0.0;
    FTYPE sum_j = 0.0;
    FTYPE scale_i = 0.0;
    FTYPE scale_j = 0.0;
    FTYPE sum = 0.0;
    __declspec(align(16)) static const FTYPE const0[2] = {0.0, 0.0};

    FTYPE *vi_p = &ME(vi,0,0), *vj_p = &ME(vj,0,0);
    FTYPE *ims_i_p =  &ME(ims,0,i), *ims_j_p =  &ME(ims,0,j);
    FTYPE *optval_p = &ME(optVals, 0, 0);
    FTYPE *val_p = &ME(values, 0, 0);
    int vi_row_dim = vi->row_dim;

    /* Transform the vector into Mahalanobis space */
    __asm {
      mov     eax, [ims_i_p]    ;
      mov     ecx, [vi_row_dim] ;
      mov     ebx, [ims_j_p]    ;
      mov     edx, [optval_p]   ;
      mov     esi, [vi_p]       ;
      mov     edi, [vj_p]       ;
      and     ecx, 0xfffffffe   ;
      sal     ecx, 3            ;
      add     ecx, esi          ; /* end point for loop */
      movapd  xmm0, [const0]    ; /* running sums */
      movapd  xmm1, [const0]    ; /* xmm0:sum_i, xmm1:sum_j*/
      
    dist_mah_cosine1:
      movapd  xmm2, [eax]       ; /* load ims_i */
      movapd  xmm4, [edx]       ; /* load optval */
      movapd  xmm3, [ebx]       ; /* load ims_j */

      mulpd   xmm2, xmm4        ; /* ims_i * optval */
      mulpd   xmm3, xmm4        ; /* ims_j * optval */
      movapd  [esi], xmm2       ;
      movapd  [edi], xmm3       ;
      mulpd   xmm2, xmm2        ; 
      mulpd   xmm3, xmm3        ; 

      addpd   xmm0, xmm2        ;
      addpd   xmm1, xmm3        ;
      add     eax, 16           ;
      add     ebx, 16           ;
      add     edx, 16           ;
      add     esi, 16           ;
      add     edi, 16           ;
      cmp     ecx, esi          ;
      jne     dist_mah_cosine1  ;     

      mov     ecx, [vi_row_dim] ;
      and     ecx, 0x1          ;
      cmp     ecx, 0x0          ;
      je      dist_mah_consine1_end  ;

      movsd  xmm2, [eax]       ; /* load ims_i */
      movsd  xmm4, [edx]       ; /* load optval */
      movsd  xmm3, [ebx]       ; /* load ims_j */

      mulsd   xmm2, xmm4        ; /* ims_i * optval */
      mulsd   xmm3, xmm4        ; /* ims_j * optval */
      movsd  [esi], xmm2       ;
      movsd  [edi], xmm3       ;
      mulsd   xmm2, xmm2        ; 
      mulsd   xmm3, xmm3        ; 

      addsd   xmm0, xmm2        ;
      addsd   xmm1, xmm3        ;    

    dist_mah_consine1_end:

      ;mov     [ims_i_p], eax    ;
      ;mov     [ims_j_p], ebx    ;
      ;mov     [optval_p], edx    ;
      ;mov     [vi_p], esi    ;
      ;mov     [vj_p], edi    ;
      
      pshufd  xmm2, xmm0, 0xe   ; /* reduction */
      pshufd  xmm3, xmm1, 0xe   ;
      addsd   xmm0, xmm2        ;
      addsd   xmm1, xmm3        ;
      movsd   [sum_i], xmm0     ;
      movsd   [sum_j], xmm1     ;
    }

   scale_i = 1.0/sqrt(sum_i);
   scale_j = 1.0/sqrt(sum_j);
   vi_p = &ME(vi,0,0);
   vj_p = &ME(vj,0,0);
  
   /* Unit length the vectors and find the dot product (cos of angle) */
   
   __asm {
      mov     ecx, [vi_row_dim] ;
      mov     eax, [vi_p]       ;
      mov     ebx, [vj_p]       ;
      mov     edx, ecx          ;
      and     edx, 0x1          ;
      and     ecx, 0xfffffffe   ;
      sal     ecx, 3            ;
      add     ecx, eax          ; /* end point for loop */
      movapd  xmm0, [const0]    ; /* running sums */
      
   dist_mah_cosine2:
      movapd  xmm2, [eax]       ; /* load vi */
      movapd  xmm3, [ebx]       ; /* load vj */
      
      mulpd   xmm2, xmm3        ; /* vi * vj */
      addpd   xmm0, xmm2        ; /* accumulate */

      add     eax, 16           ;
      add     ebx, 16           ;
      cmp     ecx, eax          ;
      jne     dist_mah_cosine2  ;     

      cmp     edx, 0x0          ;
      je      dist_mah_consine2_end ;

      movsd   xmm2, [eax]       ;
      movsd   xmm3, [ebx]       ;
      mulsd   xmm2, xmm3        ;
      addsd   xmm0, xmm2        ;

   dist_mah_consine2_end:
      pshufd  xmm2, xmm0, 0xe   ; /* reduction */
      addsd   xmm0, xmm2        ;
      movsd   [sum], xmm0     ;
   }
   
   sum = sum * scale_i * scale_j;
   
   /* return the negetive similarity or distance */
   return -sum;
}

#else /* Non-SIMD code */
FTYPE distanceMahCosine(Matrix ims, int i, int j, Matrix values,
			Matrix vi, Matrix vj, Matrix optVals) {
    int k;
    FTYPE sum_i = 0.0;
    FTYPE sum_j = 0.0;
    FTYPE scale_i = 0.0;
    FTYPE scale_j = 0.0;
    FTYPE sum = 0.0;
    static const FTYPE const0[2] = {0.0, 0.0};

    FTYPE *vi_p = &ME(vi,0,0), *vj_p = &ME(vj,0,0);
    FTYPE *ims_i_p =  &ME(ims,0,i), *ims_j_p =  &ME(ims,0,j);
    FTYPE *optval_p = &ME(optVals, 0, 0);
    FTYPE *val_p = &ME(values, 0, 0);

    /* Transform the vector into Mahalanobis space */
    for(k = 0; k < vi->row_dim-1; k+=2){
      FTYPE res_i, res_j;
      
      res_i = (*ims_i_p++)  *  (*optval_p);
      *vi_p++ = res_i;
      sum_i += res_i * res_i;



      res_j = (*ims_j_p++)  *  (*optval_p++);
      *vj_p++ = res_j;
      sum_j += res_j * res_j;


      
      /* 2nd iteration of unrolled loop */

      res_i = (*ims_i_p++)  *  (*optval_p);
      *vi_p++ = res_i;
      sum_i += res_i * res_i;



      res_j = (*ims_j_p++)  *  (*optval_p++);
      *vj_p++ = res_j;
      sum_j += res_j * res_j;


      /* Original code
        ME(vi,k,0) = ME(ims,k,i)*ME(optVals,k,0);
        sum_i += ME(vi,k,0)*ME(vi,k,0);

        ME(vj,k,0) = ME(ims,k,j)*ME(optVals,k,0);
        sum_j += ME(vj,k,0)*ME(vj,k,0);
      */

    }
  
    if (k < vi->row_dim) {      /* remainder of the loop */
      FTYPE res_i, res_j;

      res_i = (*ims_i_p++)  *  (*optval_p);
      *vi_p++ = res_i;
      sum_i += res_i * res_i;



      res_j = (*ims_j_p++)  *  (*optval_p++);
      *vj_p++ = res_j;
      sum_j += res_j * res_j;

    }

    
    scale_i = 1.0/sqrt(sum_i);
    scale_j = 1.0/sqrt(sum_j);


    vi_p = &ME(vi,0,0);
    vj_p = &ME(vj,0,0);

    /* Unit length the vectors and find the dot product (cos of angle) */
    for(k = 0; k < vi->row_dim-1; k+=2){

      sum += (*vi_p++) * (*vj_p++);
      sum += (*vi_p++) * (*vj_p++);

      /* Original code 
	 sum += ME(vi,k,0)*ME(vj,k,0);
      */
    }

    if (k < vi->row_dim) {     /* remainder of the loop */
      sum += (*vi_p++) * (*vj_p++);
    }

    sum = sum * scale_i * scale_j;

    /* return the negetive similarity or distance */
    return -sum;
}
#endif /* End non-SSE2 */

#else /* Original definition */

FTYPE distanceMahCosine(Matrix ims, int i, int j, Matrix values) {
    static int first_call = 1;
    static Matrix optVals = NULL;
    int k;
    Matrix vi = makeMatrix(ims->row_dim,1);
    Matrix vj = makeMatrix(ims->row_dim,1);
    FTYPE sum_i = 0.0;
    FTYPE sum_j = 0.0;
    FTYPE scale_i = 0.0;
    FTYPE scale_j = 0.0;
    FTYPE sum = 0.0;
    
    if(first_call){
        first_call = 0;
        optVals = duplicateMatrix(values);
        for(k = 0; k < optVals->row_dim; k++){
            ME(optVals,k,0) = 1.0/sqrt(ME(values, k, 0));
        }
    }

    /* Transform the vector into Mahalanobis space */
    for(k = 0; k < vi->row_dim; k++){
        ME(vi,k,0) = ME(ims,k,i)*ME(optVals,k,0);
        sum_i += ME(vi,k,0)*ME(vi,k,0);
        ME(vj,k,0) = ME(ims,k,j)*ME(optVals,k,0);
        sum_j += ME(vj,k,0)*ME(vj,k,0);
    }
    
    scale_i = 1.0/sqrt(sum_i);
    scale_j = 1.0/sqrt(sum_j);

    /* Unit length the vectors and find the dot product (cos of angle) */
    for(k = 0; k < vi->row_dim; k++){
        sum += ME(vi,k,0)*ME(vj,k,0);
    }
    sum = sum * scale_i * scale_j;

    /* Free the temporary vectors. */
    freeMatrix(vi);
    freeMatrix(vj);

    /* return the negetive similarity or distance */
    return -sum;
}
#endif
/*    L2 norm distance in Mahalanobis space
 */
FTYPE distanceMahL2(const Matrix ims, int i, int j, const Matrix values) {
    int k;
    FTYPE sum = 0.0;
    static int first_call = 1;
    static Matrix optVals = NULL;

    if(first_call){
        first_call = 0;
        optVals = duplicateMatrix(values);
        for(k = 0; k < optVals->row_dim; k++){
            ME(optVals,k,0) = 1.0/ME(values, k, 0);
        }
    }

    for (k = 0; k < ims->row_dim; k++) {
        sum += (ME(ims, k, i) - ME(ims, k, j)) * (ME(ims, k, i) - ME(ims, k, j)) * ME(optVals,k,0);
    }

    return sqrt(sum);
}


FTYPE distanceYamborDistance(const Matrix ims, int i, int j, const Matrix values) {
    int k;
    FTYPE sum = 0.0;
    static int first_call = 1;
    static Matrix optVals = NULL;

    if(first_call){
        first_call = 0;
        optVals = duplicateMatrix(values);
        for(k = 0; k < optVals->row_dim; k++){
            ME(optVals,k,0) = 1.0/ME(values, k, 0);
        }
    }

    for (k = 0; k < ims->row_dim; k++) {
        sum += ME(ims, k, i)*ME(ims, k, j)*ME(optVals,k,0);
    }

    return -sum;
}

/*    L1 norm distance in Mahalanobis space
 */
FTYPE distanceMahL1(const Matrix ims, int i, int j, const Matrix values) {
    int k;
    FTYPE sum = 0.0;
    static int first_call = 1;
    static Matrix optVals = NULL;

    if(first_call){
        first_call = 0;
        optVals = duplicateMatrix(values);
        for(k = 0; k < optVals->row_dim; k++){
            ME(optVals,k,0) = 1.0/sqrt(ME(values, k, 0));
        }
    }
    
    for (k = 0; k < ims->row_dim; k++) {
        sum += ABS(ME(ims, k, i) - ME(ims, k, j)) * ME(optVals,k,0);
    }
    return sum;
}

/* The soft distance measure proposed by WenYi Zhao is essentially the L2 norm
 with each axis weighted by the associated eigen value, i.e. variance, raised
 to the the power 0.2.  This is not obvious, but considerable discussion
 of this design appears in WenYi's Dissertation.
*/

FTYPE distanceLDASoft(Matrix ims, int i, int j, Matrix values) {
    int k;
    FTYPE sum = 0.0;
    for (k = 0; k < ims->row_dim; k++) {
        sum += pow(ME(values, k, 0), 0.2) * (ME(ims, k, i) - ME(ims, k, j)) * (ME(ims, k, i) - ME(ims, k, j));
    }
    return sum;
}


char** getNameByIndex(ImageList **srt, int numImages) {
    int i;
    ImageList *subject, *replicate;

    char** nameByIndex;

    /*  Allocate space for the image names for each index in images matrix */
    nameByIndex = (char**) malloc(sizeof(char*) * numImages);
    assert(nameByIndex);
    for (i = 0; i < numImages; i++) {
        nameByIndex[i] = (char*) malloc(sizeof(char) * FILE_LINE_LENGTH);
        assert(nameByIndex[i]);
    }

    /*  Move across columns and down rows of subject replicates table constructing
     an array of image file names indexed by the same index as the images matrix. */
    i = 0;
    for (subject = *srt; subject; subject = subject->next_subject) {
        for (replicate = subject; replicate; replicate = replicate->next_replicate) {
            if ((i != replicate->imageIndex) || (i == numImages)) {
                fprintf(stderr, "Error: replicate indices off or out of bounds.\n");
                exit(1);
            }
            strcpy(nameByIndex[i], replicate->filename);
            i++;
        }
    }
    return nameByIndex;
}

Matrix computeDistances(const Matrix ims, const Matrix values, int numImages, char* distName) {
    int i, j;
    Matrix distances = makeMatrix(numImages, numImages);

    if (strcmp(distName, "Euclidean") == 0) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceEuclidean(ims, i, j);
            }
        }
    } else if ((strcmp(distName, "Cityblock") == 0) || (strcmp(distName, "CityBlock") == 0)) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceCityBlock(ims, i, j);
            }
        }
    } else if (strcmp(distName, "Covariance") == 0) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceCovariance(ims, i, j);
            }
        }
    } else if (strcmp(distName, "Correlation") == 0) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceCorrelation(ims, i, j);
            }
        }
    } else if (strcmp(distName, "YamborAngle") == 0) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceYamborAngle(ims, i, j, values);
            }
        }
    } else if (strcmp(distName, "MahCosine") == 0) {
      Matrix vi = makeMatrix(ims->row_dim,1);
      Matrix vj = makeMatrix(ims->row_dim,1);
      Matrix optVals = duplicateMatrix(values);
      for(i = 0; i < optVals->row_dim; i++){
	ME(optVals,i,0) = 1.0/sqrt(ME(values, i, 0));
      }
      for (i = 0; i < numImages; i++) {
	writeProgress("Computing distances for MahCosine", i,numImages);
	for (j = 0; j < numImages; j++) {
	  ME(distances, i, j) = distanceMahCosine(ims, i, j, values, vi, vj, optVals);
	}
      }
    } else if (strcmp(distName, "MahL1") == 0) {
        for (i = 0; i < numImages; i++) {
            writeProgress("Computing distances for MahL1", i,numImages);
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceMahL1(ims, i, j, values);
            }
        }
    } else if (strcmp(distName, "MahL2") == 0) {
        for (i = 0; i < numImages; i++) {
            writeProgress("Computing distances for MahL2", i,numImages);
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceMahL2(ims, i, j, values);
            }
        }
    } else if (strcmp(distName, "YamborDistance") == 0) {
        for (i = 0; i < numImages; i++) {
            writeProgress("Computing distances for Windy", i,numImages);
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceYamborDistance(ims, i, j, values);
            }
        }
    } else if ((strcmp(distName, "ldaSoft") == 0) || (strcmp(distName, "LDASoft") == 0)) {
        for (i = 0; i < numImages; i++) {
            for (j = 0; j < numImages; j++) {
                ME(distances, i, j) = distanceLDASoft(ims, i, j, values);
            }
        }
    } else {
        fprintf(stderr, "Error: The distance measure %s is not implemented! \n", distName);
        exit(1);
    }

    return distances;
}
#ifdef THRD
void *dist_thrd_work(void* thrd_args) {
  dist_thrd_args *thrd_data = (dist_thrd_args*) thrd_args;
  Matrix ims = thrd_data->ims;
  Matrix values = thrd_data->values;
  int numImages = thrd_data->numImages;
  char*distName = thrd_data->distName;
  Matrix distances = thrd_data->distances;
  int startj = thrd_data->startj;
  int endj = thrd_data->endj;
  Matrix optVals = thrd_data->optVals;
  Matrix vi, vj;
  int j;
  

  if (strcmp(distName, "Euclidean") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceEuclidean(ims, numImages, j);
    }
  } else if ((strcmp(distName, "Cityblock") == 0) || (strcmp(distName, "CityBlock") == 0)) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceCityBlock(ims, numImages, j);
    }
  } else if (strcmp(distName, "Covariance") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceCovariance(ims, numImages, j);
    }
  } else if (strcmp(distName, "Correlation") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceCorrelation(ims, numImages, j);
            }
  } else if (strcmp(distName, "YamborAngle") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceYamborAngle(ims, numImages, j, values);
            }
  } else if (strcmp(distName, "MahCosine") == 0) {
    vi = makeMatrix(ims->row_dim, 1);
    vj = makeMatrix(ims->row_dim, 1);
    
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceMahCosine(ims, numImages, j, values,
					      vi, vj, optVals);
    }
  } else if (strcmp(distName, "MahL1") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceMahL1(ims, numImages, j, values);
    }
  } else if (strcmp(distName, "MahL2") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceMahL2(ims, numImages, j, values);
    }
  } else if (strcmp(distName, "YamborDistance") == 0) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceYamborDistance(ims, numImages, j, values);
            }
  } else if ((strcmp(distName, "ldaSoft") == 0) || (strcmp(distName, "LDASoft") == 0)) {
    for (j = startj; j < endj; j++) {
      ME(distances, j, 0) = distanceLDASoft(ims, numImages, j, values);
    }
  } else {
    fprintf(stderr, "Error: The distance measure %s is not implemented! \n", distName);
    exit(1);
  } 
  return NULL;
}

#endif

Matrix computeOneDistances(const Matrix ims, const Matrix values, int numImages, char* distName) {

    Matrix distances = makeMatrix(numImages, 1);



#ifdef THRD
    int remainder, chunk_size, tmp, rc, status, t, k, is_mahcosine=0;
    dist_thrd_args thrd_data_array[NUM_THREADS];
    Matrix optVals;

    pthread_attr_t attr;
#if (NUM_THREADS>1)
    pthread_t thread[NUM_THREADS-1];

    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
#endif

    if (strcmp(distName, "MahCosine") == 0) {
      is_mahcosine = 1;
      optVals = duplicateMatrix(values);
      for(k = 0; k < optVals->row_dim; k++){
	ME(optVals,k,0) = 1.0/sqrt(ME(values, k, 0));
      }
    }

    chunk_size = numImages/NUM_THREADS;
    remainder = numImages%NUM_THREADS;

    for(t=0;t < NUM_THREADS;t++) {
      if (t==0)
	thrd_data_array[0].startj = 0;
      else
	thrd_data_array[t].startj = thrd_data_array[t-1].endj;
      
      tmp = thrd_data_array[t].startj + chunk_size;
      
      if (remainder) {
	tmp++;
	remainder--;
      }
      
      thrd_data_array[t].endj = tmp;
      
      thrd_data_array[t].id = t;
      thrd_data_array[t].ims = ims;
      thrd_data_array[t].values = values;
      thrd_data_array[t].numImages = numImages;
      thrd_data_array[t].distName = distName;
      thrd_data_array[t].distances = distances;
      if (is_mahcosine)
	thrd_data_array[t].optVals = optVals;

      /* create threads */
      if (t!=NUM_THREADS-1) {
#if (NUM_THREADS>1)
	rc = pthread_create(&thread[t], &attr, dist_thrd_work, 
			    (void*) &thrd_data_array[t]); 

	if (rc) {
	  printf("ERROR; return code from pthread_create() is %d\n", rc);
	  exit(-1);
	}
#endif
      }
    
    } /* for */

    
    dist_thrd_work(&thrd_data_array[NUM_THREADS-1]);
    
#if (NUM_THREADS>1)
    /* Free attribute and wait for the other threads */
    pthread_attr_destroy(&attr);
    for(t=0;t < NUM_THREADS-1;t++) {
	rc = pthread_join(thread[t], (void **)&status);
	if (rc)	  {
	  printf("ERROR; return code from pthread_join() is %d\n", rc);
	  exit(-1);
	}
    }
#endif



#else
    int j;
    Matrix optVals, vi, vj;

    if (strcmp(distName, "Euclidean") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceEuclidean(ims, numImages, j);
            }
    } else if ((strcmp(distName, "Cityblock") == 0) || (strcmp(distName, "CityBlock") == 0)) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceCityBlock(ims, numImages, j);
            }
    } else if (strcmp(distName, "Covariance") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceCovariance(ims, numImages, j);
            }
    } else if (strcmp(distName, "Correlation") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceCorrelation(ims, numImages, j);
            }
    } else if (strcmp(distName, "YamborAngle") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceYamborAngle(ims, numImages, j, values);
            }
    } else if (strcmp(distName, "MahCosine") == 0) {
            optVals = duplicateMatrix(values);
	    vi = makeMatrix(ims->row_dim, 1);
	    vj = makeMatrix(ims->row_dim, 1);
	    for(j = 0; j < optVals->row_dim; j++)
	      ME(optVals,j,0) = 1.0/sqrt(ME(values, j, 0)); 

            for (j = 0; j < numImages; j++) {
	      ME(distances, j, 0) = distanceMahCosine(ims, numImages, j, values,
						      vi, vj, optVals);
            }
    } else if (strcmp(distName, "MahL1") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceMahL1(ims, numImages, j, values);
            }
    } else if (strcmp(distName, "MahL2") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceMahL2(ims, numImages, j, values);
            }
    } else if (strcmp(distName, "YamborDistance") == 0) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceYamborDistance(ims, numImages, j, values);
            }
    } else if ((strcmp(distName, "ldaSoft") == 0) || (strcmp(distName, "LDASoft") == 0)) {
            for (j = 0; j < numImages; j++) {
                ME(distances, j, 0) = distanceLDASoft(ims, numImages, j, values);
            }
    } else {
        fprintf(stderr, "Error: The distance measure %s is not implemented! \n", distName);
        exit(1);
    }
#endif
    return distances;
}

void writeDistancesForImage(char* distDirectory, char* filename, const Matrix distances, 
			    int col, char** names) {
    char name[MAX_FILENAME_LENGTH];
    FILE *file;
    int i;

    sprintf(name, "%s/%s", distDirectory, filename);
    file = fopen(name, "w");
    if (!file) {
        printf("Error: could not open file <%s>\n", name);
        exit(1);
    }
    for (i = 0; i < distances->row_dim; i++) {
        fprintf(file, "%s\t%.16e\n", names[i], ME(distances, i, col));
    }
    fclose(file);
}

void writeMatrix(Matrix m, FILE* fd) {
  if (!fwrite(m, sizeof(matrix), 1, fd)) 
    assert(0&&"write error");
  printf("wrote matrix of size %d\n",sizeof(matrix));
  if (!fwrite(m->data, sizeof(FTYPE), m->row_dim*m->col_dim, fd)) 
    assert(0&&"write error");
  printf("wrote matrix of size %d\n",sizeof(FTYPE)*m->row_dim*m->col_dim);

}

Matrix readMatrix(FILE* fd) {
  Matrix ret = (Matrix) malloc(sizeof(matrix));

  fread(ret, sizeof(matrix), 1, fd);
  ret = makeMatrix(ret->row_dim, ret->col_dim);
  fread(ret->data, sizeof(FTYPE), ret->row_dim*ret->col_dim, fd);

  return ret;
}

/* ===========================================================================
   MAIN
 
   The arguments are processed and then the subspace and related information is
   read from the training file written by csuSubspaceTrain.  The subspace basis
   is read into a matrix. If the basis vectors are for a PCA subspace, then the 
   basis vectors are tested for orthonormality. While this should not be 
   necessary, it is a prudent check to see that nothing has gone wrong either 
   in the training phase or in the transcription of the subspace basis from the
   training code to the testing code. 
 
   Once the training information is read, then the images specified in the 
   imageNamesFile are read into the images matrix. This matrix is then mean 
   centered using the mean, or centroid, associated with the training data. 
   Next, the images are projected into subspace and the distances between all
   pairs of images are computed. Finally, these distances are written to files,
   one per image.
*/

int main(int argc, char *argv[]) {
  int i;
  Arguments args;
  int numImages;
#ifdef THRD
  int numSubjs;
#endif
  ImageList *srt;
  Matrix subspims, distances;
  Subspace subspace;
  char **nameByIndex;
  DistDirNode* ddn;

  FILE *sfile;
  int ind = 0;


  MESSAGE(OPENING);
  MESSAGE(VERSION);
  process_command(argc, argv, &args);

  if (args.ind_name) ind = 1;

  if (!args.lastphase) {

    readSubspace (&subspace, args.trainingFile, quiet);
    MESSAGE1ARG("Reading image data from directory %s and projecting onto the new basis.", args.imageDirectory);
    subspims = readAndProjectImages(&subspace, args.imageNamesFile, args.imageDirectory, &numImages, &srt);

    sfile = fopen("subspace.dat","w");
    fwrite(&subspace,sizeof(subspace),1,sfile);
    writeMatrix(subspace.values, sfile);
    writeMatrix(subspace.basis, sfile);
    writeMatrix(subspace.mean, sfile);
    writeMatrix(subspims, sfile);
    fclose(sfile);

  } else { /*last phase*/
    char subspace_file[256];
    
    sprintf(subspace_file,"%s/subspace.dat",args.subspace_name);
    sfile = fopen(subspace_file,"r");
    
    fread(&subspace, sizeof(subspace), 1, sfile);
    subspace.values = readMatrix(sfile);
    subspace.basis = readMatrix(sfile);
    subspace.mean = readMatrix(sfile);
    subspims = readMatrix(sfile);

    if (PRINT_MAT_DIM) {
      printf("subspace.values rom_dim: %d col_dim: %d\n", subspace.values->row_dim,
	     subspace.values->col_dim);
      printf("subspace.basis rom_dim: %d col_dim: %d\n", subspace.basis->row_dim,
	     subspace.basis->col_dim);
      printf("subspace.mean rom_dim: %d col_dim: %d\n", subspace.mean->row_dim,
	     subspace.mean->col_dim);
      printf("subspims rom_dim: %d col_dim: %d\n", subspims->row_dim,
	     subspims->col_dim);
    }

#ifdef THRD
    srt = getImageNames(args.imageNamesFile, &numImages, &numSubjs);
#else
    srt = getImageNames(args.imageNamesFile, &numImages);
#endif

    if (ind) {
      char img_file_name[256];
      Matrix vector = makeMatrix(subspace.numPixels, 1);
      Matrix smallVector;
      int j;

      sprintf(img_file_name, "%s/%s",args.imageDirectory, args.ind_name);
      readFile(img_file_name, 0, vector);

#ifdef THRD
      smallVector = thrd_centerthenproject(&subspace, vector);
#else
      smallVector = centerThenProjectImages(&subspace, vector);
#endif

      if (PRINT_MAT_DIM)
	printf("smallVector rom_dim: %d col_dim: %d\n", smallVector->row_dim,
	       smallVector->col_dim);     

      for (j = 0; j < smallVector->row_dim; j++) {
	ME(subspims, j, numImages) = ME(smallVector, j, 0);
      }

    };

    nameByIndex = getNameByIndex(&srt, numImages);

    for (ddn = args.distList; ddn != NULL; ddn = ddn->next) {
      if (!ind) {
	MESSAGE1ARG("Computing distances with distance measure %s.", 
		    ddn->distName);
	distances = computeDistances(subspims, subspace.values, numImages, 
				     ddn->distName);
	
	MESSAGE2ARG("Writing distance files for %d test images to directory %s", 
		    numImages, ddn->distDirectory);
	for (i = 0; i < numImages; i++) {
	  writeProgress("Writing distance files", i,numImages);
	  writeDistancesForImage(ddn->distDirectory, nameByIndex[i], distances, 
				 i, nameByIndex);
	}
	freeMatrix(distances);
      } else {


	distances = computeOneDistances(subspims, subspace.values, numImages,
					ddn->distName);

	printf("writing to %s/%s\n",args.of_dir, args.of_name);
	writeDistancesForImage(args.of_dir, args.of_name, distances, 
			       0, nameByIndex);
	
	if (PRINT_MAT_DIM)
	  printf("distances rom_dim: %d col_dim: %d\n", distances->row_dim,
		 distances->col_dim);     
	
      }
    }
  }

  return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
   File: ldatrain.c                                                            
   Authors: Kai She, J. Ross Beveridge and David Bolme                         
   Date:    April. 10 2001                                                     
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/**
   Purpose: This program loads training face images into a matrix M and        
   compute the eigen space and optionally the fisher space.                    
                                                                             
   Input: Gallery image data from binary file                                  
   Output: A combined projection space in a log file 
*/

#define OPENING  "From Training Imagery, Build a PCA or PCA+LDA Subspace."

/******************************************************************************
 *                               INCLUDES                                      *
 ******************************************************************************/

#include "csuCommon.h"

/******************************************************************************
 *                               GLOBALS                                       *
 ******************************************************************************/

typedef struct {
  char* imageList;
  char* imageDirectory;
  int vecLength;
  char* training_filename;
  int cutOffMode;
  double cutOff;
  int dropNVectors;
  int uselda;
  int writeTextBasis;
  int writeTextValues;
  int writeTextInterm;
  int argc;
  char **argv;
}
Arguments;

/* Remind the user the required command to run the program
   Input: the name of the executable program generated
*/
void usage(const char* prog) {
  printf("Usage: %s [OPTIONS] training_images.[list/srt] training_output\n", prog);
  printf("  Parameters\n");
  printf("    training_images: image names file\n");
  printf("    trainName: training output file\n");
  printf("  Options\n");
  printf("    -lda:                enable lda training. (Must use srt file)\n        DEFAULT = PCA Only\n");
  printf("    -imDir <dir>:        image directory.\n        DEFAULT = \".\"\n");
  printf("    -vecLength <int>:    vector length.\n        DEFAULT = \"Auto\"\n");
  printf("    -dropNVectors <int>: Drops the first N vectors which are normally lighting effects.\n        DEFAULT = 0\n");
  printf("    -cutOffMode <mode>:  Selects the method for eigen vector selection after PCA trianing\n");
  printf("                         and droping the first vectors.  DEFAULT = SIMPLE\n");
  printf("         NONE            Retain eigenvectors.\n");
  printf("         SIMPLE          Retain a percentage of the eigenvectors. \n");
  printf("                         Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f \n", DEFAULT_CUTOFF_PERCENT_SIMPLE);
  printf("         ENERGY          Retain  eigenvectors accounting for a percentage of the total energy.\n");
  printf("                         Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f\n", DEFAULT_CUTOFF_PERCENT_ENERGY);
  printf("         STRETCH         Retains all eigenvectors greater than a percentage of the largest eigenvector.\n");
  printf("                         Expects value between 0.0 and 100.0, DEFAULT PERCENT = %f\n", DEFAULT_CUTOFF_PERCENT_STRETCH);
  printf("         CLASSES         Retains as many eigenvectors as there LDA Classes: use only with LDA.\n");
  printf("                         Ignores cutOff value and uses number of classes instead\n");
  printf("    -cutOff <percent>:   Percentage of eigen vectors to retain (see cutOffMode).\n        DEFAULT = (See cutoff mode)\n");
  printf("    -writeTextBasis:     Causes the program to print the basis vectors to text files.\n        DEFAULT = No\n");
  printf("    -writeTextValues:    Causes the program to print the basis values to text files.\n        DEFAULT = No\n");
  printf("    -writeTextInterm:    Causes the program to print intermediate matricies.\n        DEFAULT = No\n");
  printf("    -outputMatlabAscii:  Causes the program to print matricies in matlab format.\n        DEFAULT = Octave format\n");
  printf("    -quiet:              Turn off all messages.\n        DEFAULT = messages on\n");
  printf("    -debuglevel <int>:   Level of debug information to display (automatically sets quiet to no).\n        DEFAULT = 0\n");
  exit(1);
}

/**
   Process the command line and initialize the variables
   Input:
   argc        is the number of arguments
   argv        are the arguments
   imDir       is the directory of gallery images
   imNames     is the name of the file which contains the gallery
   image names
   vecLength   is the size of the vectors or number of pixels
   of the image
   trianName   is the name of the file which stores the training
   information
   cutOff      is the percentage of the eigenvectors kept to build
   the eigen space
*/

void process_command(int argc, char** argv, Arguments* args) {
  int i;
  int param_num = 0;
  int cutOffSet = 0; /* set to one if -cutOff is found so default does not change */

  args->argc = argc;
  args->argv = argv;

  args->imageDirectory  = strdup (".");
  args->vecLength       = 0;
  args->cutOffMode      = CUTOFF_SIMPLE;
  args->cutOff          = DEFAULT_CUTOFF_PERCENT_SIMPLE;
  args->uselda          = 0;
  args->dropNVectors    = 0;
  args->writeTextBasis  = 0;
  args->writeTextValues = 0;
  args->writeTextInterm = 0;
  debuglevel = 0;

  for (i = 1;i < argc;i++) {

    /* Catch common help requests */
    if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
    else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

    /* Read in input directories */
    else if (readOptionString (argc, argv, &i, "-imDir", &(args->imageDirectory)));

    else if (readOptionInt    (argc, argv, &i, "-vecLength", &(args->vecLength)));
    else if (readOptionInt    (argc, argv, &i, "-dropNVectors", &(args->dropNVectors)));

    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "NONE"))
      { args->cutOffMode = CUTOFF_NONE; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "SIMPLE"))
      { args->cutOffMode = CUTOFF_SIMPLE; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "ENERGY"))
      { args->cutOffMode = CUTOFF_ENERGY; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "STRETCH"))
      { args->cutOffMode = CUTOFF_STRETCH; }
    else if (readOptionMatch(argc, argv, &i, "-cutOffMode", "CLASSES"))
      { args->cutOffMode = CUTOFF_CLASSES; }

    else if (readOptionDouble (argc, argv, &i, "-cutOff", &(args->cutOff)))
      {
	if ((args->cutOff <= 1.0) && (args->cutOff >= 0.000001)) {
	  printf("WARNING: cutOff value is %f, expects percentage "
		 "between 0.0 and 100.0", args->cutOff);
	  printf("         will proceed assuming value is as desired.");
	}
	cutOffSet = 1;
      }   

    else if (readOption (argc, argv, &i, "-lda" ))                     { args->uselda = 1; }
    else if (readOption (argc, argv, &i, "-writeTextBasis" ))          { args->writeTextBasis = 1; }
    else if (readOption (argc, argv, &i, "-writeTextValues" ))         { args->writeTextValues = 1; }
    else if (readOption (argc, argv, &i, "-writeTextInterm" ))         { args->writeTextInterm = 1; }
    else if (readOption (argc, argv, &i, "-outputMatlabAscii" ))       { asciiFormat = 1; }

    /* other flags */
    else if (readOption    (argc, argv, &i, "-quiet")) { quiet = 1; }
    else if (readOptionInt (argc, argv, &i, "-debuglevel", &debuglevel)) {}

    /* read required arguments */ 
    else if (param_num == 0) {
      args->imageList = strdup (argv[i]);
      param_num++;
    }
    else if (param_num == 1) {
      args->training_filename = strdup (argv[i]);
      param_num++;
    } 
    else { clParseError(argc,argv,i,"Wrong number of required arguments"); }
  }

  /* make sure that there are the proper number of required arguments */

  if (param_num != 2){ clParseError(argc,argv,i,"Wrong number of required arguments"); }

  /* Choose a default cutoff if none was specified */

  if (!cutOffSet)
    {
      switch (args->cutOffMode)
	{
	case CUTOFF_NONE:
	case CUTOFF_SIMPLE:
	case CUTOFF_CLASSES:
	  args->cutOff = DEFAULT_CUTOFF_PERCENT_SIMPLE;
	  break;
	case CUTOFF_ENERGY:
	  args->cutOff = DEFAULT_CUTOFF_PERCENT_ENERGY;
	  break;
	case CUTOFF_STRETCH:
	  args->cutOff = DEFAULT_CUTOFF_PERCENT_STRETCH;
	  break;
      }
    }

  if ((!args->uselda) && (args->cutOffMode == CUTOFF_CLASSES)) {
    printf("Warning: Cutoff Mode Classes meant for use with lda only.\n");
  }

  /* Print out the program parameters for appropreate debug level */
  DEBUG(1,"Debuging enabled");
  if(debuglevel > 0){
    printf ("***************** Program Parameters *********************\n");
    printf ("Image directory: %s\n", args->imageDirectory);
    printf ("Image list:      %s\n", args->imageList);
    printf ("Training file:   %s\n", args->training_filename);
    printf ("vecLength:       %d\n", args->vecLength);
    printf ("useLda:          %s\n", args->uselda ? "YES" : "NO");
    printf ("cutOff:          %f\n", args->cutOff);
  }
}


/*
  main()
*/
int
main(int argc, char *argv[])
{
  Arguments args;
  int numImages, numSubjects;
  ImageList *srt;
  Matrix images;
  Subspace subspace;
    
  process_command(argc, argv, &args);

  MESSAGE(OPENING);
  MESSAGE(VERSION);

  /* The Matrix images is contains what is commonly calld the data matrix. It
     consists of n images, one image per column. Hence, each images data is 
     contiguous in memory. This choice facilities easy integration with the 
     Eigensolver used below */

  MESSAGE1ARG("Reading images from files in directory %s.", args.imageDirectory);

  images = readImages(args.imageList, args.imageDirectory, &args.vecLength,
		      &numImages, &numSubjects, &srt);
  
  subspaceTrain (&subspace, images, srt, numSubjects, args.dropNVectors, args.cutOffMode, args.cutOff, args.uselda, args.writeTextInterm);

  /* Write out text files for basis and values */
  if (args.writeTextBasis)
    {
      SAVE_MATRIX (subspace.basis);
      SAVE_MATRIX (subspace.mean);
      
      SAVE_MATRIX (subspace.values);
    }

  writeSubspace (&subspace, args.training_filename, args.imageList, args.argc, args.argv);
  
  MESSAGE("Finished Training.");
  
  return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
File: csuToolsImageStats.c                                                     
Authors: Marcio L. Teixeira                           
Date: May 24, 2002                                                 
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#define OPENING  "csuToolsImageStats gathers statistics about image files."

/******************************************************************************
*                               INCLUDES                                      *
******************************************************************************/

#include <csuCommon.h>
#include <stdio.h>
#include <math.h>

/******************************************************************************
*                               GLOBALS                                       *
******************************************************************************/
/**
 * The command line arguments are managed by a single structure.
 */
typedef struct {
  char* outputFile;
  char* eyeCoordsFile;
  char* imageDirectory;
  char* maskDirectory;
}
Arguments;

/**
 * Display a standard usage parameters or help if there is a problem with the
 * command line.
 */
void
usage (const char* name)
{
  printf("Usage: %s eye_coordinate_file output_file\n\n",name);
  printf ("    -imDir <dir>:       image directory. DEFAULT = \".\"\n");
  printf ("    -maskDir <dir>:     mask directory. DEFAULT = \".\"\n");
  printf ("    -debuglevel <int>:  Level of debug information to display. DEFAULT = 0\n");
  printf ("    -quiet:             Turn off all messages. DEFAULT = messages on\n");
  printf( "    This program gathers statistics about images\n\n\n");
  exit(1);
}

/**
 * Process the command line and initialize the variables
 *
 * @param argc The number of arguments
 * @param argv The arguments
 */
void
process_command(int argc, char** argv, Arguments* args)
{
  int i;
  int param_num = 0;

  /******* Set up default values *******/

  args->imageDirectory = NULL;
  args->eyeCoordsFile = NULL;
  args->outputFile     = NULL;
  args->maskDirectory  = NULL;

  quiet = 0;
  debuglevel = 0;

  for (i = 1; i < argc; i++) {

    /* Catch common help requests */

    if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
    else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

    /* Read in input directories */

    else if (readOptionString (argc, argv, &i, "-imDir",     &(args->imageDirectory)));
    else if (readOptionString (argc, argv, &i, "-maskDir",   &(args->maskDirectory)));

    /* other flags */

    else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
    else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));

    /* check if the current argument is an unparsed option */

    else if (checkBadOption(argc,argv,&i));


    else if (param_num == 0) {
      args->eyeCoordsFile = strdup(argv[i]);
      param_num++;
    }

    else if (param_num == 1) {
      args->outputFile = strdup(argv[i]);
      param_num++;
    }
  }

  if (param_num != 2)
    usage(argv[0]);

  /* Print out the program parameters for appropriate debug level */

  DEBUG_INT (1, "Debuging enabled", debuglevel);

  if(debuglevel > 0){
    printf ("***************** Program Parameters *********************\n");
    printf ("eyeCoordsFile: %s\n", args->eyeCoordsFile);
    printf ("imageDirectory: %s\n", args->imageDirectory);
    printf ("outputFile: %s\n",     args->outputFile);
  }
}

char **
loadMask (const char *filename)
{
  Image im = readPGMImage (filename);
  assert (im);
  return imageToMask (im,0);
}

int
main (int argc, char** argv)
{
  Arguments args;
  int i, j;
  FILE *fi, *fo;
  char line [FILE_LINE_LENGTH ];
  char filename [MAX_FILENAME_LENGTH];
  char **combinedEyesMask, **leftEyeMask, **rightEyeMask;
  char **foreheadStripMask, **centerStripMask, **mouthChinStripMask;
  char **leftCheekMask, **rightCheekMask;
  char **leftSideMask, **rightSideMask, **wholeMask;

  MESSAGE(OPENING);
  MESSAGE(VERSION);
  process_command(argc, argv, &args);

  /* Read in the masks */

  combinedEyesMask     = loadMask (makePath (args.maskDirectory, "combinedEyesMask.pgm"));
  foreheadStripMask    = loadMask (makePath (args.maskDirectory, "foreheadHorizontalStripMask.pgm"));
  centerStripMask      = loadMask (makePath (args.maskDirectory, "centerHorizontalStripMask.pgm"));
  mouthChinStripMask   = loadMask (makePath (args.maskDirectory, "mouthChinStripMask.pgm"));
  leftEyeMask          = loadMask (makePath (args.maskDirectory, "leftEyeMask.pgm"));
  rightEyeMask         = loadMask (makePath (args.maskDirectory, "rightEyeMask.pgm"));
  leftCheekMask        = loadMask (makePath (args.maskDirectory, "leftCheekMask.pgm"));
  rightCheekMask       = loadMask (makePath (args.maskDirectory, "rightCheekMask.pgm"));
  leftSideMask         = loadMask (makePath (args.maskDirectory, "leftSideMask.pgm"));
  rightSideMask        = loadMask (makePath (args.maskDirectory, "rightSideMask.pgm"));
  wholeMask            = loadMask (makePath (args.maskDirectory, "wholeMask.pgm"));

  fo = fopen (args.outputFile, "w");
  DEBUG_CHECK (fo,"Error opening output file");

  fi = fopen (args.eyeCoordsFile,"r");
  DEBUG_CHECK (fi,"Error opening eye coordinates file");

  fprintf (fo, "%d\n", 0);

  for (i = 1; ; i++)
    {
      Image im;
      double mean1, mean2, median1, median2;
      double stddev1, stddev2, mad1, mad2, diffMean, diffMedian;
      double ratioSD, ratioMad, tStat;
      double x1, x2, y1, y2;
      double eyeDist, eyeAng;
      int numPix1, numPix2;

      struct {
	int id;
	char *label;
	double *value;
	char   **mask1;
	char   **mask2;
      } predictors[] = {

	/* Whole-Image Predictors */

	{ 1, "MEAN_WHOLE",      &mean1,      wholeMask,          NULL},
	{ 2, "MED_WHOLE",       &median1,    wholeMask,          NULL},
	{ 3, "STD_WHOLE",       &stddev1,    wholeMask,          NULL},
	{ 4, "MAD_WHOLE",       &mad1,       wholeMask,          NULL},
	{ 5, "EYE_DIST",        &eyeDist,    wholeMask,          NULL},
	{ 6, "EYE_ANGLE",       &eyeAng,     wholeMask,          NULL},

	/* Regional Predictors */

	{ 7, "MEAN_EYES",       &mean1,      combinedEyesMask,   NULL},
	{ 8, "MED_EYES",        &median1,    combinedEyesMask,   NULL},
	{ 9, "STD_EYES",        &stddev1,    combinedEyesMask,   NULL},
	{10, "MAD_EYES",        &mad1,       combinedEyesMask,   NULL},

	{11, "MEAN_FH",         &mean1,      foreheadStripMask,  NULL},
	{12, "MED_FH",          &median1,    foreheadStripMask,  NULL},
	{13, "STD_FH",          &stddev1,    foreheadStripMask,  NULL},
	{14, "MAD_FH",          &mad1,       foreheadStripMask,  NULL},

	{15, "MEAN_CENTR",      &mean1,      centerStripMask,    NULL},
	{16, "MED_CENTR",       &median1,    centerStripMask,    NULL},
	{17, "STD_CENTR",       &stddev1,    centerStripMask,    NULL},
	{18, "MAD_CENTR",       &mad1,       centerStripMask,    NULL},

	{19, "MEAN_MC",         &mean1,      mouthChinStripMask, NULL},
	{20, "MED_MC",          &median1,    mouthChinStripMask, NULL},
	{21, "STD_MC",          &stddev1,    mouthChinStripMask, NULL},
	{22, "MAD_MC",          &mad1,       mouthChinStripMask, NULL},

	/* Statistical Contrast Predictors */

	{23, "DMEAN_LR_SIDES",  &diffMean,   leftSideMask,       rightSideMask},
	{24, "DMED_LR_SIDES",   &diffMedian, leftSideMask,       rightSideMask},
	{25, "RSTD_LR_SIDES",   &ratioSD,    leftSideMask,       rightSideMask},
	{26, "RMAD_LR_SIDES",   &ratioMad,   leftSideMask,       rightSideMask},
	{27, "TSTAT_LR_SIDES",  &tStat,      leftSideMask,       rightSideMask},

	{28, "DMEAN_LR_EYES",   &diffMean,   leftEyeMask,        rightEyeMask},
	{29, "DMED_LR_EYES",    &diffMedian, leftEyeMask,        rightEyeMask},
	{30, "RSTD_LR_EYES",    &ratioSD,    leftEyeMask,        rightEyeMask},
	{31, "RMAD_LR_EYES",    &ratioMad,   leftEyeMask,        rightEyeMask},
	{32, "TSTAT_LR_EYES",   &tStat,      leftEyeMask,        rightEyeMask},

	{33, "DMEAN_FH_CENTR",  &diffMean,   foreheadStripMask,  centerStripMask},
	{34, "DMED_FH_CENTR",   &diffMedian, foreheadStripMask,  centerStripMask},
	{35, "RSTD_FH_CENTR",   &ratioSD,    foreheadStripMask,  centerStripMask},
	{36, "RMAD_FH_CENTR",   &ratioMad,   foreheadStripMask,  centerStripMask},
	{37, "TSTAT_FH_CENTR",  &tStat,      foreheadStripMask,  centerStripMask},

	{38, "DMEAN_FH_MC",     &diffMean,   foreheadStripMask,  mouthChinStripMask},
	{39, "DMED_FH_MC",      &diffMedian, foreheadStripMask,  mouthChinStripMask},
	{40, "RSTD_FH_MC",      &ratioSD,    foreheadStripMask,  mouthChinStripMask},
	{41, "RMAD_FH_MC",      &ratioMad,   foreheadStripMask,  mouthChinStripMask},
	{42, "TSTAT_FH_MC",     &tStat,      foreheadStripMask,  mouthChinStripMask},

	{43, "DMEAN_CENTR_MC",  &diffMean,   centerStripMask,    mouthChinStripMask},
	{44, "DMED_CENTR_MC",   &diffMedian, centerStripMask,    mouthChinStripMask},
	{45, "RSTD_CENTR_MC",   &ratioSD,    centerStripMask,    mouthChinStripMask},
	{46, "RMAD_CENTR_MC",   &ratioMad,   centerStripMask,    mouthChinStripMask},
	{47, "TSTAT_CENTR_MC",  &tStat,      centerStripMask,    mouthChinStripMask},

	{48, "DMEAN_LR_CHEEK",  &diffMean,   leftCheekMask,      rightCheekMask},
	{49, "DMED_LR_CHEEK",   &diffMedian, leftCheekMask,      rightCheekMask},
	{50, "RSTD_LR_CHEEK",   &ratioSD,    leftCheekMask,      rightCheekMask},
	{51, "RMAD_LR_CHEEK",   &ratioMad,   leftCheekMask,      rightCheekMask},
	{52, "TSTAT_LR_CHEEK",  &tStat,      leftCheekMask,      rightCheekMask}
      };

      /* Read in a line from the eyes coordinates file */

      fgets (line, FILE_LINE_LENGTH, fi);
      if (feof (fi))
	break;
      
      if (sscanf (line,"%s %lf %lf %lf %lf", filename, &x1, &y1, &x2, &y2) != 5)
	{
	  printf("Error parsing line %d of eye coordinate file. Exiting...",i);
	  exit(1);
	}

      /* Load image and calculate the statistics */

      /* Print the image name, the image id (the first five characters of the name), the number of subject
       covariates and the number of image covariates
      */

      fprintf (fo, "%s\t", filename);
      fprintf (fo, "%c%c%c%c%c\t", filename[0], filename[1], filename[2], filename[3], filename[4]); 
      fprintf (fo, "%d\t%ld\t", 0, NELEM(predictors));
      
      sprintf (filename, "%s.sfi", filename);
      im = readRawImage (makePath (args.imageDirectory, filename));

      eyeDist = sqrt (SQR(x2 - x1) + SQR (y2 - y1));
      eyeAng  = atan ((y2 - y1)/(x2 - x1)) / M_PI * 180;

      for (j = 0; j < NELEM(predictors); j++)
	{
	  mean1 = stddev1 = numPix1 = median1 = mad1 = 0;
	  mean2 = stddev2 = numPix2 = median2 = mad2 = 0;
	  diffMean = diffMedian = ratioSD = ratioMad = tStat = 0;

	  /* Compute the statistics using the first mask */

	  if (predictors[j].mask1)
	    {
	      mean1   = imageMean        (im, (const char**) predictors[j].mask1);
	      stddev1 = imageStdDev      (im, (const char**) predictors[j].mask1);
	      numPix1 = imageNumOfPixels (im, (const char**) predictors[j].mask1);
	      median1 = imageMedian      (im, (const char**) predictors[j].mask1);
	      mad1    = imageMad         (im, (const char**) predictors[j].mask1);
	    }

	  /* Compute the statistics using the second mask */

	  if (predictors[j].mask2)
	    {
	      mean2   = imageMean        (im, (const char**) predictors[j].mask2);
	      stddev2 = imageStdDev      (im, (const char**) predictors[j].mask2);
	      numPix2 = imageNumOfPixels (im, (const char**) predictors[j].mask2);
	      median2 = imageMedian      (im, (const char**) predictors[j].mask2);
	      mad2    = imageMad         (im, (const char**) predictors[j].mask2);
	    }

	  /* Compute the paired statistics */

	  if (predictors[j].mask1 && predictors[j].mask2)
	    {
	      diffMean    = mean1   - mean2;
	      diffMedian  = median1 - median2;
	      ratioSD     = stddev1 / stddev2;
	      ratioMad    = mad1    / mad2;
	      tStat       = (mean1  - mean2) / sqrt (SQR (stddev1) / numPix1 + SQR (stddev2) / numPix2);
	    }
	  
	  /* Apply the operator */

	  fprintf (fo, "%s\t%.10e\t", predictors[j].label, (*predictors[j].value));
	}

      fprintf (fo, "\n");
      
      freeImage (im);
      
      writeProgress ("Generating statistics", i, 0);
    }

  fclose (fo);
  fclose (fi);

  return 0;
}


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <iostream.h>


int main(){
char c = 0;
    while(cin.get(c)){
        switch(c){
	  case 13: 
            cout.put((char)10);
            break;
	  case '\"':
            break;
          default:
            cout.put(c);
            break;
	}
    }

    return 0;

}



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>

#define OPENING  "csuToolsPGM2SFI convert PGM images to SFI format."

void usage(const char* name){
    printf("Usage: %s pgmfiles\n\n",name);
    printf( "    This program converts pgm images to sfi format.\n");
    exit(1);
}

void removeExtention(char* filename){
    int i;

    for(i = strlen(filename); i >= 0; i--){
        if(filename[i] == '.'){
            filename[i] = 0;
            break;
        }
        if(filename[i] == '/'){
            break;
        }
    }
}

int main(int argc, char** argv){
    Image im;
    char outfilename[MAX_FILENAME_LENGTH];
    int i = 1;

    printf("%s\n%s\n",OPENING,VERSION);
    if(argc == 1 || strcmp(argv[1],"-help") == 0 || strcmp(argv[1],"--help") == 0){
        usage(argv[0]);
    }


    for(;i < argc; i++){
        printf("Converting: %s\n",argv[i]);
        im = readPGMImage(argv[i]);
        
        removeExtention(argv[i]);

        sprintf(outfilename,"%s.sfi",argv[i]);
        printf("    Writing: %s\n",outfilename);
        writeRawImage(im,outfilename);
    }
    printf("done.\n");

    return 0;
}


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <csuCommon.h>

#define OPENNING "Parse list of FERET IDs into new file, one line per subject."

/*
 *  ============================================================================
 *  Copyright 2002, Colorado State University. All Rights Reserved.           
 *  --------------------------------------------------------------------------- 
 *  Permission to use, copy or modify this software and its documentation for   
 *  educational and research purposes only, provided that this copyright notice  
 *  appear on all copies and supporting documentation.                          
 *  ---------------------------------------------------------------------------        
 *  File:    csuReplicatesTable.c                                                     
 *  Authors: J. Ross Beveridge                                   
 *  Date:    May 24, 2002                                                  
 *  ============================================================================
 */

/* ===========================================================================
 * Compile time configuration options 
 */
#define PRINT_LEVEL 1    /* Controls amount of text printed to stdout */
#define MAX_FSTRLEN 100      /* Upper bound on file name string lengths */

/*  ===========================================================================
 *   Local structures to build linked lists of subjects and images
 */
typedef struct feretimage {
    char* name;        			/* The text name designating the FERET image */
    int subject;       		  	/* The unique subject identification number */
    struct feretimage *next;  	/* Next image for this subject */
}
FIM;

typedef struct feretsubject {
    int id;   					/* The unique subject identification number */
    struct feretimage *images;  /* The list of images for this subject */
    struct feretsubject *next;
}
FSU;

/* ============================================================================
 * Function Prototypes
 */

FIM* makeFIM(char* name);
FSU* makeFSU(int id);
int  positionOfFirstNonDigit(char *name);
int  idFromName(char* name);
FSU* insertSubjectsFromFile(char *inFile);
FSU* insertSubjectName(FSU *head, char* name);
void insertSubjectNameRecurse(FSU *prev, FSU* curr, int si, char* name);
void appendImage(FIM* curr, FIM* im);
void printSubjectReplicatesFile(FSU* head, char* outFile);
void readArgs(int argc, char *argv[], char **fileNames, char **outFile);

/* ===========================================================================
 * Structure Constructors
 */

FIM* makeFIM(char* name) {
    char* tt;
    FIM* im;

    im = (FIM*) malloc(sizeof(FIM));
    assert(im);
    tt = (char*) malloc(sizeof(char) * MAX_FSTRLEN);
    assert(tt);
    strcpy(tt, name);
    im->name = tt;
    im->subject = idFromName(name);
    im->next = NULL;

    return im;
}

FSU* makeFSU(int id) {
    FSU* su = (FSU*) malloc(sizeof(FSU));
    assert(su);
    su->id = id;
    su->next = NULL;

    return su;
}

/* ===========================================================================
 * Routines to assist interpreting strings representing FERET ids.
 */

/* The integer corresponding to the FERET subject ID extracted from name */
int idFromName(char* name) {
    char str[MAX_FSTRLEN];
    int i = positionOfFirstNonDigit(name);
    strncpy(str, name, i);

    return atoi(str);
}

/*  The integer index of the first character that is not a digit. */
int positionOfFirstNonDigit(char *name) {
    int i, j, len, flag;
    const char digits[] = "0123456789";

    len = strlen(name);
    flag = 1;
    i = 0;
    while ((i < len) && flag) {
        flag = 0;
        for (j = 0; j < 10; j++) {
            if (name[i] == digits[j])
                flag = 1;
        }
        i++;
    }
    return i;
}

/* ===========================================================================
 Build up a linked list of subjects, each point pointing to a linked list
 of the images for that subject. The linked list of subjects is maintained
 in sorted order from least to greatest subject id. The images for each 
 subject are in the order encountered in the input file of image names.
*/

FSU* insertSubjectsFromFile(char *inFile) {
    FILE *f;
    FSU *head = NULL;
    char buffer[MAX_FSTRLEN], name[MAX_FSTRLEN];

    f = fopen(inFile, "r");
    if (f == NULL) {
        printf("\nCannot open %s to read!\n", inFile);
        exit(1);
    }
    while (fgets(buffer, 100, f)) {
        sscanf(buffer, "%s", name);
        head = insertSubjectName(head, name);
    }
    fclose(f);
    return head;
}

FSU* insertSubjectName(FSU *head, char* name) {
    FIM* im;
    FSU* su;
    int si;  /* Subject index of name to insert */

    si = idFromName(name);
    /* First initial case, linked list of subjects is empty */
    if (head == NULL) {
        /* printf("\n Adding %s, id %d,  as first subject in linked list \n", name, si); */
        im = makeFIM(name);
        su = makeFSU(si);
        su->images = im;
        return su;
    }
    /* Special case that current subject id is less than head of list */
    if (head->id > si) {
        /* printf("Special Case: Current Subject id is less than head of list, adding %s, id %d to head. \n", name, si ); */
        im = makeFIM(name);
        su = makeFSU(si);
        su->images = im;
        su->next = head;
        return su;
    }
    /* Special case that current subject id is equal to the head of the list */
    if (head->id == si) {
        /* printf("Another image %s for subject id %d. \n", name, si); */
        appendImage(head->images, makeFIM(name));
        return head;
    }
    /* List is not empty, and current is not going to become the head */
    insertSubjectNameRecurse(head, head->next, si, name);
    return head;
}

void insertSubjectNameRecurse(FSU *prev, FSU* curr, int si, char* name) {
    FIM* im;
    FSU* su;

    /* We've run off the end of the list, tag new subject onto the end */
    if (curr == NULL) {
        /* printf("In recursion, ran off end with subject id %d, add %s to end \n", prev->id, name); */
        im = makeFIM(name);
        su = makeFSU(si);
        su->images = im;
        prev->next = su;
    }
    /* If current id equals new, then append image to current */
    else if (curr->id == si) {
        /* printf("Current id %d equals %d, adding image %s to end of images. \n", curr->id, si, name); */
        appendImage(curr->images, makeFIM(name));
    }
    /* If current id greater than new, then insert new subject here */
    else if (curr->id > si) {
        /* printf("Current id %d greater than new id %d, inserting new subject with first image %s. \n", curr->id, si, name); */
        im = makeFIM(name);
        su = makeFSU(si);
        su->images = im;
        prev->next = su;
        su->next = curr;
    }
    /* Keep looking down the list */
    else {
        insertSubjectNameRecurse(curr, curr->next, si, name);
    }
}

void appendImage(FIM* curr, FIM* im) {
    if (curr->next == NULL) {
        curr->next = im;
    } else {
        appendImage(curr->next, im);
    }
}

/* Print out a usage message and exit */
void usage(const char* progname) {
    if (progname){
        printf("\nusage: %s flat_list_file.list subject_replicate_file.srt\n", progname);
    }
    printf("\n    Two command line arguments required:\n");
    printf("    1: File of test image names, one name per line in the file.\n");
    printf("    2: Name of file to create with names grouped by subject.\n");
    exit(1);
}
/* ===========================================================================
 Read in the command line arguments, rather simple for this program 
*/

void readArgs(int argc, char *argv[], char **fileNames, char **outFile) {
    if (argc <= 1) {
        usage(argv[0]);
    }
    if ((strcmp(argv[1], "-help") == 0) || (argc < 3)) {
        usage(argv[0]);
    }
    *fileNames = argv[1];
    *outFile = argv[2];
    if (PRINT_LEVEL > 0) {
        printf("\nCommand Line arguments are:\n");
        printf("  File of test image names, one name per line in the file ... %s\n", *fileNames);
        printf("  Name of file to create with names grouped by subject ...... %s\n", *outFile);
    }
}

/*  ---------------------------------------------------------------------------
    Generate the output file from the subject replicates linked lists.
    ---------------------------------------------------------------------------*/

void printSubjectReplicatesFile(FSU* head, char* outFile) {
    FILE *f;
    FIM* im;
    int i;

    f = fopen(outFile, "w");
    if (f == NULL) {
        printf("cannot open %s to write\n", outFile);
        exit(1);
    }
    while (head != NULL) {
        i = 0;
        im = head->images;
        while (im != NULL) {
            if (i++ > 0)
                fprintf(f, "\t");  /* print tab between names */
            fprintf(f, "%s ", im->name);
            im = im->next;
        }
        fprintf(f, "\n");
        head = head->next;
    }

    fclose(f);
}

/* ===========================================================================
                                        MAIN
   
   This code reads a simple file with one FERET image name per row. It groups 
   the images by subject id and then writes a new file. This new file lists 
   all images for a single subject on one line and these lines are sorted by
   subject ID.  This is the format read by csuSubspaceTrain.
                                    
*/

int main(int argc, char *argv[]) {
    char *inFile;     /* Name of the file with image names one per line */
    char *outFile;    /* Name of the file to which results are written */
    FSU* head = NULL; /* Head pointer to the linked list of subjects */

    if (PRINT_LEVEL > 0)
        printf("\n%s\n%s", OPENNING, VERSION);
    readArgs(argc, argv, &inFile, &outFile);

    if (PRINT_LEVEL > 0)
        printf("\nReading from %s and building subject/replicates linked lists.", inFile);
    head = insertSubjectsFromFile(inFile);

    printSubjectReplicatesFile(head, outFile);
    if (PRINT_LEVEL > 0)
        printf("\nFinished. \n");
    return 0;
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include <csuCommon.h>

#define OPENING  "csuToolsSFI2PGM convert SFI images to PGM format."

void usage(const char* name){
    printf("Usage: %s [-m] sfifiles\n\n",name);
    printf( "    This program converts sfi images to pgm format.\n\n"
            "    If the first argument is -m then the program runs in multichannel mode\n"
            "    In default mode the first channel of the sfi image is saved to a file.\n"
            "    In multichannel mode every channel of the image is saved to its own pgm image.\n"
            "    The pgm image will have a channel number appended to its file name \"*_XXX.pgm\".\n");
    exit(1);
}

void removeExtention(char* filename){
    int i;

    for(i = strlen(filename); i >= 0; i--){
        if(filename[i] == '.'){
            filename[i] = 0;
            break;
        }
        if(filename[i] == '/'){
            break;
        }
    }
}

int main(int argc, char** argv){
    Image im;
    char outfilename[MAX_FILENAME_LENGTH];
    int c;
    int multichannel = 0;
    int i = 1;

    printf("%s\n%s\n",OPENING,VERSION);
    if(argc == 1 || strcmp(argv[1],"-help") == 0 || strcmp(argv[1],"--help") == 0){
        usage(argv[0]);
    }

    if(strcmp(argv[1],"-m") == 0){ multichannel = 1; i++; }

    for(;i < argc; i++){
        printf("Converting: %s\n",argv[i]);
        im = readRawImage(argv[i]);
        
        removeExtention(argv[i]);

        if(multichannel){
            for(c = 0; c < im->channels; c++){
                sprintf(outfilename,"%s_%03d.pgm",argv[i],c);
                printf("    Writing: %s\n",outfilename);
                writePGMImage(im,outfilename,c);
            }
        }
        else{
            sprintf(outfilename,"%s.pgm",argv[i]);
            printf("    Writing: %s\n",outfilename);
            writePGMImage(im,outfilename,0);
        }
    }
    printf("done.\n");

    return 0;
}


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/**
File: csuToolWriteSubspaceAsMatrices.c
Authors: Marcio Luis Teixeira                           
Date: May 24, 2002                                                       
*/

/*
Copyright (c) 2003 Colorado State University

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#define OPENING  "Saves subspace files as matrices"

/*
 Purpose: This program writes subspace training file (from either PCA or the
Bayesian classifier) as text files suitable for loading into MatLab or Octave.
*/

/*  CSU INCLUDES */
#include <csuCommon.h>

/*
 The command line arguments are managed by a single structure.
*/

typedef struct
{
  char* trainingFile;
  MatrixSaveMode mode;
}
Arguments;

/* ----------------------------------------------------------------------------------- */
/* Remind the user the usage of running this program.
*/
void usage(const char* prog)
{
  printf("Usage: %s [OPTIONS] trainingFile\n", prog);
  printf("  Parameters:\n");
  printf("     trainingFile ....    Name of file containing subspace generated by training.\n");
  printf("    -debuglevel <int>:    Level of debug information to display. DEFAULT = 0\n");
  printf("    -quiet:               Turn off all messages. DEFAULT = messages on\n");
  printf("    -matlab:              Save matrices in matlab format. DEFAULT = octave\n");

  exit(1);
}

void process_command(int argc, char** argv, Arguments* args)
{
    int i;
    int param_num = 0;

    /******* Set up default values *******/

    args->mode = octaveFormat;

    quiet = 0;
    debuglevel = 0;

    for (i = 1; i < argc; i++) {

      /* Catch common help requests */
      if      (readOption       (argc, argv, &i, "-help" )) { usage(argv[0]); }
      else if (readOption       (argc, argv, &i, "--help")) { usage(argv[0]); }

      /* other flags */
      else if (readOption       (argc, argv, &i, "-quiet")) { quiet = 1; }
      else if (readOptionInt    (argc, argv, &i, "-debuglevel", &debuglevel));
      else if (readOption       (argc, argv, &i, "-matlab")) { args->mode = matlabFormat; }

      /* check if the current argument is an unparsed option */
      else if (checkBadOption(argc,argv,&i));
      
      else if (param_num == 0) {
	args->trainingFile = strdup(argv[i]);
	param_num++;
      }
    }

    if (param_num < 1)
        usage (argv[0]);

  /* Print out the program parameters for appropriate debug level */

  DEBUG_INT (1, "Debuging enabled", debuglevel);

  if (debuglevel > 0)
    {
      printf ("***************** Program Parameters *********************\n");
      printf ("trainingFile: %s\n", args->trainingFile);
    }
}

/* ===========================================================================
 MAIN
 
 The arguments are processed and then the subspace and related information is
 read from the training file written by csuSubspaceTrain.  The subspace basis
 is read into a matrix and written out as a file.
*/

int main(int argc, char *argv[])
{
  Arguments args;
  Subspace subspace;
  char fname [255], label [255];

  MESSAGE (OPENING);
  MESSAGE (VERSION);
  
  process_command(argc, argv, &args);

  MESSAGE1ARG ("Reading subspace %s", args.trainingFile);
  readSubspace (&subspace, args.trainingFile, quiet);

  /* Save out the mean */

  strcpy (label, args.trainingFile);
  strcat (label, "_mean");
  strcpy (fname, label);
  strcat (fname, ".txt");
  MESSAGE1ARG ("Saving mean to %s", fname);
  saveMatrixAscii (fname, label, subspace.mean, args.mode);

  /* Save out the values */

  strcpy (label, args.trainingFile);
  strcat (label, "_values");
  strcpy (fname, label);
  strcat (fname, ".txt");
  MESSAGE1ARG ("Saving values to %s", fname);
  saveMatrixAscii (fname, label, subspace.values, args.mode);

  /* Save out the basis */

  strcpy (label, args.trainingFile);
  strcat (label, "_basis");
  strcpy (fname, label);
  strcat (fname, ".txt");
  MESSAGE1ARG ("Saving basis to %s", fname);
  saveMatrixAscii (fname, label, subspace.basis, args.mode);

  return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#ifdef THRD
#include <stdlib.h>
#include "threading.h"

pthread_t thread[NUM_THREADS];

barrier_t* thrd_barrier;

barrier_t * thread_barrier_init(int n_clients) {
  barrier_t *barrier;

#if (NUM_THREADS>1)

  barrier = (barrier_t *) malloc(sizeof(barrier_t));

  if (barrier != NULL) {
    barrier->n_clients = n_clients;
    barrier->n_waiting = 0;
    barrier->phase = 0;
    pthread_mutex_init(&barrier->lock, NULL);
    pthread_cond_init(&barrier->wait_cv, NULL);
  }
#endif
  return barrier;
}

void thread_barrier_destroy(barrier_t *barrier) {
#if (NUM_THREADS>1)
  pthread_mutex_destroy(&barrier->lock);
  pthread_cond_destroy(&barrier->wait_cv);
  free(barrier);
#endif
}

void thread_barrier(int t, barrier_t *barrier) {
#if (NUM_THREADS>1)
  int my_phase;

  pthread_mutex_lock(&barrier->lock);
  my_phase = barrier->phase;
  barrier->n_waiting++;

  if (barrier->n_waiting == barrier->n_clients) {
    barrier->n_waiting = 0;
    barrier->phase = 1 - my_phase;
    pthread_cond_broadcast(&barrier->wait_cv);
  }

  while (barrier->phase == my_phase) {
    pthread_cond_wait(&barrier->wait_cv, &barrier->lock);
  }

  pthread_mutex_unlock(&barrier->lock);
#endif
}

thrd_args_t thrd_data_array[NUM_THREADS];

void thrd_mean_subtract_images(Matrix images, Matrix mean, int s, int e)
{
  FTYPE *img_ptr, *mn_ptr;
#ifdef SSE2
  int i;

  img_ptr = &ME(images, s, 0);
  mn_ptr = &ME(mean, s, 0);

  /* In order to use packed aligned load, need to loop leep. */
  if (s&1) {
    *img_ptr -= *mn_ptr;
    s++; img_ptr++; mn_ptr++;
  }

  i = (e-s)>>1;

  __asm
    {
      mov      ecx, [i]    ;
      mov      edx, [mn_ptr]     ;
      mov      ebx, [img_ptr]    ;
      
    loop_label:
      movapd   xmm0, [ebx]             ; /*load 2 doubles from images*/
      movapd   xmm1, [edx]             ; /*load 2 doubles from mean */
      subpd    xmm0, xmm1              ; /*xmm0 has (img-mn) */
      movapd   [ebx], xmm0             ;     
      add      ebx, 16                 ;
      add      edx, 16                 ;
      sub      ecx, 1                  ;
      cmp      ecx, 0                  ;
      jnz      loop_label              ;
    }
  i <<= 1;
  i = s + i;

#else
  int i;
  img_ptr = &ME(images, s, 0);
  mn_ptr = &ME(mean, s, 0);
 
  for (i = s; i < e-1; i+=2) {
    *img_ptr -= *mn_ptr;
    *(img_ptr+1) -= *(mn_ptr+1);
    img_ptr+=2; mn_ptr+=2;
    /*ME(images, i, 0) -= ME(mean, i, 0);
      ME(images, i+1, 0) -= ME(mean, i+1, 0);*/
  }
#endif  

  if (i<e)
    ME(images, i, 0) -= ME(mean, i, 0);

}

void thrd_transposeMultiplyMatrixL(Matrix A, Matrix B, 
				   Matrix P, int sa, int ea)
{
  int i, j, k;
  double sum;
  __declspec(align(16)) static const double packed_zero[2] = {0.0, 0.0};
  int a_row_dim = A->row_dim;

#ifdef SSE2

  for ( j = 0; j < B->col_dim; j++) {    /* orig: B->coldim (== 1) */
    double *B_addr = &ME(B, 0, j);
    double *A_addr = &ME(A, 0, sa);
    
    for ( i = sa; i < ea; i++) {           /* original; A->col_dim */
           
      sum = 0.0;

      k = a_row_dim >> 1;
      __asm
	{
	  movapd xmm2, [packed_zero]     ; /*packed sum*/
	  mov    ebx, [A_addr]    ;
	  mov    edx, [B_addr]    ;
	  mov    ecx, [k]         ;
	  sar    ecx, 1           ;

	tmml_loop:
	  movapd   xmm0, [ebx]             ; /*load 2 doubles from A*/
	  movapd   xmm1, [edx]             ; /*load 2 doubles from B */
	  movapd   xmm3, [ebx+16]             ; /*load 2 doubles from A*/
	  movapd   xmm4, [edx+16]             ; /*load 2 doubles from B */
	  mulpd    xmm0, xmm1              ; 
	  mulpd    xmm3, xmm4              ; 
	  addpd    xmm2, xmm0              ; /*accumulate partial sums*/
	  addpd    xmm2, xmm3              ; /*accumulate partial sums*/
	  add      ebx, 32                 ;
	  add      edx, 32                 ;
	  sub      ecx, 1                  ;
	  cmp      ecx, 0                  ;
	  jnz      tmml_loop               ;
	  
	  pshufd   xmm0, xmm2, 14          ; /*reduction */
	  addsd    xmm0, xmm2              ;
	  movsd    [sum], xmm0 ;
	    
	}
      
      ME(P, i, j) = sum;
      A_addr+=a_row_dim;
    }
  }

#else  
  FTYPE sum1;
  
  for ( j = 0; j < B->col_dim; j++) {    /* orig: B->coldim (== 1) */
    double *A_addr = &ME(A, 0, sa);
    
    for ( i = sa; i < ea; i++) {           /* original; A->col_dim */
      double *B_addr = &ME(B, 0, j);

      sum = sum1=0.0;

      for (k = 0; k < a_row_dim; k+=2) {
	sum+= (*A_addr) * (*B_addr);
	sum1+= (*(A_addr+1)) * (*(B_addr+1));
	A_addr+=2;B_addr+=2;
	/*sum += ME(A, k, i) * ME(B, k, j);*/
      }
      sum += sum1;
      ME(P, i, j) = sum;
    }
  }
#endif
}

void ThreadJoin() 
{ 
#if (NUM_THREADS>1)
  int t, rc, status;
  for(t=0;t < NUM_THREADS-1;t++) {
    rc = pthread_join(thread[t], (void **)&status);
    if (rc)	  {
      printf("ERROR; return code from pthread_join() is %d\n", rc);
      exit(-1);
    }
  }
#endif
}

void* main_thrd_work(void* thrd_args) {
  thrd_args_t *my_data = (thrd_args_t*) thrd_args;
  int t = my_data->id;
  Matrix images = my_data->images;
  int chunk = images->row_dim / NUM_THREADS;
  int remainder = images->row_dim % NUM_THREADS;
  Subspace *s = my_data->s;
  int start;
  int end;

  start = (t==0) ? 0 : t*chunk;
  start += (t <= remainder) ? t:remainder;
  end = (t < remainder)? 1:0;
  end += start + chunk;

  /*printf("thread %d sub start %d end %d\n",t,start,end);*/
  thrd_mean_subtract_images(images, s->mean, start, end);

  thread_barrier(t, thrd_barrier);

  /* the mean subtract is in synch */

  chunk = s->basis->col_dim / NUM_THREADS;
  remainder = s->basis->col_dim % NUM_THREADS;

  start = (t==0) ? 0 : t*chunk;
  start += (t <= remainder) ? t:remainder;
  end = (t < remainder)? 1:0;
  end += start + chunk;
  
  /*printf("thread %d mul start %d end %d\n",t,start,end);*/
  thrd_transposeMultiplyMatrixL(s->basis, images, my_data->subspims,
				start, end);

  return NULL;
}

Matrix subspims;

Matrix thrd_centerthenproject(Subspace *s, Matrix images) {
  int t;
  int chunk;
  int remainder;
  int start;
  int end;
#if (NUM_THREADS>1)
  pthread_attr_t attr;
  int rc;

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

  thrd_barrier = thread_barrier_init(NUM_THREADS);
#endif

  subspims = makeMatrix(s->basis->col_dim, images->col_dim);

  for(t=0; t < NUM_THREADS; t++) {
    
    thrd_data_array[t].id = t;
    
    thrd_data_array[t].images = images;
    thrd_data_array[t].s = s;
    thrd_data_array[t].subspims = subspims;
    
#if (NUM_THREADS>1)
    /* create threads */
    if (t!=NUM_THREADS-1) {
      rc = pthread_create(&thread[t], &attr, main_thrd_work, 
			  (void*) &thrd_data_array[t]); 
      if (rc) {
	printf("ERROR; return code from pthread_create() is %d\n", rc);
	exit(-1);
      }
    }
#endif
  }

#if (NUM_THREADS>1)
  /* Free attribute and wait for the other threads */
  pthread_attr_destroy(&attr);
#endif

  main_thrd_work(&thrd_data_array[NUM_THREADS-1]);
  ThreadJoin();
  return subspims;
}


#endif /* end ifdef THRD */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#include<pthread.h>
#include "csuCommon.h"

typedef struct barrier_struct {
  int padding1[8]; /* Padding bytes to avoid false sharing and cache aliasing */
  pthread_mutex_t lock;   /* Mutex lock for the structure */
  int n_clients;          /* Number of threads to wait for at barrier */
  int n_waiting;          /* Number of currently waiting threads */
  int phase;              /* Flag to separate waiters from fast workers */
  pthread_cond_t wait_cv; /* Clients wait on condition variable to proceed */
  int padding2[8]; /* Padding bytes to avoid false sharing and cache aliasing */
} barrier_t;

typedef struct {
  int id;
  Matrix images, subspims;
  Subspace* s;
} thrd_args_t;

barrier_t * thread_barrier_init(int n_clients);
void thread_barrier_destroy(barrier_t *barrier);
void thread_barrier(int t,barrier_t *barrier);

Matrix thrd_centerthenproject(Subspace *s, Matrix images);

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* config.h, configuration defines                                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/* define NON_ANSI_COMPILER for compilers without function prototyping */
/* #define NON_ANSI_COMPILER */

#ifdef NON_ANSI_COMPILER
#define _ANSI_ARGS_(x) ()
#else
#define _ANSI_ARGS_(x) x
#endif

#define RB "rb"
#define WB "wb"

#ifndef O_BINARY
#define O_BINARY 0
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* display.c, X11 interface                                                 */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#ifdef DISPLAY

 /* the Xlib interface is closely modeled after
  * mpeg_play 2.0 by the Berkeley Plateau Research Group
  */

#include <stdio.h>
#include <stdlib.h>

#include <X11/Xlib.h>
#include <X11/Xutil.h>

#include "config.h"
#include "global.h"

/* private prototypes */
static void Display_Image _ANSI_ARGS_((XImage *Ximage_Ptr, unsigned char *Dithered_Image));
static void Dither_Frame _ANSI_ARGS_((unsigned char *src[]));
static void Dither_Top_Field _ANSI_ARGS_((unsigned char *src[], unsigned char *dst));
static void Dither_Bottom_Field _ANSI_ARGS_((unsigned char *src[], unsigned char *dst));
static void Dither_Top_Field420 _ANSI_ARGS_((unsigned char *src[],
                                      unsigned char *dst));
static void Dither_Bottom_Field420 _ANSI_ARGS_((unsigned char *src[],
                                      unsigned char *dst));

/* local data */
static unsigned char *Dithered_Image, *Dithered_Image2;

static unsigned char Y_Table[256+16];
static unsigned char Cb_Table[128+16];
static unsigned char Cr_Table[128+16];

/* X11 related variables */
static Display *Display_Ptr;
static Window Window_Instance;
static GC GC_Instance;
static XImage *Ximage_Ptr, *Ximage_Ptr2;
static unsigned char Pixel[256];

#ifdef SH_MEM

#include <sys/ipc.h>
#include <sys/shm.h>
#include <X11/extensions/XShm.h>

static int HandleXError _ANSI_ARGS_((Display *dpy, XErrorEvent *event));
static void InstallXErrorHandler _ANSI_ARGS_((void));
static void DeInstallXErrorHandler _ANSI_ARGS_((void));

static int Shmem_Flag;
static XShmSegmentInfo Shminfo1, Shminfo2;
static int gXErrorFlag;
static int CompletionType = -1;

static int HandleXError(Dpy, Event)
Display *Dpy;
XErrorEvent *Event;
{
  gXErrorFlag = 1;

  return 0;
}

static void InstallXErrorHandler()
{
  XSetErrorHandler(HandleXError);
  XFlush(Display_Ptr);
}

static void DeInstallXErrorHandler()
{
  XSetErrorHandler(NULL);
  XFlush(Display_Ptr);
}

#endif

/* connect to server, create and map window,
 * allocate colors and (shared) memory
 */
void Initialize_Display_Process(name)
char *name;
{
  int crv, cbu, cgu, cgv;
  int Y, Cb, Cr, R, G, B;
  int i;
  char dummy;
  int screen;
  Colormap cmap;
  int private;
  XColor xcolor;
  unsigned int fg, bg;
  char *hello = "MPEG-2 Display";
  XSizeHints hint;
  XVisualInfo vinfo;
  XEvent xev;
  unsigned long tmp_pixel;
  XWindowAttributes xwa;

  Display_Ptr = XOpenDisplay(name);

  if (Display_Ptr == NULL)
    Error("Can not open display\n");

  screen = DefaultScreen(Display_Ptr);

  hint.x = 200;
  hint.y = 200;
  hint.width = horizontal_size;
  hint.height = vertical_size;
  hint.flags = PPosition | PSize;

  /* Get some colors */

  bg = WhitePixel (Display_Ptr, screen);
  fg = BlackPixel (Display_Ptr, screen);

  /* Make the window */

  if (!XMatchVisualInfo(Display_Ptr, screen, 8, PseudoColor, &vinfo))
  {
    if (!XMatchVisualInfo(Display_Ptr, screen, 8, GrayScale, &vinfo))
      Error("requires 8 bit display\n");
  }

  Window_Instance = XCreateSimpleWindow (Display_Ptr, DefaultRootWindow (Display_Ptr),
             hint.x, hint.y, hint.width, hint.height, 4, fg, bg);

  XSelectInput(Display_Ptr, Window_Instance, StructureNotifyMask);

  /* Tell other applications about this window */

  XSetStandardProperties (Display_Ptr, Window_Instance, hello, hello, None, NULL, 0, &hint);

  /* Map window. */

  XMapWindow(Display_Ptr, Window_Instance);

  /* Wait for map. */
  do
  {
    XNextEvent(Display_Ptr, &xev);
  }
  while (xev.type != MapNotify || xev.xmap.event != Window_Instance);

  XSelectInput(Display_Ptr, Window_Instance, NoEventMask);

  /* matrix coefficients */
  crv = Inverse_Table_6_9[matrix_coefficients][0];
  cbu = Inverse_Table_6_9[matrix_coefficients][1];
  cgu = Inverse_Table_6_9[matrix_coefficients][2];
  cgv = Inverse_Table_6_9[matrix_coefficients][3];

  /* allocate colors */

  GC_Instance = DefaultGC(Display_Ptr, screen);
  cmap = DefaultColormap(Display_Ptr, screen);
  private = 0;

  /* color allocation:
   * i is the (internal) 8 bit color number, it consists of separate
   * bit fields for Y, U and V: i = (yyyyuuvv), we don't use yyyy=0000
   * and yyyy=1111, this leaves 32 colors for other applications
   *
   * the allocated colors correspond to the following Y, U and V values:
   * Y:   24, 40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232
   * U,V: -48, -16, 16, 48
   *
   * U and V values span only about half the color space; this gives
   * usually much better quality, although highly saturated colors can
   * not be displayed properly
   *
   * translation to R,G,B is implicitly done by the color look-up table
   */
  for (i=16; i<240; i++)
  {
    /* color space conversion */
    Y  = 16*((i>>4)&15) + 8;
    Cb = 32*((i>>2)&3)  - 48;
    Cr = 32*(i&3)       - 48;

    Y = 76309 * (Y - 16); /* (255/219)*65536 */

    R = Clip[(Y + crv*Cr + 32768)>>16];
    G = Clip[(Y - cgu*Cb - cgv*Cr + 32768)>>16];
    B = Clip[(Y + cbu*Cb + 32786)>>16];

    /* X11 colors are 16 bit */
    xcolor.red   = R << 8;
    xcolor.green = G << 8;
    xcolor.blue  = B << 8;

    if (XAllocColor(Display_Ptr, cmap, &xcolor) != 0)
      Pixel[i] = xcolor.pixel;
    else
    {
      /* allocation failed, have to use a private colormap */

      if (private)
        Error("Couldn't allocate private colormap");

      private = 1;

      if (!Quiet_Flag)
        fprintf(stderr, "Using private colormap (%d colors were available).\n",
          i-16);

      /* Free colors. */
      while (--i >= 16)
      {
        tmp_pixel = Pixel[i]; /* because XFreeColors expects unsigned long */
        XFreeColors(Display_Ptr, cmap, &tmp_pixel, 1, 0);
      }

      /* i is now 15, this restarts the outer loop */

      /* create private colormap */

      XGetWindowAttributes(Display_Ptr, Window_Instance, &xwa);
      cmap = XCreateColormap(Display_Ptr, Window_Instance, xwa.visual, AllocNone);
      XSetWindowColormap(Display_Ptr, Window_Instance, cmap);
    }
  }

#ifdef SH_MEM
  if (XShmQueryExtension(Display_Ptr))
    Shmem_Flag = 1;
  else
  {
    Shmem_Flag = 0;
    if (!Quiet_Flag)
      fprintf(stderr, "Shared memory not supported\nReverting to normal Xlib\n");
  }

  if (Shmem_Flag)
    CompletionType = XShmGetEventBase(Display_Ptr) + ShmCompletion;

  InstallXErrorHandler();

  if (Shmem_Flag)
  {

    Ximage_Ptr = XShmCreateImage(Display_Ptr, None, 8, ZPixmap, NULL,
                             &Shminfo1,
                             Coded_Picture_Width, Coded_Picture_Height);

    if (!progressive_sequence)
      Ximage_Ptr2 = XShmCreateImage(Display_Ptr, None, 8, ZPixmap, NULL,
                                &Shminfo2,
                                Coded_Picture_Width, Coded_Picture_Height);

    /* If no go, then revert to normal Xlib calls. */

    if (Ximage_Ptr==NULL || (!progressive_sequence && Ximage_Ptr2==NULL))
    {
      if (Ximage_Ptr!=NULL)
        XDestroyImage(Ximage_Ptr);
      if (!progressive_sequence && Ximage_Ptr2!=NULL)
        XDestroyImage(Ximage_Ptr2);
      if (!Quiet_Flag)
        fprintf(stderr, "Shared memory error, disabling (Ximage error)\n");
      goto shmemerror;
    }

    /* Success here, continue. */

    Shminfo1.shmid = shmget(IPC_PRIVATE, 
                            Ximage_Ptr->bytes_per_line * Ximage_Ptr->height,
                            IPC_CREAT | 0777);
    if (!progressive_sequence)
      Shminfo2.shmid = shmget(IPC_PRIVATE, 
                              Ximage_Ptr2->bytes_per_line * Ximage_Ptr2->height,
                              IPC_CREAT | 0777);

    if (Shminfo1.shmid<0 || (!progressive_sequence && Shminfo2.shmid<0))
    {
      XDestroyImage(Ximage_Ptr);
      if (!progressive_sequence)
        XDestroyImage(Ximage_Ptr2);
      if (!Quiet_Flag)
        fprintf(stderr, "Shared memory error, disabling (seg id error)\n");
      goto shmemerror;
    }

    Shminfo1.shmaddr = (char *) shmat(Shminfo1.shmid, 0, 0);
    Shminfo2.shmaddr = (char *) shmat(Shminfo2.shmid, 0, 0);

    if (Shminfo1.shmaddr==((char *) -1) ||
        (!progressive_sequence && Shminfo2.shmaddr==((char *) -1)))
    {
      XDestroyImage(Ximage_Ptr);
      if (Shminfo1.shmaddr!=((char *) -1))
        shmdt(Shminfo1.shmaddr);
      if (!progressive_sequence)
      {
        XDestroyImage(Ximage_Ptr2);
        if (Shminfo2.shmaddr!=((char *) -1))
          shmdt(Shminfo2.shmaddr);
      }
      if (!Quiet_Flag)
      {
        fprintf(stderr, "Shared memory error, disabling (address error)\n");
      }
      goto shmemerror;
    }

    Ximage_Ptr->data = Shminfo1.shmaddr;
    Dithered_Image = (unsigned char *)Ximage_Ptr->data;
    Shminfo1.readOnly = False;
    XShmAttach(Display_Ptr, &Shminfo1);
    if (!progressive_sequence)
    {
      Ximage_Ptr2->data = Shminfo2.shmaddr;
      Dithered_Image2 = (unsigned char *)Ximage_Ptr2->data;
      Shminfo2.readOnly = False;
      XShmAttach(Display_Ptr, &Shminfo2);
    }

    XSync(Display_Ptr, False);

    if (gXErrorFlag)
    {
      /* Ultimate failure here. */
      XDestroyImage(Ximage_Ptr);
      shmdt(Shminfo1.shmaddr);
      if (!progressive_sequence)
      {
        XDestroyImage(Ximage_Ptr2);
        shmdt(Shminfo2.shmaddr);
      }
      if (!Quiet_Flag)
        fprintf(stderr, "Shared memory error, disabling.\n");
      gXErrorFlag = 0;
      goto shmemerror;
    }
    else
    {
      shmctl(Shminfo1.shmid, IPC_RMID, 0);
      if (!progressive_sequence)
        shmctl(Shminfo2.shmid, IPC_RMID, 0);
    }

    if (!Quiet_Flag)
    {
      fprintf(stderr, "Sharing memory.\n");
    }
  }
  else
  {
shmemerror:
    Shmem_Flag = 0;
#endif

    Ximage_Ptr = XCreateImage(Display_Ptr,None,8,ZPixmap,0,&dummy,
                          Coded_Picture_Width,Coded_Picture_Height,8,0);

    if (!(Dithered_Image = (unsigned char *)malloc(Coded_Picture_Width*
                                                   Coded_Picture_Height)))
      Error("malloc failed");

    if (!progressive_sequence)
    {
      Ximage_Ptr2 = XCreateImage(Display_Ptr,None,8,ZPixmap,0,&dummy,
                             Coded_Picture_Width,Coded_Picture_Height,8,0);

      if (!(Dithered_Image2 = (unsigned char *)malloc(Coded_Picture_Width*
                                                      Coded_Picture_Height)))
        Error("malloc failed");
    }

#ifdef SH_MEM
  }

  DeInstallXErrorHandler();
#endif
}

void Terminate_Display_Process()
{
#ifdef SH_MEM
  if (Shmem_Flag)
  {
    XShmDetach(Display_Ptr, &Shminfo1);
    XDestroyImage(Ximage_Ptr);
    shmdt(Shminfo1.shmaddr);
    if (!progressive_sequence)
    {
      XShmDetach(Display_Ptr, &Shminfo2);
      XDestroyImage(Ximage_Ptr2);
      shmdt(Shminfo2.shmaddr);
    }
  }
#endif
}

static void Display_Image(Ximage_Ptr,Dithered_Image)
XImage *Ximage_Ptr;
unsigned char *Dithered_Image;
{
  /* display dithered image */
#ifdef SH_MEM
  if (Shmem_Flag)
  {
    XShmPutImage(Display_Ptr, Window_Instance, GC_Instance, Ximage_Ptr, 
       	         0, 0, 0, 0, Ximage_Ptr->width, Ximage_Ptr->height, True);
    XFlush(Display_Ptr);
      
    while (1)
    {
      XEvent xev;
	
      XNextEvent(Display_Ptr, &xev);
      if (xev.type == CompletionType)
        break;
    }
  }
  else 
#endif
  {
    Ximage_Ptr->data = (char *) Dithered_Image; 
    XPutImage(Display_Ptr, Window_Instance, GC_Instance, Ximage_Ptr, 0, 0, 0, 0, Ximage_Ptr->width, Ximage_Ptr->height);
  }
}

void Display_Second_Field()
{
  Display_Image(Ximage_Ptr2,Dithered_Image2);
}

/* 4x4 ordered dither
 *
 * threshold pattern:
 *   0  8  2 10
 *  12  4 14  6
 *   3 11  1  9
 *  15  7 13  5
 */

void Initialize_Dither_Matrix()
{
  int i, v;

  for (i=-8; i<256+8; i++)
  {
    v = i>>4;
    if (v<1)
      v = 1;
    else if (v>14)
      v = 14;
    Y_Table[i+8] = v<<4;
  }

  for (i=0; i<128+16; i++)
  {
    v = (i-40)>>4;
    if (v<0)
      v = 0;
    else if (v>3)
      v = 3;
    Cb_Table[i] = v<<2;
    Cr_Table[i] = v;
  }
}

void dither(src)
unsigned char *src[];
{
  /* should this test only the display flag, not progressive_sequence ? --CF */
  /* CHANGE 95/05/13: progressive_sequence -> progressive_frame */

  if( progressive_frame || Display_Progressive_Flag)
    Dither_Frame(src);
  else
  {
    if ((picture_structure==FRAME_PICTURE && top_field_first) || picture_structure==BOTTOM_FIELD)
    {
      /* top field first */
      if (chroma_format==CHROMA420 && hiQdither)
      {
        Dither_Top_Field420(src,Dithered_Image);
        Dither_Bottom_Field420(src,Dithered_Image2);
      }
      else
      {
        Dither_Top_Field(src,Dithered_Image);
        Dither_Bottom_Field(src,Dithered_Image2);
      }
    }
    else
    {
      /* bottom field first */
      if (chroma_format==CHROMA420 && hiQdither)
      {
        Dither_Bottom_Field420(src,Dithered_Image);
        Dither_Top_Field420(src,Dithered_Image2);
      }
      else
      {
        Dither_Bottom_Field(src,Dithered_Image);
        Dither_Top_Field(src,Dithered_Image2);
      }
    }
  }

  Display_Image(Ximage_Ptr,Dithered_Image);
}

static void Dither_Frame(src)
unsigned char *src[];
{
  int i,j;
  int y,u,v;
  unsigned char *py,*pu,*pv,*dst;

  py = src[0];
  pu = src[1];
  pv = src[2];
  dst = Dithered_Image;

  for (j=0; j<Coded_Picture_Height; j+=4)
  {
    /* line j + 0 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y]|Cb_Table[u]|Cr_Table[v]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+8]|Cb_Table[u+8]|Cr_Table[v+8]];
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+2]|Cb_Table[u+2]|Cr_Table[v+2]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+10]|Cb_Table[u+10]|Cr_Table[v+10]];
    }

    if (chroma_format==CHROMA420)
    {
      pu -= Chroma_Width;
      pv -= Chroma_Width;
    }

    /* line j + 1 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+12]|Cb_Table[u+12]|Cr_Table[v+12]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+4]|Cb_Table[u+4]|Cr_Table[v+4]];
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+14]|Cb_Table[u+14]|Cr_Table[v+14]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+6]|Cb_Table[u+6]|Cr_Table[v+6]];
    }

    /* line j + 2 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+3]|Cb_Table[u+3]|Cr_Table[v+3]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+11]|Cb_Table[u+11]|Cr_Table[v+11]];
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+1]|Cb_Table[u+1]|Cr_Table[v+1]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+9]|Cb_Table[u+9]|Cr_Table[v+9]];
    }

    if (chroma_format==CHROMA420)
    {
      pu -= Chroma_Width;
      pv -= Chroma_Width;
    }

    /* line j + 3 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+15]|Cb_Table[u+15]|Cr_Table[v+15]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+7]|Cb_Table[u+7]|Cr_Table[v+7]];
      y = *py++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++ = Pixel[Y_Table[y+13]|Cb_Table[u+13]|Cr_Table[v+13]];
      y = *py++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++ = Pixel[Y_Table[y+5]|Cb_Table[u+5]|Cr_Table[v+5]];
    }
  }

}

static void Dither_Top_Field(src,dst)
unsigned char *src[];
unsigned char *dst;
{
  int i,j;
  int y,Y2,u,v;
  unsigned char *py,*Y2_ptr,*pu,*pv,*dst2;

  py = src[0];
  Y2_ptr = src[0] + (Coded_Picture_Width<<1);
  pu = src[1];
  pv = src[2];
  dst2 = dst + Coded_Picture_Width;

  for (j=0; j<Coded_Picture_Height; j+=4)
  {
    /* line j + 0, j + 1 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[y]|Cb_Table[u]|Cr_Table[v]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+12]|Cb_Table[u+12]|Cr_Table[v+12]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[y+8]|Cb_Table[u+8]|Cr_Table[v+8]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+4]|Cb_Table[u+4]|Cr_Table[v+4]];

      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[y+2]|Cb_Table[u+2]|Cr_Table[v+2]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+14]|Cb_Table[u+14]|Cr_Table[v+14]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[y+10]|Cb_Table[u+10]|Cr_Table[v+10]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+6]|Cb_Table[u+6]|Cr_Table[v+6]];
    }

    py += Coded_Picture_Width;

    if (j!=(Coded_Picture_Height-4))
      Y2_ptr += Coded_Picture_Width;
    else
      Y2_ptr -= Coded_Picture_Width;

    dst += Coded_Picture_Width;
    dst2 += Coded_Picture_Width;

    if (chroma_format==CHROMA420)
    {
      pu -= Chroma_Width;
      pv -= Chroma_Width;
    }
    else
    {
      pu += Chroma_Width;
      pv += Chroma_Width;
    }

    /* line j + 2, j + 3 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[y+3]|Cb_Table[u+3]|Cr_Table[v+3]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+15]|Cb_Table[u+15]|Cr_Table[v+15]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[y+11]|Cb_Table[u+11]|Cr_Table[v+11]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+7]|Cb_Table[u+7]|Cr_Table[v+7]];

      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[y+1]|Cb_Table[u+1]|Cr_Table[v+1]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+13]|Cb_Table[u+13]|Cr_Table[v+13]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[y+9]|Cb_Table[u+9]|Cr_Table[v+9]];
      *dst2++ = Pixel[Y_Table[((y+Y2)>>1)+5]|Cb_Table[u+5]|Cr_Table[v+5]];
    }

    py += Coded_Picture_Width;
    Y2_ptr += Coded_Picture_Width;
    dst += Coded_Picture_Width;
    dst2 += Coded_Picture_Width;
    pu += Chroma_Width;
    pv += Chroma_Width;
  }
}

static void Dither_Bottom_Field(src,dst)
unsigned char *src[];
unsigned char *dst;
{
  int i,j;
  int y,Y2,u,v;
  unsigned char *py,*Y2_ptr,*pu,*pv,*dst2;

  py = src[0] + Coded_Picture_Width;
  Y2_ptr = py;
  pu = src[1] + Chroma_Width;
  pv = src[2] + Chroma_Width;
  dst2 = dst + Coded_Picture_Width;

  for (j=0; j<Coded_Picture_Height; j+=4)
  {
    /* line j + 0, j + 1 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)]|Cb_Table[u]|Cr_Table[v]];
      *dst2++ = Pixel[Y_Table[Y2+12]|Cb_Table[u+12]|Cr_Table[v+12]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+8]|Cb_Table[u+8]|Cr_Table[v+8]];
      *dst2++ = Pixel[Y_Table[Y2+4]|Cb_Table[u+4]|Cr_Table[v+4]];

      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+2]|Cb_Table[u+2]|Cr_Table[v+2]];
      *dst2++ = Pixel[Y_Table[Y2+14]|Cb_Table[u+14]|Cr_Table[v+14]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+10]|Cb_Table[u+10]|Cr_Table[v+10]];
      *dst2++ = Pixel[Y_Table[Y2+6]|Cb_Table[u+6]|Cr_Table[v+6]];
    }

    if (j==0)
      py -= Coded_Picture_Width;
    else
      py += Coded_Picture_Width;

    Y2_ptr += Coded_Picture_Width;
    dst += Coded_Picture_Width;
    dst2 += Coded_Picture_Width;

    if (chroma_format==CHROMA420)
    {
      pu -= Chroma_Width;
      pv -= Chroma_Width;
    }
    else
    {
      pu += Chroma_Width;
      pv += Chroma_Width;
    }

    /* line j + 2. j + 3 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+3]|Cb_Table[u+3]|Cr_Table[v+3]];
      *dst2++ = Pixel[Y_Table[Y2+15]|Cb_Table[u+15]|Cr_Table[v+15]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+11]|Cb_Table[u+11]|Cr_Table[v+11]];
      *dst2++ = Pixel[Y_Table[Y2+7]|Cb_Table[u+7]|Cr_Table[v+7]];

      y = *py++;
      Y2 = *Y2_ptr++;
      u = *pu++ >> 1;
      v = *pv++ >> 1;
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+1]|Cb_Table[u+1]|Cr_Table[v+1]];
      *dst2++ = Pixel[Y_Table[Y2+13]|Cb_Table[u+13]|Cr_Table[v+13]];

      y = *py++;
      Y2 = *Y2_ptr++;
      if (chroma_format==CHROMA444)
      {
        u = *pu++ >> 1;
        v = *pv++ >> 1;
      }
      *dst++  = Pixel[Y_Table[((y+Y2)>>1)+9]|Cb_Table[u+9]|Cr_Table[v+9]];
      *dst2++ = Pixel[Y_Table[Y2+5]|Cb_Table[u+5]|Cr_Table[v+5]];
    }

    py += Coded_Picture_Width;
    Y2_ptr += Coded_Picture_Width;
    dst += Coded_Picture_Width;
    dst2 += Coded_Picture_Width;
    pu += Chroma_Width;
    pv += Chroma_Width;
  }
}

static void Dither_Top_Field420(src,dst)
unsigned char *src[];
unsigned char *dst;
{
  int i,j;
  int Y1,Cb1,Cr1,Y2,Cb2,Cr2;
  unsigned char *Y1_ptr,*Cb1_ptr,*Cr1_ptr,*Y2_ptr,*Cb2_ptr,*Cr2_ptr,*dst2;

  Y1_ptr = src[0];
  Cb1_ptr = src[1];
  Cr1_ptr = src[2];

  Y2_ptr = Y1_ptr + (Coded_Picture_Width<<1);
  Cb2_ptr = Cb1_ptr + (Chroma_Width<<1);
  Cr2_ptr = Cr1_ptr + (Chroma_Width<<1);

  dst2 = dst + Coded_Picture_Width;

  for (j=0; j<Coded_Picture_Height; j+=4)
  {
    /* line j + 0, j + 1 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)]|Cb_Table[Cb1]|Cr_Table[Cr1]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+12]|Cb_Table[((3*Cb1+Cb2)>>2)+12]
                                             |Cr_Table[((3*Cr1+Cr2)>>2)+12]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+8]|Cb_Table[Cb1+8]|Cr_Table[Cr1+8]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+4]|Cb_Table[((3*Cb1+Cb2)>>2)+4]
                                            |Cr_Table[((3*Cr1+Cr2)>>2)+4]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+2]|Cb_Table[Cb1+2]|Cr_Table[Cr1+2]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+14]|Cb_Table[((3*Cb1+Cb2)>>2)+14]
                                             |Cr_Table[((3*Cr1+Cr2)>>2)+14]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+10]|Cb_Table[Cb1+10]|Cr_Table[Cr1+10]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+6]|Cb_Table[((3*Cb1+Cb2)>>2)+6]
                                            |Cr_Table[((3*Cr1+Cr2)>>2)+6]];
    }

    Y1_ptr += Coded_Picture_Width;

    if (j!=(Coded_Picture_Height-4))
      Y2_ptr += Coded_Picture_Width;
    else
      Y2_ptr -= Coded_Picture_Width;

    Cb1_ptr -= Chroma_Width;
    Cr1_ptr -= Chroma_Width;
    Cb2_ptr -= Chroma_Width;
    Cr2_ptr -= Chroma_Width;

    dst  += Coded_Picture_Width;
    dst2 += Coded_Picture_Width;

    /* line j + 2, j + 3 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+3]|Cb_Table[((Cb1+Cb2)>>1)+3]
                                            |Cr_Table[((Cr1+Cr2)>>1)+3]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+15]|Cb_Table[((Cb1+3*Cb2)>>2)+15]
                                             |Cr_Table[((Cr1+3*Cr2)>>2)+15]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+11]|Cb_Table[((Cb1+Cb2)>>1)+11]
                                             |Cr_Table[((Cr1+Cr2)>>1)+11]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+7]|Cb_Table[((Cb1+3*Cb2)>>2)+7]
                                            |Cr_Table[((Cr1+3*Cr2)>>2)+7]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+1]|Cb_Table[((Cb1+Cb2)>>1)+1]
                                            |Cr_Table[((Cr1+Cr2)>>1)+1]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+13]|Cb_Table[((Cb1+3*Cb2)>>2)+13]
                                             |Cr_Table[((Cr1+3*Cr2)>>2)+13]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+9]|Cb_Table[((Cb1+Cb2)>>1)+9]
                                            |Cr_Table[((Cr1+Cr2)>>1)+9]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+5]|Cb_Table[((Cb1+3*Cb2)>>2)+5]
                                            |Cr_Table[((Cr1+3*Cr2)>>2)+5]];
    }

    Y1_ptr += Coded_Picture_Width;
    Y2_ptr += Coded_Picture_Width;
    Cb1_ptr += Chroma_Width;
    Cr1_ptr += Chroma_Width;
    if (j!=(Coded_Picture_Height-8))
    {
      Cb2_ptr += Chroma_Width;
      Cr2_ptr += Chroma_Width;
    }
    else
    {
      Cb2_ptr -= Chroma_Width;
      Cr2_ptr -= Chroma_Width;
    }
    dst += Coded_Picture_Width;
    dst2+= Coded_Picture_Width;
  }
}

static void Dither_Bottom_Field420(src,dst)
unsigned char *src[];
unsigned char *dst;
{
  int i,j;
  int Y1,Cb1,Cr1,Y2,Cb2,Cr2;
  unsigned char *Y1_ptr,*Cb1_ptr,*Cr1_ptr,*Y2_ptr,*Cb2_ptr,*Cr2_ptr,*dst2;

  Y2_ptr = Y1_ptr = src[0] + Coded_Picture_Width;
  Cb2_ptr = Cb1_ptr = src[1] + Chroma_Width;
  Cr2_ptr = Cr1_ptr = src[2] + Chroma_Width;

  dst2 = dst;

  for (j=0; j<Coded_Picture_Height; j+=4)
  {
    /* line j + 0, j + 1 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+15]|Cb_Table[((3*Cb1+Cb2)>>2)+15]
                                             |Cr_Table[((3*Cr1+Cr2)>>2)+15]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)]|Cb_Table[((Cb1+Cb2)>>1)]
                                          |Cr_Table[((Cr1+Cr2)>>1)]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+7]|Cb_Table[((3*Cb1+Cb2)>>2)+7]
                                            |Cr_Table[((3*Cr1+Cr2)>>2)+7]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+8]|Cb_Table[((Cb1+Cb2)>>1)+8]
                                            |Cr_Table[((Cr1+Cr2)>>1)+8]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+13]|Cb_Table[((3*Cb1+Cb2)>>2)+13]
                                             |Cr_Table[((3*Cr1+Cr2)>>2)+13]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+2]|Cb_Table[((Cb1+Cb2)>>1)+2]
                                            |Cr_Table[((Cr1+Cr2)>>1)+2]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+5]|Cb_Table[((3*Cb1+Cb2)>>2)+5]
                                            |Cr_Table[((3*Cr1+Cr2)>>2)+5]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+10]|Cb_Table[((Cb1+Cb2)>>1)+10]
                                             |Cr_Table[((Cr1+Cr2)>>1)+10]];
    }

    if (j!=0)
      Y1_ptr += Coded_Picture_Width;
    else
      Y1_ptr -= Coded_Picture_Width;

    Y2_ptr += Coded_Picture_Width;

    Cb1_ptr -= Chroma_Width;
    Cr1_ptr -= Chroma_Width;
    Cb2_ptr -= Chroma_Width;
    Cr2_ptr -= Chroma_Width;

    if (j!=0)
      dst  += Coded_Picture_Width;

    dst2 += Coded_Picture_Width;

    /* line j + 2, j + 3 */
    for (i=0; i<Coded_Picture_Width; i+=4)
    {
      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+12]|Cb_Table[((Cb1+3*Cb2)>>2)+12]
                                             |Cr_Table[((Cr1+3*Cr2)>>2)+12]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+3]|Cb_Table[Cb2+3]
                                            |Cr_Table[Cr2+3]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+4]|Cb_Table[((Cb1+3*Cb2)>>2)+4]
                                            |Cr_Table[((Cr1+3*Cr2)>>2)+4]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+11]|Cb_Table[Cb2+11]
                                             |Cr_Table[Cr2+11]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      Cb1 = *Cb1_ptr++ >> 1;
      Cr1 = *Cr1_ptr++ >> 1;
      Cb2 = *Cb2_ptr++ >> 1;
      Cr2 = *Cr2_ptr++ >> 1;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+14]|Cb_Table[((Cb1+3*Cb2)>>2)+14]
                                             |Cr_Table[((Cr1+3*Cr2)>>2)+14]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+1]|Cb_Table[Cb2+1]
                                            |Cr_Table[Cr2+1]];

      Y1 = *Y1_ptr++;
      Y2 = *Y2_ptr++;
      *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+6]|Cb_Table[((Cb1+3*Cb2)>>2)+6]
                                            |Cr_Table[((Cr1+3*Cr2)>>2)+6]];
      *dst2++ = Pixel[Y_Table[((Y1+3*Y2)>>2)+9]|Cb_Table[Cb2+9]
                                            |Cr_Table[Cr2+9]];
    }

    Y1_ptr += Coded_Picture_Width;
    Y2_ptr += Coded_Picture_Width;

    if (j!=0)
    {
      Cb1_ptr += Chroma_Width;
      Cr1_ptr += Chroma_Width;
    }
    else
    {
      Cb1_ptr -= Chroma_Width;
      Cr1_ptr -= Chroma_Width;
    }

    Cb2_ptr += Chroma_Width;
    Cr2_ptr += Chroma_Width;

    dst += Coded_Picture_Width;
    dst2+= Coded_Picture_Width;
  }

  Y2_ptr -= (Coded_Picture_Width<<1);
  Cb2_ptr -= (Chroma_Width<<1);
  Cr2_ptr -= (Chroma_Width<<1);

  /* dither last line */
  for (i=0; i<Coded_Picture_Width; i+=4)
  {
    Y1 = *Y1_ptr++;
    Y2 = *Y2_ptr++;
    Cb1 = *Cb1_ptr++ >> 1;
    Cr1 = *Cr1_ptr++ >> 1;
    Cb2 = *Cb2_ptr++ >> 1;
    Cr2 = *Cr2_ptr++ >> 1;
    *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+15]|Cb_Table[((3*Cb1+Cb2)>>2)+15]
                                           |Cr_Table[((3*Cr1+Cr2)>>2)+15]];

    Y1 = *Y1_ptr++;
    Y2 = *Y2_ptr++;
    *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+7]|Cb_Table[((3*Cb1+Cb2)>>2)+7]
                                          |Cr_Table[((3*Cr1+Cr2)>>2)+7]];

    Y1 = *Y1_ptr++;
    Y2 = *Y2_ptr++;
    Cb1 = *Cb1_ptr++ >> 1;
    Cr1 = *Cr1_ptr++ >> 1;
    Cb2 = *Cb2_ptr++ >> 1;
    Cr2 = *Cr2_ptr++ >> 1;
    *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+13]|Cb_Table[((3*Cb1+Cb2)>>2)+13]
                                           |Cr_Table[((3*Cr1+Cr2)>>2)+13]];

    Y1 = *Y1_ptr++;
    Y2 = *Y2_ptr++;
    *dst++  = Pixel[Y_Table[((3*Y1+Y2)>>2)+5]|Cb_Table[((3*Cb1+Cb2)>>2)+5]
                                          |Cr_Table[((3*Cr1+Cr2)>>2)+5]];
    }

}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* getbits.c, bit level routines                                            */

/*
 * All modifications (mpeg2decode -> mpeg2play) are
 * Copyright (C) 1996, Stefan Eckart. All Rights Reserved.
 */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

#include "config.h"
#include "global.h"

/* initialize buffer, call once before first getbits or showbits */

void Initialize_Buffer()
{
  ld->Incnt = 0;
  ld->Rdptr = ld->Rdbfr + 2048;
  ld->Rdmax = ld->Rdptr;

#ifdef VERIFY
  /*  only the verifier uses this particular bit counter 
   *  Bitcnt keeps track of the current parser position with respect
   *  to the video elementary stream being decoded, regardless 
   *  of whether or not it is wrapped within a systems layer stream 
   */
  ld->Bitcnt = 0;
#endif

  ld->Bfr = 0;
  Flush_Buffer(0); /* fills valid data into bfr */
}

void Fill_Buffer()
{
  int Buffer_Level;

  Buffer_Level = read(ld->Infile,ld->Rdbfr,2048);
  ld->Rdptr = ld->Rdbfr;

  if (System_Stream_Flag)
    ld->Rdmax -= 2048;

  
  /* end of the bitstream file */
  if (Buffer_Level < 2048)
  {
    /* just to be safe */
    if (Buffer_Level < 0)
      Buffer_Level = 0;

    /* pad until the next to the next 32-bit word boundary */
    while (Buffer_Level & 3)
      ld->Rdbfr[Buffer_Level++] = 0;

	/* pad the buffer with sequence end codes */
    while (Buffer_Level < 2048)
    {
      ld->Rdbfr[Buffer_Level++] = SEQUENCE_END_CODE>>24;
      ld->Rdbfr[Buffer_Level++] = SEQUENCE_END_CODE>>16;
      ld->Rdbfr[Buffer_Level++] = SEQUENCE_END_CODE>>8;
      ld->Rdbfr[Buffer_Level++] = SEQUENCE_END_CODE&0xff;
    }
  }
}


/* MPEG-1 system layer demultiplexer */

int Get_Byte()
{
  while(ld->Rdptr >= ld->Rdbfr+2048)
  {
    read(ld->Infile,ld->Rdbfr,2048);
    ld->Rdptr -= 2048;
    ld->Rdmax -= 2048;
  }
  return *ld->Rdptr++;
}

/* extract a 16-bit word from the bitstream buffer */
int Get_Word()
{
  int Val;

  Val = Get_Byte();
  return (Val<<8) | Get_Byte();
}


/* return next n bits (right adjusted) without advancing */

unsigned int Show_Bits(N)
int N;
{
  return ld->Bfr >> (32-N);
}


/* return next bit (could be made faster than Get_Bits(1)) */

unsigned int Get_Bits1()
{
  return Get_Bits(1);
}


/* advance by n bits */

void Flush_Buffer(N)
int N;
{
  int Incnt;

  ld->Bfr <<= N;

  Incnt = ld->Incnt -= N;

  if (Incnt <= 24)
  {
    if (System_Stream_Flag && (ld->Rdptr >= ld->Rdmax-4))
    {
      do
      {
        if (ld->Rdptr >= ld->Rdmax)
          Next_Packet();
        ld->Bfr |= Get_Byte() << (24 - Incnt);
        Incnt += 8;
      }
      while (Incnt <= 24);
    }
    else if (ld->Rdptr < ld->Rdbfr+2044)
    {
      do
      {
        ld->Bfr |= *ld->Rdptr++ << (24 - Incnt);
        Incnt += 8;
      }
      while (Incnt <= 24);
    }
    else
    {
      do
      {
        if (ld->Rdptr >= ld->Rdbfr+2048)
          Fill_Buffer();
        ld->Bfr |= *ld->Rdptr++ << (24 - Incnt);
        Incnt += 8;
      }
      while (Incnt <= 24);
    }
    ld->Incnt = Incnt;
  }

#ifdef VERIFY 
  ld->Bitcnt += N;
#endif /* VERIFY */

}


/* return next n bits (right adjusted) */

unsigned int Get_Bits(N)
int N;
{
  unsigned int Val;

  Val = Show_Bits(N);
  Flush_Buffer(N);

  return Val;
}


#ifdef THRD 
/* These are thread-specific functions. They are duplicated so they can operate
   on different buffers */

void Thrd_Initialize_Buffer(t)
int t;
{
  thrd_buf[t] = 0;
  Thrd_Flush_Buffer(t, 0); /* fills valid data into bfr */
}


/* MPEG-1 system layer demultiplexer */

int Thrd_Get_Byte(int t)
{
  return *thrd_ptr[t]++;
}

/* extract a 16-bit word from the bitstream buffer */
int Thrd_Get_Word(int t)
{
  int Val;

  Val = Thrd_Get_Byte(t);
  return (Val<<8) | Thrd_Get_Byte(t);
}


/* return next n bits (right adjusted) without advancing */

unsigned int Thrd_Show_Bits(t, N)
int t;
int N;
{
  return thrd_buf[t] >> (32-N);
}


/* return next bit (could be made faster than Get_Bits(1)) */

unsigned int Thrd_Get_Bits1(int t)
{
  return Thrd_Get_Bits(t, 1);
}


/* advance by n bits */

void Thrd_Flush_Buffer(t, N)
int t;
int N;
{
  int Incnt;

  thrd_buf[t] <<= N;

  Incnt = thrd_Incnt[t] -= N;
  
  if (Incnt <= 24) {
    if (System_Stream_Flag && (ld->Rdptr >= ld->Rdmax-4)) {
      assert(0&&"System_Strem_Flag is 1\n");
      do {
        if (ld->Rdptr >= ld->Rdmax)
          Next_Packet();
        ld->Bfr |= Get_Byte() << (24 - Incnt);
        Incnt += 8;
      } while (Incnt <= 24);
    }  else {
      do {
        thrd_buf[t] |= *thrd_ptr[t]++ << (24 - Incnt);
        Incnt += 8;
      }  while (Incnt <= 24);
    }
    thrd_Incnt[t] = Incnt;
  }
  
}


/* return next n bits (right adjusted) */

unsigned int Thrd_Get_Bits(t,N)
int t,N;
{
  unsigned int Val;
  
  Val = Thrd_Show_Bits(t,N);
  Thrd_Flush_Buffer(t,N);

  return Val;
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* getblk.c, DCT block decoding                                             */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>

#include "config.h"
#include "global.h"


/* defined in getvlc.h */
typedef struct {
  char run, level, len;
} DCTtab;

extern DCTtab DCTtabfirst[],DCTtabnext[],DCTtab0[],DCTtab1[];
extern DCTtab DCTtab2[],DCTtab3[],DCTtab4[],DCTtab5[],DCTtab6[];
extern DCTtab DCTtab0a[],DCTtab1a[];


/* decode one intra coded MPEG-1 block */

void Decode_MPEG1_Intra_Block(comp,dc_dct_pred)
int comp;
int dc_dct_pred[];
{
  int val, i, j, sign;
  unsigned int code;
  DCTtab *tab;
  short *bp;

  bp = ld->block[comp];

  /* ISO/IEC 11172-2 section 2.4.3.7: Block layer. */
  /* decode DC coefficients */
  if (comp<4)
    bp[0] = (dc_dct_pred[0]+=Get_Luma_DC_dct_diff()) << 3;
  else if (comp==4)
    bp[0] = (dc_dct_pred[1]+=Get_Chroma_DC_dct_diff()) << 3;
  else
    bp[0] = (dc_dct_pred[2]+=Get_Chroma_DC_dct_diff()) << 3;

  if (Fault_Flag) return;

  /* D-pictures do not contain AC coefficients */
  if(picture_coding_type == D_TYPE)
    return;

  /* decode AC coefficients */
  for (i=1; ; i++)
  {
    code = Show_Bits(16);
    if (code>=16384)
      tab = &DCTtabnext[(code>>12)-4];
    else if (code>=1024)
      tab = &DCTtab0[(code>>8)-4];
    else if (code>=512)
      tab = &DCTtab1[(code>>6)-8];
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG1_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Flush_Buffer(tab->len);

    if (tab->run==64) /* end_of_block */
      return;

    if (tab->run==65) /* escape */
    {
      i+= Get_Bits(6);

      val = Get_Bits(8);
      if (val==0)
        val = Get_Bits(8);
      else if (val==128)
        val = Get_Bits(8) - 256;
      else if (val>128)
        val -= 256;

      if((sign = (val<0)))
        val = -val;
    }
    else
    {
      i+= tab->run;
      val = tab->level;
      sign = Get_Bits(1);
    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (intra)\n");
      Fault_Flag = 1;
      return;
    }

    j = scan[ZIG_ZAG][i];
    val = (val*ld->quantizer_scale*ld->intra_quantizer_matrix[j]) >> 3;

    /* mismatch control ('oddification') */
    if (val!=0) /* should always be true, but it's not guaranteed */
      val = (val-1) | 1; /* equivalent to: if ((val&1)==0) val = val - 1; */

    /* saturation */
    if (!sign)
      bp[j] = (val>2047) ?  2047 :  val; /* positive */
    else
      bp[j] = (val>2048) ? -2048 : -val; /* negative */
  }
}


/* decode one non-intra coded MPEG-1 block */

void Decode_MPEG1_Non_Intra_Block(comp)
int comp;
{
  int val, i, j, sign;
  unsigned int code;
  DCTtab *tab;
  short *bp;

  bp = ld->block[comp];

  /* decode AC coefficients */
  for (i=0; ; i++)
  {
    code = Show_Bits(16);
    if (code>=16384)
    {
      if (i==0)
        tab = &DCTtabfirst[(code>>12)-4];
      else
        tab = &DCTtabnext[(code>>12)-4];
    }
    else if (code>=1024)
      tab = &DCTtab0[(code>>8)-4];
    else if (code>=512)
      tab = &DCTtab1[(code>>6)-8];
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG1_Non_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Flush_Buffer(tab->len);

    if (tab->run==64) /* end_of_block */
      return;

    if (tab->run==65) /* escape */
    {
      i+= Get_Bits(6);

      val = Get_Bits(8);
      if (val==0)
        val = Get_Bits(8);
      else if (val==128)
        val = Get_Bits(8) - 256;
      else if (val>128)
        val -= 256;

      if((sign = (val<0)))
        val = -val;
    }
    else
    {
      i+= tab->run;
      val = tab->level;
      sign = Get_Bits(1);
    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (inter)\n");
      Fault_Flag = 1;
      return;
    }

    j = scan[ZIG_ZAG][i];
    val = (((val<<1)+1)*ld->quantizer_scale*ld->non_intra_quantizer_matrix[j]) >> 4;

    /* mismatch control ('oddification') */
    if (val!=0) /* should always be true, but it's not guaranteed */
      val = (val-1) | 1; /* equivalent to: if ((val&1)==0) val = val - 1; */

    /* saturation */
    if (!sign)
      bp[j] = (val>2047) ?  2047 :  val; /* positive */
    else
      bp[j] = (val>2048) ? -2048 : -val; /* negative */
  }
}


/* decode one intra coded MPEG-2 block */

void Decode_MPEG2_Intra_Block(comp,dc_dct_pred)
int comp;
int dc_dct_pred[];
{
  int val, i, j, sign, nc, cc, run;
  unsigned int code;
  DCTtab *tab;
  short *bp;
  int *qmat;
  struct layer_data *ld1;

  /* with data partitioning, data always goes to base layer */
  ld1 = (ld->scalable_mode==SC_DP) ? &base : ld;
  bp = ld1->block[comp];

  if (base.scalable_mode==SC_DP) {
    if (base.priority_breakpoint<64)
      ld = &enhan;
    else
      ld = &base;
  }

  cc = (comp<4) ? 0 : (comp&1)+1;

  qmat = (comp<4 || chroma_format==CHROMA420)
         ? ld1->intra_quantizer_matrix
         : ld1->chroma_intra_quantizer_matrix;

  /* ISO/IEC 13818-2 section 7.2.1: decode DC coefficients */
  if (cc==0)
    val = (dc_dct_pred[0]+= Get_Luma_DC_dct_diff());
  else if (cc==1)
    val = (dc_dct_pred[1]+= Get_Chroma_DC_dct_diff());
  else
    val = (dc_dct_pred[2]+= Get_Chroma_DC_dct_diff());

  if (Fault_Flag) return;

  bp[0] = val << (3-intra_dc_precision);

  nc=0;

#ifdef TRACE
  if (Trace_Flag)
    printf("DCT(%d)i:",comp);
#endif /* TRACE */

  /* decode AC coefficients */
  for (i=1; ; i++)
  {
    code = Show_Bits(16);
    if (code>=16384 && !intra_vlc_format)
      tab = &DCTtabnext[(code>>12)-4];
    else if (code>=1024)
    {
      if (intra_vlc_format)
        tab = &DCTtab0a[(code>>8)-4];
      else
        tab = &DCTtab0[(code>>8)-4];
    }
    else if (code>=512)
    {
      if (intra_vlc_format)
        tab = &DCTtab1a[(code>>6)-8];
      else
        tab = &DCTtab1[(code>>6)-8];
    }
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG2_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Flush_Buffer(tab->len);

#ifdef TRACE
    if (Trace_Flag)
    {
      printf(" (");
      Print_Bits(code,16,tab->len);
    }
#endif /* TRACE */

    if (tab->run==64) /* end_of_block */
    {
#ifdef TRACE
      if (Trace_Flag)
        printf("): EOB\n");
#endif /* TRACE */
      return;
    }

    if (tab->run==65) /* escape */
    {
#ifdef TRACE
      if (Trace_Flag)
      {
        putchar(' ');
        Print_Bits(Show_Bits(6),6,6);
      }
#endif /* TRACE */

      i+= run = Get_Bits(6);

#ifdef TRACE
      if (Trace_Flag)
      {
        putchar(' ');
        Print_Bits(Show_Bits(12),12,12);
      }
#endif /* TRACE */

      val = Get_Bits(12);
      if ((val&2047)==0)
      {
        if (!Quiet_Flag)
          printf("invalid escape in Decode_MPEG2_Intra_Block()\n");
        Fault_Flag = 1;
        return;
      }
      if((sign = (val>=2048)))
        val = 4096 - val;
    }
    else
    {
      i+= run = tab->run;
      val = tab->level;
      sign = Get_Bits(1);

#ifdef TRACE
      if (Trace_Flag)
        printf("%d",sign);
#endif /* TRACE */
    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (intra2)\n");
      Fault_Flag = 1;
      return;
    }

#ifdef TRACE
    if (Trace_Flag)
      printf("): %d/%d",run,sign ? -val : val);
#endif /* TRACE */

    j = scan[ld1->alternate_scan][i];
    val = (val * ld1->quantizer_scale * qmat[j]) >> 4;
    bp[j] = sign ? -val : val;
    nc++;

    if (base.scalable_mode==SC_DP && nc==base.priority_breakpoint-63)
      ld = &enhan;
  }
}


/* decode one non-intra coded MPEG-2 block */

void Decode_MPEG2_Non_Intra_Block(comp)
int comp;
{
  int val, i, j, sign, nc, run;
  unsigned int code;
  DCTtab *tab;
  short *bp;
  int *qmat;
  struct layer_data *ld1;

  /* with data partitioning, data always goes to base layer */
  ld1 = (ld->scalable_mode==SC_DP) ? &base : ld;
  bp = ld1->block[comp];

  if (base.scalable_mode==SC_DP) {
    if (base.priority_breakpoint<64)
      ld = &enhan;
    else
      ld = &base;
  }

  qmat = (comp<4 || chroma_format==CHROMA420)
         ? ld1->non_intra_quantizer_matrix
         : ld1->chroma_non_intra_quantizer_matrix;

  nc = 0;

#ifdef TRACE
  if (Trace_Flag)
    printf("DCT(%d)n:",comp);
#endif /* TRACE */

  /* decode AC coefficients */
  for (i=0; ; i++)
  {
    code = Show_Bits(16);
    if (code>=16384)
    {
      if (i==0)
        tab = &DCTtabfirst[(code>>12)-4];
      else
        tab = &DCTtabnext[(code>>12)-4];
    }
    else if (code>=1024)
      tab = &DCTtab0[(code>>8)-4];
    else if (code>=512)
      tab = &DCTtab1[(code>>6)-8];
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG2_Non_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Flush_Buffer(tab->len);

#ifdef TRACE
    if (Trace_Flag)
    {
      printf(" (");
      Print_Bits(code,16,tab->len);
    }
#endif /* TRACE */

    if (tab->run==64) /* end_of_block */
    {
#ifdef TRACE
      if (Trace_Flag)
        printf("): EOB\n");
#endif /* TRACE */
      return;
    }

    if (tab->run==65) /* escape */
    {
#ifdef TRACE
      if (Trace_Flag)
      {
        putchar(' ');
        Print_Bits(Show_Bits(6),6,6);
      }
#endif /* TRACE */

      i+= run = Get_Bits(6);

#ifdef TRACE
      if (Trace_Flag)
      {
        putchar(' ');
        Print_Bits(Show_Bits(12),12,12);
      }
#endif /* TRACE */

      val = Get_Bits(12);
      if ((val&2047)==0)
      {
        if (!Quiet_Flag)
          printf("invalid escape in Decode_MPEG2_Intra_Block()\n");
        Fault_Flag = 1;
        return;
      }
      if((sign = (val>=2048)))
        val = 4096 - val;
    }
    else
    {
      i+= run = tab->run;
      val = tab->level;
      sign = Get_Bits(1);

#ifdef TRACE
      if (Trace_Flag)
        printf("%d",sign);
#endif /* TRACE */
    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (inter2)\n");
      Fault_Flag = 1;
      return;
    }

#ifdef TRACE
    if (Trace_Flag)
      printf("): %d/%d",run,sign?-val:val);
#endif /* TRACE */

    j = scan[ld1->alternate_scan][i];
    val = (((val<<1)+1) * ld1->quantizer_scale * qmat[j]) >> 5;
    bp[j] = sign ? -val : val;
    nc++;

    if (base.scalable_mode==SC_DP && nc==base.priority_breakpoint-63)
      ld = &enhan;
  }
}

#ifdef THRD
void Thrd_Decode_MPEG2_Intra_Block(t, comp,dc_dct_pred)
     int t;
int comp;
int dc_dct_pred[];
{
  int val, i, j, sign, nc, cc, run;
  unsigned int code;
  DCTtab *tab;
  short *bp;
  int *qmat;
  struct layer_data *ld1;

  /* with data partitioning, data always goes to base layer */
  bp = thrd_ld[t].block[comp];
  ld1 = ld;

  cc = (comp<4) ? 0 : (comp&1)+1;

  qmat = (comp<4 || chroma_format==CHROMA420)
         ? ld1->intra_quantizer_matrix
         : ld1->chroma_intra_quantizer_matrix;

  /* ISO/IEC 13818-2 section 7.2.1: decode DC coefficients */
  if (cc==0)
    val = (dc_dct_pred[0]+= Thrd_Get_Luma_DC_dct_diff(t));
  else if (cc==1)
    val = (dc_dct_pred[1]+= Thrd_Get_Chroma_DC_dct_diff(t));
  else
    val = (dc_dct_pred[2]+= Thrd_Get_Chroma_DC_dct_diff(t));

  if (Fault_Flag) return;

  bp[0] = val << (3-intra_dc_precision);

  nc=0;

  /* decode AC coefficients */
  for (i=1; ; i++)
  {
    code = Thrd_Show_Bits(t,16);
    if (code>=16384 && !intra_vlc_format)
      tab = &DCTtabnext[(code>>12)-4];
    else if (code>=1024)
    {
      if (intra_vlc_format)
        tab = &DCTtab0a[(code>>8)-4];
      else
        tab = &DCTtab0[(code>>8)-4];
    }
    else if (code>=512)
    {
      if (intra_vlc_format)
        tab = &DCTtab1a[(code>>6)-8];
      else
        tab = &DCTtab1[(code>>6)-8];
    }
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG2_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Thrd_Flush_Buffer(t,tab->len);

    if (tab->run==64) /* end_of_block */
    {
      return;
    }

    if (tab->run==65) /* escape */
    {
      i+= run = Thrd_Get_Bits(t,6);

      val = Thrd_Get_Bits(t,12);
      if ((val&2047)==0)
      {
        if (!Quiet_Flag)
          printf("invalid escape in Decode_MPEG2_Intra_Block()\n");
        Fault_Flag = 1;
        return;
      }
      if((sign = (val>=2048)))
        val = 4096 - val;
    }
    else
    {
      i+= run = tab->run;
      val = tab->level;
      sign = Thrd_Get_Bits(t,1);

    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (intra2)\n");
      Fault_Flag = 1;
      return;
    }

    j = scan[ld1->alternate_scan][i];
    val = (val * thrd_ld[t].quantizer_scale * qmat[j]) >> 4;
    bp[j] = sign ? -val : val;
    nc++;

    if (base.scalable_mode==SC_DP && nc==base.priority_breakpoint-63)
      ld = &enhan;
  }
}


/* decode one non-intra coded MPEG-2 block */

void Thrd_Decode_MPEG2_Non_Intra_Block(t,comp)
     int t;
int comp;
{
  int val, i, j, sign, nc, run;
  unsigned int code;
  DCTtab *tab;
  short *bp;
  int *qmat;
  struct layer_data *ld1;

  /* with data partitioning, data always goes to base layer */
  ld1 = ld;
  bp = thrd_ld[t].block[comp];

  if (base.scalable_mode==SC_DP) {
    if (base.priority_breakpoint<64)
      ld = &enhan;
    else
      ld = &base;
  }
  qmat = (comp<4 || chroma_format==CHROMA420)
         ? ld1->non_intra_quantizer_matrix
         : ld1->chroma_non_intra_quantizer_matrix;

  nc = 0;

  /* decode AC coefficients */
  for (i=0; ; i++)
  {
    code = Thrd_Show_Bits(t,16);
    if (code>=16384)
    {
      if (i==0)
        tab = &DCTtabfirst[(code>>12)-4];
      else
        tab = &DCTtabnext[(code>>12)-4];
    }
    else if (code>=1024)
      tab = &DCTtab0[(code>>8)-4];
    else if (code>=512)
      tab = &DCTtab1[(code>>6)-8];
    else if (code>=256)
      tab = &DCTtab2[(code>>4)-16];
    else if (code>=128)
      tab = &DCTtab3[(code>>3)-16];
    else if (code>=64)
      tab = &DCTtab4[(code>>2)-16];
    else if (code>=32)
      tab = &DCTtab5[(code>>1)-16];
    else if (code>=16)
      tab = &DCTtab6[code-16];
    else
    {
      if (!Quiet_Flag)
        printf("invalid Huffman code in Decode_MPEG2_Non_Intra_Block()\n");
      Fault_Flag = 1;
      return;
    }

    Thrd_Flush_Buffer(t,tab->len);

    if (tab->run==64) /* end_of_block */
    {
      return;
    }

    if (tab->run==65) /* escape */
    {
      i+= run = Thrd_Get_Bits(t,6);

      val = Thrd_Get_Bits(t,12);
      if ((val&2047)==0)
      {
        if (!Quiet_Flag)
          printf("invalid escape in Decode_MPEG2_Intra_Block()\n");
        Fault_Flag = 1;
        return;
      }
      if((sign = (val>=2048)))
        val = 4096 - val;
    }
    else
    {
      i+= run = tab->run;
      val = tab->level;
      sign = Thrd_Get_Bits(t,1);

    }

    if (i>=64)
    {
      if (!Quiet_Flag)
        fprintf(stderr,"DCT coeff index (i) out of bounds (inter2)\n");
      Fault_Flag = 1;
      return;
    }

    j = scan[ld1->alternate_scan][i];
    val = (((val<<1)+1) * thrd_ld[t].quantizer_scale * qmat[j]) >> 5;
    bp[j] = sign ? -val : val;
    nc++;

    if (base.scalable_mode==SC_DP && nc==base.priority_breakpoint-63)
      ld = &enhan;
  }
}

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* gethdr.c, header decoding                                                */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include "config.h"
#include "global.h"


/* private prototypes */
static void sequence_header _ANSI_ARGS_((void));
static void group_of_pictures_header _ANSI_ARGS_((void));
static void picture_header _ANSI_ARGS_((void));
static void extension_and_user_data _ANSI_ARGS_((void));
static void sequence_extension _ANSI_ARGS_((void));
static void sequence_display_extension _ANSI_ARGS_((void));
static void quant_matrix_extension _ANSI_ARGS_((void));
static void sequence_scalable_extension _ANSI_ARGS_((void));
static void picture_display_extension _ANSI_ARGS_((void));
static void picture_coding_extension _ANSI_ARGS_((void));
static void picture_spatial_scalable_extension _ANSI_ARGS_((void));
static void picture_temporal_scalable_extension _ANSI_ARGS_((void));
static int  extra_bit_information _ANSI_ARGS_((void));
static void copyright_extension _ANSI_ARGS_((void));
static void user_data _ANSI_ARGS_((void));
static void user_data _ANSI_ARGS_((void));
#ifdef THRD
static int  Thrd_extra_bit_information _ANSI_ARGS_((int t));
#endif



/* introduced in September 1995 to assist spatial scalable decoding */
static void Update_Temporal_Reference_Tacking_Data _ANSI_ARGS_((void));
/* private variables */
static int Temporal_Reference_Base = 0;
static int True_Framenum_max  = -1;
static int Temporal_Reference_GOP_Reset = 0;

#define RESERVED    -1 
static double frame_rate_Table[16] =
{
  0.0,
  ((23.0*1000.0)/1001.0),
  24.0,
  25.0,
  ((30.0*1000.0)/1001.0),
  30.0,
  50.0,
  ((60.0*1000.0)/1001.0),
  60.0,
 
  RESERVED,
  RESERVED,
  RESERVED,
  RESERVED,
  RESERVED,
  RESERVED,
  RESERVED
};

/*
 * decode headers from one input stream
 * until an End of Sequence or picture start code
 * is found
 */
int Get_Hdr()
{
  unsigned int code;

  for (;;)
  {
    /* look for next_start_code */
    next_start_code();
    code = Get_Bits32();
  
    switch (code)
    {
    case SEQUENCE_HEADER_CODE:
      sequence_header();
      break;
    case GROUP_START_CODE:
      group_of_pictures_header();
      break;
    case PICTURE_START_CODE:
      picture_header();
      return 1;
      break;
    case SEQUENCE_END_CODE:
      return 0;
      break;
    default:
      if (!Quiet_Flag)
        fprintf(stderr,"Unexpected next_start_code %08x (ignored)\n",code);
      break;
    }
  }
}


/* align to start of next next_start_code */

void next_start_code()
{
  /* byte align */
  Flush_Buffer(ld->Incnt&7);
  while (Show_Bits(24)!=0x01L)
    Flush_Buffer(8);
}

#ifdef THRD
void Thrd_next_start_code(t)
int t;
{  
  Thrd_Flush_Buffer(t, thrd_Incnt[t]&7);
  while (Thrd_Show_Bits(t, 24)!=0x01L)
    Thrd_Flush_Buffer(t, 8);
}

int Thrd_slice_header(t)
int t;
{
  int slice_vertical_position_extension;
  int quantizer_scale_code;
  int slice_picture_id_enable = 0;
  int slice_picture_id = 0;
  int extra_information_slice = 0;


  slice_vertical_position_extension =
    (ld->MPEG2_Flag && vertical_size>2800) ? Thrd_Get_Bits(t, 3) : 0;
  
  if (ld->scalable_mode==SC_DP) {
    printf("scalable_mode==SC_DP\n"); exit(-1);
    ld->priority_breakpoint = Get_Bits(7);
  }

  quantizer_scale_code = Thrd_Get_Bits(t, 5);
  thrd_ld[t].quantizer_scale =
    ld->MPEG2_Flag ? (ld->q_scale_type ? Non_Linear_quantizer_scale[quantizer_scale_code] : quantizer_scale_code<<1) : quantizer_scale_code;
  
  /* slice_id introduced in March 1995 as part of the video corridendum
     (after the IS was drafted in November 1994) */
  if (Thrd_Get_Bits(t,1)) {
    thrd_ld[t].intra_slice = Thrd_Get_Bits(t,1);

    slice_picture_id_enable = Thrd_Get_Bits(t,1);
    slice_picture_id = Thrd_Get_Bits(t,6);
    
    extra_information_slice = Thrd_extra_bit_information(t);
  }
  else
    thrd_ld[t].intra_slice = 0;
  
  return slice_vertical_position_extension;
}

static int Thrd_extra_bit_information(t)
int t;
{
  int Byte_Count = 0;
  
  while (Thrd_Get_Bits1(t))
    {
      Thrd_Flush_Buffer(t,8);
      Byte_Count++;
    }
  
  return(Byte_Count);
}


#endif

/* decode sequence header */

static void sequence_header()
{
  int i;
  int pos;

  pos = ld->Bitcnt;
  horizontal_size             = Get_Bits(12);
  vertical_size               = Get_Bits(12);
  aspect_ratio_information    = Get_Bits(4);
  frame_rate_code             = Get_Bits(4);
  bit_rate_value              = Get_Bits(18);
  marker_bit("sequence_header()");
  vbv_buffer_size             = Get_Bits(10);
  constrained_parameters_flag = Get_Bits(1);

  if((ld->load_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
      ld->intra_quantizer_matrix[scan[ZIG_ZAG][i]] = Get_Bits(8);
  }
  else
  {
    for (i=0; i<64; i++)
      ld->intra_quantizer_matrix[i] = default_intra_quantizer_matrix[i];
  }

  if((ld->load_non_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
      ld->non_intra_quantizer_matrix[scan[ZIG_ZAG][i]] = Get_Bits(8);
  }
  else
  {
    for (i=0; i<64; i++)
      ld->non_intra_quantizer_matrix[i] = 16;
  }

  /* copy luminance to chrominance matrices */
  for (i=0; i<64; i++)
  {
    ld->chroma_intra_quantizer_matrix[i] =
      ld->intra_quantizer_matrix[i];

    ld->chroma_non_intra_quantizer_matrix[i] =
      ld->non_intra_quantizer_matrix[i];
  }

#ifdef VERBOSE
  if (Verbose_Flag > NO_LAYER)
  {
    printf("sequence header (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag > SEQUENCE_LAYER)
    {
      printf("  horizontal_size=%d\n",horizontal_size);
      printf("  vertical_size=%d\n",vertical_size);
      printf("  aspect_ratio_information=%d\n",aspect_ratio_information);
      printf("  frame_rate_code=%d",frame_rate_code);
      printf("  bit_rate_value=%d\n",bit_rate_value);
      printf("  vbv_buffer_size=%d\n",vbv_buffer_size);
      printf("  constrained_parameters_flag=%d\n",constrained_parameters_flag);
      printf("  load_intra_quantizer_matrix=%d\n",ld->load_intra_quantizer_matrix);
      printf("  load_non_intra_quantizer_matrix=%d\n",ld->load_non_intra_quantizer_matrix);
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_sequence_header++;
#endif /* VERIFY */

  extension_and_user_data();
}



/* decode group of pictures header */
/* ISO/IEC 13818-2 section 6.2.2.6 */
static void group_of_pictures_header()
{
  int pos;

  if (ld == &base)
  {
    Temporal_Reference_Base = True_Framenum_max + 1; 	/* *CH* */
    Temporal_Reference_GOP_Reset = 1;
  }
  pos = ld->Bitcnt;
  drop_flag   = Get_Bits(1);
  hour        = Get_Bits(5);
  minute      = Get_Bits(6);
  marker_bit("group_of_pictures_header()");
  sec         = Get_Bits(6);
  frame       = Get_Bits(6);
  closed_gop  = Get_Bits(1);
  broken_link = Get_Bits(1);

#ifdef VERBOSE
  if (Verbose_Flag > NO_LAYER)
  {
    printf("group of pictures (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag > SEQUENCE_LAYER)
    {
      printf("  drop_flag=%d\n",drop_flag);
      printf("  timecode %d:%02d:%02d:%02d\n",hour,minute,sec,frame);
      printf("  closed_gop=%d\n",closed_gop);
      printf("  broken_link=%d\n",broken_link);
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_group_of_pictures_header++;
#endif /* VERIFY */

  extension_and_user_data();

}


/* decode picture header */

/* ISO/IEC 13818-2 section 6.2.3 */
static void picture_header()
{
  int pos;
  int Extra_Information_Byte_Count;

  /* unless later overwritten by picture_spatial_scalable_extension() */
  ld->pict_scal = 0; 
  
  pos = ld->Bitcnt;
  temporal_reference  = Get_Bits(10);
  picture_coding_type = Get_Bits(3);
  vbv_delay           = Get_Bits(16);

  /*printf("pic_code_type %d\n",picture_coding_type);*/
  if (picture_coding_type==P_TYPE || picture_coding_type==B_TYPE)
  {
    full_pel_forward_vector = Get_Bits(1);
    forward_f_code = Get_Bits(3);
  }
  if (picture_coding_type==B_TYPE)
  {
    full_pel_backward_vector = Get_Bits(1);
    backward_f_code = Get_Bits(3);
  }

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("picture header (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  temporal_reference=%d\n",temporal_reference);
      printf("  picture_coding_type=%d\n",picture_coding_type);
      printf("  vbv_delay=%d\n",vbv_delay);
      if (picture_coding_type==P_TYPE || picture_coding_type==B_TYPE)
      {
        printf("  full_pel_forward_vector=%d\n",full_pel_forward_vector);
        printf("  forward_f_code =%d\n",forward_f_code);
      }
      if (picture_coding_type==B_TYPE)
      {
        printf("  full_pel_backward_vector=%d\n",full_pel_backward_vector);
        printf("  backward_f_code =%d\n",backward_f_code);
      }
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_picture_header++;
#endif /* VERIFY */

  Extra_Information_Byte_Count = 
    extra_bit_information();
  
  extension_and_user_data();

  /* update tracking information used to assist spatial scalability */
  Update_Temporal_Reference_Tacking_Data();
}

/* decode slice header */

/* ISO/IEC 13818-2 section 6.2.4 */
int slice_header()
{
  int slice_vertical_position_extension;
  int quantizer_scale_code;
  int pos;
  int slice_picture_id_enable = 0;
  int slice_picture_id = 0;
  int extra_information_slice = 0;

  pos = ld->Bitcnt;

  slice_vertical_position_extension =
    (ld->MPEG2_Flag && vertical_size>2800) ? Get_Bits(3) : 0;

  if (ld->scalable_mode==SC_DP)
    ld->priority_breakpoint = Get_Bits(7);

  quantizer_scale_code = Get_Bits(5);
  ld->quantizer_scale =
    ld->MPEG2_Flag ? (ld->q_scale_type ? Non_Linear_quantizer_scale[quantizer_scale_code] : quantizer_scale_code<<1) : quantizer_scale_code;

  /* slice_id introduced in March 1995 as part of the video corridendum
     (after the IS was drafted in November 1994) */
  if (Get_Bits(1))
  {
    ld->intra_slice = Get_Bits(1);

    slice_picture_id_enable = Get_Bits(1);
	slice_picture_id = Get_Bits(6);

    extra_information_slice = extra_bit_information();
  }
  else
    ld->intra_slice = 0;

#ifdef VERBOSE
  if (Verbose_Flag>PICTURE_LAYER)
  {
    printf("slice header (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SLICE_LAYER)
    {
      if (ld->MPEG2_Flag && vertical_size>2800)
        printf("  slice_vertical_position_extension=%d\n",slice_vertical_position_extension);
  
      if (ld->scalable_mode==SC_DP)
        printf("  priority_breakpoint=%d\n",ld->priority_breakpoint);

      printf("  quantizer_scale_code=%d\n",quantizer_scale_code);

      printf("  slice_picture_id_enable = %d\n", slice_picture_id_enable);

      if(slice_picture_id_enable)
        printf("  slice_picture_id = %d\n", slice_picture_id);

    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_slice_header++;
#endif /* VERIFY */


  return slice_vertical_position_extension;
}


/* decode extension and user data */
/* ISO/IEC 13818-2 section 6.2.2.2 */
static void extension_and_user_data()
{
  int code,ext_ID;

  next_start_code();

  while ((code = Show_Bits(32))==EXTENSION_START_CODE || code==USER_DATA_START_CODE)
  {
    if (code==EXTENSION_START_CODE)
    {
      Flush_Buffer32();
      ext_ID = Get_Bits(4);
      switch (ext_ID)
      {
      case SEQUENCE_EXTENSION_ID:
        sequence_extension();
        break;
      case SEQUENCE_DISPLAY_EXTENSION_ID:
        sequence_display_extension();
        break;
      case QUANT_MATRIX_EXTENSION_ID:
        quant_matrix_extension();
        break;
      case SEQUENCE_SCALABLE_EXTENSION_ID:
        sequence_scalable_extension();
        break;
      case PICTURE_DISPLAY_EXTENSION_ID:
        picture_display_extension();
        break;
      case PICTURE_CODING_EXTENSION_ID:
        picture_coding_extension();
        break;
      case PICTURE_SPATIAL_SCALABLE_EXTENSION_ID:
        picture_spatial_scalable_extension();
        break;
      case PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID:
        picture_temporal_scalable_extension();
        break;
      case COPYRIGHT_EXTENSION_ID:
        copyright_extension();
        break;
     default:
        fprintf(stderr,"reserved extension start code ID %d\n",ext_ID);
        break;
      }
      next_start_code();
    }
    else
    {
#ifdef VERBOSE
      if (Verbose_Flag>NO_LAYER)
        printf("user data\n");
#endif /* VERBOSE */
      Flush_Buffer32();
      user_data();
    }
  }
}


/* decode sequence extension */

/* ISO/IEC 13818-2 section 6.2.2.3 */
static void sequence_extension()
{
  int horizontal_size_extension;
  int vertical_size_extension;
  int bit_rate_extension;
  int vbv_buffer_size_extension;
#ifdef VERBOSE
  int pos;

  /* derive bit position for trace */

  pos = ld->Bitcnt;
#endif

  ld->MPEG2_Flag = 1;

  ld->scalable_mode = SC_NONE; /* unless overwritten by sequence_scalable_extension() */
  layer_id = 0;                /* unless overwritten by sequence_scalable_extension() */
  
  profile_and_level_indication = Get_Bits(8);
  progressive_sequence         = Get_Bits(1);
  chroma_format                = Get_Bits(2);
  horizontal_size_extension    = Get_Bits(2);
  vertical_size_extension      = Get_Bits(2);
  bit_rate_extension           = Get_Bits(12);
  marker_bit("sequence_extension");
  vbv_buffer_size_extension    = Get_Bits(8);
  low_delay                    = Get_Bits(1);
  frame_rate_extension_n       = Get_Bits(2);
  frame_rate_extension_d       = Get_Bits(5);

  frame_rate = frame_rate_Table[frame_rate_code] *
    ((frame_rate_extension_n+1)/(frame_rate_extension_d+1));

  /* special case for 422 profile & level must be made */
  if((profile_and_level_indication>>7) & 1)
  {  /* escape bit of profile_and_level_indication set */
  
    /* 4:2:2 Profile @ Main Level */
    if((profile_and_level_indication&15)==5)
    {
      profile = PROFILE_422;
      level   = MAIN_LEVEL;  
    }
  }
  else
  {
    profile = profile_and_level_indication >> 4;  /* Profile is upper nibble */
    level   = profile_and_level_indication & 0xF;  /* Level is lower nibble */
  }
  
 
  horizontal_size = (horizontal_size_extension<<12) | (horizontal_size&0x0fff);
  vertical_size = (vertical_size_extension<<12) | (vertical_size&0x0fff);


  /* ISO/IEC 13818-2 does not define bit_rate_value to be composed of
   * both the original bit_rate_value parsed in sequence_header() and
   * the optional bit_rate_extension in sequence_extension_header(). 
   * However, we use it for bitstream verification purposes. 
   */

  bit_rate_value += (bit_rate_extension << 18);
  bit_rate = ((double) bit_rate_value) * 400.0;
  vbv_buffer_size += (vbv_buffer_size_extension << 10);

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("sequence extension (byte %d)\n",(pos>>3)-4);

    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  profile_and_level_indication=%d\n",profile_and_level_indication);

      if (profile_and_level_indication<128)
      {
        printf("    profile=%d, level=%d\n",profile,level);
      }

      printf("  progressive_sequence=%d\n",progressive_sequence);
      printf("  chroma_format=%d\n",chroma_format);
      printf("  horizontal_size_extension=%d\n",horizontal_size_extension);
      printf("  vertical_size_extension=%d\n",vertical_size_extension);
      printf("  bit_rate_extension=%d\n",bit_rate_extension);
      printf("  vbv_buffer_size_extension=%d\n",vbv_buffer_size_extension);
      printf("  low_delay=%d\n",low_delay);
      printf("  frame_rate_extension_n=%d\n",frame_rate_extension_n);
      printf("  frame_rate_extension_d=%d\n",frame_rate_extension_d);
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_sequence_extension++;
#endif /* VERIFY */


}


/* decode sequence display extension */

static void sequence_display_extension()
{
  int pos;

  pos = ld->Bitcnt;
  video_format      = Get_Bits(3);
  color_description = Get_Bits(1);

  if (color_description)
  {
    color_primaries          = Get_Bits(8);
    transfer_characteristics = Get_Bits(8);
    matrix_coefficients      = Get_Bits(8);
  }

  display_horizontal_size = Get_Bits(14);
  marker_bit("sequence_display_extension");
  display_vertical_size   = Get_Bits(14);

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("sequence display extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {

      printf("  video_format=%d\n",video_format);
      printf("  color_description=%d\n",color_description);

      if (color_description)
      {
        printf("    color_primaries=%d\n",color_primaries);
        printf("    transfer_characteristics=%d\n",transfer_characteristics);
        printf("    matrix_coefficients=%d\n",matrix_coefficients);
      }
      printf("  display_horizontal_size=%d\n",display_horizontal_size);
      printf("  display_vertical_size=%d\n",display_vertical_size);
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_sequence_display_extension++;
#endif /* VERIFY */

}


/* decode quant matrix entension */
/* ISO/IEC 13818-2 section 6.2.3.2 */
static void quant_matrix_extension()
{
  int i;
  int pos;

  pos = ld->Bitcnt;

  if((ld->load_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
    {
      ld->chroma_intra_quantizer_matrix[scan[ZIG_ZAG][i]]
      = ld->intra_quantizer_matrix[scan[ZIG_ZAG][i]]
      = Get_Bits(8);
    }
  }

  if((ld->load_non_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
    {
      ld->chroma_non_intra_quantizer_matrix[scan[ZIG_ZAG][i]]
      = ld->non_intra_quantizer_matrix[scan[ZIG_ZAG][i]]
      = Get_Bits(8);
    }
  }

  if((ld->load_chroma_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
      ld->chroma_intra_quantizer_matrix[scan[ZIG_ZAG][i]] = Get_Bits(8);
  }

  if((ld->load_chroma_non_intra_quantizer_matrix = Get_Bits(1)))
  {
    for (i=0; i<64; i++)
      ld->chroma_non_intra_quantizer_matrix[scan[ZIG_ZAG][i]] = Get_Bits(8);
  }

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("quant matrix extension (byte %d)\n",(pos>>3)-4);
    printf("  load_intra_quantizer_matrix=%d\n",
      ld->load_intra_quantizer_matrix);
    printf("  load_non_intra_quantizer_matrix=%d\n",
      ld->load_non_intra_quantizer_matrix);
    printf("  load_chroma_intra_quantizer_matrix=%d\n",
      ld->load_chroma_intra_quantizer_matrix);
    printf("  load_chroma_non_intra_quantizer_matrix=%d\n",
      ld->load_chroma_non_intra_quantizer_matrix);
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_quant_matrix_extension++;
#endif /* VERIFY */

}


/* decode sequence scalable extension */
/* ISO/IEC 13818-2   section 6.2.2.5 */
static void sequence_scalable_extension()
{
  int pos;

  pos = ld->Bitcnt;

  /* values (without the +1 offset) of scalable_mode are defined in 
     Table 6-10 of ISO/IEC 13818-2 */
  ld->scalable_mode = Get_Bits(2) + 1; /* add 1 to make SC_DP != SC_NONE */

  layer_id = Get_Bits(4);

  if (ld->scalable_mode==SC_SPAT)
  {
    lower_layer_prediction_horizontal_size = Get_Bits(14);
    marker_bit("sequence_scalable_extension()");
    lower_layer_prediction_vertical_size   = Get_Bits(14); 
    horizontal_subsampling_factor_m        = Get_Bits(5);
    horizontal_subsampling_factor_n        = Get_Bits(5);
    vertical_subsampling_factor_m          = Get_Bits(5);
    vertical_subsampling_factor_n          = Get_Bits(5);
  }

  if (ld->scalable_mode==SC_TEMP)
    Error("temporal scalability not implemented\n");

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("sequence scalable extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  scalable_mode=%d\n",ld->scalable_mode-1);
      printf("  layer_id=%d\n",layer_id);
      if (ld->scalable_mode==SC_SPAT)
      {
        printf("    lower_layer_prediction_horiontal_size=%d\n",
          lower_layer_prediction_horizontal_size);
        printf("    lower_layer_prediction_vertical_size=%d\n",
          lower_layer_prediction_vertical_size);
        printf("    horizontal_subsampling_factor_m=%d\n",
          horizontal_subsampling_factor_m);
        printf("    horizontal_subsampling_factor_n=%d\n",
          horizontal_subsampling_factor_n);
        printf("    vertical_subsampling_factor_m=%d\n",
          vertical_subsampling_factor_m);
        printf("    vertical_subsampling_factor_n=%d\n",
          vertical_subsampling_factor_n);
      }
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_sequence_scalable_extension++;
#endif /* VERIFY */

}


/* decode picture display extension */
/* ISO/IEC 13818-2 section 6.2.3.3. */
static void picture_display_extension()
{
  int i;
  int number_of_frame_center_offsets;
  int pos;

  pos = ld->Bitcnt;
  /* based on ISO/IEC 13818-2 section 6.3.12 
    (November 1994) Picture display extensions */

  /* derive number_of_frame_center_offsets */
  if(progressive_sequence)
  {
    if(repeat_first_field)
    {
      if(top_field_first)
        number_of_frame_center_offsets = 3;
      else
        number_of_frame_center_offsets = 2;
    }
    else
    {
      number_of_frame_center_offsets = 1;
    }
  }
  else
  {
    if(picture_structure!=FRAME_PICTURE)
    {
      number_of_frame_center_offsets = 1;
    }
    else
    {
      if(repeat_first_field)
        number_of_frame_center_offsets = 3;
      else
        number_of_frame_center_offsets = 2;
    }
  }


  /* now parse */
  for (i=0; i<number_of_frame_center_offsets; i++)
  {
    frame_center_horizontal_offset[i] = Get_Bits(16);
    marker_bit("picture_display_extension, first marker bit");
    
    frame_center_vertical_offset[i]   = Get_Bits(16);
    marker_bit("picture_display_extension, second marker bit");
  }

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("picture display extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {

      for (i=0; i<number_of_frame_center_offsets; i++)
      {
        printf("  frame_center_horizontal_offset[%d]=%d\n",i,
          frame_center_horizontal_offset[i]);
        printf("  frame_center_vertical_offset[%d]=%d\n",i,
          frame_center_vertical_offset[i]);
      }
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_picture_display_extension++;
#endif /* VERIFY */

}


/* decode picture coding extension */
static void picture_coding_extension()
{
  int pos;

  pos = ld->Bitcnt;

  f_code[0][0] = Get_Bits(4);
  f_code[0][1] = Get_Bits(4);
  f_code[1][0] = Get_Bits(4);
  f_code[1][1] = Get_Bits(4);

  intra_dc_precision         = Get_Bits(2);
  picture_structure          = Get_Bits(2);
  top_field_first            = Get_Bits(1);
  frame_pred_frame_dct       = Get_Bits(1);
  concealment_motion_vectors = Get_Bits(1);
  ld->q_scale_type           = Get_Bits(1);
  intra_vlc_format           = Get_Bits(1);
  ld->alternate_scan         = Get_Bits(1);
  repeat_first_field         = Get_Bits(1);
  chroma_420_type            = Get_Bits(1);
  progressive_frame          = Get_Bits(1);
  composite_display_flag     = Get_Bits(1);

  if (composite_display_flag)
  {
    v_axis            = Get_Bits(1);
    field_sequence    = Get_Bits(3);
    sub_carrier       = Get_Bits(1);
    burst_amplitude   = Get_Bits(7);
    sub_carrier_phase = Get_Bits(8);
  }

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("picture coding extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  forward horizontal f_code=%d\n", f_code[0][0]);
      printf("  forward vertical f_code=%d\n", f_code[0][1]);
      printf("  backward horizontal f_code=%d\n", f_code[1][0]);
      printf("  backward_vertical f_code=%d\n", f_code[1][1]);
      printf("  intra_dc_precision=%d\n",intra_dc_precision);
      printf("  picture_structure=%d\n",picture_structure);
      printf("  top_field_first=%d\n",top_field_first);
      printf("  frame_pred_frame_dct=%d\n",frame_pred_frame_dct);
      printf("  concealment_motion_vectors=%d\n",concealment_motion_vectors);
      printf("  q_scale_type=%d\n",ld->q_scale_type);
      printf("  intra_vlc_format=%d\n",intra_vlc_format);
      printf("  alternate_scan=%d\n",ld->alternate_scan);
      printf("  repeat_first_field=%d\n",repeat_first_field);
      printf("  chroma_420_type=%d\n",chroma_420_type);
      printf("  progressive_frame=%d\n",progressive_frame);
      printf("  composite_display_flag=%d\n",composite_display_flag);

      if (composite_display_flag)
      {
        printf("    v_axis=%d\n",v_axis);
        printf("    field_sequence=%d\n",field_sequence);
        printf("    sub_carrier=%d\n",sub_carrier);
        printf("    burst_amplitude=%d\n",burst_amplitude);
        printf("    sub_carrier_phase=%d\n",sub_carrier_phase);
      }
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_picture_coding_extension++;
#endif /* VERIFY */
}


/* decode picture spatial scalable extension */
/* ISO/IEC 13818-2 section 6.2.3.5. */
static void picture_spatial_scalable_extension()
{
  int pos;

  pos = ld->Bitcnt;

  ld->pict_scal = 1; /* use spatial scalability in this picture */

  lower_layer_temporal_reference = Get_Bits(10);
  marker_bit("picture_spatial_scalable_extension(), first marker bit");
  lower_layer_horizontal_offset = Get_Bits(15);
  if (lower_layer_horizontal_offset>=16384)
    lower_layer_horizontal_offset-= 32768;
  marker_bit("picture_spatial_scalable_extension(), second marker bit");
  lower_layer_vertical_offset = Get_Bits(15);
  if (lower_layer_vertical_offset>=16384)
    lower_layer_vertical_offset-= 32768;
  spatial_temporal_weight_code_table_index = Get_Bits(2);
  lower_layer_progressive_frame = Get_Bits(1);
  lower_layer_deinterlaced_field_select = Get_Bits(1);

#ifdef VERBOSE
  if (Verbose_Flag>NO_LAYER)
  {
    printf("picture spatial scalable extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  lower_layer_temporal_reference=%d\n",lower_layer_temporal_reference);
      printf("  lower_layer_horizontal_offset=%d\n",lower_layer_horizontal_offset);
      printf("  lower_layer_vertical_offset=%d\n",lower_layer_vertical_offset);
      printf("  spatial_temporal_weight_code_table_index=%d\n",
        spatial_temporal_weight_code_table_index);
      printf("  lower_layer_progressive_frame=%d\n",lower_layer_progressive_frame);
      printf("  lower_layer_deinterlaced_field_select=%d\n",lower_layer_deinterlaced_field_select);
    }
  }
#endif /* VERBOSE */

#ifdef VERIFY
  verify_picture_spatial_scalable_extension++;
#endif /* VERIFY */

}


/* decode picture temporal scalable extension
 *
 * not implemented
 */
/* ISO/IEC 13818-2 section 6.2.3.4. */
static void picture_temporal_scalable_extension()
{
  Error("temporal scalability not supported\n");

#ifdef VERIFY
  verify_picture_temporal_scalable_extension++;
#endif /* VERIFY */
}


/* decode extra bit information */
/* ISO/IEC 13818-2 section 6.2.3.4. */
static int extra_bit_information()
{
  int Byte_Count = 0;

  while (Get_Bits1())
  {
    Flush_Buffer(8);
    Byte_Count++;
  }

  return(Byte_Count);
}



/* ISO/IEC 13818-2 section 5.3 */
/* Purpose: this function is mainly designed to aid in bitstream conformance
   testing.  A simple Flush_Buffer(1) would do */
void marker_bit(text)
char *text;
{
  int marker;

  marker = Get_Bits(1);

#ifdef VERIFY  
  if(!marker)
    printf("ERROR: %s--marker_bit set to 0",text);
#endif
}


/* ISO/IEC 13818-2  sections 6.3.4.1 and 6.2.2.2.2 */
static void user_data()
{
  /* skip ahead to the next start code */
  next_start_code();
}



/* Copyright extension */
/* ISO/IEC 13818-2 section 6.2.3.6. */
/* (header added in November, 1994 to the IS document) */


static void copyright_extension()
{
  int pos;
  int reserved_data;

  pos = ld->Bitcnt;
  

  copyright_flag =       Get_Bits(1); 
  copyright_identifier = Get_Bits(8);
  original_or_copy =     Get_Bits(1);
  
  /* reserved */
  reserved_data = Get_Bits(7);

  marker_bit("copyright_extension(), first marker bit");
  copyright_number_1 =   Get_Bits(20);
  marker_bit("copyright_extension(), second marker bit");
  copyright_number_2 =   Get_Bits(22);
  marker_bit("copyright_extension(), third marker bit");
  copyright_number_3 =   Get_Bits(22);

  if(Verbose_Flag>NO_LAYER)
  {
    printf("copyright_extension (byte %d)\n",(pos>>3)-4);
    if (Verbose_Flag>SEQUENCE_LAYER)
    {
      printf("  copyright_flag =%d\n",copyright_flag);
        
      printf("  copyright_identifier=%d\n",copyright_identifier);
        
      printf("  original_or_copy = %d (original=1, copy=0)\n",
        original_or_copy);
        
      printf("  copyright_number_1=%d\n",copyright_number_1);
      printf("  copyright_number_2=%d\n",copyright_number_2);
      printf("  copyright_number_3=%d\n",copyright_number_3);
    }
  }

#ifdef VERIFY
  verify_copyright_extension++;
#endif /* VERIFY */
}



/* introduced in September 1995 to assist Spatial Scalability */
static void Update_Temporal_Reference_Tacking_Data()
{
  static int temporal_reference_wrap  = 0;
  static int temporal_reference_old   = 0;

  if (ld == &base)			/* *CH* */
  {
    if (picture_coding_type!=B_TYPE && temporal_reference!=temporal_reference_old) 	
    /* check first field of */
    {							
       /* non-B-frame */
      if (temporal_reference_wrap) 		
      {/* wrap occured at previous I- or P-frame */	
       /* now all intervening B-frames which could 
          still have high temporal_reference values are done  */
        Temporal_Reference_Base += 1024;
	    temporal_reference_wrap = 0;
      }
      
      /* distinguish from a reset */
      if (temporal_reference<temporal_reference_old && !Temporal_Reference_GOP_Reset)	
	    temporal_reference_wrap = 1;  /* we must have just passed a GOP-Header! */
      
      temporal_reference_old = temporal_reference;
      Temporal_Reference_GOP_Reset = 0;
    }

    True_Framenum = Temporal_Reference_Base + temporal_reference;
    
    /* temporary wrap of TR at 1024 for M frames */
    if (temporal_reference_wrap && temporal_reference <= temporal_reference_old)	
      True_Framenum += 1024;				

    True_Framenum_max = (True_Framenum > True_Framenum_max) ?
                        True_Framenum : True_Framenum_max;
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* getpic.c, picture decoding                                               */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#if defined(THRD) && (NUM_THREADS>1)
#include <pthread.h>
#endif

#include "config.h"
#include "global.h"

#define DEBUG 0
#define ADD_BLK_TEST_CODE 0

/* private prototypes*/
static void picture_data _ANSI_ARGS_((int framenum));
static void macroblock_modes _ANSI_ARGS_((int *pmacroblock_type, int *pstwtype,
  int *pstwclass, int *pmotion_type, int *pmotion_vector_count, int *pmv_format, int *pdmv,
  int *pmvscale, int *pdct_type));
static void Clear_Block _ANSI_ARGS_((int comp));
static void Sum_Block _ANSI_ARGS_((int comp));
static void Saturate _ANSI_ARGS_((short *bp));
static void Add_Block _ANSI_ARGS_((int comp, int bx, int by,
  int dct_type, int addflag));
static void Update_Picture_Buffers _ANSI_ARGS_((void));
static void frame_reorder _ANSI_ARGS_((int bitstream_framenum, 
  int sequence_framenum));
static void Decode_SNR_Macroblock _ANSI_ARGS_((int *SNRMBA, int *SNRMBAinc, 
  int MBA, int MBAmax, int *dct_type));

static void motion_compensation _ANSI_ARGS_((int MBA, int macroblock_type, 
 int motion_type, int PMV[2][2][2], int motion_vertical_field_select[2][2], 
 int dmvector[2], int stwtype, int dct_type));

static void skipped_macroblock _ANSI_ARGS_((int dc_dct_pred[3], 
  int PMV[2][2][2], int *motion_type, int motion_vertical_field_select[2][2],
  int *stwtype, int *macroblock_type));

static int slice _ANSI_ARGS_((int framenum, int MBAmax));

static int start_of_slice _ANSI_ARGS_ ((int MBAmax, int *MBA,
  int *MBAinc, int dc_dct_pred[3], int PMV[2][2][2]));

static int decode_macroblock _ANSI_ARGS_((int *macroblock_type, 
  int *stwtype, int *stwclass, int *motion_type, int *dct_type,
  int PMV[2][2][2], int dc_dct_pred[3], 
  int motion_vertical_field_select[2][2], int dmvector[2]));
#ifdef THRD
static int Thrd_start_of_slice _ANSI_ARGS_ ((int t, int MBAmax, int *MBA,
  int *MBAinc, int dc_dct_pred[3], int PMV[2][2][2]));

static int Thrd_decode_macroblock _ANSI_ARGS_((int t, int *macroblock_type, 
  int *stwtype, int *stwclass, int *motion_type, int *dct_type,
  int PMV[2][2][2], int dc_dct_pred[3], 
  int motion_vertical_field_select[2][2], int dmvector[2]));

static void Thrd_skipped_macroblock _ANSI_ARGS_((int t, int dc_dct_pred[3], 
  int PMV[2][2][2], int *motion_type, int motion_vertical_field_select[2][2],
  int *stwtype, int *macroblock_type));

static void Thrd_motion_compensation _ANSI_ARGS_((int t, int MBA, int macroblock_type, 
 int motion_type, int PMV[2][2][2], int motion_vertical_field_select[2][2], 
 int dmvector[2], int stwtype, int dct_type));

static int new_slice _ANSI_ARGS_((int framenum, int MBAmax));
static void Thrd_macroblock_modes _ANSI_ARGS_((int t, int *pmacroblock_type, int *pstwtype,
  int *pstwclass, int *pmotion_type, int *pmotion_vector_count, int *pmv_format, int *pdmv,
  int *pmvscale, int *pdct_type));
static void Thrd_Clear_Block _ANSI_ARGS_((int t,int comp));
static void Thrd_Add_Block _ANSI_ARGS_((int t, int comp, int bx, int by,
  int dct_type, int addflag));
#endif


/* decode one frame or field picture */
void Decode_Picture(bitstream_framenum, sequence_framenum)
int bitstream_framenum, sequence_framenum;
{

  if (picture_structure==FRAME_PICTURE && Second_Field)
  {
    /* recover from illegal number of field pictures */
    printf("odd number of field pictures\n");
    Second_Field = 0;
  }

  /* IMPLEMENTATION: update picture buffer pointers */
  Update_Picture_Buffers();

#ifdef VERIFY 
  Check_Headers(bitstream_framenum, sequence_framenum);
#endif /* VERIFY */

  /* ISO/IEC 13818-4 section 2.4.5.4 "frame buffer intercept method" */
  /* (section number based on November 1995 (Dallas) draft of the 
      conformance document) */
  if(Ersatz_Flag)
    Substitute_Frame_Buffer(bitstream_framenum, sequence_framenum);

  /* form spatial scalable picture */
 
  /* form spatial scalable picture */
  /* ISO/IEC 13818-2 section 7.7: Spatial scalability */
  if (base.pict_scal && !Second_Field) 
  {
    Spatial_Prediction();
  }
  
  /* decode picture data ISO/IEC 13818-2 section 6.2.3.7 */
  picture_data(bitstream_framenum);

  /* write or display current or previously decoded reference frame */
  /* ISO/IEC 13818-2 section 6.1.1.11: Frame reordering */
  frame_reorder(bitstream_framenum, sequence_framenum);

  if (picture_structure!=FRAME_PICTURE)
    Second_Field = !Second_Field;
}
 
/* decode all macroblocks of the current picture */
/* stages described in ISO/IEC 13818-2 section 7 */
static void picture_data(framenum)
int framenum;
{
  int MBAmax;
  int ret;

#ifdef THRD
  int slice_num=0;
#endif
  
  /* number of macroblocks per picture */
  MBAmax = mb_width*mb_height;
  
  if (picture_structure!=FRAME_PICTURE)
    MBAmax>>=1; /* field picture has half as mnay macroblocks as frame */
  
  for(;;)
    {

#ifdef THRD
      ++slice_num; /* printf("slice number %d\n",slice_num++); */
    if((ret=new_slice(framenum, MBAmax))<0) /* || mb_height==slice_num)*/
#else
    if ((ret=slice(framenum, MBAmax)) <0)
#endif
      return;
  }

}


/* decode all macroblocks of the current picture */
/* ISO/IEC 13818-2 section 6.3.16 */
static int slice(framenum, MBAmax)
int framenum, MBAmax;
{
  int MBA; 
  int MBAinc, macroblock_type, motion_type, dct_type;
  int dc_dct_pred[3];
  int PMV[2][2][2], motion_vertical_field_select[2][2];
  int dmvector[2];
  int stwtype, stwclass;
  int SNRMBA, SNRMBAinc;
  int ret;

  MBA = 0; /* macroblock address */
  MBAinc = 0;

  if((ret=start_of_slice(MBAmax, &MBA, &MBAinc, dc_dct_pred, PMV))!=1)
    return(ret);
  if (DEBUG) printf("MBA %d\n",MBA);
  if (Two_Streams && enhan.scalable_mode==SC_SNR)
  {
    SNRMBA=0;
    SNRMBAinc=0;
  }

  Fault_Flag=0;

  for (;;)
  {

    /* this is how we properly exit out of picture */
    if (MBA>=MBAmax)
      return(-1); /* all macroblocks decoded */

#ifdef TRACE
    if (Trace_Flag)
      printf("frame %d, MB %d\n",framenum,MBA);
#endif /* TRACE */

#ifdef DISPLAY
    if (!progressive_frame && picture_structure==FRAME_PICTURE 
      && MBA==(MBAmax>>1) && framenum!=0 && Output_Type==T_X11 
       && !Display_Progressive_Flag)
    {
      Display_Second_Field();
    }
#endif

    ld = &base;

    if (MBAinc==0)
    {
      if (base.scalable_mode==SC_DP && base.priority_breakpoint==1)
          ld = &enhan;

      if (!Show_Bits(23) || Fault_Flag) /* next_start_code or fault */
      {
resync: /* if Fault_Flag: resynchronize to next next_start_code */
        Fault_Flag = 0;
        return(0);     /* trigger: go to next slice */
      }
      else /* neither next_start_code nor Fault_Flag */
      {
        if (base.scalable_mode==SC_DP && base.priority_breakpoint==1)
          ld = &enhan;

        /* decode macroblock address increment */
        MBAinc = Get_macroblock_address_increment();

        if (Fault_Flag) goto resync;
      }
    }

    if (MBA>=MBAmax)
    {
      /* MBAinc points beyond picture dimensions */
      if (!Quiet_Flag)
        printf("Too many macroblocks in picture\n");
      return(-1);
    }

    if (MBAinc==1) /* not skipped */
    {
      ret = decode_macroblock(&macroblock_type, &stwtype, &stwclass,
              &motion_type, &dct_type, PMV, dc_dct_pred, 
              motion_vertical_field_select, dmvector);

      if(ret==-1)
        return(-1);
   
      if(ret==0)
        goto resync;

    }
    else /* MBAinc!=1: skipped macroblock */
    {      
      /* ISO/IEC 13818-2 section 7.6.6 */
      skipped_macroblock(dc_dct_pred, PMV, &motion_type, 
        motion_vertical_field_select, &stwtype, &macroblock_type);
    }

    /* SCALABILITY: SNR */
    /* ISO/IEC 13818-2 section 7.8 */
    /* NOTE: we currently ignore faults encountered in this routine */
    if (Two_Streams && enhan.scalable_mode==SC_SNR)
      Decode_SNR_Macroblock(&SNRMBA, &SNRMBAinc, MBA, MBAmax, &dct_type);

    /* ISO/IEC 13818-2 section 7.6 */
    motion_compensation(MBA, macroblock_type, motion_type, PMV, 
      motion_vertical_field_select, dmvector, stwtype, dct_type);


    /* advance to next macroblock */
    MBA++;
    MBAinc--;
 
    /* SCALABILITY: SNR */
    if (Two_Streams && enhan.scalable_mode==SC_SNR)
    {
      SNRMBA++;
      SNRMBAinc--;
    }

    if (MBA>=MBAmax)
      return(-1); /* all macroblocks decoded */
  }
}

 
/* ISO/IEC 13818-2 section 6.3.17.1: Macroblock modes */
static void macroblock_modes(pmacroblock_type,pstwtype,pstwclass,
  pmotion_type,pmotion_vector_count,pmv_format,pdmv,pmvscale,pdct_type)
  int *pmacroblock_type, *pstwtype, *pstwclass;
  int *pmotion_type, *pmotion_vector_count, *pmv_format, *pdmv, *pmvscale;
  int *pdct_type;
{
  int macroblock_type;
  int stwtype, stwcode, stwclass;
  int motion_type = 0;
  int motion_vector_count, mv_format, dmv, mvscale;
  int dct_type;
  static unsigned char stwc_table[3][4]
    = { {6,3,7,4}, {2,1,5,4}, {2,5,7,4} };
  static unsigned char stwclass_table[9]
    = {0, 1, 2, 1, 1, 2, 3, 3, 4};

  /* get macroblock_type */
  macroblock_type = Get_macroblock_type();

  if (Fault_Flag) return;

  /* get spatial_temporal_weight_code */
  if (macroblock_type & MB_WEIGHT)
  {
    if (spatial_temporal_weight_code_table_index==0)
      stwtype = 4;
    else
    {
      stwcode = Get_Bits(2);
#ifdef TRACE
      if (Trace_Flag)
      {
        printf("spatial_temporal_weight_code (");
        Print_Bits(stwcode,2,2);
        printf("): %d\n",stwcode);
      }
#endif /* TRACE */
      stwtype = stwc_table[spatial_temporal_weight_code_table_index-1][stwcode];
    }
  }
  else
    stwtype = (macroblock_type & MB_CLASS4) ? 8 : 0;

  /* SCALABILITY: derive spatial_temporal_weight_class (Table 7-18) */
  stwclass = stwclass_table[stwtype];

  /* get frame/field motion type */
  if (macroblock_type & (MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD))
  {
    if (picture_structure==FRAME_PICTURE) /* frame_motion_type */
    {
      motion_type = frame_pred_frame_dct ? MC_FRAME : Get_Bits(2);
#ifdef TRACE
      if (!frame_pred_frame_dct && Trace_Flag)
      {
        printf("frame_motion_type (");
        Print_Bits(motion_type,2,2);
        printf("): %s\n",motion_type==MC_FIELD?"Field":
                         motion_type==MC_FRAME?"Frame":
                         motion_type==MC_DMV?"Dual_Prime":"Invalid");
      }
#endif /* TRACE */
    }
    else /* field_motion_type */
    {
      motion_type = Get_Bits(2);
#ifdef TRACE
      if (Trace_Flag)
      {
        printf("field_motion_type (");
        Print_Bits(motion_type,2,2);
        printf("): %s\n",motion_type==MC_FIELD?"Field":
                         motion_type==MC_16X8?"16x8 MC":
                         motion_type==MC_DMV?"Dual_Prime":"Invalid");
      }
#endif /* TRACE */
    }
  }
  else if ((macroblock_type & MACROBLOCK_INTRA) && concealment_motion_vectors)
  {
    /* concealment motion vectors */
    motion_type = (picture_structure==FRAME_PICTURE) ? MC_FRAME : MC_FIELD;
  }
#if 0
  else
  {
    printf("maroblock_modes(): unknown macroblock type\n");
    motion_type = -1;
  }
#endif

  /* derive motion_vector_count, mv_format and dmv, (table 6-17, 6-18) */
  if (picture_structure==FRAME_PICTURE)
  {
    motion_vector_count = (motion_type==MC_FIELD && stwclass<2) ? 2 : 1;
    mv_format = (motion_type==MC_FRAME) ? MV_FRAME : MV_FIELD;
  }
  else
  {
    motion_vector_count = (motion_type==MC_16X8) ? 2 : 1;
    mv_format = MV_FIELD;
  }

  dmv = (motion_type==MC_DMV); /* dual prime */

  /* field mv predictions in frame pictures have to be scaled
   * ISO/IEC 13818-2 section 7.6.3.1 Decoding the motion vectors
   * IMPLEMENTATION: mvscale is derived for later use in motion_vectors()
   * it displaces the stage:
   *
   *    if((mv_format=="field")&&(t==1)&&(picture_structure=="Frame picture"))
   *      prediction = PMV[r][s][t] DIV 2;
   */

  mvscale = ((mv_format==MV_FIELD) && (picture_structure==FRAME_PICTURE));

  /* get dct_type (frame DCT / field DCT) */
  dct_type = (picture_structure==FRAME_PICTURE)
             && (!frame_pred_frame_dct)
             && (macroblock_type & (MACROBLOCK_PATTERN|MACROBLOCK_INTRA))
             ? Get_Bits(1)
             : 0;

#ifdef TRACE
  if (Trace_Flag  && (picture_structure==FRAME_PICTURE)
             && (!frame_pred_frame_dct)
             && (macroblock_type & (MACROBLOCK_PATTERN|MACROBLOCK_INTRA)))
    printf("dct_type (%d): %s\n",dct_type,dct_type?"Field":"Frame");
#endif /* TRACE */

  /* return values */
  *pmacroblock_type = macroblock_type;
  *pstwtype = stwtype;
  *pstwclass = stwclass;
  *pmotion_type = motion_type;
  *pmotion_vector_count = motion_vector_count;
  *pmv_format = mv_format;
  *pdmv = dmv;
  *pmvscale = mvscale;
  *pdct_type = dct_type;
}


/* move/add 8x8-Block from block[comp] to backward_reference_frame */
/* copy reconstructed 8x8 block from block[comp] to current_frame[]
 * ISO/IEC 13818-2 section 7.6.8: Adding prediction and coefficient data
 * This stage also embodies some of the operations implied by:
 *   - ISO/IEC 13818-2 section 7.6.7: Combining predictions
 *   - ISO/IEC 13818-2 section 6.1.3: Macroblock
*/
static void Add_Block(comp,bx,by,dct_type,addflag)
int comp,bx,by,dct_type,addflag;
{
  int cc,i, j, iincr;
  unsigned char *rfp;
  short *bp;

  
  /* derive color component index */
  /* equivalent to ISO/IEC 13818-2 Table 7-1 */
  cc = (comp<4) ? 0 : (comp&1)+1; /* color component index */

  if (cc==0)
  {
    /* luminance */

    if (picture_structure==FRAME_PICTURE)
      if (dct_type)
      {
        /* field DCT coding */
        rfp = current_frame[0]
              + Coded_Picture_Width*(by+((comp&2)>>1)) + bx + ((comp&1)<<3);
        iincr = (Coded_Picture_Width<<1) - 8;
      }
      else
      {
        /* frame DCT coding */
        rfp = current_frame[0]
              + Coded_Picture_Width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
        iincr = Coded_Picture_Width - 8;
      }
    else
    {
      /* field picture */
      rfp = current_frame[0]
            + (Coded_Picture_Width<<1)*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
      iincr = (Coded_Picture_Width<<1) - 8;
    }
  }
  else
  {
    /* chrominance */

    /* scale coordinates */
    if (chroma_format!=CHROMA444)
      bx >>= 1;
    if (chroma_format==CHROMA420)
      by >>= 1;
    if (picture_structure==FRAME_PICTURE)
    {
      if (dct_type && (chroma_format!=CHROMA420))
      {
        /* field DCT coding */
        rfp = current_frame[cc]
              + Chroma_Width*(by+((comp&2)>>1)) + bx + (comp&8);
        iincr = (Chroma_Width<<1) - 8;
      }
      else
      {
        /* frame DCT coding */
        rfp = current_frame[cc]
              + Chroma_Width*(by+((comp&2)<<2)) + bx + (comp&8);
        iincr = Chroma_Width - 8;
      }
    }
    else
    {
      /* field picture */
      rfp = current_frame[cc]
            + (Chroma_Width<<1)*(by+((comp&2)<<2)) + bx + (comp&8);
      iincr = (Chroma_Width<<1) - 8;
    }
  }

  bp = ld->block[comp];

  if (addflag)
  {
    for (i=0; i<8; i++)
    {
      for (j=0; j<8; j++)
      {
        *rfp = Clip[*bp++ + *rfp];
        rfp++;
      }

      rfp+= iincr;
    }
  }
  else
  {
    for (i=0; i<8; i++)
    {
      for (j=0; j<8; j++)
        *rfp++ = Clip[*bp++ + 128];

      rfp+= iincr;
    }
  }
}


/* ISO/IEC 13818-2 section 7.8 */
static void Decode_SNR_Macroblock(SNRMBA, SNRMBAinc, MBA, MBAmax, dct_type)
  int *SNRMBA, *SNRMBAinc;
  int MBA, MBAmax;
  int *dct_type;
{
  int SNRmacroblock_type, SNRcoded_block_pattern, SNRdct_type, dummy; 
  int slice_vert_pos_ext, quantizer_scale_code, comp, code;

  ld = &enhan;

  if (*SNRMBAinc==0)
  {
    if (!Show_Bits(23)) /* next_start_code */
    {
      next_start_code();
      code = Show_Bits(32);

      if (code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)
      {
        /* only slice headers are allowed in picture_data */
        if (!Quiet_Flag)
          printf("SNR: Premature end of picture\n");
        return;
      }

      Flush_Buffer32();

      /* decode slice header (may change quantizer_scale) */
      slice_vert_pos_ext = slice_header();

      /* decode macroblock address increment */
      *SNRMBAinc = Get_macroblock_address_increment();

      /* set current location */
      *SNRMBA =
        ((slice_vert_pos_ext<<7) + (code&255) - 1)*mb_width + *SNRMBAinc - 1;

      *SNRMBAinc = 1; /* first macroblock in slice: not skipped */
    }
    else /* not next_start_code */
    {
      if (*SNRMBA>=MBAmax)
      {
        if (!Quiet_Flag)
          printf("Too many macroblocks in picture\n");
        return;
      }

      /* decode macroblock address increment */
      *SNRMBAinc = Get_macroblock_address_increment();
    }
  }

  if (*SNRMBA!=MBA)
  {
    /* streams out of sync */
    if (!Quiet_Flag)
      printf("Cant't synchronize streams\n");
    return;
  }

  if (*SNRMBAinc==1) /* not skipped */
  {
    macroblock_modes(&SNRmacroblock_type, &dummy, &dummy,
      &dummy, &dummy, &dummy, &dummy, &dummy,
      &SNRdct_type);

    if (SNRmacroblock_type & MACROBLOCK_PATTERN)
      *dct_type = SNRdct_type;

    if (SNRmacroblock_type & MACROBLOCK_QUANT)
    {
      quantizer_scale_code = Get_Bits(5);
      ld->quantizer_scale =
        ld->q_scale_type ? Non_Linear_quantizer_scale[quantizer_scale_code] : quantizer_scale_code<<1;
    }

    /* macroblock_pattern */
    if (SNRmacroblock_type & MACROBLOCK_PATTERN)
    {
      SNRcoded_block_pattern = Get_coded_block_pattern();

      if (chroma_format==CHROMA422)
        SNRcoded_block_pattern = (SNRcoded_block_pattern<<2) | Get_Bits(2); /* coded_block_pattern_1 */
      else if (chroma_format==CHROMA444)
        SNRcoded_block_pattern = (SNRcoded_block_pattern<<6) | Get_Bits(6); /* coded_block_pattern_2 */
    }
    else
      SNRcoded_block_pattern = 0;

    /* decode blocks */
    for (comp=0; comp<block_count; comp++)
    {
      Clear_Block(comp);

      if (SNRcoded_block_pattern & (1<<(block_count-1-comp)))
        Decode_MPEG2_Non_Intra_Block(comp);
    }
  }
  else /* SNRMBAinc!=1: skipped macroblock */
  {
    for (comp=0; comp<block_count; comp++)
      Clear_Block(comp);
  }

  ld = &base;
}



/* IMPLEMENTATION: set scratch pad macroblock to zero */
static void Clear_Block(comp)
int comp;
{
  short *Block_Ptr;
  int i;

  Block_Ptr = ld->block[comp];
#ifdef SSE2
  __asm{
    mov     edx, [Block_Ptr]  ; /* load addr into edx */
    mov     ecx, 8            ; /* loop 8 times */
    pxor    xmm0, xmm0        ; /* reset xmm0 to zero */
    
  cb_loop:
    movdqu  [edx], xmm0       ;
    add     edx, 16           ;
    loop    cb_loop           ;
  }
  
#else
  for (i=0; i<64;i+=8 ) {

    Block_Ptr[i] = 0;
    Block_Ptr[i+1] = 0;
    Block_Ptr[i+2] = 0;
    Block_Ptr[i+3] = 0;

    Block_Ptr[i+4] = 0;
    Block_Ptr[i+5] = 0;
    Block_Ptr[i+6] = 0;
    Block_Ptr[i+7] = 0;

  }
#endif
}


/* SCALABILITY: add SNR enhancement layer block data to base layer */
/* ISO/IEC 13818-2 section 7.8.3.4: Addition of coefficients from the two layes */
static void Sum_Block(comp)
int comp;
{
  short *Block_Ptr1, *Block_Ptr2;
  int i;

  Block_Ptr1 = base.block[comp];
  Block_Ptr2 = enhan.block[comp];

  for (i=0; i<64; i++)
    *Block_Ptr1++ += *Block_Ptr2++;
}


/* limit coefficients to -2048..2047 */
/* ISO/IEC 13818-2 section 7.4.3 and 7.4.4: Saturation and Mismatch
   control */
static void Saturate(Block_Ptr)
short *Block_Ptr;
{
#ifdef SSE2
  int i, sum, val, j;
  const short upper[8] = {2047,2047,2047,2047,
			  2047,2047,2047,2047};
  const short lower[8] = {-2048,-2048,-2048,-2048,
			  -2048,-2048,-2048,-2048};

  __asm {
    mov      eax, [Block_Ptr]   ;
    movdqu   xmm0, [upper]      ;
    movdqu   xmm1, [lower]      ;
    pxor     xmm3, xmm3         ;

    movdqu   xmm2, [eax]        ; /* load Blocks */
    movdqu   xmm4, [eax+16]        ; /* load Blocks */
    movdqu   xmm5, [eax+32]        ; /* load Blocks */
    movdqu   xmm6, [eax+48]        ; /* load Blocks */
    movdqu   xmm7, [eax+64]        ; /* load Blocks */

    pminsw   xmm2, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm2, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax], xmm2          ; 
    paddsw   xmm3, xmm2         ;
    movdqu   xmm2, [eax+80]        ; /* load Blocks */
   
    pminsw   xmm4, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm4, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+16], xmm4          ; 
    paddsw   xmm3, xmm4        ;
    movdqu   xmm4, [eax+96]        ; /* load Blocks */

    pminsw   xmm5, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm5, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+32], xmm5          ; 
    paddsw   xmm3, xmm5        ;
    movdqu   xmm5, [eax+112]        ; /* load Blocks */

    pminsw   xmm6, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm6, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+48], xmm6          ; 
    paddsw   xmm3, xmm6         ;
    pminsw   xmm7, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm7, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+64], xmm7          ; 
    paddsw   xmm3, xmm7         ;
    pminsw   xmm2, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm2, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+80], xmm2          ; 
    paddsw   xmm3, xmm2         ;
    pminsw   xmm4, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm4, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+96], xmm4          ; 
    paddsw   xmm3, xmm4         ;
    pminsw   xmm5, xmm0         ; /*if (val > 2047) val = 2047*/
    pmaxsw   xmm5, xmm1         ; /*if (val < -2048) val = -2048*/
    movdqu   [eax+112], xmm5          ; 
    paddsw   xmm3, xmm5         ;

    pshufd   xmm0, xmm3,0xe     ; /*move upper 64 bits to xmm0 */
    paddw   xmm0, xmm3        ;
    pshuflw  xmm3, xmm0, 0xe    ; /*move upper 32 bits to xmm3 */
    paddw   xmm0, xmm3        ; /*xmm0 has 2 16-bit */
    pshuflw  xmm3, xmm0, 0x1    ; /*move upper 16 bits to xmm3 */
    paddw   xmm0, xmm3        ; /*xmm0 has 1 16-bit */
    movss   [sum], xmm0        ; 

  }

  /* ISO/IEC 13818-2 section 7.4.3: Saturation */
  /* unrolled 4 times for SIMD instructions */

  /* ISO/IEC 13818-2 section 7.4.4: Mismatch control */
  if ((sum&1)==0)
    Block_Ptr[63]^= 1;

#else /* NON-SSE2 code */
  int i, sum, val, j;

  sum = 0;

  /* ISO/IEC 13818-2 section 7.4.3: Saturation */
  /* unrolled 4 times for SIMD instructions */


  for (i=0; i<64; )
  {

    for (j=0; j < 8; j++, i++) { 

      val = Block_Ptr[i]; 
      if (val>2047)
	val = 2047;
      else if (val<-2048)
	val = -2048;
      Block_Ptr[i] = val;
      sum+= val;
      
    }

  } 

  /* ISO/IEC 13818-2 section 7.4.4: Mismatch control */
  if ((sum&1)==0)
    Block_Ptr[63]^= 1;
#endif

}


/* reuse old picture buffers as soon as they are no longer needed 
   based on life-time axioms of MPEG */
static void Update_Picture_Buffers()
{                           
  int cc;              /* color component index */
  unsigned char *tmp;  /* temporary swap pointer */

  for (cc=0; cc<3; cc++)
  {
    /* B pictures do not need to be save for future reference */
    if (picture_coding_type==B_TYPE)
    {
      current_frame[cc] = auxframe[cc];
    }
    else
    {
      /* only update at the beginning of the coded frame */
      if (!Second_Field)
      {
        tmp = forward_reference_frame[cc];

        /* the previously decoded reference frame is stored
           coincident with the location where the backward 
           reference frame is stored (backwards prediction is not
           needed in P pictures) */
        forward_reference_frame[cc] = backward_reference_frame[cc];
        
        /* update pointer for potential future B pictures */
        backward_reference_frame[cc] = tmp;
      }

      /* can erase over old backward reference frame since it is not used
         in a P picture, and since any subsequent B pictures will use the 
         previously decoded I or P frame as the backward_reference_frame */
      current_frame[cc] = backward_reference_frame[cc];
    }

    /* IMPLEMENTATION:
       one-time folding of a line offset into the pointer which stores the
       memory address of the current frame saves offsets and conditional 
       branches throughout the remainder of the picture processing loop */
    if (picture_structure==BOTTOM_FIELD)
      current_frame[cc]+= (cc==0) ? Coded_Picture_Width : Chroma_Width;
  }
}


/* store last frame */

void Output_Last_Frame_of_Sequence(Framenum)
int Framenum;
{
  if (Second_Field)
    printf("last frame incomplete, not stored\n");
  else
    Write_Frame(backward_reference_frame,Framenum-1);
}



static void frame_reorder(Bitstream_Framenum, Sequence_Framenum)
int Bitstream_Framenum, Sequence_Framenum;
{
  /* tracking variables to insure proper output in spatial scalability */
  static int Oldref_progressive_frame, Newref_progressive_frame;

  if (Sequence_Framenum!=0)
  {
    if (picture_structure==FRAME_PICTURE || Second_Field)
    {
      if (picture_coding_type==B_TYPE)
        Write_Frame(auxframe,Bitstream_Framenum-1);
      else
      {
        Newref_progressive_frame = progressive_frame;
        progressive_frame = Oldref_progressive_frame;

        Write_Frame(forward_reference_frame,Bitstream_Framenum-1);

        Oldref_progressive_frame = progressive_frame = Newref_progressive_frame;
      }
    }
#ifdef DISPLAY
    else if (Output_Type==T_X11)
    {
      if(!Display_Progressive_Flag)
        Display_Second_Field();
    }
#endif
  }
  else
    Oldref_progressive_frame = progressive_frame;
}


/* ISO/IEC 13818-2 section 7.6 */
static void motion_compensation(MBA, macroblock_type, motion_type, PMV, 
  motion_vertical_field_select, dmvector, stwtype, dct_type)
int MBA;
int macroblock_type;
int motion_type;
int PMV[2][2][2];
int motion_vertical_field_select[2][2];
int dmvector[2];
int stwtype;
int dct_type;
{
  int bx, by;
  int comp;

  /* derive current macroblock position within picture */
  /* ISO/IEC 13818-2 section 6.3.1.6 and 6.3.1.7 */
  bx = 16*(MBA%mb_width);
  by = 16*(MBA/mb_width);

  /* motion compensation */
  if (!(macroblock_type & MACROBLOCK_INTRA))
    form_predictions(bx,by,macroblock_type,motion_type,PMV,
      motion_vertical_field_select,dmvector,stwtype);
  
  /* SCALABILITY: Data Partitioning */
  if (base.scalable_mode==SC_DP)
    ld = &base;

  /* copy or add block data into picture */
  for (comp=0; comp<block_count; comp++)
  {
    /* SCALABILITY: SNR */
    /* ISO/IEC 13818-2 section 7.8.3.4: Addition of coefficients from 
       the two a layers */
    if (Two_Streams && enhan.scalable_mode==SC_SNR)
      Sum_Block(comp); /* add SNR enhancement layer data to base layer */

    /* MPEG-2 saturation and mismatch control */
    /* base layer could be MPEG-1 stream, enhancement MPEG-2 SNR */
    /* ISO/IEC 13818-2 section 7.4.3 and 7.4.4: Saturation and Mismatch control */
    if ((Two_Streams && enhan.scalable_mode==SC_SNR) || ld->MPEG2_Flag)
      Saturate(ld->block[comp]);

    /* ISO/IEC 13818-2 section Annex A: inverse DCT */
    if (Reference_IDCT_Flag)
      Reference_IDCT(ld->block[comp]);
    else
      Fast_IDCT(ld->block[comp]);
    
    /* ISO/IEC 13818-2 section 7.6.8: Adding prediction and coefficient data */
    Add_Block(comp,bx,by,dct_type,(macroblock_type & MACROBLOCK_INTRA)==0);
  }

}



/* ISO/IEC 13818-2 section 7.6.6 */
static void skipped_macroblock(dc_dct_pred, PMV, motion_type, 
  motion_vertical_field_select, stwtype, macroblock_type)
int dc_dct_pred[3];
int PMV[2][2][2];
int *motion_type;
int motion_vertical_field_select[2][2];
int *stwtype;
int *macroblock_type;
{
  int comp;
  
  /* SCALABILITY: Data Paritioning */
  if (base.scalable_mode==SC_DP)
    ld = &base;

  for (comp=0; comp<block_count; comp++)
    Clear_Block(comp);

  /* reset intra_dc predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;

  /* reset motion vector predictors */
  /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
  if (picture_coding_type==P_TYPE)
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;

  /* derive motion_type */
  if (picture_structure==FRAME_PICTURE)
    *motion_type = MC_FRAME;
  else
  {
    *motion_type = MC_FIELD;

    /* predict from field of same parity */
    /* ISO/IEC 13818-2 section 7.6.6.1 and 7.6.6.3: P field picture and B field
       picture */
    motion_vertical_field_select[0][0]=motion_vertical_field_select[0][1] = 
      (picture_structure==BOTTOM_FIELD);
  }

  /* skipped I are spatial-only predicted, */
  /* skipped P and B are temporal-only predicted */
  /* ISO/IEC 13818-2 section 7.7.6: Skipped macroblocks */
  *stwtype = (picture_coding_type==I_TYPE) ? 8 : 0;

 /* IMPLEMENTATION: clear MACROBLOCK_INTRA */
  *macroblock_type&= ~MACROBLOCK_INTRA;

}


/* return==-1 means go to next picture */
/* the expression "start of slice" is used throughout the normative
   body of the MPEG specification */
static int start_of_slice(MBAmax, MBA, MBAinc, 
  dc_dct_pred, PMV)
int MBAmax;
int *MBA;
int *MBAinc;
int dc_dct_pred[3];
int PMV[2][2][2];
{
  unsigned int code;
  int slice_vert_pos_ext;

  ld = &base;

  Fault_Flag = 0;

  next_start_code();
  code = Show_Bits(32);

  if (code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)
  {
    /* only slice headers are allowed in picture_data */
    if (!Quiet_Flag)
      printf("start_of_slice(): Premature end of picture\n");

    return(-1);  /* trigger: go to next picture */
  }

  Flush_Buffer32(); 

  /* decode slice header (may change quantizer_scale) */
  slice_vert_pos_ext = slice_header();
  if (DEBUG) printf("slice_vert_pos_ext %d\n",slice_vert_pos_ext);
 
  /* SCALABILITY: Data Partitioning */
  if (base.scalable_mode==SC_DP)
  {
    ld = &enhan;
    next_start_code();
    code = Show_Bits(32);

    if (code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)
    {
      /* only slice headers are allowed in picture_data */
      if (!Quiet_Flag)
        printf("DP: Premature end of picture\n");
      return(-1);    /* trigger: go to next picture */
    }

    Flush_Buffer32();

    /* decode slice header (may change quantizer_scale) */
    slice_vert_pos_ext = slice_header();

    if (base.priority_breakpoint!=1)
      ld = &base;
  }
  if (DEBUG) printf("slice_vert_pos_ext %d code %d\n",slice_vert_pos_ext,code);
  /* decode macroblock address increment */
  *MBAinc = Get_macroblock_address_increment();

  if (Fault_Flag) 
  {
    printf("start_of_slice(): MBAinc unsuccessful\n");
    return(0);   /* trigger: go to next slice */
  }

  /* set current location */
  /* NOTE: the arithmetic used to derive macroblock_address below is
   *       equivalent to ISO/IEC 13818-2 section 6.3.17: Macroblock
   */
  *MBA = ((slice_vert_pos_ext<<7) + (code&255) - 1)*mb_width + *MBAinc - 1;
  *MBAinc = 1; /* first macroblock in slice: not skipped */

  /* reset all DC coefficient and motion vector predictors */
  /* reset all DC coefficient and motion vector predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;
  
  /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
  PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
  PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;

  /* successfull: trigger decode macroblocks in slice */
  return(1);
}


/* ISO/IEC 13818-2 sections 7.2 through 7.5 */
static int decode_macroblock(macroblock_type, stwtype, stwclass,
  motion_type, dct_type, PMV, dc_dct_pred, 
  motion_vertical_field_select, dmvector)
int *macroblock_type; 
int *stwtype;
int *stwclass;
int *motion_type; 
int *dct_type;
int PMV[2][2][2]; 
int dc_dct_pred[3]; 
int motion_vertical_field_select[2][2];
int dmvector[2];
{
  /* locals */
  int quantizer_scale_code; 
  int comp;

  int motion_vector_count; 
  int mv_format; 
  int dmv; 
  int mvscale;
  int coded_block_pattern;

  /* SCALABILITY: Data Patitioning */
  if (base.scalable_mode==SC_DP)
  {
    if (base.priority_breakpoint<=2)
      ld = &enhan;
    else
      ld = &base;
  }

  /* ISO/IEC 13818-2 section 6.3.17.1: Macroblock modes */
  macroblock_modes(macroblock_type, stwtype, stwclass,
    motion_type, &motion_vector_count, &mv_format, &dmv, &mvscale,
    dct_type);

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  if (*macroblock_type & MACROBLOCK_QUANT)
  {
    quantizer_scale_code = Get_Bits(5);

#ifdef TRACE
    if (Trace_Flag)
    {
      printf("quantiser_scale_code (");
      Print_Bits(quantizer_scale_code,5,5);
      printf("): %d\n",quantizer_scale_code);
    }
#endif /* TRACE */

    /* ISO/IEC 13818-2 section 7.4.2.2: Quantizer scale factor */
    if (ld->MPEG2_Flag)
      ld->quantizer_scale =
      ld->q_scale_type ? Non_Linear_quantizer_scale[quantizer_scale_code] 
       : (quantizer_scale_code << 1);
    else
      ld->quantizer_scale = quantizer_scale_code;

    /* SCALABILITY: Data Partitioning */
    if (base.scalable_mode==SC_DP)
      /* make sure base.quantizer_scale is valid */
      base.quantizer_scale = ld->quantizer_scale;
  }

  /* motion vectors */


  /* ISO/IEC 13818-2 section 6.3.17.2: Motion vectors */

  /* decode forward motion vectors */
  if ((*macroblock_type & MACROBLOCK_MOTION_FORWARD) 
    || ((*macroblock_type & MACROBLOCK_INTRA) 
    && concealment_motion_vectors))
  {
    if (ld->MPEG2_Flag)
      motion_vectors(PMV,dmvector,motion_vertical_field_select,
        0,motion_vector_count,mv_format,f_code[0][0]-1,f_code[0][1]-1,
        dmv,mvscale);
    else
      motion_vector(PMV[0][0],dmvector,
      forward_f_code-1,forward_f_code-1,0,0,full_pel_forward_vector);
  }

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  /* decode backward motion vectors */
  if (*macroblock_type & MACROBLOCK_MOTION_BACKWARD)
  {
    if (ld->MPEG2_Flag)
      motion_vectors(PMV,dmvector,motion_vertical_field_select,
        1,motion_vector_count,mv_format,f_code[1][0]-1,f_code[1][1]-1,0,
        mvscale);
    else
      motion_vector(PMV[0][1],dmvector,
        backward_f_code-1,backward_f_code-1,0,0,full_pel_backward_vector);
  }

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  if ((*macroblock_type & MACROBLOCK_INTRA) && concealment_motion_vectors)
    Flush_Buffer(1); /* remove marker_bit */

  if (base.scalable_mode==SC_DP && base.priority_breakpoint==3)
    ld = &enhan;

  /* macroblock_pattern */
  /* ISO/IEC 13818-2 section 6.3.17.4: Coded block pattern */
  if (*macroblock_type & MACROBLOCK_PATTERN)
  {
    coded_block_pattern = Get_coded_block_pattern();

    if (chroma_format==CHROMA422)
    {
      /* coded_block_pattern_1 */
      coded_block_pattern = (coded_block_pattern<<2) | Get_Bits(2); 

#ifdef TRACE
       if (Trace_Flag)
       {
         printf("coded_block_pattern_1: ");
         Print_Bits(coded_block_pattern,2,2);
         printf(" (%d)\n",coded_block_pattern&3);
       }
#endif /* TRACE */
     }
     else if (chroma_format==CHROMA444)
     {
      /* coded_block_pattern_2 */
      coded_block_pattern = (coded_block_pattern<<6) | Get_Bits(6); 

#ifdef TRACE
      if (Trace_Flag)
      {
        printf("coded_block_pattern_2: ");
        Print_Bits(coded_block_pattern,6,6);
        printf(" (%d)\n",coded_block_pattern&63);
      }
#endif /* TRACE */
    }
  }
  else
    coded_block_pattern = (*macroblock_type & MACROBLOCK_INTRA) ? 
      (1<<block_count)-1 : 0;

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  /* decode blocks */
  for (comp=0; comp<block_count; comp++)
  {
    /* SCALABILITY: Data Partitioning */
    if (base.scalable_mode==SC_DP)
    ld = &base;

    Clear_Block(comp);

    if (coded_block_pattern & (1<<(block_count-1-comp)))
    {
      if (*macroblock_type & MACROBLOCK_INTRA)
      {
        if (ld->MPEG2_Flag)
          Decode_MPEG2_Intra_Block(comp,dc_dct_pred);
        else
          Decode_MPEG1_Intra_Block(comp,dc_dct_pred);
      }
      else
      {
        if (ld->MPEG2_Flag)
          Decode_MPEG2_Non_Intra_Block(comp);
        else
          Decode_MPEG1_Non_Intra_Block(comp);
      }

      if (Fault_Flag) return(0);  /* trigger: go to next slice */
    }
  }

  if(picture_coding_type==D_TYPE)
  {
    /* remove end_of_macroblock (always 1, prevents startcode emulation) */
    /* ISO/IEC 11172-2 section 2.4.2.7 and 2.4.3.6 */
    marker_bit("D picture end_of_macroblock bit");
  }

  /* reset intra_dc predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  if (!(*macroblock_type & MACROBLOCK_INTRA))
    dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;

  /* reset motion vector predictors */
  if ((*macroblock_type & MACROBLOCK_INTRA) && !concealment_motion_vectors)
  {
    /* intra mb without concealment motion vectors */
    /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
    PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  }

  /* special "No_MC" macroblock_type case */
  /* ISO/IEC 13818-2 section 7.6.3.5: Prediction in P pictures */
  if ((picture_coding_type==P_TYPE) 
    && !(*macroblock_type & (MACROBLOCK_MOTION_FORWARD|MACROBLOCK_INTRA)))
  {
    /* non-intra mb without forward mv in a P picture */
    /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;

    /* derive motion_type */
    /* ISO/IEC 13818-2 section 6.3.17.1: Macroblock modes, frame_motion_type */
    if (picture_structure==FRAME_PICTURE)
      *motion_type = MC_FRAME;
    else
    {
      *motion_type = MC_FIELD;
      /* predict from field of same parity */
      motion_vertical_field_select[0][0] = (picture_structure==BOTTOM_FIELD);
    }
  }

  if (*stwclass==4)
  {
    /* purely spatially predicted macroblock */
    /* ISO/IEC 13818-2 section 7.7.5.1: Resetting motion vector predictions */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
    PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  }

  /* successfully decoded macroblock */
  return(1);

} /* decode_macroblock */


#ifdef THRD

void write_frame_buf8(int t, unsigned char data) {
#if 0 /*alex*/
  if (frame_buf_offset == frame_buf_size) {
    frame_buf_size <<= 1;
    frame_buffer = (unsigned char *) realloc(frame_buffer, 
					     sizeof(unsigned char)*frame_buf_size);
    if (DEBUG) printf("increase buf size to %d\n",frame_buf_size);
  };
  frame_buffer[frame_buf_offset++] = data;
#else
  if (tb[t].frame_buf_offset == tb[t].frame_buf_size) {
    tb[t].frame_buf_size <<= 1;
    tb[t].frame_buf = 
      (unsigned char *) realloc(tb[t].frame_buf,
				sizeof(unsigned char)*tb[t].frame_buf_size);
  };
  tb[t].frame_buf[tb[t].frame_buf_offset++] = data;
#endif
}

void write_frame_buf32(int t, unsigned int data) {
  write_frame_buf8(t, (unsigned char) (data >> 24));
  write_frame_buf8(t, (unsigned char) (data >> 16));
  write_frame_buf8(t, (unsigned char) (data >> 8));
  write_frame_buf8(t, (unsigned char) data);
}



extern short ic[8][8];

void *Thrd_Work(void* thrd_args) {
  Thrd_Args *mydata = (Thrd_Args*) thrd_args;

  int id = mydata->id;
  int num_slices = mydata->num_slices;
#ifdef DISPLAY
  int framenum = mydata->framenum;
#endif
  int MBAmax = mydata->MBAmax;
  int MBA; 
  int MBAinc, macroblock_type, motion_type, dct_type;
  int dc_dct_pred[3];
  int PMV[2][2][2], motion_vertical_field_select[2][2];
  int dmvector[2];
  int stwtype, stwclass;
  int SNRMBA, SNRMBAinc;
  int localMBA, localMBAmax;
  int ret;

  MBA = 0; /* macroblock address */
  MBAinc = 0;
  localMBA = 0;
  localMBAmax = num_slices * mb_width;


  if (DEBUG)
    printf("decoding %d mb thrd_ptr %p\n",localMBAmax,thrd_ptr[id]);

 next_slice:
  if((ret=Thrd_start_of_slice(id, MBAmax, &MBA, &MBAinc, dc_dct_pred, PMV))!=1) {
    /*assert(0&&"no way!");*/
    if (localMBA >= localMBAmax)
      return NULL;
  }

  if (DEBUG)
  printf("MBAinc is %d, MBA is %d\n",MBAinc, MBA);
  
  if (Two_Streams && enhan.scalable_mode==SC_SNR)
  {
    SNRMBA=0;
    SNRMBAinc=0;
  }

  Fault_Flag=0;

  for (;;)
    {
      
      /* this is how we properly exit out of picture */
      if (localMBA>=localMBAmax) {
	    if (DEBUG) printf("exit 0\n");
	    return NULL; /* all macroblocks decoded */
      }


#ifdef DISPLAY
    if (!progressive_frame && picture_structure==FRAME_PICTURE 
      && MBA==(MBAmax>>1) && framenum!=0 && Output_Type==T_X11 
       && !Display_Progressive_Flag)
    {
      assert(0&&"display second field");
      Display_Second_Field();
    }
#endif

    ld = &base;

    if (MBAinc==0)
      {
	if (base.scalable_mode==SC_DP && base.priority_breakpoint==1)
          ld = &enhan;
	
	if (!Thrd_Show_Bits(id,23) || Fault_Flag) /* next_start_code or fault */
	  {
	  resync: /* if Fault_Flag: resynchronize to next next_start_code */
	    if (DEBUG) printf("exit 1 fault_flag %d ptr %p\n", Fault_Flag,thrd_ptr[id]);
	    Fault_Flag = 0;
	    goto next_slice;
	    return NULL;     /* trigger: go to next slice */
	  }
	else /* neither next_start_code nor Fault_Flag */
	  {
	    if (base.scalable_mode==SC_DP && base.priority_breakpoint==1)
	      ld = &enhan;
	    
	    /* decode macroblock address increment */
	    MBAinc = Thrd_Get_macroblock_address_increment(id);
	    
	    if (Fault_Flag) goto resync;
	  }
      }

    if (MBA>=MBAmax)
    {
      /* MBAinc points beyond picture dimensions */
      if (!Quiet_Flag)
        printf("Too many macroblocks in picture\n");
      if (DEBUG) printf("exit 2\n");
      return NULL;
    }

    if (MBAinc==1) /* not skipped */
    {
      ret = Thrd_decode_macroblock(id, &macroblock_type, &stwtype, &stwclass,
				   &motion_type, &dct_type, PMV, dc_dct_pred, 
				   motion_vertical_field_select, dmvector);
      
      if(ret==-1) {
	if (DEBUG) printf("exit 3\n");
        return NULL;
      }
      
      if(ret==0) {
	if (DEBUG) printf("exit 4\n");
        goto resync;
      }
      
    }
    else /* MBAinc!=1: skipped macroblock */
    {      
      /* ISO/IEC 13818-2 section 7.6.6 */
      Thrd_skipped_macroblock(id, dc_dct_pred, PMV, &motion_type, 
        motion_vertical_field_select, &stwtype, &macroblock_type);
    }

    /* SCALABILITY: SNR */
    /* ISO/IEC 13818-2 section 7.8 */
    /* NOTE: we currently ignore faults encountered in this routine */
    if (Two_Streams && enhan.scalable_mode==SC_SNR)
      Decode_SNR_Macroblock(&SNRMBA, &SNRMBAinc, MBA, MBAmax, &dct_type);

    /* ISO/IEC 13818-2 section 7.6 */
    Thrd_motion_compensation(id, MBA, macroblock_type, motion_type, PMV, 
			     motion_vertical_field_select, dmvector, stwtype, dct_type);
    
    if (DEBUG)
      printf("localMBA %d MBA is %d\n",localMBA, MBA);
    
    /* advance to next macroblock */
    localMBA++;
    MBA++;
    MBAinc--;
 
    /* SCALABILITY: SNR */
    if (Two_Streams && enhan.scalable_mode==SC_SNR)
    {
      SNRMBA++;
      SNRMBAinc--;
    }

    if (localMBA>=localMBAmax) {
      if (DEBUG) printf("exit 5\n");
      return NULL; /* all macroblocks decoded */
    }
  }
  
  return NULL;

} 

Thrd_Args thread_data_array[NUM_THREADS];

static int new_slice(framenum, MBAmax)
int framenum, MBAmax;
{
  unsigned int code;
  unsigned int num_slices = 0;
  int chunk_size;
  int remainder;
  int thrd_num = 1;
  int num_decode_slice[NUM_THREADS];
  int tmp, t, next_marker;
  unsigned int ptr_offset[NUM_THREADS];

#if (NUM_THREADS>1)
  pthread_t thread[NUM_THREADS-1];
  pthread_attr_t attr;
  int rc, status;
#endif
  int num_thrds = (mb_height > NUM_THREADS) ? NUM_THREADS : mb_height;
  
  /*assert((mb_height >= NUM_THREADS) && "more threads than slices\n");    */

#if (NUM_THREADS>1)
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
#endif   

  tb[0].frame_buf_offset = 0;
  next_start_code(); /*this should be pointing to the first slice of the picture*/
  code = Show_Bits(32);
  
  assert(!(code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)&&"Bad slice start code\n");
  write_frame_buf32(0,code);
  Flush_Buffer32();
  
  num_slices++;
  
  chunk_size = mb_height / num_thrds;
  remainder = mb_height % num_thrds;
  
  if (DEBUG)
    printf("next_marker %d mb_height %d\n",next_marker, mb_height);

  num_decode_slice[0]= (remainder>0) ? chunk_size+1 : chunk_size;
  next_marker = num_decode_slice[0];
  
  while (num_slices <= mb_height) {
    
    assert(ld->Incnt > 24);
    while (Show_Bits(24)!=0x01L) {
      write_frame_buf8(thrd_num-1,(unsigned char)Show_Bits(8));
      Flush_Buffer(8);
    };
    
    if (num_slices != mb_height) {
      code = Show_Bits(32);
      assert(!(code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)&&"Bad slice start code\n");
      
      if (num_slices == next_marker) {
	tb[thrd_num].frame_buf_offset = 0;
	
	num_decode_slice[thrd_num] = (remainder > thrd_num) ? chunk_size+1 : chunk_size;
	next_marker += num_decode_slice[thrd_num];

#if 1	
	/*Thread Create */
	t = thrd_num - 1;
	thread_data_array[t].id = t;
	thread_data_array[t].num_slices = num_decode_slice[t];
	thread_data_array[t].framenum = framenum;
	thread_data_array[t].MBAmax = MBAmax;
	thrd_ptr[t] = tb[t].frame_buf;
	
	Thrd_Initialize_Buffer(t);

#if (NUM_THREADS>1)	
	if (t!=num_thrds-1) {
	  rc = pthread_create(&thread[t], &attr, Thrd_Work, 
			      (void*) &thread_data_array[t]); 
	  if (rc) {
	    printf("ERROR; return code from pthread_create() is %d\n", rc);
	    exit(-1);
	  }
	  
	}
#endif
#endif
	thrd_num++;
	
      }
      write_frame_buf32(thrd_num-1,code);
      Flush_Buffer32();
    }
    num_slices++;
  }
  /* End of reading phase */

  t = thrd_num - 1;
  thread_data_array[t].id = t;
  thread_data_array[t].num_slices = num_decode_slice[t];
  thread_data_array[t].framenum = framenum;
  thread_data_array[t].MBAmax = MBAmax;
  thrd_ptr[t] = tb[t].frame_buf;
  
  Thrd_Initialize_Buffer(t);

#if 0
 /*Thread Create */
  for (t=0; t<NUM_THREADS; t++) {
    thread_data_array[t].id = t;
    thread_data_array[t].num_slices = num_decode_slice[t];
    thread_data_array[t].framenum = framenum;
    thread_data_array[t].MBAmax = MBAmax;
    thrd_ptr[t] = frame_buffer+ptr_offset[t];

    Thrd_Initialize_Buffer(t);

    if (t!=NUM_THREADS-1) {
      rc = pthread_create(&thread[t], &attr, Thrd_Work, 
			  (void*) &thread_data_array[t]); 
      if (rc) {
	printf("ERROR; return code from pthread_create() is %d\n", rc);
	exit(-1);
      }

    }
  }
#endif

  Thrd_Work((void*) &thread_data_array[t]);
#if (NUM_THREADS>1)
/*Thread JOIN */
  for(t=0;t < num_thrds-1;t++)
    {
      rc = pthread_join(thread[t], (void **)&status);
      if (rc)
	{
	  printf("ERROR; return code from pthread_join() is %d\n", rc);
	  exit(-1);
	}
    }
#endif
  return -1;
}

/* return==-1 means go to next picture */
/* the expression "start of slice" is used throughout the normative
   body of the MPEG specification */
static int Thrd_start_of_slice(t, MBAmax, MBA, MBAinc, 
  dc_dct_pred, PMV)
int t;
int MBAmax;
int *MBA;
int *MBAinc;
int dc_dct_pred[3];
int PMV[2][2][2];
{
  unsigned int code;
  int slice_vert_pos_ext;

  ld = &base;

  Fault_Flag = 0;
  if (DEBUG) printf("thrd_ptr[t] %p frame_buf %p\n",thrd_ptr[t],frame_buffer);
  Thrd_next_start_code(t);
  code = Thrd_Show_Bits(t, 32);
  
  if (code<SLICE_START_CODE_MIN || code>SLICE_START_CODE_MAX)
  {
    /* only slice headers are allowed in picture_data */
    if (!Quiet_Flag)
      printf("start_of_slice(): Premature end of picture\n");

    return(-1);  /* trigger: go to next picture */
  }
  if (DEBUG) printf("thrd_ptr[t] %p frame_buf %p\n",thrd_ptr[t],frame_buffer);
  Thrd_Flush_Buffer32(t); 
  if (DEBUG) printf("thrd_ptr[t] %p\n",thrd_ptr[t]);

  /* decode slice header (may change quantizer_scale) */
  slice_vert_pos_ext = Thrd_slice_header(t);
  if (DEBUG) printf("slice_vert_pos_ext %d code %d\n",slice_vert_pos_ext, code);
  /* decode macroblock address increment */
  *MBAinc = Thrd_Get_macroblock_address_increment(t);

  if (Fault_Flag) 
  {
    printf("start_of_slice(): MBAinc unsuccessful\n");
    return(0);   /* trigger: go to next slice */
  }

  /* set current location */
  /* NOTE: the arithmetic used to derive macroblock_address below is
   *       equivalent to ISO/IEC 13818-2 section 6.3.17: Macroblock
   */
  *MBA = ((slice_vert_pos_ext<<7) + (code&255) - 1)*mb_width + *MBAinc - 1;
  *MBAinc = 1; /* first macroblock in slice: not skipped */

  /* reset all DC coefficient and motion vector predictors */
  /* reset all DC coefficient and motion vector predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;
  
  /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
  PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
  PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;

  /* successfull: trigger decode macroblocks in slice */
  return(1);
}


static int Thrd_decode_macroblock(t, macroblock_type, stwtype, stwclass,
  motion_type, dct_type, PMV, dc_dct_pred, 
  motion_vertical_field_select, dmvector)
int t;
int *macroblock_type; 
int *stwtype;
int *stwclass;
int *motion_type; 
int *dct_type;
int PMV[2][2][2]; 
int dc_dct_pred[3]; 
int motion_vertical_field_select[2][2];
int dmvector[2];
{
  /* locals */
  int quantizer_scale_code; 
  int comp;

  int motion_vector_count; 
  int mv_format; 
  int dmv; 
  int mvscale;
  int coded_block_pattern;

  /* SCALABILITY: Data Patitioning */
  if (base.scalable_mode==SC_DP)
  {
    if (base.priority_breakpoint<=2)
      ld = &enhan;
    else
      ld = &base;
  }

  /* ISO/IEC 13818-2 section 6.3.17.1: Macroblock modes */
  Thrd_macroblock_modes(t, macroblock_type, stwtype, stwclass,
    motion_type, &motion_vector_count, &mv_format, &dmv, &mvscale,
    dct_type);

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  if (*macroblock_type & MACROBLOCK_QUANT)
  {
    quantizer_scale_code = Thrd_Get_Bits(t,5);

    /* ISO/IEC 13818-2 section 7.4.2.2: Quantizer scale factor */
    if (ld->MPEG2_Flag)
      thrd_ld[t].quantizer_scale =
	ld->q_scale_type ? Non_Linear_quantizer_scale[quantizer_scale_code] 
	: (quantizer_scale_code << 1);
    else
      thrd_ld[t].quantizer_scale = quantizer_scale_code;

    /* SCALABILITY: Data Partitioning */
    if (base.scalable_mode==SC_DP) {
      printf("DP exiting\n");
      exit(-1);
      /* make sure base.quantizer_scale is valid */
      base.quantizer_scale = ld->quantizer_scale;
    }
  }

  /* motion vectors */


  /* ISO/IEC 13818-2 section 6.3.17.2: Motion vectors */

  /* decode forward motion vectors */
  if ((*macroblock_type & MACROBLOCK_MOTION_FORWARD) 
    || ((*macroblock_type & MACROBLOCK_INTRA) 
    && concealment_motion_vectors))
  {
    if (ld->MPEG2_Flag) 
      Thrd_motion_vectors(t, PMV,dmvector,motion_vertical_field_select,
			  0,motion_vector_count,mv_format,f_code[0][0]-1,f_code[0][1]-1,
			  dmv,mvscale);
    else
      Thrd_motion_vector(t, PMV[0][0],dmvector,
			 forward_f_code-1,forward_f_code-1,0,0,full_pel_forward_vector);
  }

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  /* decode backward motion vectors */
  if (*macroblock_type & MACROBLOCK_MOTION_BACKWARD)
  {
    if (ld->MPEG2_Flag)
      Thrd_motion_vectors(t, PMV,dmvector,motion_vertical_field_select,
        1,motion_vector_count,mv_format,f_code[1][0]-1,f_code[1][1]-1,0,
        mvscale);
    else
      Thrd_motion_vector(t, PMV[0][1],dmvector,
        backward_f_code-1,backward_f_code-1,0,0,full_pel_backward_vector);
  }

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  if ((*macroblock_type & MACROBLOCK_INTRA) && concealment_motion_vectors)
    Thrd_Flush_Buffer(t,1); /* remove marker_bit */

  if (base.scalable_mode==SC_DP && base.priority_breakpoint==3) {
    printf("enhan not supported, exiting...\n");
    exit(-1);
    ld = &enhan;
  }

  /* macroblock_pattern */
  /* ISO/IEC 13818-2 section 6.3.17.4: Coded block pattern */
  if (*macroblock_type & MACROBLOCK_PATTERN)
    {
      coded_block_pattern = Thrd_Get_coded_block_pattern(t);
      
      if (chroma_format==CHROMA422)
	{
	  /* coded_block_pattern_1 */
	  coded_block_pattern = (coded_block_pattern<<2) | Thrd_Get_Bits(t,2); 
	}
      else if (chroma_format==CHROMA444)
     {
      /* coded_block_pattern_2 */
      coded_block_pattern = (coded_block_pattern<<6) | Thrd_Get_Bits(t,6); 
     }
    }
  else
    coded_block_pattern = (*macroblock_type & MACROBLOCK_INTRA) ? 
      (1<<block_count)-1 : 0;

  if (Fault_Flag) return(0);  /* trigger: go to next slice */

  /* decode blocks */
  for (comp=0; comp<block_count; comp++)
    {
      /* SCALABILITY: Data Partitioning */
    if (base.scalable_mode==SC_DP)
      ld = &base;

    Thrd_Clear_Block(t,comp);

    if (coded_block_pattern & (1<<(block_count-1-comp)))
    {
      if (*macroblock_type & MACROBLOCK_INTRA)
      {
        if (ld->MPEG2_Flag)
          Thrd_Decode_MPEG2_Intra_Block(t,comp,dc_dct_pred);
        else {
	  printf("not mpeg2, exiting...\n"); exit(-1);
          Decode_MPEG1_Intra_Block(comp,dc_dct_pred);
	}
      }
      else
	{
	  if (ld->MPEG2_Flag)
	    Thrd_Decode_MPEG2_Non_Intra_Block(t,comp);
        else {
	  printf("not mpeg2, exiting...\n"); exit(-1);
          Decode_MPEG1_Non_Intra_Block(comp);
	}
      }

      if (Fault_Flag) return(0);  /* trigger: go to next slice */
    }
  }

  if(picture_coding_type==D_TYPE)
  {
    /* remove end_of_macroblock (always 1, prevents startcode emulation) */
    /* ISO/IEC 11172-2 section 2.4.2.7 and 2.4.3.6 */
    Thrd_Get_Bits(t,1);
  }

  /* reset intra_dc predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  if (!(*macroblock_type & MACROBLOCK_INTRA))
    dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;

  /* reset motion vector predictors */
  if ((*macroblock_type & MACROBLOCK_INTRA) && !concealment_motion_vectors)
  {
    /* intra mb without concealment motion vectors */
    /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
    PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  }

  /* special "No_MC" macroblock_type case */
  /* ISO/IEC 13818-2 section 7.6.3.5: Prediction in P pictures */
  if ((picture_coding_type==P_TYPE) 
    && !(*macroblock_type & (MACROBLOCK_MOTION_FORWARD|MACROBLOCK_INTRA)))
  {
    /* non-intra mb without forward mv in a P picture */
    /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;

    /* derive motion_type */
    /* ISO/IEC 13818-2 section 6.3.17.1: Macroblock modes, frame_motion_type */
    if (picture_structure==FRAME_PICTURE)
      *motion_type = MC_FRAME;
    else
    {
      *motion_type = MC_FIELD;
      /* predict from field of same parity */
      motion_vertical_field_select[0][0] = (picture_structure==BOTTOM_FIELD);
    }
  }

  if (*stwclass==4)
  {
    /* purely spatially predicted macroblock */
    /* ISO/IEC 13818-2 section 7.7.5.1: Resetting motion vector predictions */
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
    PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  }

  /* successfully decoded macroblock */
  return(1);

} /* decode_macroblock */

/* ISO/IEC 13818-2 section 7.6.6 */
static void Thrd_skipped_macroblock(t, dc_dct_pred, PMV, motion_type, 
  motion_vertical_field_select, stwtype, macroblock_type)
int t;
int dc_dct_pred[3];
int PMV[2][2][2];
int *motion_type;
int motion_vertical_field_select[2][2];
int *stwtype;
int *macroblock_type;
{
  int comp;
  
  /* SCALABILITY: Data Paritioning */
  if (base.scalable_mode==SC_DP)
    ld = &base;

  for (comp=0; comp<block_count; comp++)
    Thrd_Clear_Block(t,comp);

  /* reset intra_dc predictors */
  /* ISO/IEC 13818-2 section 7.2.1: DC coefficients in intra blocks */
  dc_dct_pred[0]=dc_dct_pred[1]=dc_dct_pred[2]=0;

  /* reset motion vector predictors */
  /* ISO/IEC 13818-2 section 7.6.3.4: Resetting motion vector predictors */
  if (picture_coding_type==P_TYPE)
    PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;

  /* derive motion_type */
  if (picture_structure==FRAME_PICTURE)
    *motion_type = MC_FRAME;
  else
  {
    *motion_type = MC_FIELD;

    /* predict from field of same parity */
    /* ISO/IEC 13818-2 section 7.6.6.1 and 7.6.6.3: P field picture and B field
       picture */
    motion_vertical_field_select[0][0]=motion_vertical_field_select[0][1] = 
      (picture_structure==BOTTOM_FIELD);
  }

  /* skipped I are spatial-only predicted, */
  /* skipped P and B are temporal-only predicted */
  /* ISO/IEC 13818-2 section 7.7.6: Skipped macroblocks */
  *stwtype = (picture_coding_type==I_TYPE) ? 8 : 0;

 /* IMPLEMENTATION: clear MACROBLOCK_INTRA */
  *macroblock_type&= ~MACROBLOCK_INTRA;

}

static void Thrd_motion_compensation(t, MBA, macroblock_type, motion_type, PMV, 
  motion_vertical_field_select, dmvector, stwtype, dct_type)
int t;
int MBA;
int macroblock_type;
int motion_type;
int PMV[2][2][2];
int motion_vertical_field_select[2][2];
int dmvector[2];
int stwtype;
int dct_type;
{
  int bx, by;
  int comp;


  /* derive current macroblock position within picture */
  /* ISO/IEC 13818-2 section 6.3.1.6 and 6.3.1.7 */
  bx = 16*(MBA%mb_width);
  by = 16*(MBA/mb_width);

  /* motion compensation */
  if (!(macroblock_type & MACROBLOCK_INTRA))
    form_predictions(bx,by,macroblock_type,motion_type,PMV,
      motion_vertical_field_select,dmvector,stwtype);
  
  /* SCALABILITY: Data Partitioning */
  if (base.scalable_mode==SC_DP)
    ld = &base;

  /* copy or add block data into picture */
  for (comp=0; comp<block_count; comp++)
  {
    /* SCALABILITY: SNR */
    /* ISO/IEC 13818-2 section 7.8.3.4: Addition of coefficients from 
       the two a layers */
    if (Two_Streams && enhan.scalable_mode==SC_SNR) {
      printf("two streams and sc_snr not supported, exiting...\n"); exit(-1);
      Sum_Block(comp); /* add SNR enhancement layer data to base layer */
    }

    /* MPEG-2 saturation and mismatch control */
    /* base layer could be MPEG-1 stream, enhancement MPEG-2 SNR */
    /* ISO/IEC 13818-2 section 7.4.3 and 7.4.4: Saturation and Mismatch control */
    if ((Two_Streams && enhan.scalable_mode==SC_SNR) || ld->MPEG2_Flag)
      Saturate(thrd_ld[t].block[comp]);

    /* ISO/IEC 13818-2 section Annex A: inverse DCT */
    if (Reference_IDCT_Flag)
      Reference_IDCT(thrd_ld[t].block[comp]);
    else
      Fast_IDCT(thrd_ld[t].block[comp]);
    
    /* ISO/IEC 13818-2 section 7.6.8: Adding prediction and coefficient data */
    Thrd_Add_Block(t,comp,bx,by,dct_type,(macroblock_type & MACROBLOCK_INTRA)==0);
  }

}

static void Thrd_macroblock_modes(t, pmacroblock_type,pstwtype,pstwclass,
  pmotion_type,pmotion_vector_count,pmv_format,pdmv,pmvscale,pdct_type)
     int t;
  int *pmacroblock_type, *pstwtype, *pstwclass;
  int *pmotion_type, *pmotion_vector_count, *pmv_format, *pdmv, *pmvscale;
  int *pdct_type;
{
  int macroblock_type;
  int stwtype, stwcode, stwclass;
  int motion_type = 0;
  int motion_vector_count, mv_format, dmv, mvscale;
  int dct_type;
  static unsigned char stwc_table[3][4]
    = { {6,3,7,4}, {2,1,5,4}, {2,5,7,4} };
  static unsigned char stwclass_table[9]
    = {0, 1, 2, 1, 1, 2, 3, 3, 4};

  /* get macroblock_type */
  macroblock_type = Thrd_Get_macroblock_type(t);

  if (Fault_Flag) return;

  /* get spatial_temporal_weight_code */
  if (macroblock_type & MB_WEIGHT)
  {
    if (spatial_temporal_weight_code_table_index==0)
      stwtype = 4;
    else
    {
      stwcode = Thrd_Get_Bits(t,2);
      stwtype = stwc_table[spatial_temporal_weight_code_table_index-1][stwcode];
    }
  }
  else
    stwtype = (macroblock_type & MB_CLASS4) ? 8 : 0;

  /* SCALABILITY: derive spatial_temporal_weight_class (Table 7-18) */
  stwclass = stwclass_table[stwtype];

  /* get frame/field motion type */
  if (macroblock_type & (MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD))
  {
    if (picture_structure==FRAME_PICTURE) /* frame_motion_type */
    {
      motion_type = frame_pred_frame_dct ? MC_FRAME : Thrd_Get_Bits(t,2);
    }
    else /* field_motion_type */
      {
	motion_type = Thrd_Get_Bits(t,2);
      }
  }
  else if ((macroblock_type & MACROBLOCK_INTRA) && concealment_motion_vectors)
  {
    /* concealment motion vectors */
    motion_type = (picture_structure==FRAME_PICTURE) ? MC_FRAME : MC_FIELD;
  }

  /* derive motion_vector_count, mv_format and dmv, (table 6-17, 6-18) */
  if (picture_structure==FRAME_PICTURE)
  {
    motion_vector_count = (motion_type==MC_FIELD && stwclass<2) ? 2 : 1;
    mv_format = (motion_type==MC_FRAME) ? MV_FRAME : MV_FIELD;
  }
  else
  {
    motion_vector_count = (motion_type==MC_16X8) ? 2 : 1;
    mv_format = MV_FIELD;
  }

  dmv = (motion_type==MC_DMV); /* dual prime */

  /* field mv predictions in frame pictures have to be scaled
   * ISO/IEC 13818-2 section 7.6.3.1 Decoding the motion vectors
   * IMPLEMENTATION: mvscale is derived for later use in motion_vectors()
   * it displaces the stage:
   *
   *    if((mv_format=="field")&&(t==1)&&(picture_structure=="Frame picture"))
   *      prediction = PMV[r][s][t] DIV 2;
   */

  mvscale = ((mv_format==MV_FIELD) && (picture_structure==FRAME_PICTURE));

  /* get dct_type (frame DCT / field DCT) */
  dct_type = (picture_structure==FRAME_PICTURE)
             && (!frame_pred_frame_dct)
             && (macroblock_type & (MACROBLOCK_PATTERN|MACROBLOCK_INTRA))
             ? Thrd_Get_Bits(t,1)
             : 0;

  /* return values */
  *pmacroblock_type = macroblock_type;
  *pstwtype = stwtype;
  *pstwclass = stwclass;
  *pmotion_type = motion_type;
  *pmotion_vector_count = motion_vector_count;
  *pmv_format = mv_format;
  *pdmv = dmv;
  *pmvscale = mvscale;
  *pdct_type = dct_type;
}

static void Thrd_Clear_Block(t,comp)
int t;
int comp;
{
  short *Block_Ptr;
  int i, j;
  
  Block_Ptr = thrd_ld[t].block[comp];

#ifdef SSE2
  __asm{
    mov     edx, [Block_Ptr]  ; /* load addr into edx */
    mov     ecx, 8            ; /* loop 8 times */
    pxor    xmm0, xmm0        ; /* reset xmm0 to zero */
    
  cb_loop:
    movdqu  [edx], xmm0       ;
    add     edx, 16           ;
    loop    cb_loop           ;
  }
  
#else
  for (i=0; i<64;i+=8 ) {

    Block_Ptr[i] = 0;
    Block_Ptr[i+1] = 0;
    Block_Ptr[i+2] = 0;
    Block_Ptr[i+3] = 0;

    Block_Ptr[i+4] = 0;
    Block_Ptr[i+5] = 0;
    Block_Ptr[i+6] = 0;
    Block_Ptr[i+7] = 0;

  }
#endif
    
}

static void Thrd_Add_Block(t,comp,bx,by,dct_type,addflag)
int t, comp,bx,by,dct_type,addflag;
{
  int cc,i, j, iincr;
  unsigned char *rfp;
  short *bptr, tmp;

  /* derive color component index */
  /* equivalent to ISO/IEC 13818-2 Table 7-1 */
  cc = (comp<4) ? 0 : (comp&1)+1; /* color component index */

  if (cc==0)
  {
    /* luminance */

    if (picture_structure==FRAME_PICTURE)
      if (dct_type)
      {
        /* field DCT coding */
        rfp = current_frame[0]
              + Coded_Picture_Width*(by+((comp&2)>>1)) + bx + ((comp&1)<<3);
        iincr = (Coded_Picture_Width<<1) - 8;
      }
      else
      {
        /* frame DCT coding */
        rfp = current_frame[0]
              + Coded_Picture_Width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
        iincr = Coded_Picture_Width - 8;
      }
    else
    {
      /* field picture */
      rfp = current_frame[0]
            + (Coded_Picture_Width<<1)*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
      iincr = (Coded_Picture_Width<<1) - 8;
    }
  }
  else
  {
    /* chrominance */

    /* scale coordinates */
    if (chroma_format!=CHROMA444)
      bx >>= 1;
    if (chroma_format==CHROMA420)
      by >>= 1;
    if (picture_structure==FRAME_PICTURE)
    {
      if (dct_type && (chroma_format!=CHROMA420))
      {
        /* field DCT coding */
        rfp = current_frame[cc]
              + Chroma_Width*(by+((comp&2)>>1)) + bx + (comp&8);
        iincr = (Chroma_Width<<1) - 8;
      }
      else
      {
        /* frame DCT coding */
        rfp = current_frame[cc]
              + Chroma_Width*(by+((comp&2)<<2)) + bx + (comp&8);
        iincr = Chroma_Width - 8;
      }
    }
    else
    {
      /* field picture */
      rfp = current_frame[cc]
            + (Chroma_Width<<1)*(by+((comp&2)<<2)) + bx + (comp&8);
      iincr = (Chroma_Width<<1) - 8;
    }
  }

  bptr = thrd_ld[t].block[comp];

  if (addflag)
  {

#ifdef SSE2
#if (ADD_BLK_TEST_CODE)
    short *bp = bptr;
    unsigned char * ref = rfp;
    unsigned char blk[64];

    for (i=0; i<8; i++)
      {
      for (j=0; j<8; j++)
        {
	  tmp = *bp++ + *ref;
	  tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	  blk[8*i+j] = tmp;
	  ref++;
	}
      ref+= iincr;
      }
#endif
    /* bptr has shorts, rfp has chars */
    __asm {
      mov ebx, [bptr]     ; /* load blk ptr */
      mov eax, [rfp]    ; /* load ref frame ptr*/
      mov edx, [iincr]  ;
      pxor xmm1, xmm1   ;
      mov ecx, 4        ; /* unrolled twice */
      add edx, 8        ;
      mov esi, edx      ;
      sal esi, 1        ;
      
    add_blk_loop1:
      movq      xmm0,[eax]        ; /* load 8B from rfp */
      movq      xmm3,[eax+edx]    ; /* load 8B from rfp+iincr+8 */
      movdqu    xmm2, [ebx]       ; /* load 8W from bptr */
      movdqu    xmm4, [ebx+16]     ; /* load 8W from bptr+8*/
      punpcklbw xmm0, xmm1        ; /* unpack to 8W */
      punpcklbw xmm3, xmm1        ; /* unpack to 8W */

      paddsw    xmm0, xmm2        ; /* *bptr + *rfp */
      paddsw    xmm3, xmm4        ; /* ditto + 8 */
      packuswb  xmm0, xmm1        ;
      packuswb  xmm3, xmm1        ;
      movq      [eax], xmm0       ;
      movq      [eax+edx], xmm3   ;
      add       ebx, 32           ;
      add       eax, esi          ;
      loop add_blk_loop1  
    }      
#if (ADD_BLK_TEST_CODE)
    for (i=0; i<8; i++)
      {
	for (j=0; j<8; j++)
	  {
	    if (rfp[0] != blk[8*i+j])
	      printf("%d bad %d good %d\n",8*i+j,rfp[0],blk[8*i+j]);
	    rfp++;  
	  }
	rfp+=iincr;
      }
#endif
#else
    for (i=0; i<4; i++)
    {

      for (j=0; j<8; j++)
      {

	tmp = *bptr + *rfp;
	tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	*rfp = tmp;
	bptr++;
        /* *rfp = Clip[*bptr++ + *rfp];*/
        rfp++;

      }
      
      rfp+= iincr;

      for (j=0; j<8; j++)
      {

	tmp = *bptr + *rfp;
	tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	*rfp = tmp;
	bptr++;
        /* *rfp = Clip[*bptr++ + *rfp];*/
        rfp++;

      }
      
      rfp+= iincr;


    }
#endif
    /* original code */
    /*
    for (i=0; i<8; i++)
      {
      for (j=0; j<8; j++)
        {
	*rfp = Clip[*bptr++ + *rfp];
	rfp++;
	}
      rfp+= iincr;
      }
    */
  }
  else
  {

#ifdef SSE2
    const short immed[8] = {128, 128, 128, 128,
			    128, 128, 128, 128};

#if (ADD_BLK_TEST_CODE)
    short *bp = bptr;
    unsigned char * ref = rfp;
    unsigned char blk[64];

    for (i=0; i<8; i++)
      {
      for (j=0; j<8; j++)
        {
	  tmp = *bp++ + 128;
	  tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	  blk[8*i+j] = tmp;
	}
      }
#endif
    /* bptr has shorts, rfp has chars */
    __asm {
      mov ebx, [bptr]     ; /* load blk ptr */
      mov eax, [rfp]    ; /* load ref frame ptr*/
      mov edx, [iincr]  ;
      movdqu xmm0, [immed] ;
      pxor xmm1, xmm1   ;
      mov ecx, 4        ; /* unrolled twice */
      add edx, 8        ;
      mov esi, edx      ;
      sal esi, 1        ;
      
    add_blk_loop2:
      movdqu    xmm2, [ebx]       ; /* load 8W from bptr */
      movdqu    xmm4, [ebx+16]     ; /* load 8W from bptr+8*/

      paddsw    xmm2, xmm0        ; /* *bptr + *rfp */
      paddsw    xmm4, xmm0        ; /* ditto + 8 */
      packuswb  xmm2, xmm1        ;
      packuswb  xmm4, xmm1        ;
      movq      [eax], xmm2       ;
      movq      [eax+edx], xmm4   ;
      add       ebx, 32           ;
      add       eax, esi          ;
      loop add_blk_loop2  
    }      
#if (ADD_BLK_TEST_CODE)
    for (i=0; i<8; i++)
      {
	for (j=0; j<8; j++)
	  {
	    if (rfp[0] != blk[8*i+j])
	      printf("%d bad %d good %d\n",8*i+j,rfp[0],blk[8*i+j]);
	    rfp++;  
	  }
	rfp+=iincr;
      }
#endif
#else
    for (i=0; i<4; i++)
    {

      for (j=0; j<8; j++) {

	tmp = *bptr + 128;
	tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	*rfp = tmp;
	rfp++; bptr++;
      }
      rfp+= iincr;

      for (j=0; j<8; j++) {

	tmp = *bptr + 128;
	tmp = (tmp<0) ? 0 : (tmp > 255) ? 255 : tmp;
	*rfp = tmp;
	rfp++; bptr++;
      }

      rfp+= iincr;

    }
#endif
    /*original code */
    /*
      for (i=0; i<8; i++)
    {
      for (j=0; j<8; j++)
        *rfp++ = Clip[*bptr++ + 128];

      rfp+= iincr;
    }
    */
  }

}


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* getvlc.c, variable length decoding                                       */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "global.h"
#include "getvlc.h"

/* private prototypes */
/* generic picture macroblock type processing functions */
static int Get_I_macroblock_type _ANSI_ARGS_((void));
static int Get_P_macroblock_type _ANSI_ARGS_((void));
static int Get_B_macroblock_type _ANSI_ARGS_((void));
static int Get_D_macroblock_type _ANSI_ARGS_((void));

/* spatial picture macroblock type processing functions */
static int Get_I_Spatial_macroblock_type _ANSI_ARGS_((void));
static int Get_P_Spatial_macroblock_type _ANSI_ARGS_((void));
static int Get_B_Spatial_macroblock_type _ANSI_ARGS_((void));
static int Get_SNR_macroblock_type _ANSI_ARGS_((void));

#ifdef THRD
static int Thrd_Get_I_macroblock_type _ANSI_ARGS_((int t));
static int Thrd_Get_P_macroblock_type _ANSI_ARGS_((int t));
static int Thrd_Get_B_macroblock_type _ANSI_ARGS_((int t));
static int Thrd_Get_D_macroblock_type _ANSI_ARGS_((int t));
#endif

int Get_macroblock_type()
{
  int macroblock_type = 0;

  if (ld->scalable_mode==SC_SNR)
    macroblock_type = Get_SNR_macroblock_type();
  else
  {
    switch (picture_coding_type)
    {
    case I_TYPE:
      macroblock_type = ld->pict_scal ? Get_I_Spatial_macroblock_type() : Get_I_macroblock_type();
      break;
    case P_TYPE:
      macroblock_type = ld->pict_scal ? Get_P_Spatial_macroblock_type() : Get_P_macroblock_type();
      break;
    case B_TYPE:
      macroblock_type = ld->pict_scal ? Get_B_Spatial_macroblock_type() : Get_B_macroblock_type();
      break;
    case D_TYPE:
      macroblock_type = Get_D_macroblock_type();
      break;
    default:
      printf("Get_macroblock_type(): unrecognized picture coding type\n");
      break;
    }
  }

  return macroblock_type;
}

static int Get_I_macroblock_type()
{
#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(I) ");
#endif /* TRACE */

  if (Get_Bits1())
  {
#ifdef TRACE
    if (Trace_Flag)
      printf("(1): Intra (1)\n");
#endif /* TRACE */
    return 1;
  }

  if (!Get_Bits1())
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
  }

#ifdef TRACE
  if (Trace_Flag)
    printf("(01): Intra, Quant (17)\n");
#endif /* TRACE */

  return 17;
}

#ifdef TRACE
static char *MBdescr[]={
  "",                  "Intra",        "No MC, Coded",         "",
  "Bwd, Not Coded",    "",             "Bwd, Coded",           "",
  "Fwd, Not Coded",    "",             "Fwd, Coded",           "",
  "Interp, Not Coded", "",             "Interp, Coded",        "",
  "",                  "Intra, Quant", "No MC, Coded, Quant",  "",
  "",                  "",             "Bwd, Coded, Quant",    "",
  "",                  "",             "Fwd, Coded, Quant",    "",
  "",                  "",             "Interp, Coded, Quant", ""
};
#endif /* TRACE */

static int Get_P_macroblock_type()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(P) (");
#endif /* TRACE */

  if ((code = Show_Bits(6))>=8)
  {
    code >>= 3;
    Flush_Buffer(PMBtab0[code].len);
#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,3,PMBtab0[code].len);
      printf("): %s (%d)\n",MBdescr[(int)PMBtab0[code].val],PMBtab0[code].val);
    }
#endif /* TRACE */
    return PMBtab0[code].val;
  }

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Flush_Buffer(PMBtab1[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,6,PMBtab1[code].len);
    printf("): %s (%d)\n",MBdescr[(int)PMBtab1[code].val],PMBtab1[code].val);
  }
#endif /* TRACE */

  return PMBtab1[code].val;
}

static int Get_B_macroblock_type()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(B) (");
#endif /* TRACE */

  if ((code = Show_Bits(6))>=8)
  {
    code >>= 2;
    Flush_Buffer(BMBtab0[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,4,BMBtab0[code].len);
      printf("): %s (%d)\n",MBdescr[(int)BMBtab0[code].val],BMBtab0[code].val);
    }
#endif /* TRACE */

    return BMBtab0[code].val;
  }

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Flush_Buffer(BMBtab1[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,6,BMBtab1[code].len);
    printf("): %s (%d)\n",MBdescr[(int)BMBtab1[code].val],BMBtab1[code].val);
  }
#endif /* TRACE */

  return BMBtab1[code].val;
}

static int Get_D_macroblock_type()
{
  if (!Get_Bits1())
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag=1;
  }

  return 1;
}

/* macroblock_type for pictures with spatial scalability */
static int Get_I_Spatial_macroblock_type()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(I,spat) (");
#endif /* TRACE */

  code = Show_Bits(4);

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,4,spIMBtab[code].len);
    printf("): %02x\n",spIMBtab[code].val);
  }
#endif /* TRACE */

  Flush_Buffer(spIMBtab[code].len);
  return spIMBtab[code].val;
}

static int Get_P_Spatial_macroblock_type()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(P,spat) (");
#endif /* TRACE */

  code = Show_Bits(7);

  if (code<2)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  if (code>=16)
  {
    code >>= 3;
    Flush_Buffer(spPMBtab0[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,4,spPMBtab0[code].len);
      printf("): %02x\n",spPMBtab0[code].val);
    }
#endif /* TRACE */

    return spPMBtab0[code].val;
  }

  Flush_Buffer(spPMBtab1[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,7,spPMBtab1[code].len);
    printf("): %02x\n",spPMBtab1[code].val);
  }
#endif /* TRACE */

  return spPMBtab1[code].val;
}

static int Get_B_Spatial_macroblock_type()
{
  int code;
  VLCtab *p;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_type(B,spat) (");
#endif /* TRACE */

  code = Show_Bits(9);

  if (code>=64)
    p = &spBMBtab0[(code>>5)-2];
  else if (code>=16)
    p = &spBMBtab1[(code>>2)-4];
  else if (code>=8)
    p = &spBMBtab2[code-8];
  else
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Flush_Buffer(p->len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,9,p->len);
    printf("): %02x\n",p->val);
  }
#endif /* TRACE */

  return p->val;
}

static int Get_SNR_macroblock_type()
{
  int code;

#ifdef TRACE                 /* *CH* */
  if (Trace_Flag)
    printf("macroblock_type(SNR) (");
#endif /*TRACE*/

  code = Show_Bits(3);

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Flush_Buffer(SNRMBtab[code].len);

#ifdef TRACE			/* *CH* */
  if (Trace_Flag)
  {
    Print_Bits(code,3,SNRMBtab[code].len);
    printf("): %s (%d)\n",MBdescr[(int)SNRMBtab[code].val],SNRMBtab[code].val);
  }
#endif /*TRACE*/


  return SNRMBtab[code].val;
}

int Get_motion_code()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("motion_code (");
#endif /* TRACE */

  if (Get_Bits1())
  {
#ifdef TRACE
    if (Trace_Flag)
      printf("0): 0\n");
#endif /* TRACE */
    return 0;
  }

  if ((code = Show_Bits(9))>=64)
  {
    code >>= 6;
    Flush_Buffer(MVtab0[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,3,MVtab0[code].len);
      printf("%d): %d\n",
        Show_Bits(1),Show_Bits(1)?-MVtab0[code].val:MVtab0[code].val);
    }
#endif /* TRACE */

    return Get_Bits1()?-MVtab0[code].val:MVtab0[code].val;
  }

  if (code>=24)
  {
    code >>= 3;
    Flush_Buffer(MVtab1[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,6,MVtab1[code].len);
      printf("%d): %d\n",
        Show_Bits(1),Show_Bits(1)?-MVtab1[code].val:MVtab1[code].val);
    }
#endif /* TRACE */

    return Get_Bits1()?-MVtab1[code].val:MVtab1[code].val;
  }

  if ((code-=12)<0)
  {
    if (!Quiet_Flag)
/* HACK */
      printf("Invalid motion_vector code (MBA %d, pic %d)\n", global_MBA, global_pic);
    Fault_Flag=1;
    return 0;
  }

  Flush_Buffer(MVtab2[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code+12,9,MVtab2[code].len);
    printf("%d): %d\n",
      Show_Bits(1),Show_Bits(1)?-MVtab2[code].val:MVtab2[code].val);
  }
#endif /* TRACE */

  return Get_Bits1() ? -MVtab2[code].val : MVtab2[code].val;
}

/* get differential motion vector (for dual prime prediction) */
int Get_dmvector()
{
#ifdef TRACE
  if (Trace_Flag)
    printf("dmvector (");
#endif /* TRACE */

  if (Get_Bits(1))
  {
#ifdef TRACE
    if (Trace_Flag)
      printf(Show_Bits(1) ? "11): -1\n" : "10): 1\n");
#endif /* TRACE */
    return Get_Bits(1) ? -1 : 1;
  }
  else
  {
#ifdef TRACE
    if (Trace_Flag)
      printf("0): 0\n");
#endif /* TRACE */
    return 0;
  }
}

int Get_coded_block_pattern()
{
  int code;

#ifdef TRACE
  if (Trace_Flag)
    printf("coded_block_pattern_420 (");
#endif /* TRACE */

  if ((code = Show_Bits(9))>=128)
  {
    code >>= 4;
    Flush_Buffer(CBPtab0[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,5,CBPtab0[code].len);
      printf("): ");
      Print_Bits(CBPtab0[code].val,6,6);
      printf(" (%d)\n",CBPtab0[code].val);
    }
#endif /* TRACE */

    return CBPtab0[code].val;
  }

  if (code>=8)
  {
    code >>= 1;
    Flush_Buffer(CBPtab1[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,8,CBPtab1[code].len);
      printf("): ");
      Print_Bits(CBPtab1[code].val,6,6);
      printf(" (%d)\n",CBPtab1[code].val);
    }
#endif /* TRACE */

    return CBPtab1[code].val;
  }

  if (code<1)
  {
    if (!Quiet_Flag)
      printf("Invalid coded_block_pattern code\n");
    Fault_Flag = 1;
    return 0;
  }

  Flush_Buffer(CBPtab2[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code,9,CBPtab2[code].len);
    printf("): ");
    Print_Bits(CBPtab2[code].val,6,6);
    printf(" (%d)\n",CBPtab2[code].val);
  }
#endif /* TRACE */

  return CBPtab2[code].val;
}


int Get_macroblock_address_increment()
{
  int code, val;

#ifdef TRACE
  if (Trace_Flag)
    printf("macroblock_address_increment (");
#endif /* TRACE */

  val = 0;

  while ((code = Show_Bits(11))<24)
  {
    if (code!=15) /* if not macroblock_stuffing */
    {
      if (code==8) /* if macroblock_escape */
      {
#ifdef TRACE
        if (Trace_Flag)
          printf("00000001000 ");
#endif /* TRACE */

        val+= 33;
      }
      else
      {
        if (!Quiet_Flag)
          printf("Invalid macroblock_address_increment code\n");

        Fault_Flag = 1;
        return 1;
      }
    }
    else /* macroblock suffing */
    {
#ifdef TRACE
      if (Trace_Flag)
        printf("00000001111 ");
#endif /* TRACE */
    }

    Flush_Buffer(11);
  }

  /* macroblock_address_increment == 1 */
  /* ('1' is in the MSB position of the lookahead) */
  if (code>=1024)
  {
    Flush_Buffer(1);
#ifdef TRACE
    if (Trace_Flag)
      printf("1): %d\n",val+1);
#endif /* TRACE */
    return val + 1;
  }

  /* codes 00010 ... 011xx */
  if (code>=128)
  {
    /* remove leading zeros */
    code >>= 6;
    Flush_Buffer(MBAtab1[code].len);

#ifdef TRACE
    if (Trace_Flag)
    {
      Print_Bits(code,5,MBAtab1[code].len);
      printf("): %d\n",val+MBAtab1[code].val);
    }
#endif /* TRACE */

    
    return val + MBAtab1[code].val;
  }
  
  /* codes 00000011000 ... 0000111xxxx */
  code-= 24; /* remove common base */
  Flush_Buffer(MBAtab2[code].len);

#ifdef TRACE
  if (Trace_Flag)
  {
    Print_Bits(code+24,11,MBAtab2[code].len);
    printf("): %d\n",val+MBAtab2[code].val);
  }
#endif /* TRACE */

  return val + MBAtab2[code].val;
}

/* combined MPEG-1 and MPEG-2 stage. parse VLC and 
   perform dct_diff arithmetic.

   MPEG-1:  ISO/IEC 11172-2 section
   MPEG-2:  ISO/IEC 13818-2 section 7.2.1 
   
   Note: the arithmetic here is presented more elegantly than
   the spec, yet the results, dct_diff, are the same.
*/

int Get_Luma_DC_dct_diff()
{
  int code, size, dct_diff;

#ifdef TRACE
/*
  if (Trace_Flag)
    printf("dct_dc_size_luminance: (");
*/
#endif /* TRACE */

  /* decode length */
  code = Show_Bits(5);

  if (code<31)
  {
    size = DClumtab0[code].val;
    Flush_Buffer(DClumtab0[code].len);
#ifdef TRACE
/*
    if (Trace_Flag)
    {
      Print_Bits(code,5,DClumtab0[code].len);
      printf("): %d",size);
    }
*/
#endif /* TRACE */
  }
  else
  {
    code = Show_Bits(9) - 0x1f0;
    size = DClumtab1[code].val;
    Flush_Buffer(DClumtab1[code].len);

#ifdef TRACE
/*
    if (Trace_Flag)
    {
      Print_Bits(code+0x1f0,9,DClumtab1[code].len);
      printf("): %d",size);
    }
*/
#endif /* TRACE */
  }

#ifdef TRACE
/*
  if (Trace_Flag)
    printf(", dct_dc_differential (");
*/
#endif /* TRACE */

  if (size==0)
    dct_diff = 0;
  else
  {
    dct_diff = Get_Bits(size);
#ifdef TRACE
/*
    if (Trace_Flag)
      Print_Bits(dct_diff,size,size);
*/
#endif /* TRACE */
    if ((dct_diff & (1<<(size-1)))==0)
      dct_diff-= (1<<size) - 1;
  }

#ifdef TRACE
/*
  if (Trace_Flag)
    printf("): %d\n",dct_diff);
*/
#endif /* TRACE */

  return dct_diff;
}


int Get_Chroma_DC_dct_diff()
{
  int code, size, dct_diff;

#ifdef TRACE
/*
  if (Trace_Flag)
    printf("dct_dc_size_chrominance: (");
*/
#endif /* TRACE */

  /* decode length */
  code = Show_Bits(5);

  if (code<31)
  {
    size = DCchromtab0[code].val;
    Flush_Buffer(DCchromtab0[code].len);

#ifdef TRACE
/*
    if (Trace_Flag)
    {
      Print_Bits(code,5,DCchromtab0[code].len);
      printf("): %d",size);
    }
*/
#endif /* TRACE */
  }
  else
  {
    code = Show_Bits(10) - 0x3e0;
    size = DCchromtab1[code].val;
    Flush_Buffer(DCchromtab1[code].len);

#ifdef TRACE
/*
    if (Trace_Flag)
    {
      Print_Bits(code+0x3e0,10,DCchromtab1[code].len);
      printf("): %d",size);
    }
*/
#endif /* TRACE */
  }

#ifdef TRACE
/* 
  if (Trace_Flag)
    printf(", dct_dc_differential (");
*/
#endif /* TRACE */

  if (size==0)
    dct_diff = 0;
  else
  {
    dct_diff = Get_Bits(size);
#ifdef TRACE
/*
    if (Trace_Flag)
      Print_Bits(dct_diff,size,size);
*/
#endif /* TRACE */
    if ((dct_diff & (1<<(size-1)))==0)
      dct_diff-= (1<<size) - 1;
  }

#ifdef TRACE
/*
  if (Trace_Flag)
    printf("): %d\n",dct_diff);
*/
#endif /* TRACE */

  return dct_diff;
}

#ifdef THRD

int Thrd_Get_macroblock_type(t)
     int t;
{
  int macroblock_type = 0;

  if (ld->scalable_mode==SC_SNR || ld->pict_scal!=0) {
    printf("not supported macroblock type");
    exit(-1);
  }
  switch (picture_coding_type)
    {
    case I_TYPE:
      macroblock_type = Thrd_Get_I_macroblock_type(t);
      break;
    case P_TYPE:
      macroblock_type = Thrd_Get_P_macroblock_type(t);
      break;
    case B_TYPE:
      macroblock_type = Thrd_Get_B_macroblock_type(t);
      break;
    case D_TYPE:
      macroblock_type = Thrd_Get_D_macroblock_type(t);
      break;
    default:
      printf("Get_macroblock_type(): unrecognized picture coding type\n");
      break;
    }

  return macroblock_type;
}

static int Thrd_Get_I_macroblock_type(t)
int t;
{
  if (Thrd_Get_Bits1(t))
  {
    return 1;
  }

  if (!Thrd_Get_Bits1(t))
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
  }

  return 17;
}

static int Thrd_Get_P_macroblock_type(t)
int t;
{
  int code;

  if ((code = Thrd_Show_Bits(t,6))>=8)
  {
    code >>= 3;
    Thrd_Flush_Buffer(t, PMBtab0[code].len);

    return PMBtab0[code].val;
  }

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Thrd_Flush_Buffer(t,PMBtab1[code].len);

  return PMBtab1[code].val;
}

static int Thrd_Get_B_macroblock_type(t)
     int t;
{
  int code;

  if ((code = Thrd_Show_Bits(t,6))>=8)
  {
    code >>= 2;
    Thrd_Flush_Buffer(t, BMBtab0[code].len);

    return BMBtab0[code].val;
  }

  if (code==0)
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag = 1;
    return 0;
  }

  Thrd_Flush_Buffer(t, BMBtab1[code].len);

  return BMBtab1[code].val;
}

static int Thrd_Get_D_macroblock_type(t)
int t;
{
  if (!Thrd_Get_Bits1(t))
  {
    if (!Quiet_Flag)
      printf("Invalid macroblock_type code\n");
    Fault_Flag=1;
  }

  return 1;
}


int Thrd_Get_macroblock_address_increment(t)
int t;
{
  int code, val;

  val = 0;

  while ((code = Thrd_Show_Bits(t,11))<24)
  {
    if (code!=15) /* if not macroblock_stuffing */
    {
      if (code==8) /* if macroblock_escape */
      {
        val+= 33;
      }
      else
      {
        if (!Quiet_Flag)
          printf("Invalid macroblock_address_increment code\n");

        Fault_Flag = 1;
        return 1;
      }
    }

    Thrd_Flush_Buffer(t, 11);
  }

  /* macroblock_address_increment == 1 */
  /* ('1' is in the MSB position of the lookahead) */
  if (code>=1024)
  {
    Thrd_Flush_Buffer(t,1);
    return val + 1;
  }
  
  /* codes 00010 ... 011xx */
  if (code>=128)
    {
      /* remove leading zeros */
      code >>= 6;
      Thrd_Flush_Buffer(t, MBAtab1[code].len);
      
      return val + MBAtab1[code].val;
    }
  
  /* codes 00000011000 ... 0000111xxxx */
  code-= 24; /* remove common base */
  Thrd_Flush_Buffer(t, MBAtab2[code].len);
  
  return val + MBAtab2[code].val;
}

int Thrd_Get_motion_code(t)
int t;
{
  int code;

  if (Thrd_Get_Bits1(t))
  {
    return 0;
  }

  if ((code = Thrd_Show_Bits(t,9))>=64)
  {
    code >>= 6;
    Thrd_Flush_Buffer(t,MVtab0[code].len);

    return Thrd_Get_Bits1(t)?-MVtab0[code].val:MVtab0[code].val;
  }

  if (code>=24)
  {
    code >>= 3;
    Thrd_Flush_Buffer(t,MVtab1[code].len);

    return Thrd_Get_Bits1(t)?-MVtab1[code].val:MVtab1[code].val;
  }

  if ((code-=12)<0)
  {
    if (!Quiet_Flag)
/* HACK */
      printf("Invalid motion_vector code (MBA %d, pic %d)\n", global_MBA, global_pic);
    Fault_Flag=1;
    return 0;
  }

  Thrd_Flush_Buffer(t,MVtab2[code].len);

  return Thrd_Get_Bits1(t) ? -MVtab2[code].val : MVtab2[code].val;
}

/* get differential motion vector (for dual prime prediction) */
int Thrd_Get_dmvector(t)
int t;
{
  if (Thrd_Get_Bits(t,1))
  {
    return Thrd_Get_Bits(t,1) ? -1 : 1;
  }
  else
  {
    return 0;
  }
}

int Thrd_Get_coded_block_pattern(t)
int t;
{
  int code;

  if ((code = Thrd_Show_Bits(t,9))>=128)
  {
    code >>= 4;
    Thrd_Flush_Buffer(t,CBPtab0[code].len);

    return CBPtab0[code].val;
  }

  if (code>=8)
  {
    code >>= 1;
    Thrd_Flush_Buffer(t,CBPtab1[code].len);

    return CBPtab1[code].val;
  }

  if (code<1)
  {
    if (!Quiet_Flag)
      printf("Invalid coded_block_pattern code\n");
    Fault_Flag = 1;
    return 0;
  }

  Thrd_Flush_Buffer(t,CBPtab2[code].len);

  return CBPtab2[code].val;
}

int Thrd_Get_Luma_DC_dct_diff(t)
int t;
{
  int code, size, dct_diff;

  /* decode length */
  code = Thrd_Show_Bits(t, 5);

  if (code<31)
  {
    size = DClumtab0[code].val;
    Thrd_Flush_Buffer(t, DClumtab0[code].len);
  }
  else
  {
    code = Thrd_Show_Bits(t,9) - 0x1f0;
    size = DClumtab1[code].val;
    Thrd_Flush_Buffer(t, DClumtab1[code].len);
  }

  if (size==0)
    dct_diff = 0;
  else
  {
    dct_diff = Thrd_Get_Bits(t,size);

    if ((dct_diff & (1<<(size-1)))==0)
      dct_diff-= (1<<size) - 1;
  }

  return dct_diff;
}


int Thrd_Get_Chroma_DC_dct_diff(t)
int t;
{
  int code, size, dct_diff;

  /* decode length */
  code = Thrd_Show_Bits(t,5);

  if (code<31)
  {
    size = DCchromtab0[code].val;
    Thrd_Flush_Buffer(t, DCchromtab0[code].len);
  }
  else
  {
    code = Thrd_Show_Bits(t,10) - 0x3e0;
    size = DCchromtab1[code].val;
    Thrd_Flush_Buffer(t,DCchromtab1[code].len);
  }

  if (size==0)
    dct_diff = 0;
  else
  {
    dct_diff = Thrd_Get_Bits(t,size);

    if ((dct_diff & (1<<(size-1)))==0)
      dct_diff-= (1<<size) - 1;
  }

  return dct_diff;
}
#endif /* END OF ifdef THRD */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* getvlc.h, variable length code tables                                    */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/* NOTE: #define constants such as MACROBLOCK_QUANT are upper case 
   as per C programming convention. However, the MPEG document 
   (ISO/IEC 13818-2) lists them in all lower case (e.g. Annex B) */

/* NOTE: the VLC tables are in a flash format---a transformation
   of the tables in Annex B to a form more convenient towards 
   parallel (more than one-bit-at-a-time) decoding */

typedef struct {
  char val, len;
} VLCtab;

typedef struct {
  char run, level, len;
} DCTtab;

/* Table B-3, macroblock_type in P-pictures, codes 001..1xx */
static VLCtab PMBtab0[8] = {
  {ERROR,0},
  {MACROBLOCK_MOTION_FORWARD,3},
  {MACROBLOCK_PATTERN,2}, {MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,1}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,1},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,1}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,1}
};

/* Table B-3, macroblock_type in P-pictures, codes 000001..00011x */
static VLCtab PMBtab1[8] = {
  {ERROR,0},
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,6},
  {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,5}, {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,5},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,5}, {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,5},
  {MACROBLOCK_INTRA,5}, {MACROBLOCK_INTRA,5}
};

/* Table B-4, macroblock_type in B-pictures, codes 0010..11xx */
static VLCtab BMBtab0[16] = {
  {ERROR,0}, 
  {ERROR,0},
  {MACROBLOCK_MOTION_FORWARD,4},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,4},
  {MACROBLOCK_MOTION_BACKWARD,3}, 
  {MACROBLOCK_MOTION_BACKWARD,3},
  {MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,3}, 
  {MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,3},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2}
};

/* Table B-4, macroblock_type in B-pictures, codes 000001..00011x */
static VLCtab BMBtab1[8] = {
  {ERROR,0},
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,6},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,6},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,6},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,5},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,5},
  {MACROBLOCK_INTRA,5}, 
  {MACROBLOCK_INTRA,5}
};

/* Table B-5, macroblock_type in spat. scal. I-pictures, codes 0001..1xxx */
static VLCtab spIMBtab[16] = {
  {ERROR,0},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS,4},
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,4},
  {MACROBLOCK_INTRA,4},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1}, {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,1}
};

/* Table B-6, macroblock_type in spat. scal. P-pictures, codes 0010..11xx */
static VLCtab spPMBtab0[16] =
{
  {ERROR,0},
  {ERROR,0},
  {MACROBLOCK_MOTION_FORWARD,4},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD,4},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,3}, {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,3},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,3}, {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,3},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,2}
};

/* Table B-6, macroblock_type in spat. scal. P-pictures, codes 0000010..000111x */
static VLCtab spPMBtab1[16] = {
  {ERROR,0},
  {ERROR,0},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,7},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS,7},
  {MACROBLOCK_PATTERN,7},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,7},
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,7},
  {MACROBLOCK_INTRA,7},
  {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,6}, 
  {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_PATTERN,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_PATTERN,6}
};

/* Table B-7, macroblock_type in spat. scal. B-pictures, codes 0010..11xx */
static VLCtab spBMBtab0[14] = {
  {MACROBLOCK_MOTION_FORWARD,4},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,4},
  {MACROBLOCK_MOTION_BACKWARD,3}, 
  {MACROBLOCK_MOTION_BACKWARD,3},
  {MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,3}, 
  {MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,3},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2}, 
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,2}
};

/* Table B-7, macroblock_type in spat. scal. B-pictures, codes 0000100..000111x */
static VLCtab spBMBtab1[12] = {
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,7},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,7},
  {MACROBLOCK_INTRA,7},
  {MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,7},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_BACKWARD,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_BACKWARD,6},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,6}, 
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,6}
};

/* Table B-7, macroblock_type in spat. scal. B-pictures, codes 00000100x..000001111 */
static VLCtab spBMBtab2[8] = {
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,8}, 
  {MACROBLOCK_QUANT|MACROBLOCK_INTRA,8},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,8},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_FORWARD|MACROBLOCK_PATTERN,8},
  {SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG|MACROBLOCK_QUANT|MACROBLOCK_MOTION_BACKWARD|MACROBLOCK_PATTERN,9},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_QUANT|MACROBLOCK_PATTERN,9},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS,9},
  {PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS|MACROBLOCK_PATTERN,9}
};

/* Table B-8, macroblock_type in spat. scal. B-pictures, codes 001..1xx */
static VLCtab SNRMBtab[8] = {
  {ERROR,0},
  {0,3},
  {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2}, 
  {MACROBLOCK_QUANT|MACROBLOCK_PATTERN,2},
  {MACROBLOCK_PATTERN,1}, 
  {MACROBLOCK_PATTERN,1}, 
  {MACROBLOCK_PATTERN,1}, 
  {MACROBLOCK_PATTERN,1}
};

/* Table B-10, motion_code, codes 0001 ... 01xx */
static VLCtab MVtab0[8] =
{ {ERROR,0}, {3,3}, {2,2}, {2,2}, {1,1}, {1,1}, {1,1}, {1,1}
};

/* Table B-10, motion_code, codes 0000011 ... 000011x */
static VLCtab MVtab1[8] =
{ {ERROR,0}, {ERROR,0}, {ERROR,0}, {7,6}, {6,6}, {5,6}, {4,5}, {4,5}
};

/* Table B-10, motion_code, codes 0000001100 ... 000001011x */
static VLCtab MVtab2[12] =
{ {16,9}, {15,9}, {14,9}, {13,9},
  {12,9}, {11,9}, {10,8}, {10,8},
  {9,8},  {9,8},  {8,8},  {8,8}
};

/* Table B-9, coded_block_pattern, codes 01000 ... 111xx */
static VLCtab CBPtab0[32] =
{ {ERROR,0}, {ERROR,0}, {ERROR,0}, {ERROR,0},
  {ERROR,0}, {ERROR,0}, {ERROR,0}, {ERROR,0},
  {62,5}, {2,5},  {61,5}, {1,5},  {56,5}, {52,5}, {44,5}, {28,5},
  {40,5}, {20,5}, {48,5}, {12,5}, {32,4}, {32,4}, {16,4}, {16,4},
  {8,4},  {8,4},  {4,4},  {4,4},  {60,3}, {60,3}, {60,3}, {60,3}
};

/* Table B-9, coded_block_pattern, codes 00000100 ... 001111xx */
static VLCtab CBPtab1[64] =
{ {ERROR,0}, {ERROR,0}, {ERROR,0}, {ERROR,0},
  {58,8}, {54,8}, {46,8}, {30,8},
  {57,8}, {53,8}, {45,8}, {29,8}, {38,8}, {26,8}, {37,8}, {25,8},
  {43,8}, {23,8}, {51,8}, {15,8}, {42,8}, {22,8}, {50,8}, {14,8},
  {41,8}, {21,8}, {49,8}, {13,8}, {35,8}, {19,8}, {11,8}, {7,8},
  {34,7}, {34,7}, {18,7}, {18,7}, {10,7}, {10,7}, {6,7},  {6,7},
  {33,7}, {33,7}, {17,7}, {17,7}, {9,7},  {9,7},  {5,7},  {5,7},
  {63,6}, {63,6}, {63,6}, {63,6}, {3,6},  {3,6},  {3,6},  {3,6},
  {36,6}, {36,6}, {36,6}, {36,6}, {24,6}, {24,6}, {24,6}, {24,6}
};

/* Table B-9, coded_block_pattern, codes 000000001 ... 000000111 */
static VLCtab CBPtab2[8] =
{ {ERROR,0}, {0,9}, {39,9}, {27,9}, {59,9}, {55,9}, {47,9}, {31,9}
};

/* Table B-1, macroblock_address_increment, codes 00010 ... 011xx */
static VLCtab MBAtab1[16] =
{ {ERROR,0}, {ERROR,0}, {7,5}, {6,5}, {5,4}, {5,4}, {4,4}, {4,4},
  {3,3}, {3,3}, {3,3}, {3,3}, {2,3}, {2,3}, {2,3}, {2,3}
};

/* Table B-1, macroblock_address_increment, codes 00000011000 ... 0000111xxxx */
static VLCtab MBAtab2[104] =
{
  {33,11}, {32,11}, {31,11}, {30,11}, {29,11}, {28,11}, {27,11}, {26,11},
  {25,11}, {24,11}, {23,11}, {22,11}, {21,10}, {21,10}, {20,10}, {20,10},
  {19,10}, {19,10}, {18,10}, {18,10}, {17,10}, {17,10}, {16,10}, {16,10},
  {15,8},  {15,8},  {15,8},  {15,8},  {15,8},  {15,8},  {15,8},  {15,8},
  {14,8},  {14,8},  {14,8},  {14,8},  {14,8},  {14,8},  {14,8},  {14,8},
  {13,8},  {13,8},  {13,8},  {13,8},  {13,8},  {13,8},  {13,8},  {13,8},
  {12,8},  {12,8},  {12,8},  {12,8},  {12,8},  {12,8},  {12,8},  {12,8},
  {11,8},  {11,8},  {11,8},  {11,8},  {11,8},  {11,8},  {11,8},  {11,8},
  {10,8},  {10,8},  {10,8},  {10,8},  {10,8},  {10,8},  {10,8},  {10,8},
  {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},
  {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},   {9,7},
  {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7},
  {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7},   {8,7}
};

/* Table B-12, dct_dc_size_luminance, codes 00xxx ... 11110 */
static VLCtab DClumtab0[32] =
{ {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2},
  {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2},
  {0, 3}, {0, 3}, {0, 3}, {0, 3}, {3, 3}, {3, 3}, {3, 3}, {3, 3},
  {4, 3}, {4, 3}, {4, 3}, {4, 3}, {5, 4}, {5, 4}, {6, 5}, {ERROR, 0}
};

/* Table B-12, dct_dc_size_luminance, codes 111110xxx ... 111111111 */
static VLCtab DClumtab1[16] =
{ {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6},
  {8, 7}, {8, 7}, {8, 7}, {8, 7}, {9, 8}, {9, 8}, {10,9}, {11,9}
};

/* Table B-13, dct_dc_size_chrominance, codes 00xxx ... 11110 */
static VLCtab DCchromtab0[32] =
{ {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2},
  {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2},
  {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2},
  {3, 3}, {3, 3}, {3, 3}, {3, 3}, {4, 4}, {4, 4}, {5, 5}, {ERROR, 0}
};

/* Table B-13, dct_dc_size_chrominance, codes 111110xxxx ... 1111111111 */
static VLCtab DCchromtab1[32] =
{ {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6},
  {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6}, {6, 6},
  {7, 7}, {7, 7}, {7, 7}, {7, 7}, {7, 7}, {7, 7}, {7, 7}, {7, 7},
  {8, 8}, {8, 8}, {8, 8}, {8, 8}, {9, 9}, {9, 9}, {10,10}, {11,10}
};

/* Table B-14, DCT coefficients table zero,
 * codes 0100 ... 1xxx (used for first (DC) coefficient)
 */
DCTtab DCTtabfirst[12] =
{
  {0,2,4}, {2,1,4}, {1,1,3}, {1,1,3},
  {0,1,1}, {0,1,1}, {0,1,1}, {0,1,1},
  {0,1,1}, {0,1,1}, {0,1,1}, {0,1,1}
};

/* Table B-14, DCT coefficients table zero,
 * codes 0100 ... 1xxx (used for all other coefficients)
 */
DCTtab DCTtabnext[12] =
{
  {0,2,4},  {2,1,4},  {1,1,3},  {1,1,3},
  {64,0,2}, {64,0,2}, {64,0,2}, {64,0,2}, /* EOB */
  {0,1,2},  {0,1,2},  {0,1,2},  {0,1,2}
};

/* Table B-14, DCT coefficients table zero,
 * codes 000001xx ... 00111xxx
 */
DCTtab DCTtab0[60] =
{
  {65,0,6}, {65,0,6}, {65,0,6}, {65,0,6}, /* Escape */
  {2,2,7}, {2,2,7}, {9,1,7}, {9,1,7},
  {0,4,7}, {0,4,7}, {8,1,7}, {8,1,7},
  {7,1,6}, {7,1,6}, {7,1,6}, {7,1,6},
  {6,1,6}, {6,1,6}, {6,1,6}, {6,1,6},
  {1,2,6}, {1,2,6}, {1,2,6}, {1,2,6},
  {5,1,6}, {5,1,6}, {5,1,6}, {5,1,6},
  {13,1,8}, {0,6,8}, {12,1,8}, {11,1,8},
  {3,2,8}, {1,3,8}, {0,5,8}, {10,1,8},
  {0,3,5}, {0,3,5}, {0,3,5}, {0,3,5},
  {0,3,5}, {0,3,5}, {0,3,5}, {0,3,5},
  {4,1,5}, {4,1,5}, {4,1,5}, {4,1,5},
  {4,1,5}, {4,1,5}, {4,1,5}, {4,1,5},
  {3,1,5}, {3,1,5}, {3,1,5}, {3,1,5},
  {3,1,5}, {3,1,5}, {3,1,5}, {3,1,5}
};

/* Table B-15, DCT coefficients table one,
 * codes 000001xx ... 11111111
*/
DCTtab DCTtab0a[252] =
{
  {65,0,6}, {65,0,6}, {65,0,6}, {65,0,6}, /* Escape */
  {7,1,7}, {7,1,7}, {8,1,7}, {8,1,7},
  {6,1,7}, {6,1,7}, {2,2,7}, {2,2,7},
  {0,7,6}, {0,7,6}, {0,7,6}, {0,7,6},
  {0,6,6}, {0,6,6}, {0,6,6}, {0,6,6},
  {4,1,6}, {4,1,6}, {4,1,6}, {4,1,6},
  {5,1,6}, {5,1,6}, {5,1,6}, {5,1,6},
  {1,5,8}, {11,1,8}, {0,11,8}, {0,10,8},
  {13,1,8}, {12,1,8}, {3,2,8}, {1,4,8},
  {2,1,5}, {2,1,5}, {2,1,5}, {2,1,5},
  {2,1,5}, {2,1,5}, {2,1,5}, {2,1,5},
  {1,2,5}, {1,2,5}, {1,2,5}, {1,2,5},
  {1,2,5}, {1,2,5}, {1,2,5}, {1,2,5},
  {3,1,5}, {3,1,5}, {3,1,5}, {3,1,5},
  {3,1,5}, {3,1,5}, {3,1,5}, {3,1,5},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {1,1,3}, {1,1,3}, {1,1,3}, {1,1,3},
  {64,0,4}, {64,0,4}, {64,0,4}, {64,0,4}, /* EOB */
  {64,0,4}, {64,0,4}, {64,0,4}, {64,0,4},
  {64,0,4}, {64,0,4}, {64,0,4}, {64,0,4},
  {64,0,4}, {64,0,4}, {64,0,4}, {64,0,4},
  {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},
  {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},
  {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},
  {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,2,3}, {0,2,3}, {0,2,3}, {0,2,3},
  {0,4,5}, {0,4,5}, {0,4,5}, {0,4,5},
  {0,4,5}, {0,4,5}, {0,4,5}, {0,4,5},
  {0,5,5}, {0,5,5}, {0,5,5}, {0,5,5},
  {0,5,5}, {0,5,5}, {0,5,5}, {0,5,5},
  {9,1,7}, {9,1,7}, {1,3,7}, {1,3,7},
  {10,1,7}, {10,1,7}, {0,8,7}, {0,8,7},
  {0,9,7}, {0,9,7}, {0,12,8}, {0,13,8},
  {2,3,8}, {4,2,8}, {0,14,8}, {0,15,8}
};

/* Table B-14, DCT coefficients table zero,
 * codes 0000001000 ... 0000001111
 */
DCTtab DCTtab1[8] =
{
  {16,1,10}, {5,2,10}, {0,7,10}, {2,3,10},
  {1,4,10}, {15,1,10}, {14,1,10}, {4,2,10}
};

/* Table B-15, DCT coefficients table one,
 * codes 000000100x ... 000000111x
 */
DCTtab DCTtab1a[8] =
{
  {5,2,9}, {5,2,9}, {14,1,9}, {14,1,9},
  {2,4,10}, {16,1,10}, {15,1,9}, {15,1,9}
};

/* Table B-14/15, DCT coefficients table zero / one,
 * codes 000000010000 ... 000000011111
 */
DCTtab DCTtab2[16] =
{
  {0,11,12}, {8,2,12}, {4,3,12}, {0,10,12},
  {2,4,12}, {7,2,12}, {21,1,12}, {20,1,12},
  {0,9,12}, {19,1,12}, {18,1,12}, {1,5,12},
  {3,3,12}, {0,8,12}, {6,2,12}, {17,1,12}
};

/* Table B-14/15, DCT coefficients table zero / one,
 * codes 0000000010000 ... 0000000011111
 */
DCTtab DCTtab3[16] =
{
  {10,2,13}, {9,2,13}, {5,3,13}, {3,4,13},
  {2,5,13}, {1,7,13}, {1,6,13}, {0,15,13},
  {0,14,13}, {0,13,13}, {0,12,13}, {26,1,13},
  {25,1,13}, {24,1,13}, {23,1,13}, {22,1,13}
};

/* Table B-14/15, DCT coefficients table zero / one,
 * codes 00000000010000 ... 00000000011111
 */
DCTtab DCTtab4[16] =
{
  {0,31,14}, {0,30,14}, {0,29,14}, {0,28,14},
  {0,27,14}, {0,26,14}, {0,25,14}, {0,24,14},
  {0,23,14}, {0,22,14}, {0,21,14}, {0,20,14},
  {0,19,14}, {0,18,14}, {0,17,14}, {0,16,14}
};

/* Table B-14/15, DCT coefficients table zero / one,
 * codes 000000000010000 ... 000000000011111
 */
DCTtab DCTtab5[16] =
{
  {0,40,15}, {0,39,15}, {0,38,15}, {0,37,15},
  {0,36,15}, {0,35,15}, {0,34,15}, {0,33,15},
  {0,32,15}, {1,14,15}, {1,13,15}, {1,12,15},
  {1,11,15}, {1,10,15}, {1,9,15}, {1,8,15}
};

/* Table B-14/15, DCT coefficients table zero / one,
 * codes 0000000000010000 ... 0000000000011111
 */
DCTtab DCTtab6[16] =
{
  {1,18,16}, {1,17,16}, {1,16,16}, {1,15,16},
  {6,3,16}, {16,2,16}, {15,2,16}, {14,2,16},
  {13,2,16}, {12,2,16}, {11,2,16}, {31,1,16},
  {30,1,16}, {29,1,16}, {28,1,16}, {27,1,16}
};

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* global.h, global variables                                               */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include "mpeg2dec.h"

/* choose between declaration (GLOBAL undefined)
 * and definition (GLOBAL defined)
 * GLOBAL is defined in exactly one file mpeg2dec.c)
 */

#ifndef GLOBAL
#define EXTERN extern
#else
#define EXTERN
#endif

/* prototypes of global functions */
/* readpic.c */
void Substitute_Frame_Buffer _ANSI_ARGS_ ((int bitstream_framenum, 
  int sequence_framenum));

/* Get_Bits.c */
void Initialize_Buffer _ANSI_ARGS_((void));
void Fill_Buffer _ANSI_ARGS_((void));
unsigned int Show_Bits _ANSI_ARGS_((int n));
unsigned int Get_Bits1 _ANSI_ARGS_((void));
void Flush_Buffer _ANSI_ARGS_((int n));
unsigned int Get_Bits _ANSI_ARGS_((int n));
int Get_Byte _ANSI_ARGS_((void));
int Get_Word _ANSI_ARGS_((void));
#ifdef THRD
void Thrd_Initialize_Buffer _ANSI_ARGS_((int t));
unsigned int Thrd_Show_Bits _ANSI_ARGS_((int t, int n));
unsigned int Thrd_Get_Bits1 _ANSI_ARGS_((int t));
void Thrd_Flush_Buffer _ANSI_ARGS_((int t, int n));
unsigned int Thrd_Get_Bits _ANSI_ARGS_((int t, int n));
int Thrd_Get_Byte _ANSI_ARGS_((int t));
int Thrd_Get_Word _ANSI_ARGS_((int t));
#endif

/* systems.c */
void Next_Packet _ANSI_ARGS_((void));
int Get_Long _ANSI_ARGS_((void));
void Flush_Buffer32 _ANSI_ARGS_((void));
unsigned int Get_Bits32 _ANSI_ARGS_((void));
#ifdef THRD
int Thrd_Get_Long _ANSI_ARGS_((int t));
void Thrd_Flush_Buffer32 _ANSI_ARGS_((int t));
unsigned int Thrd_Get_Bits32 _ANSI_ARGS_((int t));
#endif



/* getblk.c */
void Decode_MPEG1_Intra_Block _ANSI_ARGS_((int comp, int dc_dct_pred[]));
void Decode_MPEG1_Non_Intra_Block _ANSI_ARGS_((int comp));
void Decode_MPEG2_Intra_Block _ANSI_ARGS_((int comp, int dc_dct_pred[]));
void Decode_MPEG2_Non_Intra_Block _ANSI_ARGS_((int comp));

/* gethdr.c */
int Get_Hdr _ANSI_ARGS_((void));
void next_start_code _ANSI_ARGS_((void));
int slice_header _ANSI_ARGS_((void));
void marker_bit _ANSI_ARGS_((char *text));

/* getpic.c */
void Decode_Picture _ANSI_ARGS_((int bitstream_framenum, 
  int sequence_framenum));
void Output_Last_Frame_of_Sequence _ANSI_ARGS_((int framenum));

/* getvlc.c */
int Get_macroblock_type _ANSI_ARGS_((void));
int Get_motion_code _ANSI_ARGS_((void));
int Get_dmvector _ANSI_ARGS_((void));
int Get_coded_block_pattern _ANSI_ARGS_((void));
int Get_macroblock_address_increment _ANSI_ARGS_((void));
int Get_Luma_DC_dct_diff _ANSI_ARGS_((void));
int Get_Chroma_DC_dct_diff _ANSI_ARGS_((void));

/* idct.c */
void Fast_IDCT _ANSI_ARGS_((short *block));
void Initialize_Fast_IDCT _ANSI_ARGS_((void));

/* Reference_IDCT.c */
void Initialize_Reference_IDCT _ANSI_ARGS_((void));
void Reference_IDCT _ANSI_ARGS_((short *block));

/* motion.c */
void motion_vectors _ANSI_ARGS_((int PMV[2][2][2], int dmvector[2],
  int motion_vertical_field_select[2][2], int s, int motion_vector_count, 
  int mv_format, int h_r_size, int v_r_size, int dmv, int mvscale));
void motion_vector _ANSI_ARGS_((int *PMV, int *dmvector,
  int h_r_size, int v_r_size, int dmv, int mvscale, int full_pel_vector));
void Dual_Prime_Arithmetic _ANSI_ARGS_((int DMV[][2], int *dmvector, int mvx, int mvy));
#ifdef THRD
void Thrd_motion_vectors _ANSI_ARGS_((int t, int PMV[2][2][2], int dmvector[2],
  int motion_vertical_field_select[2][2], int s, int motion_vector_count, 
  int mv_format, int h_r_size, int v_r_size, int dmv, int mvscale));
void Thrd_motion_vector _ANSI_ARGS_((int t, int *PMV, int *dmvector,
  int h_r_size, int v_r_size, int dmv, int mvscale, int full_pel_vector));
#endif

/* mpeg2dec.c */
void Error _ANSI_ARGS_((char *text));
void Warning _ANSI_ARGS_((char *text));
void Print_Bits _ANSI_ARGS_((int code, int bits, int len));

/* recon.c */
void form_predictions _ANSI_ARGS_((int bx, int by, int macroblock_type, 
  int motion_type, int PMV[2][2][2], int motion_vertical_field_select[2][2], 
  int dmvector[2], int stwtype));

/* spatscal.c */
void Spatial_Prediction _ANSI_ARGS_((void));

/* store.c */
void Write_Frame _ANSI_ARGS_((unsigned char *src[], int frame));

#ifdef DISPLAY
/* display.c */
void Initialize_Display_Process _ANSI_ARGS_((char *name));
void Terminate_Display_Process _ANSI_ARGS_((void));
void Display_Second_Field _ANSI_ARGS_((void));
void dither _ANSI_ARGS_((unsigned char *src[]));
void Initialize_Dither_Matrix _ANSI_ARGS_((void));
#endif

/*additional functions for threaded version */
#ifdef THRD
/*getvlc.c*/
int Thrd_Get_macroblock_type _ANSI_ARGS_((int t));
int Thrd_Get_Luma_DC_dct_diff _ANSI_ARGS_((int t));
int Thrd_Get_Chroma_DC_dct_diff _ANSI_ARGS_((int t));
int Thrd_Get_coded_block_pattern _ANSI_ARGS_((int t));
int Thrd_Get_motion_code _ANSI_ARGS_((int t));

/*gethdr.c*/
int Thrd_Get_macroblock_address_increment _ANSI_ARGS_((int t));
void Thrd_next_start_code _ANSI_ARGS_((int t));
int Thrd_slice_header _ANSI_ARGS_((int t));
int Thrd_Get_dmvector _ANSI_ARGS_((int t));

/*getblk.c*/
void Thrd_Decode_MPEG2_Non_Intra_Block _ANSI_ARGS_((int t, int comp));
void Thrd_Decode_MPEG2_Intra_Block _ANSI_ARGS_((int t, int comp, int dc_dct_pred[]));

#endif

/* global variables */

EXTERN char Version[]
#ifdef GLOBAL
  ="mpeg2decode V1.2a, 96/07/19"
#endif
;

EXTERN char Author[]
#ifdef GLOBAL
  ="(C) 1996, MPEG Software Simulation Group"
#endif
;


/* zig-zag and alternate scan patterns */
EXTERN unsigned char scan[2][64]
#ifdef GLOBAL
=
{
  { /* Zig-Zag scan pattern  */
    0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,
    12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
    35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,
    58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63
  },
  { /* Alternate scan pattern */
    0,8,16,24,1,9,2,10,17,25,32,40,48,56,57,49,
    41,33,26,18,3,11,4,12,19,27,34,42,50,58,35,43,
    51,59,20,28,5,13,6,14,21,29,36,44,52,60,37,45,
    53,61,22,30,7,15,23,31,38,46,54,62,39,47,55,63
  }
}
#endif
;

/* default intra quantization matrix */
EXTERN unsigned char default_intra_quantizer_matrix[64]
#ifdef GLOBAL
=
{
  8, 16, 19, 22, 26, 27, 29, 34,
  16, 16, 22, 24, 27, 29, 34, 37,
  19, 22, 26, 27, 29, 34, 34, 38,
  22, 22, 26, 27, 29, 34, 37, 40,
  22, 26, 27, 29, 32, 35, 40, 48,
  26, 27, 29, 32, 35, 40, 48, 58,
  26, 27, 29, 34, 38, 46, 56, 69,
  27, 29, 35, 38, 46, 56, 69, 83
}
#endif
;

/* non-linear quantization coefficient table */
EXTERN unsigned char Non_Linear_quantizer_scale[32]
#ifdef GLOBAL
=
{
   0, 1, 2, 3, 4, 5, 6, 7,
   8,10,12,14,16,18,20,22,
  24,28,32,36,40,44,48,52,
  56,64,72,80,88,96,104,112
}
#endif
;

/* color space conversion coefficients
 * for YCbCr -> RGB mapping
 *
 * entries are {crv,cbu,cgu,cgv}
 *
 * crv=(255/224)*65536*(1-cr)/0.5
 * cbu=(255/224)*65536*(1-cb)/0.5
 * cgu=(255/224)*65536*(cb/cg)*(1-cb)/0.5
 * cgv=(255/224)*65536*(cr/cg)*(1-cr)/0.5
 *
 * where Y=cr*R+cg*G+cb*B (cr+cg+cb=1)
 */

/* ISO/IEC 13818-2 section 6.3.6 sequence_display_extension() */

EXTERN int Inverse_Table_6_9[8][4]
#ifdef GLOBAL
=
{
  {117504, 138453, 13954, 34903}, /* no sequence_display_extension */
  {117504, 138453, 13954, 34903}, /* ITU-R Rec. 709 (1990) */
  {104597, 132201, 25675, 53279}, /* unspecified */
  {104597, 132201, 25675, 53279}, /* reserved */
  {104448, 132798, 24759, 53109}, /* FCC */
  {104597, 132201, 25675, 53279}, /* ITU-R Rec. 624-4 System B, G */
  {104597, 132201, 25675, 53279}, /* SMPTE 170M */
  {117579, 136230, 16907, 35559}  /* SMPTE 240M (1987) */
}
#endif
;





/* output types (Output_Type) */
#define T_YUV   0
#define T_SIF   1
#define T_TGA   2
#define T_PPM   3
#define T_X11   4
#define T_X11HIQ 5

/* decoder operation control variables */
EXTERN int Output_Type;
EXTERN int hiQdither;

/* decoder operation control flags */
EXTERN int Quiet_Flag;
EXTERN int Trace_Flag;
EXTERN int Fault_Flag;
EXTERN int Verbose_Flag;
EXTERN int Two_Streams;
EXTERN int Spatial_Flag;
EXTERN int Reference_IDCT_Flag;
EXTERN int Frame_Store_Flag;
EXTERN int System_Stream_Flag;
EXTERN int Display_Progressive_Flag;
EXTERN int Ersatz_Flag;
EXTERN int Big_Picture_Flag;
EXTERN int Verify_Flag;
EXTERN int Stats_Flag;
EXTERN int User_Data_Flag;
EXTERN int Main_Bitstream_Flag;


/* filenames */
EXTERN char *Output_Picture_Filename;
EXTERN char *Substitute_Picture_Filename;
EXTERN char *Main_Bitstream_Filename; 
EXTERN char *Enhancement_Layer_Bitstream_Filename; 


/* buffers for multiuse purposes */
EXTERN char Error_Text[256];
EXTERN unsigned char *Clip;

/* pointers to generic picture buffers */
EXTERN unsigned char *backward_reference_frame[3];
EXTERN unsigned char *forward_reference_frame[3];

EXTERN unsigned char *auxframe[3];
EXTERN unsigned char *current_frame[3];
EXTERN unsigned char *substitute_frame[3];


/* pointers to scalability picture buffers */
EXTERN unsigned char *llframe0[3];
EXTERN unsigned char *llframe1[3];

EXTERN short *lltmp;
EXTERN char *Lower_Layer_Picture_Filename;




/* non-normative variables derived from normative elements */
EXTERN int Coded_Picture_Width;
EXTERN int Coded_Picture_Height;
EXTERN int Chroma_Width;
EXTERN int Chroma_Height;
EXTERN int block_count;
EXTERN int Second_Field;
EXTERN int profile, level;

/* normative derived variables (as per ISO/IEC 13818-2) */
EXTERN int horizontal_size;
EXTERN int vertical_size;
EXTERN int mb_width;
EXTERN int mb_height;
EXTERN double bit_rate;
EXTERN double frame_rate; 



/* headers */

/* ISO/IEC 13818-2 section 6.2.2.1:  sequence_header() */
EXTERN int aspect_ratio_information;
EXTERN int frame_rate_code; 
EXTERN int bit_rate_value; 
EXTERN int vbv_buffer_size;
EXTERN int constrained_parameters_flag;

/* ISO/IEC 13818-2 section 6.2.2.3:  sequence_extension() */
EXTERN int profile_and_level_indication;
EXTERN int progressive_sequence;
EXTERN int chroma_format;
EXTERN int low_delay;
EXTERN int frame_rate_extension_n;
EXTERN int frame_rate_extension_d;

/* ISO/IEC 13818-2 section 6.2.2.4:  sequence_display_extension() */
EXTERN int video_format;  
EXTERN int color_description;
EXTERN int color_primaries;
EXTERN int transfer_characteristics;
EXTERN int matrix_coefficients;
EXTERN int display_horizontal_size;
EXTERN int display_vertical_size;

/* ISO/IEC 13818-2 section 6.2.3: picture_header() */
EXTERN int temporal_reference;
EXTERN int picture_coding_type;
EXTERN int vbv_delay;
EXTERN int full_pel_forward_vector;
EXTERN int forward_f_code;
EXTERN int full_pel_backward_vector;
EXTERN int backward_f_code;


/* ISO/IEC 13818-2 section 6.2.3.1: picture_coding_extension() header */
EXTERN int f_code[2][2];
EXTERN int intra_dc_precision;
EXTERN int picture_structure;
EXTERN int top_field_first;
EXTERN int frame_pred_frame_dct;
EXTERN int concealment_motion_vectors;

EXTERN int intra_vlc_format;

EXTERN int repeat_first_field;

EXTERN int chroma_420_type;
EXTERN int progressive_frame;
EXTERN int composite_display_flag;
EXTERN int v_axis;
EXTERN int field_sequence;
EXTERN int sub_carrier;
EXTERN int burst_amplitude;
EXTERN int sub_carrier_phase;



/* ISO/IEC 13818-2 section 6.2.3.3: picture_display_extension() header */
EXTERN int frame_center_horizontal_offset[3];
EXTERN int frame_center_vertical_offset[3];



/* ISO/IEC 13818-2 section 6.2.2.5: sequence_scalable_extension() header */
EXTERN int layer_id;
EXTERN int lower_layer_prediction_horizontal_size;
EXTERN int lower_layer_prediction_vertical_size;
EXTERN int horizontal_subsampling_factor_m;
EXTERN int horizontal_subsampling_factor_n;
EXTERN int vertical_subsampling_factor_m;
EXTERN int vertical_subsampling_factor_n;


/* ISO/IEC 13818-2 section 6.2.3.5: picture_spatial_scalable_extension() header */
EXTERN int lower_layer_temporal_reference;
EXTERN int lower_layer_horizontal_offset;
EXTERN int lower_layer_vertical_offset;
EXTERN int spatial_temporal_weight_code_table_index;
EXTERN int lower_layer_progressive_frame;
EXTERN int lower_layer_deinterlaced_field_select;






/* ISO/IEC 13818-2 section 6.2.3.6: copyright_extension() header */
EXTERN int copyright_flag;
EXTERN int copyright_identifier;
EXTERN int original_or_copy;
EXTERN int copyright_number_1;
EXTERN int copyright_number_2;
EXTERN int copyright_number_3;

/* ISO/IEC 13818-2 section 6.2.2.6: group_of_pictures_header()  */
EXTERN int drop_flag;
EXTERN int hour;
EXTERN int minute;
EXTERN int sec;
EXTERN int frame;
EXTERN int closed_gop;
EXTERN int broken_link;



/* layer specific variables (needed for SNR and DP scalability) */
EXTERN struct layer_data {
  /* bit input */
  int Infile;
  unsigned char Rdbfr[2048];
  unsigned char *Rdptr;
  unsigned char Inbfr[16];
  /* from mpeg2play */
  unsigned int Bfr;
  unsigned char *Rdmax;
  int Incnt;
  int Bitcnt;
  /* sequence header and quant_matrix_extension() */
  int intra_quantizer_matrix[64];
  int non_intra_quantizer_matrix[64];
  int chroma_intra_quantizer_matrix[64];
  int chroma_non_intra_quantizer_matrix[64];
  
  int load_intra_quantizer_matrix;
  int load_non_intra_quantizer_matrix;
  int load_chroma_intra_quantizer_matrix;
  int load_chroma_non_intra_quantizer_matrix;

  int MPEG2_Flag;
  /* sequence scalable extension */
  int scalable_mode;
  /* picture coding extension */
  int q_scale_type;
  int alternate_scan;
  /* picture spatial scalable extension */
  int pict_scal;
  /* slice/macroblock */
  int priority_breakpoint;
  int quantizer_scale;
  int intra_slice;
  short block[12][64];
} base, enhan, *ld;



#ifdef VERIFY
EXTERN int verify_sequence_header;
EXTERN int verify_group_of_pictures_header;
EXTERN int verify_picture_header;
EXTERN int verify_slice_header;
EXTERN int verify_sequence_extension;
EXTERN int verify_sequence_display_extension;
EXTERN int verify_quant_matrix_extension;
EXTERN int verify_sequence_scalable_extension;
EXTERN int verify_picture_display_extension;
EXTERN int verify_picture_coding_extension;
EXTERN int verify_picture_spatial_scalable_extension;
EXTERN int verify_picture_temporal_scalable_extension;
EXTERN int verify_copyright_extension;
#endif /* VERIFY */


EXTERN int Decode_Layer;

/* verify.c */
#ifdef VERIFY
void Check_Headers _ANSI_ARGS_((int Bitstream_Framenum, int Sequence_Framenum));
void Clear_Verify_Headers _ANSI_ARGS_((void));
#endif /* VERIFY */


EXTERN int global_MBA;
EXTERN int global_pic;
EXTERN int True_Framenum;

#ifdef THRD
unsigned char *frame_buffer;
unsigned char *frame_buf_ptr;
unsigned int frame_buf_size;
unsigned int frame_buf_offset;

unsigned char *thrd_ptr[NUM_THREADS];
unsigned int thrd_buf[NUM_THREADS];
int thrd_Incnt[NUM_THREADS];

#define INIT_BUF_SIZE 2048
#if 0
unsigned char *thrd_frame_buf[NUM_THREADS];
unsigned int thrd_frame_buf_size[NUM_THREADS];
unsigned int trhd_frame_buf_offset[NUM_THREADS];
#else
typedef struct {
  unsigned char *frame_buf;
  unsigned int frame_buf_size;
  unsigned int frame_buf_offset;
  unsigned char padding[20];
} thrd_buf_info;

thrd_buf_info tb[NUM_THREADS];
#endif

typedef struct{
  int id;
  int num_slices;
  int framenum;
  int MBAmax;
} Thrd_Args;

#ifndef USE_ICC
#define __declspec(x)
#define align(x)
#define _mm_malloc(x,y) malloc(x)
#define _mm_free(x) free(x)
#endif

__declspec(align(16)) struct thrd_layer_data {
  /* picture spatial scalable extension */
  int pict_scal;
  /* slice/macroblock */
  int priority_breakpoint;
  int quantizer_scale;
  int intra_slice;
  short block[12][64];
} thrd_ld[NUM_THREADS];


#endif
#ifdef NEW_TWORK 

typedef struct {
  int MBA;
  int macroblock_type, motion_type, dct_type;
  int dc_dct_pred[3];
  int PMV[2][2][2], motion_vertical_field_select[2][2];
  int dmvector[2];
  int stwtype, stwclass;
} MB_t;
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* idct.c, inverse fast discrete cosine transform                           */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/*
 * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
 * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
 *
 * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
 * See http://libmpeg2.sourceforge.net/ for updates.
 *
 * mpeg2dec is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * mpeg2dec is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/**********************************************************/
/* inverse two dimensional DCT, Chen-Wang algorithm       */
/* (cf. IEEE ASSP-32, pp. 803-816, Aug. 1984)             */
/* 32-bit integer arithmetic (8 bit coefficients)         */
/* 11 mults, 29 adds per DCT                              */
/*                                      sE, 18.8.91       */
/**********************************************************/
/* coefficients extended to 12 bit for IEEE1180-1990      */
/* compliance                           sE,  2.1.94       */
/**********************************************************/

/* this code assumes >> to be a two's-complement arithmetic */
/* right shift: (-2)>>1 == -1 , (-3)>>1 == -2               */

#include <math.h>
#include "config.h"
#include <assert.h>
#include "global.h"

/*#define ORIGINAL_IDCT 0
  #define MATRIX_IDCT 0*/

#define W1 2841 /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676 /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408 /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609 /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108 /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565  /* 2048*sqrt(2)*cos(7*pi/16) */
#define PI 3.14159265358979323846

#define CLIP_BYTE(i)  (((i)<-256) ? -256 : (((i)>255) ? 255 : (i)))

/* global declarations */
void Initialize_Fast_IDCT _ANSI_ARGS_((void));
void Fast_IDCT _ANSI_ARGS_((short *block));

/* private data */
#if 0
static short iclip[1024]; /* clipping table */
#endif
static short *iclp;

__declspec(align(16)) short ic[8][8];

#if (ORIGINAL_IDCT)
/* private prototypes */
static void idctrow _ANSI_ARGS_((short *blk));
static void idctcol _ANSI_ARGS_((short *blk));

/* row (horizontal) IDCT
 *
 *           7                       pi         1
 * dst[k] = sum c[l] * src[l] * cos( -- * ( k + - ) * l )
 *          l=0                      8          2
 *
 * where: c[0]    = 128
 *        c[1..7] = 128*sqrt(2)
 */

static void idctrow(blk)
short *blk;
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = blk[4]<<11) | (x2 = blk[6]) | (x3 = blk[2]) |
        (x4 = blk[1]) | (x5 = blk[7]) | (x6 = blk[5]) | (x7 = blk[3])))
  {
    blk[0]=blk[1]=blk[2]=blk[3]=blk[4]=blk[5]=blk[6]=blk[7]=blk[0]<<3;
    return;
  }

  x0 = (blk[0]<<11) + 128; /* for proper rounding in the fourth stage */

  /* first stage */
  x8 = W7*(x4+x5);
  x4 = x8 + (W1-W7)*x4;
  x5 = x8 - (W1+W7)*x5;
  x8 = W3*(x6+x7);
  x6 = x8 - (W3-W5)*x6;
  x7 = x8 - (W3+W5)*x7;
  
  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2);
  x2 = x1 - (W2+W6)*x2;
  x3 = x1 + (W2-W6)*x3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;
  
  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;
  
  /* fourth stage */
  blk[0] = (x7+x1)>>8;
  blk[1] = (x3+x2)>>8;
  blk[2] = (x0+x4)>>8;
  blk[3] = (x8+x6)>>8;
  blk[4] = (x8-x6)>>8;
  blk[5] = (x0-x4)>>8;
  blk[6] = (x3-x2)>>8;
  blk[7] = (x7-x1)>>8;
}

/* column (vertical) IDCT
 *
 *             7                         pi         1
 * dst[8*k] = sum c[l] * src[8*l] * cos( -- * ( k + - ) * l )
 *            l=0                        8          2
 *
 * where: c[0]    = 1/1024
 *        c[1..7] = (1/1024)*sqrt(2)
 */
static void idctcol(blk)
short *blk;
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = (blk[8*4]<<8)) | (x2 = blk[8*6]) | (x3 = blk[8*2]) |
        (x4 = blk[8*1]) | (x5 = blk[8*7]) | (x6 = blk[8*5]) | (x7 = blk[8*3])))
  {
    blk[8*0]=blk[8*1]=blk[8*2]=blk[8*3]=blk[8*4]=blk[8*5]=blk[8*6]=blk[8*7]=
      CLIP_BYTE((blk[8*0]+32)>>6);/*iclp[(blk[8*0]+32)>>6];*/
    return;
  }

  x0 = (blk[8*0]<<8) + 8192;

  /* first stage */
  x8 = W7*(x4+x5) + 4;
  x4 = (x8+(W1-W7)*x4)>>3;
  x5 = (x8-(W1+W7)*x5)>>3;
  x8 = W3*(x6+x7) + 4;
  x6 = (x8-(W3-W5)*x6)>>3;
  x7 = (x8-(W3+W5)*x7)>>3;
  
  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2) + 4;
  x2 = (x1-(W2+W6)*x2)>>3;
  x3 = (x1+(W2-W6)*x3)>>3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;
  
  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;
  
  /* fourth stage */
  blk[8*0] = CLIP_BYTE((x7+x1)>>14);    /*iclp[(x7+x1)>>14];*/
  blk[8*1] = CLIP_BYTE((x3+x2)>>14);    /*iclp[(x3+x2)>>14];*/
  blk[8*2] = CLIP_BYTE((x0+x4)>>14);    /*iclp[(x0+x4)>>14];*/
  blk[8*3] = CLIP_BYTE((x8+x6)>>14);    /*iclp[(x8+x6)>>14];*/
  blk[8*4] = CLIP_BYTE((x8-x6)>>14);    /*iclp[(x8-x6)>>14];*/
  blk[8*5] = CLIP_BYTE((x0-x4)>>14);    /*iclp[(x0-x4)>>14];*/
  blk[8*6] = CLIP_BYTE((x3-x2)>>14);    /*iclp[(x3-x2)>>14];*/
  blk[8*7] = CLIP_BYTE((x7-x1)>>14);    /*iclp[(x7-x1)>>14];*/
}

#else

#if !(MATRIX_IDCT)
/*
// Intel's SSE2 implementation of iDCT
// AP-945
// http://cache-www.intel.com/cd/00/00/01/76/17680_w_idct.pdf
*/

#define BITS_INV_ACC 4 /* 4 or 5 for IEEE */
#define SHIFT_INV_ROW 16 - BITS_INV_ACC
#define SHIFT_INV_COL 1 + BITS_INV_ACC
const short RND_INV_ROW = 1024 * (6 - BITS_INV_ACC); /*1 << (SHIFT_INV_ROW-1) */
#define RND_INV_COL (16 * (BITS_INV_ACC - 3)) /* 1 << (SHIFT_INV_COL-1) */
const short RND_INV_CORR = RND_INV_COL - 1; /* correction -1.0 and round */

#ifdef SSE2

__declspec(align(16)) short M128_one_corr[8] = {1,1,1,1,1,1,1,1};
__declspec(align(16)) short M128_round_inv_row[8] = {RND_INV_ROW, 0, RND_INV_ROW, 0, RND_INV_ROW, 0, RND_INV_ROW, 0};
__declspec(align(16)) short M128_round_inv_col[8] = {RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL};
__declspec(align(16)) short M128_round_inv_corr[8]= {RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR};
__declspec(align(16)) short M128_tg_1_16[8] = {13036, 13036, 13036, 13036, 13036, 13036, 13036, 13036}; /* tg * (2<<16) + 0.5 */
__declspec(align(16)) short M128_tg_2_16[8] = {27146, 27146, 27146, 27146, 27146, 27146, 27146, 27146}; /* tg * (2<<16) + 0.5 */
__declspec(align(16)) short M128_tg_3_16[8] = {-21746, -21746, -21746, -21746, -21746, -21746, -21746, -21746}; /* tg * (2<<16) + 0.5 */
__declspec(align(16)) short M128_cos_4_16[8] = {-19195, -19195, -19195, -19195, -19195, -19195, -19195, -19195};/* cos * (2<<16) + 0.5 */

/*
//-----------------------------------------------------------------------------
// Table for rows 0,4 - constants are multiplied on cos_4_16
//movq -> w13 w12 w09 w08 w05 w04 w01 w00
// w15 w14 w11 w10 w07 w06 w03 w02
// w29 w28 w25 w24 w21 w20 w17 w16
// w31 w30 w27 w26 w23 w22 w19 w18
*/

__declspec(align(16)) short M128_tab_i_04[] = 
{
  16384, 21407, 16384, 8867, /*movq -> w05 w04 w01 w00 */
	16384, -8867, 16384, -21407, /* w13 w12 w09 w08 */
	16384, 8867, -16384, -21407, /* w07 w06 w03 w02 */
	-16384, 21407, 16384, -8867, /* w15 w14 w11 w10 */
	22725, 19266, 19266, -4520, /* w21 w20 w17 w16 */
	12873, -22725, 4520, -12873, /* w29 w28 w25 w24 */
	12873, 4520, -22725, -12873, /* w23 w22 w19 w18 */
	4520, 19266, 19266, -22725  /* w31 w30 w27 w26 */
};

/* Table for rows 1,7 - constants are multiplied on cos_1_16 */

__declspec(align(16)) short M128_tab_i_17[] =
{
	22725, 29692, 22725, 12299, 
	22725, -12299, 22725, -29692,
	22725, 12299, -22725, -29692,
	-22725, 29692, 22725, -12299,
	31521, 26722, 26722, -6270, 
	17855, -31521, 6270, -17855,
	17855, 6270, -31521, -17855,
	6270, 26722, 26722, -31521 
};

/* Table for rows 2,6 - constants are multiplied on cos_2_16 */

__declspec(align(16)) short M128_tab_i_26[] =
{
	21407, 27969, 21407, 11585, 
	21407, -11585, 21407, -27969,
	21407, 11585, -21407, -27969,
	-21407, 27969, 21407, -11585,
	29692, 25172, 25172, -5906, 
	16819, -29692, 5906, -16819,
	16819, 5906, -29692, -16819,
	5906, 25172, 25172, -29692 
};

/* Table for rows 3,5 - constants are multiplied on cos_3_16 */

__declspec(align(16)) short M128_tab_i_35[] = 
{
	19266, 25172, 19266, 10426, 
	19266, -10426, 19266, -25172,
	19266, 10426, -19266, -25172,
	-19266, 25172, 19266, -10426,
	26722, 22654, 22654, -5315, 
	15137, -26722, 5315, -15137,
	15137, 5315, -26722, -15137,
	5315, 22654, 22654, -26722 
};

/*xmm7 = round_inv_row*/
#define DCT_8_INV_ROW __asm{ \
	__asm pshuflw xmm0, xmm0, 0xD8 \
	__asm pshufd xmm1, xmm0, 0 \
	__asm pmaddwd xmm1, [esi] \
	__asm pshufd xmm3, xmm0, 0x55 \
	__asm pshufhw xmm0, xmm0, 0xD8 \
	__asm pmaddwd xmm3, [esi+32] \
	__asm pshufd xmm2, xmm0, 0xAA \
	__asm pshufd xmm0, xmm0, 0xFF \
	__asm pmaddwd xmm2, [esi+16] \
	__asm pshufhw xmm4, xmm4, 0xD8 \
	__asm paddd xmm1, M128_round_inv_row \
	__asm pshuflw xmm4, xmm4, 0xD8 \
	__asm pmaddwd xmm0, [esi+48] \
	__asm pshufd xmm5, xmm4, 0 \
	__asm pshufd xmm6, xmm4, 0xAA \
	__asm pmaddwd xmm5, [ecx] \
	__asm paddd xmm1, xmm2 \
	__asm movdqa xmm2, xmm1 \
	__asm pshufd xmm7, xmm4, 0x55 \
	__asm pmaddwd xmm6, [ecx+16] \
	__asm paddd xmm0, xmm3 \
	__asm pshufd xmm4, xmm4, 0xFF \
	__asm psubd xmm2, xmm0 \
	__asm pmaddwd xmm7, [ecx+32] \
	__asm paddd xmm0, xmm1 \
	__asm psrad xmm2, 12 \
	__asm paddd xmm5, M128_round_inv_row \
	__asm pmaddwd xmm4, [ecx+48] \
	__asm paddd xmm5, xmm6 \
	__asm movdqa xmm6, xmm5 \
	__asm psrad xmm0, 12 \
	__asm pshufd xmm2, xmm2, 0x1B \
	__asm packssdw xmm0, xmm2 \
	__asm paddd xmm4, xmm7 \
	__asm psubd xmm6, xmm4 \
	__asm paddd xmm4, xmm5 \
	__asm psrad xmm6, 12 \
	__asm psrad xmm4, 12 \
	__asm pshufd xmm6, xmm6, 0x1B \
	__asm packssdw xmm4, xmm6 \
}
#define DCT_8_INV_COL_8 __asm{ \
	__asm movdqa xmm1, XMMWORD PTR M128_tg_3_16 \
	__asm movdqa xmm2, xmm0 \
	__asm movdqa xmm3, XMMWORD PTR [edx+3*16] \
	__asm pmulhw xmm0, xmm1 \
	__asm pmulhw xmm1, xmm3 \
	__asm movdqa xmm5, XMMWORD PTR M128_tg_1_16 \
	__asm movdqa xmm6, xmm4 \
	__asm pmulhw xmm4, xmm5 \
	__asm paddsw xmm0, xmm2 \
	__asm pmulhw xmm5, [edx+1*16] \
	__asm paddsw xmm1, xmm3 \
	__asm movdqa xmm7, XMMWORD PTR [edx+6*16] \
	__asm paddsw xmm0, xmm3 \
	__asm movdqa xmm3, XMMWORD PTR M128_tg_2_16 \
	__asm psubsw xmm2, xmm1 \
	__asm pmulhw xmm7, xmm3 \
	__asm movdqa xmm1, xmm0 \
	__asm pmulhw xmm3, [edx+2*16] \
	__asm psubsw xmm5, xmm6 \
	__asm paddsw xmm4, [edx+1*16] \
	__asm paddsw xmm0, xmm4 \
	__asm paddsw xmm0, XMMWORD PTR M128_one_corr \
	__asm psubsw xmm4, xmm1 \
	__asm movdqa xmm6, xmm5 \
	__asm psubsw xmm5, xmm2 \
	__asm paddsw xmm5, XMMWORD PTR M128_one_corr \
	__asm paddsw xmm6, xmm2 \
	__asm movdqa [edx+7*16], xmm0 \
	__asm movdqa xmm1, xmm4 \
	__asm movdqa xmm0, XMMWORD PTR M128_cos_4_16 \
	__asm paddsw xmm4, xmm5 \
	__asm movdqa xmm2, XMMWORD PTR M128_cos_4_16 \
	__asm pmulhw xmm2, xmm4 \
	__asm movdqa [edx+3*16], xmm6 \
	__asm psubsw xmm1, xmm5 \
	__asm paddsw xmm7, [edx+2*16] \
	__asm psubsw xmm3, [edx+6*16] \
	__asm movdqa xmm6, [edx] \
	__asm pmulhw xmm0, xmm1 \
	__asm movdqa xmm5, [edx+4*16] \
	__asm paddsw xmm5, xmm6 \
	__asm psubsw xmm6, [edx+4*16] \
	__asm paddsw xmm4, xmm2 \
	__asm por xmm4, XMMWORD PTR M128_one_corr \
	__asm paddsw xmm0, xmm1 \
	__asm por xmm0, XMMWORD PTR M128_one_corr \
	__asm movdqa xmm2, xmm5 \
	__asm paddsw xmm5, xmm7 \
	__asm movdqa xmm1, xmm6 \
	__asm paddsw xmm5, XMMWORD PTR M128_round_inv_col \
	__asm psubsw xmm2, xmm7 \
	__asm movdqa xmm7, [edx+7*16] \
	__asm paddsw xmm6, xmm3 \
	__asm paddsw xmm6, XMMWORD PTR M128_round_inv_col \
	__asm paddsw xmm7, xmm5 \
	__asm psraw xmm7, SHIFT_INV_COL \
	__asm psubsw xmm1, xmm3 \
	__asm paddsw xmm1, XMMWORD PTR M128_round_inv_corr \
	__asm movdqa xmm3, xmm6 \
	__asm paddsw xmm2, XMMWORD PTR M128_round_inv_corr \
	__asm paddsw xmm6, xmm4 \
	__asm movdqa [edx], xmm7 \
	__asm psraw xmm6, SHIFT_INV_COL \
	__asm movdqa xmm7, xmm1 \
	__asm paddsw xmm1, xmm0 \
	__asm movdqa [edx+1*16], xmm6 \
	__asm psraw xmm1, SHIFT_INV_COL \
	__asm movdqa xmm6, [edx+3*16] \
	__asm psubsw xmm7, xmm0 \
	__asm psraw xmm7, SHIFT_INV_COL \
	__asm movdqa [edx+2*16], xmm1 \
	__asm psubsw xmm5, [edx+7*16] \
	__asm psraw xmm5, SHIFT_INV_COL \
	__asm movdqa [edx+7*16], xmm5 \
	__asm psubsw xmm3, xmm4 \
	__asm paddsw xmm6, xmm2 \
	__asm psubsw xmm2, [edx+3*16] \
	__asm psraw xmm6, SHIFT_INV_COL \
	__asm psraw xmm2, SHIFT_INV_COL \
	__asm movdqa [edx+3*16], xmm6 \
	__asm psraw xmm3, SHIFT_INV_COL \
	__asm movdqa [edx+4*16], xmm2 \
	__asm movdqa [edx+5*16], xmm7 \
	__asm movdqa [edx+6*16], xmm3 \
}

/* assumes src and destination are aligned on a 16-byte boundary */

static void idct_M128ASM(short* src)
{
  /*ASSERT(((DWORD)src & 0xf) == 0);*/ /* aligned on 16-byte boundary */

	__asm mov edx, src

	__asm movdqa xmm0, XMMWORD PTR[edx] //row 1
	__asm lea esi, M128_tab_i_04
	__asm movdqa xmm4, XMMWORD PTR[edx+16*2] //row 3
	__asm lea ecx, M128_tab_i_26
	DCT_8_INV_ROW; //Row 1, tab_i_04 and Row 3, tab_i_26
	__asm movdqa XMMWORD PTR[edx], xmm0
	__asm movdqa XMMWORD PTR[edx+16*2], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*4] //row 5
	//__asm lea esi, M128_tab_i_04
	__asm movdqa xmm4, XMMWORD PTR[edx+16*6] //row 7
	//__asm lea ecx, M128_tab_i_26
	DCT_8_INV_ROW; //Row 5, tab_i_04 and Row 7, tab_i_26
	__asm movdqa XMMWORD PTR[edx+16*4], xmm0
	__asm movdqa XMMWORD PTR[edx+16*6], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*3] //row 4
	__asm lea esi, M128_tab_i_35
	__asm movdqa xmm4, XMMWORD PTR[edx+16*1] //row 2
	__asm lea ecx, M128_tab_i_17
	DCT_8_INV_ROW; //Row 4, tab_i_35 and Row 2, tab_i_17
	__asm movdqa XMMWORD PTR[edx+16*3], xmm0
	__asm movdqa XMMWORD PTR[edx+16*1], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*5] //row 6
	//__asm lea esi, M128_tab_i_35
	__asm movdqa xmm4, XMMWORD PTR[edx+16*7] //row 8
	//__asm lea ecx, M128_tab_i_17
	DCT_8_INV_ROW; //Row 6, tab_i_35 and Row 8, tab_i_17
	//__asm movdqa XMMWORD PTR[edx+80], xmm0
	//__asm movdqa xmm0, XMMWORD PTR [edx+80] /* 0 /* x5 */
	//__asm movdqa XMMWORD PTR[edx+16*7], xmm4
	//__asm movdqa xmm4, XMMWORD PTR [edx+7*16]/* 4 ; x7 */
	DCT_8_INV_COL_8
	// __asm emms
}



#else

/*
//-----------------------------------------------------------------------------

;=============================================================================
;=============================================================================
;=============================================================================
;
; Inverse DCT
;
;-----------------------------------------------------------------------------
;
; This implementation calculates iDCT-2D by a row-column method.
; On the first stage the iDCT-1D is calculated for each row with use
; direct algorithm, on the second stage the calculation is executed
; at once for four columns with use of scaled iDCT-1D algorithm.
; Base R&Y algorithm for iDCT-1D is modified for second stage.
;
;=============================================================================
;-----------------------------------------------------------------------------
;
; The first stage - inverse DCTs of rows
;
;-----------------------------------------------------------------------------
; The 8-point inverse DCT direct algorithm
;-----------------------------------------------------------------------------
;*/

__declspec(align(16)) short tab_i_04[] = 
{
  16384, 21407, 16384, 8867,
  16384, 8867, -16384, -21407,
  16384, -8867, -16384, 21407,
  16384, -21407, 16384, -8867,
  22725, 19266, 12873, 4520,
  19266, -4520, -22725, -12873,
  12873, -22725, 4520, 19266,
  4520, -12873, 19266, -22725,
};

/* Table for rows 1,7 - constants are multiplied on cos_1_16 */

__declspec(align(16)) short tab_i_17[] =
{
  22725, 29692, 22725, 12299,
  22725, 12299, -22725, -29692,
  22725, -12299, -22725, 29692,
  22725, -29692, 22725, -12299,
  31521, 26722, 17855, 6270,
  26722, -6270, -31521, -17855,
  17855, -31521, 6270, 26722,
  6270, -17855, 26722, -31521,
};

/* Table for rows 2,6 - constants are multiplied on cos_2_16 */

__declspec(align(16)) short tab_i_26[] =
{
  21407, 27969, 21407, 11585,
  21407, 11585, -21407, -27969,
  21407, -11585, -21407, 27969,
  21407, -27969, 21407, -11585,
  29692, 25172, 16819, 5906,
  25172, -5906, -29692, -16819,
  16819, -29692, 5906, 25172,
  5906, -16819, 25172, -29692,
};

/* Table for rows 3,5 - constants are multiplied on cos_3_16 */

__declspec(align(16)) short tab_i_35[] = 
{
  19266, 25172, 19266, 10426,
  19266, 10426, -19266, -25172,
  19266, -10426, -19266, 25172,
  19266, -25172, 19266, -10426,
  26722, 22654, 15137, 5315,
  22654, -5315, -26722, -15137,
  15137, -26722, 5315, 22654,
  5315, -15137, 22654, -26722,
};


#define SHIFT_ROUND_ROW(x) (((x)+RND_INV_ROW)>>SHIFT_INV_ROW)

/*
  static const short w[32] = {
  FIX(cos_4_16), FIX(cos_2_16), FIX(cos_4_16), FIX(cos_6_16),
  FIX(cos_4_16), FIX(cos_6_16), -FIX(cos_4_16), -FIX(cos_2_16),
  FIX(cos_4_16), -FIX(cos_6_16), -FIX(cos_4_16), FIX(cos_2_16),
  FIX(cos_4_16), -FIX(cos_2_16), FIX(cos_4_16), -FIX(cos_6_16),
  FIX(cos_1_16), FIX(cos_3_16), FIX(cos_5_16), FIX(cos_7_16),
  FIX(cos_3_16), -FIX(cos_7_16), -FIX(cos_1_16), -FIX(cos_5_16),
  FIX(cos_5_16), -FIX(cos_1_16), FIX(cos_7_16), FIX(cos_3_16),
  FIX(cos_7_16), -FIX(cos_5_16), FIX(cos_3_16), -FIX(cos_1_16) };
*/

#define DCT_8_INV_ROW_SCALAR(x, y, w) \
{ \
  int a0, a1, a2, a3, b0, b1, b2, b3; \
 \
  a0 = x[0] * w[ 0] + x[2] * w[ 1] + x[4] * w[ 2] + x[6] * w[ 3]; \
  a1 = x[0] * w[ 4] + x[2] * w[ 5] + x[4] * w[ 6] + x[6] * w[ 7]; \
  a2 = x[0] * w[ 8] + x[2] * w[ 9] + x[4] * w[10] + x[6] * w[11];\
  a3 = x[0] * w[12] + x[2] * w[13] + x[4] * w[14] + x[6] * w[15];\
  b0 = x[1] * w[16] + x[3] * w[17] + x[5] * w[18] + x[7] * w[19];\
  b1 = x[1] * w[20] + x[3] * w[21] + x[5] * w[22] + x[7] * w[23];\
  b2 = x[1] * w[24] + x[3] * w[25] + x[5] * w[26] + x[7] * w[27];\
  b3 = x[1] * w[28] + x[3] * w[29] + x[5] * w[30] + x[7] * w[31];\
\
  y[0] = SHIFT_ROUND_ROW ( a0 + b0 );\
  y[1] = SHIFT_ROUND_ROW ( a1 + b1 );\
  y[2] = SHIFT_ROUND_ROW ( a2 + b2 );\
  y[3] = SHIFT_ROUND_ROW ( a3 + b3 );\
  y[4] = SHIFT_ROUND_ROW ( a3 - b3 );\
  y[5] = SHIFT_ROUND_ROW ( a2 - b2 );\
  y[6] = SHIFT_ROUND_ROW ( a1 - b1 );\
  y[7] = SHIFT_ROUND_ROW ( a0 - b0 );\
}

/*
;-----------------------------------------------------------------------------
;
; In this implementation the outputs of the iDCT-1D are multiplied
; for rows 0,4 - on cos_4_16,
; for rows 1,7 - on cos_1_16,
; for rows 2,6 - on cos_2_16,
; for rows 3,5 - on cos_3_16
; and are shifted to the left for rise of accuracy
;
; For used constants
; FIX(float_const) = (short) (float_const * (1<<15) + 0.5)
;
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;
; The second stage - inverse DCTs of columns
;
; The inputs are multiplied
; for rows 0,4 - on cos_4_16,
; for rows 1,7 - on cos_1_16,
; for rows 2,6 - on cos_2_16,
; for rows 3,5 - on cos_3_16
; and are shifted to the left for rise of accuracy
;
;-----------------------------------------------------------------------------
;
; The 8-point scaled inverse DCT algorithm (26a8m)
;
;-----------------------------------------------------------------------------
;
*/

#define SHIFT_COL(x)  ((x)>>SHIFT_INV_COL)
#define CLIP(x)  ((x)>32767?32767:(((x)<-32768)?-32768:(x)))
#define tg_1_16 13036
#define tg_2_16  27146
#define tg_3_16  -21746
#define cos_4_16 -19195

#define DCT_8_INV_COL(x, y)				\
  {							\
    int t0, t1, t2, t3, t4, t5, t6, t7;			\
    int tp03, tm03, tp12, tm12, tp65, tm65;		\
    int tp465, tm465, tp765, tm765;			\
							\
    tp765 = x[8*1] + (((int) x[8*7] * tg_1_16)>>16);		\
    tp465 = (((int)x[8*1] * tg_1_16)>>16) - x[8*7];		\
    tm765 = (((int)x[8*5] * tg_3_16)>>16) + x[8*5] + x[8*3];	\
    tm465 = x[8*5] - (((int)x[8*3] * tg_3_16)>>16)-x[8*3];		\
								\
    t7 = tp765 + tm765 + 1;					\
    tp65 = tp765 - tm765;				\
    t4 = tp465 + tm465;					\
    tm65 = tp465 - tm465 + 1;				\
							\
    t6 = (((int)( tp65 + tm65 ) * cos_4_16)>>16)|0x1;	\
    t6 += tp65+tm65;					\
    t5 = (((int)( tp65 - tm65 ) * cos_4_16)>>16)|0x1;	\
    t5 += (tp65-tm65);					\
							\
    tp03 = x[8*0] + x[8*4];				\
    tp12 = x[8*0] - x[8*4];				\
							\
    tm03 = x[8*2] + (((int)x[8*6] * tg_2_16)>>16);	\
    tm12 = (((int)x[8*2] * tg_2_16)>>16) - x[8*6];	\
    							\
    t0 = tp03 + tm03+RND_INV_COL;			\
    t3 = tp03 - tm03+RND_INV_CORR;			\
    t1 = tp12 + tm12+RND_INV_COL;			\
    t2 = tp12 - tm12+RND_INV_CORR;   			\
    							\
    y[8*0] = SHIFT_COL ( CLIP(t0 + t7 ));		\
    y[8*7] = SHIFT_COL (  CLIP(t0 - t7 ));	\
    y[8*1] = SHIFT_COL (  CLIP(t1 + t6 ));	\
    y[8*6] = SHIFT_COL (  CLIP(t1 - t6 ));	\
    y[8*2] = SHIFT_COL (  CLIP(t2 + t5 ));	\
    y[8*5] = SHIFT_COL (  CLIP(t2 - t5 ));	\
    y[8*3] = SHIFT_COL (  CLIP(t3 + t4 ));	\
    y[8*4] = SHIFT_COL (  CLIP(t3 - t4 ));	\
  }



static void idct_M128ASM_scalar(short* src)
{
  /*04 17 26 35 */
  DCT_8_INV_ROW_SCALAR(src,src,tab_i_04);
  DCT_8_INV_ROW_SCALAR((src+8*4),(src+8*4),tab_i_04);

  DCT_8_INV_ROW_SCALAR((src+8),(src+8),tab_i_17);
  DCT_8_INV_ROW_SCALAR((src+8*7),(src+8*7),tab_i_17);

  DCT_8_INV_ROW_SCALAR((src+8*2),(src+8*2),tab_i_26);
  DCT_8_INV_ROW_SCALAR((src+8*6),(src+8*6),tab_i_26);

  DCT_8_INV_ROW_SCALAR((src+8*3),(src+8*3),tab_i_35);
  DCT_8_INV_ROW_SCALAR((src+8*5),(src+8*5),tab_i_35);

  DCT_8_INV_COL(src, src);
  DCT_8_INV_COL((src+1),(src+1));
  DCT_8_INV_COL((src+2),(src+2));
  DCT_8_INV_COL((src+3),(src+3));
  DCT_8_INV_COL((src+4),(src+4));
  DCT_8_INV_COL((src+5),(src+5));
  DCT_8_INV_COL((src+6),(src+6));
  DCT_8_INV_COL((src+7),(src+7));
}

#endif
#endif
#endif
/*
  ;
  ;-----------------------------------------------------------------------------
*/



/* two dimensional inverse discrete cosine transform */
void Fast_IDCT(block)
short *block;
{
#if (ORIGINAL_IDCT)
    int i;
    for (i=0; i<8; i++)
      idctrow(block+8*i);
    
    for (i=0; i<8; i++)
      idctcol(block+i);
#elif (MATRIX_IDCT)
    int i, j, k;
    int s;
    __declspec(align(16)) short tmp[64];
#ifdef SSE2

    short *b_p, *icp, *tmp_p, *b2_p;

    /* not the most elegant approach, can be improved with other fast IDCT 
       methods out there */
    
    b_p = block;/*block+8*i;*/
    icp = &ic[0][0];
    tmp_p = &tmp[0]; /*&tmp[8*i];*/
    b2_p = &block[63];

    /*	
    for (i=0; i<8; i++) {

      for (j=0; j<8; j++) {
      
        s=0;

        for (k=0; k<8; k++)
          s += ic[j][k] * block[8*i+k];          

        tmp[8*i+j] = s >> 15;
      }
    }
    */
    __asm 
	{
	  mov   ecx, [b2_p]          ;
	  mov   ebx, [b_p]        ; /*load blk ptr*/
	  mov   edx, [icp]       ; /*load ic ptr */
	  mov   eax, [tmp_p]    ;
      
	idct_row_loop:
	  movdqa   xmm0, [ebx]      ; /*load 8 shorts from block*/
	  movdqa   xmm1, [edx]         ; /*ic[0][0..7]*/
	  movdqa   xmm2, [edx+16]      ; /*ic[1][0..7]*/
	  movdqa   xmm3, [edx+32]      ; /*ic[2][0..7]*/
	  movdqa   xmm4, [edx+48]      ; /*ic[3][0..7]*/

	  movdqa   xmm7, [edx+64]      ; /*ic[4][0..7]*/

	  pmaddwd xmm1, xmm0     ; /* xmms : 4 32-bit partial sums */
	  pmaddwd xmm2, xmm0     ;
	  pmaddwd xmm3, xmm0     ;
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm7, xmm0     ;

	  movdqa  xmm5, xmm1     ;
	  movdqa  xmm6, xmm3     ;

	  unpcklpd xmm1, xmm2    ; /*xmm1: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm5, xmm2    ; /*xmm5: 2.3 2.2 1.3 1.2 */

	  movdqa   xmm2, [edx+80]      ; /*ic[5][0..7]*/

	  unpcklpd xmm3, xmm4    ;
	  unpckhpd xmm6, xmm4    ;

	  movdqa   xmm4, [edx+96]      ; /*ic[6][0..7]*/
	  pmaddwd  xmm2, xmm0    ;

	  paddd  xmm6, xmm3      ; 

	  movdqa   xmm3, [edx+112]      ; /*ic[7][0..7]*/
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm3, xmm0     ; /*2nd batch, 7,2,4,3 */

	  paddd  xmm5, xmm1      ; /*xmm5: 2.a 2.b | 1.a 1.b */

	  movdqa xmm1, xmm5      ;
	  shufps  xmm1, xmm6, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm5, xmm6, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */
	  
	  movdqa xmm6, xmm7      ;

	  paddd  xmm1, xmm5      ;

	  movdqa xmm5, xmm4      ;
	  
	  unpcklpd xmm7, xmm2    ; /*xmm7: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm6, xmm2    ; /*xmm6: 2.3 2.2 1.3 1.2 */

	  unpcklpd xmm4, xmm3    ;
	  unpckhpd xmm5, xmm3    ;

	  paddd xmm6, xmm7       ;
	  paddd xmm5, xmm4       ;

	  movdqa xmm2, xmm6      ;
	  shufps  xmm2, xmm5, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm6, xmm5, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */

	  paddd xmm2, xmm6       ;

	  psrad  xmm1, 15        ;
	  psrad  xmm2, 15         ;

	  packssdw xmm1, xmm2    ;

	  movdqa [eax], xmm1     ;

	  add   ebx, 16         ;
	  add   eax, 16         ;

	  cmp   ebx, ecx        ;
	  jb    idct_row_loop   ;
	  
	  ; /* start of second phase */
	mov edx, [tmp_p]        ; /* load tmp blk ptr */
	mov eax, [icp]          ; /* load coeffs table ptr*/
	mov ebx, [b_p]          ;
	mov edi, [b2_p]         ;

      idct_col_outer:
	movdqa xmm6, [eax]      ; /* load ic[0][0..7] */
	
	pxor xmm4, xmm4         ;
	pxor xmm5, xmm5         ;
	mov  ecx, 8             ;

      idct_col_loop:
	movdqa xmm1, [edx]      ; /* load tmp[0][0..7] */
	pshuflw xmm0, xmm6, 0   ; /* copy the lowest word to all positions */
	;pshuflw xmm0, xmm0, 0   ;
	pshufd xmm0, xmm0, 0
	psrldq  xmm6, 2         ; /* prepare for next word*/
	
	movdqa xmm2, xmm0       ;
	pmulhw xmm2, xmm1       ; /*multiply them */
	pmullw xmm0, xmm1       ; /*2 :high words 1: low words */

	movdqa xmm3, xmm0       ; /*3 : low words */
	punpckhwd xmm0,xmm2     ; /*1 : left half, 4 32-bit */
	punpcklwd xmm3,xmm2    ; /*3 : right half, 4 32-bit */

	paddd xmm4, xmm0      ; /*accumulate */
	paddd xmm5, xmm3      ; /*4 : left, 5 : right*/

	add  edx, 16          ;
	
	loop idct_col_loop    ; /* end of inner loop */

	sub  edx, 128           ;
	psrad xmm4, 15        ; /*s >> 15 */
	psrad xmm5, 15        ;
	
	packssdw xmm5, xmm4   ;

	movdqa [ebx], xmm5    ; /*store to block[i][j]*/

	add  ebx, 16          ;
	add  eax, 16          ;
	cmp  ebx, edi         ;
	jb   idct_col_outer   ;
      }
#else /* NON-SSE2 code */

    for (i=0; i<8; i++) { 

      for (j=0; j<8; j++) { 

	s = 0;
	
	for (k=0; k<8; k++)
	  s += ic[j][k] * block[8*i+k];          /* this is block[i][k] */
	tmp[8*i+j] = s >> 15;                         /* this is block[i][j] */

      }  /* for j */

    } /* for i */
    

    /* 	simd multiplication of AxB = C is done as follows:
	If col_dim(A) == N
  	To produce row C[0]

	For i=0 to N-1 {

		// each element in the 0th row of A is multiplied by
		// all elements in row B[i] and a running sum is kep in sum

		sum[0..N-1] = A[0][i] * B[k][0..N-1]   

	} 

	C[0][0..N]  = sum[0..N];

        If we do the above loop for all rows of A, we can produce C entirely.
   */



    for (j=0; j<8; j++) {
      

      for (i=0; i<8; i++) {

	s = 0;
	
	for (k=0; k<8; k++)
	  s += ic[i][k] * tmp[8*k+j];
	block[8*i+j] =  s >> 15;
	
      } /* end of i */

    } /* end of j */

#endif /* end non-SSE2 */

#else /* INTEL IDCT */
#ifdef SSE2
    idct_M128ASM(block);
#else
    idct_M128ASM_scalar(block);
#endif
#endif
}


void Initialize_Fast_IDCT()
{
  int i, j;
  double s;

#if 0
  iclp = iclip+512;
  for (i= -512; i<512; i++)
    iclp[i] = (i<-256) ? -256 : ((i>255) ? 255 : i);
#endif

#if MATRIX_IDCT
  for (j=0; j<8; j++) {
    for (i=0; i<8; i++) {
      s = (i==0) ? sqrt(0.125) : 0.5;
      
      ic[j][i] = (short) ((s * cos((PI/8.0)*i*(j+0.5)) * 32768) + 0.5); 
    }
  }
#endif
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* Reference_IDCT.c, Inverse Discrete Fourier Transform, double precision          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/*  Perform IEEE 1180 reference (64-bit floating point, separable 8x1
 *  direct matrix multiply) Inverse Discrete Cosine Transform
*/


/* Here we use math.h to generate constants.  Compiler results may
   vary a little */

#include <math.h>

#include "config.h"

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

/* global declarations */
void Initialize_Fast_IDCTref _ANSI_ARGS_((void));
void Reference_IDCT _ANSI_ARGS_((short *block));

/* private data */

/* cosine transform matrix for 8x1 IDCT */
static double c[8][8];

/* initialize DCT coefficient matrix */

void Initialize_Reference_IDCT()
{
  int freq, time;
  double scale;

  for (freq=0; freq < 8; freq++)
  {
    scale = (freq == 0) ? sqrt(0.125) : 0.5;
    for (time=0; time<8; time++)
      c[freq][time] = scale*cos((PI/8.0)*freq*(time + 0.5));
  }
}

/* perform IDCT matrix multiply for 8x8 coefficient block */

void Reference_IDCT(block)
short *block;
{
  int i, j, k, v;
  double partial_product;
  double tmp[64];

  for (i=0; i<8; i++)
    for (j=0; j<8; j++)
    {
      partial_product = 0.0;

      for (k=0; k<8; k++)
        partial_product+= c[k][j]*block[8*i+k];

      tmp[8*i+j] = partial_product;
    }

  /* Transpose operation is integrated into address mapping by switching 
     loop order of i and j */

  for (j=0; j<8; j++)
    for (i=0; i<8; i++)
    {
      partial_product = 0.0;

      for (k=0; k<8; k++)
        partial_product+= c[k][i]*tmp[8*k+j];

      v = (int) floor(partial_product+0.5);
      block[8*i+j] = (v<-256) ? -256 : ((v>255) ? 255 : v);
    }
}
# Makefile for mpeg2decode

# Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved.

#
# Disclaimer of Warranty
#
# These software programs are available to the user without any license fee or
# royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
# any and all warranties, whether express, implied, or statuary, including any
# implied warranties or merchantability or of fitness for a particular
# purpose.  In no event shall the copyright-holder be liable for any
# incidental, punitive, or consequential damages of any kind whatsoever
# arising from the use of these programs.
#
# This disclaimer of warranty extends to the user of these programs and user's
# customers, employees, agents, transferees, successors, and assigns.
#
# The MPEG Software Simulation Group does not represent or warrant that the
# programs furnished hereunder are free of infringement of any third-party
# patents.
#
# Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
# are subject to royalty fees to patent holders.  Many of these patents are
# general enough such that they are unavoidable regardless of implementation
# design.
#
#

#WARNINGS = -Wall
#VERIFY = -DVERIFY

#disable this flag if you do not want bitstream element tracing 
#this will speed up the decoder some since it does not have to test
#the trace flag at several critical inner loop locations.
#TRACE = -DTRACE

#disable this flag if you do not need verbose trace, such as
#header information
VERBOSE = -DVERBOSE

# uncomment the following two lines if you want to include X11 support

USE_DISP = -DDISPLAY #-DTHRD -DNUM_THREADS=8 -DINT_IDCT
LIBS = -lpthread -lX11

# uncomment the following two lines if you want to use shared memory
# (faster display if server and client run on the same machine)

#USE_SHMEM = -DSH_MEM
#LIBS = -lXext -lX11

# if your X11 include files / libraries are in a non standard location:
# set INCLUDEDIR to -I followed by the appropriate include file path and
# set LIBRARYDIR to -L followed by the appropriate library path and

INCLUDEDIR = -I/usr/X11R6/include
LIBRARYDIR = -L/usr/X11R6/lib

#
# GNU gcc
#
CC = gcc
CFLAGS = -g -O4 $(USE_DISP) $(USE_SHMEM) $(INCLUDEDIR) $(TRACE) $(VERBOSE) $(VERIFY) $(WARNINGS)

OBJ = mpeg2dec.o getpic.o motion.o getvlc.o gethdr.o getblk.o getbits.o store.o recon.o spatscal.o idct.o idctref.o display.o systems.o subspic.o verify.o

all: mpeg2decode

pc: mpeg2dec.exe

clean:
	rm -f *.o *% core mpeg2decode

mpeg2dec.exe: mpeg2decode
	coff2exe mpeg2dec

mpeg2decode: $(OBJ)
	$(CC) $(CFLAGS) $(LIBRARYDIR) -o mpeg2decode $(OBJ) -lm $(LIBS)

display.o : display.c config.h global.h mpeg2dec.h 
getbits.o : getbits.c config.h global.h mpeg2dec.h 
getblk.o : getblk.c config.h global.h mpeg2dec.h 
gethdr.o : gethdr.c config.h global.h mpeg2dec.h 
getpic.o : getpic.c config.h global.h mpeg2dec.h 
getvlc.o : getvlc.c config.h global.h mpeg2dec.h getvlc.h 
idct.o : idct.c config.h 
idctref.o : idctref.c config.h 
motion.o : motion.c config.h global.h mpeg2dec.h 
mpeg2dec.o : mpeg2dec.c config.h global.h mpeg2dec.h 
recon.o : recon.c config.h global.h mpeg2dec.h 
spatscal.o : spatscal.c config.h global.h mpeg2dec.h 
store.o : store.c config.h global.h mpeg2dec.h 

# additions since July 4, 1994 edition
systems.o : systems.c config.h global.h mpeg2dec.h 
subspic.o : subspic.c config.h global.h mpeg2dec.h 
verify.o:   verify.c config.h global.h mpeg2dec.h
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* motion.c, motion vector decoding                                         */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>

#include "config.h"
#include "global.h"

/* private prototypes */
static void decode_motion_vector _ANSI_ARGS_((int *pred, int r_size, int motion_code,
  int motion_residualesidual, int full_pel_vector));

/* ISO/IEC 13818-2 sections 6.2.5.2, 6.3.17.2, and 7.6.3: Motion vectors */
void motion_vectors(PMV,dmvector,
  motion_vertical_field_select,s,motion_vector_count,mv_format,h_r_size,v_r_size,dmv,mvscale)
int PMV[2][2][2];
int dmvector[2];
int motion_vertical_field_select[2][2];
int s, motion_vector_count, mv_format, h_r_size, v_r_size, dmv, mvscale;
{
  if (motion_vector_count==1)
  {
    if (mv_format==MV_FIELD && !dmv)
    {
      motion_vertical_field_select[1][s] = motion_vertical_field_select[0][s] = Get_Bits(1);
#ifdef TRACE
      if (Trace_Flag)
      {
        printf("motion_vertical_field_select[][%d] (%d): %d\n",s,
          motion_vertical_field_select[0][s],motion_vertical_field_select[0][s]);
      }
#endif /* TRACE */
    }

    motion_vector(PMV[0][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);

    /* update other motion vector predictors */
    PMV[1][s][0] = PMV[0][s][0];
    PMV[1][s][1] = PMV[0][s][1];
  }
  else
  {
    motion_vertical_field_select[0][s] = Get_Bits(1);
#ifdef TRACE
    if (Trace_Flag)
    {
      printf("motion_vertical_field_select[0][%d] (%d): %d\n",s,
        motion_vertical_field_select[0][s],motion_vertical_field_select[0][s]);
    }
#endif /* TRACE */
    motion_vector(PMV[0][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);

    motion_vertical_field_select[1][s] = Get_Bits(1);
#ifdef TRACE
    if (Trace_Flag)
    {
      printf("motion_vertical_field_select[1][%d] (%d): %d\n",s,
        motion_vertical_field_select[1][s],motion_vertical_field_select[1][s]);
    }
#endif /* TRACE */
    motion_vector(PMV[1][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);
  }
}

/* get and decode motion vector and differential motion vector 
   for one prediction */
void motion_vector(PMV,dmvector,
  h_r_size,v_r_size,dmv,mvscale,full_pel_vector)
int *PMV;
int *dmvector;
int h_r_size;
int v_r_size;
int dmv; /* MPEG-2 only: get differential motion vectors */
int mvscale; /* MPEG-2 only: field vector in frame pic */
int full_pel_vector; /* MPEG-1 only */
{
  int motion_code, motion_residual;

  /* horizontal component */
  /* ISO/IEC 13818-2 Table B-10 */
  motion_code = Get_motion_code();

  motion_residual = (h_r_size!=0 && motion_code!=0) ? Get_Bits(h_r_size) : 0;

#ifdef TRACE
  if (Trace_Flag)
  {
    if (h_r_size!=0 && motion_code!=0)
    {
      printf("motion_residual (");
      Print_Bits(motion_residual,h_r_size,h_r_size);
      printf("): %d\n",motion_residual);
    }
  }
#endif /* TRACE */


  decode_motion_vector(&PMV[0],h_r_size,motion_code,motion_residual,full_pel_vector);

  if (dmv)
    dmvector[0] = Get_dmvector();


  /* vertical component */
  motion_code     = Get_motion_code();
  motion_residual = (v_r_size!=0 && motion_code!=0) ? Get_Bits(v_r_size) : 0;

#ifdef TRACE
  if (Trace_Flag)
  {
    if (v_r_size!=0 && motion_code!=0)
    {
      printf("motion_residual (");
      Print_Bits(motion_residual,v_r_size,v_r_size);
      printf("): %d\n",motion_residual);
    }
  }
#endif /* TRACE */

  if (mvscale)
    PMV[1] >>= 1; /* DIV 2 */

  decode_motion_vector(&PMV[1],v_r_size,motion_code,motion_residual,full_pel_vector);

  if (mvscale)
    PMV[1] <<= 1;

  if (dmv)
    dmvector[1] = Get_dmvector();

#ifdef TRACE
  if (Trace_Flag)
    printf("PMV = %d,%d\n",PMV[0],PMV[1]);
#endif /* TRACE */
}

/* calculate motion vector component */
/* ISO/IEC 13818-2 section 7.6.3.1: Decoding the motion vectors */
/* Note: the arithmetic here is more elegant than that which is shown 
   in 7.6.3.1.  The end results (PMV[][][]) should, however, be the same.  */

static void decode_motion_vector(pred,r_size,motion_code,motion_residual,full_pel_vector)
int *pred;
int r_size, motion_code, motion_residual;
int full_pel_vector; /* MPEG-1 (ISO/IEC 11172-1) support */
{
  int lim, vec;

  lim = 16<<r_size;
  vec = full_pel_vector ? (*pred >> 1) : (*pred);

  if (motion_code>0)
  {
    vec+= ((motion_code-1)<<r_size) + motion_residual + 1;
    if (vec>=lim)
      vec-= lim + lim;
  }
  else if (motion_code<0)
  {
    vec-= ((-motion_code-1)<<r_size) + motion_residual + 1;
    if (vec<-lim)
      vec+= lim + lim;
  }
  *pred = full_pel_vector ? (vec<<1) : vec;
}


/* ISO/IEC 13818-2 section 7.6.3.6: Dual prime additional arithmetic */
void Dual_Prime_Arithmetic(DMV,dmvector,mvx,mvy)
int DMV[][2];
int *dmvector; /* differential motion vector */
int mvx, mvy;  /* decoded mv components (always in field format) */
{
  if (picture_structure==FRAME_PICTURE)
  {
    if (top_field_first)
    {
      /* vector for prediction of top field from bottom field */
      DMV[0][0] = ((mvx  +(mvx>0))>>1) + dmvector[0];
      DMV[0][1] = ((mvy  +(mvy>0))>>1) + dmvector[1] - 1;

      /* vector for prediction of bottom field from top field */
      DMV[1][0] = ((3*mvx+(mvx>0))>>1) + dmvector[0];
      DMV[1][1] = ((3*mvy+(mvy>0))>>1) + dmvector[1] + 1;
    }
    else
    {
      /* vector for prediction of top field from bottom field */
      DMV[0][0] = ((3*mvx+(mvx>0))>>1) + dmvector[0];
      DMV[0][1] = ((3*mvy+(mvy>0))>>1) + dmvector[1] - 1;

      /* vector for prediction of bottom field from top field */
      DMV[1][0] = ((mvx  +(mvx>0))>>1) + dmvector[0];
      DMV[1][1] = ((mvy  +(mvy>0))>>1) + dmvector[1] + 1;
    }
  }
  else
  {
    /* vector for prediction from field of opposite 'parity' */
    DMV[0][0] = ((mvx+(mvx>0))>>1) + dmvector[0];
    DMV[0][1] = ((mvy+(mvy>0))>>1) + dmvector[1];

    /* correct for vertical field shift */
    if (picture_structure==TOP_FIELD)
      DMV[0][1]--;
    else
      DMV[0][1]++;
  }
}

#ifdef THRD
void Thrd_motion_vectors(t,PMV,dmvector,
  motion_vertical_field_select,s,motion_vector_count,mv_format,h_r_size,v_r_size,dmv,mvscale)
     int t;
int PMV[2][2][2];
int dmvector[2];
int motion_vertical_field_select[2][2];
int s, motion_vector_count, mv_format, h_r_size, v_r_size, dmv, mvscale;
{
  if (motion_vector_count==1)
  {
    if (mv_format==MV_FIELD && !dmv)
    {
      motion_vertical_field_select[1][s] = motion_vertical_field_select[0][s] = Thrd_Get_Bits(t,1);
    }

    Thrd_motion_vector(t, PMV[0][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);

    /* update other motion vector predictors */
    PMV[1][s][0] = PMV[0][s][0];
    PMV[1][s][1] = PMV[0][s][1];
  }
  else
  {
    motion_vertical_field_select[0][s] = Thrd_Get_Bits(t,1);
    Thrd_motion_vector(t,PMV[0][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);

    motion_vertical_field_select[1][s] = Thrd_Get_Bits(t,1);
    Thrd_motion_vector(t, PMV[1][s],dmvector,h_r_size,v_r_size,dmv,mvscale,0);
  }
}

/* get and decode motion vector and differential motion vector 
   for one prediction */
void Thrd_motion_vector(t,PMV,dmvector,
  h_r_size,v_r_size,dmv,mvscale,full_pel_vector)
int t;
int *PMV;
int *dmvector;
int h_r_size;
int v_r_size;
int dmv; /* MPEG-2 only: get differential motion vectors */
int mvscale; /* MPEG-2 only: field vector in frame pic */
int full_pel_vector; /* MPEG-1 only */
{
  int motion_code, motion_residual;

  /* horizontal component */
  /* ISO/IEC 13818-2 Table B-10 */
  motion_code = Thrd_Get_motion_code(t);

  motion_residual = (h_r_size!=0 && motion_code!=0) ? Thrd_Get_Bits(t,h_r_size) : 0;

  decode_motion_vector(&PMV[0],h_r_size,motion_code,motion_residual,full_pel_vector);

  if (dmv)
    dmvector[0] = Thrd_Get_dmvector(t);


  /* vertical component */
  motion_code     = Thrd_Get_motion_code(t);
  motion_residual = (v_r_size!=0 && motion_code!=0) ? Thrd_Get_Bits(t,v_r_size) : 0;

  if (mvscale)
    PMV[1] >>= 1; /* DIV 2 */
  
  decode_motion_vector(&PMV[1],v_r_size,motion_code,motion_residual,full_pel_vector);

  if (mvscale)
    PMV[1] <<= 1;

  if (dmv)
    dmvector[1] = Thrd_Get_dmvector(t);

}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */



/* mpeg2dec.c, main(), initialization, option processing                    */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>
#include <assert.h>
#include <unistd.h>

#define GLOBAL
#include "config.h"
#include "global.h"

/* private prototypes */
static int  video_sequence _ANSI_ARGS_((int *framenum));
static int Decode_Bitstream _ANSI_ARGS_((void));
static int  Headers _ANSI_ARGS_((void));
static void Initialize_Sequence _ANSI_ARGS_((void));
static void Initialize_Decoder _ANSI_ARGS_((void));
static void Deinitialize_Sequence _ANSI_ARGS_((void));
static void Process_Options _ANSI_ARGS_((int argc, char *argv[]));
#ifdef THRD
static void Initialize_Frame_Buffer _ANSI_ARGS_((void));
#endif

#if OLD
static int  Get_Val _ANSI_ARGS_((char *argv[]));
#endif

/* #define DEBUG */

static void Clear_Options();
#ifdef DEBUG
static void Print_Options();
#endif

int main(argc,argv)
int argc;
char *argv[];
{
  int ret, code;

  Clear_Options();

  /* decode command line arguments */
  Process_Options(argc,argv);

#ifdef DEBUG
  Print_Options();
#endif

  ld = &base; /* select base layer context */

  /* open MPEG base layer bitstream file(s) */
  /* NOTE: this is either a base layer stream or a spatial enhancement stream */
  if ((base.Infile=open(Main_Bitstream_Filename,O_RDONLY|O_BINARY))<0)
  {
    fprintf(stderr,"Base layer input file %s not found\n", Main_Bitstream_Filename);
    exit(1);
  }


  if(base.Infile != 0)
  {
    Initialize_Buffer(); 
  
    if(Show_Bits(8)==0x47)
    {
      sprintf(Error_Text,"Decoder currently does not parse transport streams\n");
      Error(Error_Text);
    }

    next_start_code();
    code = Show_Bits(32);

    switch(code)
    {
    case SEQUENCE_HEADER_CODE:
      break;
    case PACK_START_CODE:
      System_Stream_Flag = 1;
    case VIDEO_ELEMENTARY_STREAM:
      System_Stream_Flag = 1;
      break;
    default:
      sprintf(Error_Text,"Unable to recognize stream type\n");
      Error(Error_Text);
      break;
    }

    lseek(base.Infile, 0l, 0);
    Initialize_Buffer(); 
  }
  assert(!System_Stream_Flag);

  if(base.Infile!=0)
  {
    lseek(base.Infile, 0l, 0);
  }

  Initialize_Buffer(); 

  assert(!Two_Streams&&"I don't support two streams\n");
  if(Two_Streams)
  {
    ld = &enhan; /* select enhancement layer context */

    if ((enhan.Infile = open(Enhancement_Layer_Bitstream_Filename,O_RDONLY|O_BINARY))<0)
    {
      sprintf(Error_Text,"enhancment layer bitstream file %s not found\n",
        Enhancement_Layer_Bitstream_Filename);

      Error(Error_Text);
    }

    Initialize_Buffer();
    ld = &base;
  }

  Initialize_Decoder();
#ifdef THRD
  Initialize_Frame_Buffer();
#endif

  ret = Decode_Bitstream();

  close(base.Infile);

  if (Two_Streams)
    close(enhan.Infile);

  return 0;
}

#ifdef THRD
static void Initialize_Frame_Buffer() {
#if 0 /*alex*/
  frame_buf_size = INIT_BUF_SIZE; /* 2Kb initial buffer size */
  frame_buffer = (unsigned char *) malloc(sizeof(unsigned char)*frame_buf_size);
  frame_buf_offset = 0;
#else
  int i;
  for (i=0; i<NUM_THREADS; i++) {
    tb[i].frame_buf_size = INIT_BUF_SIZE;
    tb[i].frame_buf = 
      (unsigned char *) malloc(sizeof(unsigned char)*INIT_BUF_SIZE);
  }
#endif
}
#endif

/* IMPLEMENTAION specific rouintes */
static void Initialize_Decoder()
{
  int i;

  /* Clip table */
  if (!(Clip=(unsigned char *)malloc(1024)))
    Error("Clip[] malloc failed\n");

  Clip += 384;

  for (i=-384; i<640; i++)
    Clip[i] = (i<0) ? 0 : ((i>255) ? 255 : i);

  /* IDCT */
  if (Reference_IDCT_Flag)
    Initialize_Reference_IDCT();
  else
    Initialize_Fast_IDCT();

}

/* mostly IMPLEMENTAION specific rouintes */
static void Initialize_Sequence()
{
  int cc, size;
  static int Table_6_20[3] = {6,8,12};

  /* check scalability mode of enhancement layer */
  if (Two_Streams && (enhan.scalable_mode!=SC_SNR) && (base.scalable_mode!=SC_DP))
    Error("unsupported scalability mode\n");

  /* force MPEG-1 parameters for proper decoder behavior */
  /* see ISO/IEC 13818-2 section D.9.14 */
  if (!base.MPEG2_Flag)
  {
    progressive_sequence = 1;
    progressive_frame = 1;
    picture_structure = FRAME_PICTURE;
    frame_pred_frame_dct = 1;
    chroma_format = CHROMA420;
    matrix_coefficients = 5;
  }

  /* round to nearest multiple of coded macroblocks */
  /* ISO/IEC 13818-2 section 6.3.3 sequence_header() */
  mb_width = (horizontal_size+15)/16;
  mb_height = (base.MPEG2_Flag && !progressive_sequence) ? 2*((vertical_size+31)/32)
                                        : (vertical_size+15)/16;

  Coded_Picture_Width = 16*mb_width;
  Coded_Picture_Height = 16*mb_height;

  printf("height %d width %d\n",Coded_Picture_Height, Coded_Picture_Width);

  /* ISO/IEC 13818-2 sections 6.1.1.8, 6.1.1.9, and 6.1.1.10 */
  Chroma_Width = (chroma_format==CHROMA444) ? Coded_Picture_Width
                                           : Coded_Picture_Width>>1;
  Chroma_Height = (chroma_format!=CHROMA420) ? Coded_Picture_Height
                                            : Coded_Picture_Height>>1;
  
  /* derived based on Table 6-20 in ISO/IEC 13818-2 section 6.3.17 */
  block_count = Table_6_20[chroma_format-1];

  for (cc=0; cc<3; cc++)
  {
    if (cc==0)
      size = Coded_Picture_Width*Coded_Picture_Height;
    else
      size = Chroma_Width*Chroma_Height;

    if (!(backward_reference_frame[cc] = (unsigned char *)_mm_malloc(size,16)))
      Error("backward_reference_frame[] malloc failed\n");

    if (!(forward_reference_frame[cc] = (unsigned char *)_mm_malloc(size,16)))
      Error("forward_reference_frame[] malloc failed\n");

    if (!(auxframe[cc] = (unsigned char *)_mm_malloc(size,16)))
      Error("auxframe[] malloc failed\n");

    if(Ersatz_Flag)
      if (!(substitute_frame[cc] = (unsigned char *)_mm_malloc(size,16)))
        Error("substitute_frame[] malloc failed\n");


    if (base.scalable_mode==SC_SPAT)
    {
      /* this assumes lower layer is 4:2:0 */
      if (!(llframe0[cc] = (unsigned char *)_mm_malloc((lower_layer_prediction_horizontal_size*lower_layer_prediction_vertical_size)/(cc?4:1),16)))
        Error("llframe0 malloc failed\n");
      if (!(llframe1[cc] = (unsigned char *)_mm_malloc((lower_layer_prediction_horizontal_size*lower_layer_prediction_vertical_size)/(cc?4:1),16)))
        Error("llframe1 malloc failed\n");
    }
  }

  /* SCALABILITY: Spatial */
  if (base.scalable_mode==SC_SPAT)
  {
    if (!(lltmp = (short *)_mm_malloc(lower_layer_prediction_horizontal_size*((lower_layer_prediction_vertical_size*vertical_subsampling_factor_n)/vertical_subsampling_factor_m)*sizeof(short),16)))
      Error("lltmp malloc failed\n");
  }

#ifdef DISPLAY
  if (Output_Type==T_X11)
  {
    Initialize_Display_Process("");
    Initialize_Dither_Matrix();
  }
#endif /* DISPLAY */

}

void Error(text)
char *text;
{
  fprintf(stderr,text);
  exit(1);
}

/* Trace_Flag output */
void Print_Bits(code,bits,len)
int code,bits,len;
{
  int i;
  for (i=0; i<len; i++)
    printf("%d",(code>>(bits-1-i))&1);
}



/* option processing */
static void Process_Options(argc,argv)
int argc;                  /* argument count  */
char *argv[];              /* argument vector */
{
  int i, LastArg, NextArg;

  /* at least one argument should be present */
  if (argc<2)
  {
    printf("\n%s, %s\n",Version,Author);
    printf("Usage:  mpeg2decode {options}\n\
Options: -b  file  main bitstream (base or spatial enhancement layer)\n\
         -cn file  conformance report (n: level)\n\
         -e  file  enhancement layer bitstream (SNR or Data Partitioning)\n\
         -f        store/display interlaced video in frame format\n\
         -g        concatenated file format for substitution method (-x)\n\
         -in file  information & statistics report  (n: level)\n\
         -l  file  file name pattern for lower layer sequence\n\
                   (for spatial scalability)\n\
         -on file  output format (0:YUV 1:SIF 2:TGA 3:PPM 4:X11 5:X11HiQ)\n\
         -q        disable warnings to stderr\n\
         -r        use double precision reference IDCT\n\
         -t        enable low level tracing to stdout\n\
         -u  file  print user_data to stdio or file\n\
         -vn       verbose output (n: level)\n\
         -x  file  filename pattern of picture substitution sequence\n\n\
File patterns:  for sequential filenames, \"printf\" style, e.g. rec%%d\n\
                 or rec%%d%%c for fieldwise storage\n\
Levels:        0:none 1:sequence 2:picture 3:slice 4:macroblock 5:block\n\n\
Example:       mpeg2decode -b bitstream.mpg -f -r -o0 rec%%d\n\
         \n");
    exit(0);
  }


  Output_Type = -1;
  i = 1;

  /* command-line options are proceeded by '-' */

  while(i < argc)
  {
    /* check if this is the last argument */
    LastArg = ((argc-i)==1);

    /* parse ahead to see if another flag immediately follows current
       argument (this is used to tell if a filename is missing) */
    if(!LastArg)
      NextArg = (argv[i+1][0]=='-');
    else
      NextArg = 0;

    /* second character, [1], after '-' is the switch */
    if(argv[i][0]=='-')
    {
      switch(toupper(argv[i][1]))
      {
        /* third character. [2], is the value */
      case 'B':
        Main_Bitstream_Flag = 1;

        if(NextArg || LastArg)
        {
          printf("ERROR: -b must be followed the main bitstream filename\n");
	}
        else
          Main_Bitstream_Filename = argv[++i]; 

        break;


      case 'C':

#ifdef VERIFY
        Verify_Flag = atoi(&argv[i][2]); 

        if((Verify_Flag < NO_LAYER) || (Verify_Flag > ALL_LAYERS))
        {
          printf("ERROR: -c level (%d) out of range [%d,%d]\n",
            Verify_Flag, NO_LAYER, ALL_LAYERS);
          exit(ERROR);
        }
#else  /* VERIFY */
        printf("This program not compiled for Verify_Flag option\n");
#endif /* VERIFY */
        break;

      case 'E':
        Two_Streams = 1; /* either Data Partitioning (DP) or SNR Scalability enhancment */
	                   
        if(NextArg || LastArg)
        {
          printf("ERROR: -e must be followed by filename\n");
          exit(ERROR);
        }
        else
          Enhancement_Layer_Bitstream_Filename = argv[++i]; 

        break;


      case 'F':
        Frame_Store_Flag = 1;
        break;

      case 'G':
        Big_Picture_Flag = 1;
        break;


      case 'I':
#ifdef VERIFY
        Stats_Flag = atoi(&argv[i][2]); 
#else /* VERIFY */
        printf("WARNING: This program not compiled for -i option\n");
#endif /* VERIFY */     
        break;
    
      case 'L':  /* spatial scalability flag */
        Spatial_Flag = 1;

       if(NextArg || LastArg)
       {
         printf("ERROR: -l must be followed by filename\n");
         exit(ERROR);
       }
       else
         Lower_Layer_Picture_Filename = argv[++i]; 

        break;

      case 'O':
  
        Output_Type = atoi(&argv[i][2]); 
  
        if((Output_Type==4) || (Output_Type==5))
          Output_Picture_Filename = "";  /* no need of filename */
        else if(NextArg || LastArg)  
        {
          printf("ERROR: -o must be followed by filename\n");
          exit(ERROR);
        }
        else
        /* filename is separated by space, so it becomes the next argument */
          Output_Picture_Filename = argv[++i]; 

#ifdef DISPLAY
        if (Output_Type==T_X11HIQ)
        {
          hiQdither = 1;
          Output_Type=T_X11;
        }
#endif /* DISPLAY */
        break;

      case 'Q':
        Quiet_Flag = 1;
        break;

      case 'R':
        Reference_IDCT_Flag = 1;
        break;
    
      case 'T':
#ifdef TRACE
        Trace_Flag = 1;
#else /* TRACE */
        printf("WARNING: This program not compiled for -t option\n");
#endif /* TRACE */
        break;

      case 'U':
        User_Data_Flag = 1;

      case 'V':
#ifdef VERBOSE
        Verbose_Flag = atoi(&argv[i][2]); 
#else /* VERBOSE */
        printf("This program not compiled for -v option\n");
#endif /* VERBOSE */
        break;


      case 'X':
        Ersatz_Flag = 1;

       if(NextArg || LastArg)
       {
         printf("ERROR: -x must be followed by filename\n"); 
         exit(ERROR);
       }
       else
        Substitute_Picture_Filename = argv[++i]; 

        break;



      default:
        fprintf(stderr,"undefined option -%c ignored. Exiting program\n", 
          argv[i][1]);

        exit(ERROR);
    
      } /* switch() */
    } /* if argv[i][0] == '-' */
    
    i++;

  	/* check for bitstream filename argument (there must always be one, at the very end
	   of the command line arguments */

  } /* while() */


  /* options sense checking */

  if(Main_Bitstream_Flag!=1)
  {
    printf("There must be a main bitstream specified (-b filename)\n");
  }

  /* force display process to show frame pictures */
  if((Output_Type==4 || Output_Type==5) && Frame_Store_Flag)
    Display_Progressive_Flag = 1;
  else
    Display_Progressive_Flag = 0;

#ifdef VERIFY
  /* parse the bitstream, do not actually decode it completely */
  

#if 0
  if(Output_Type==-1)
  {
    Decode_Layer = Verify_Flag;
    printf("FYI: Decoding bitstream elements up to: %s\n", 
      Layer_Table[Decode_Layer]);
  }
  else
#endif
    Decode_Layer = ALL_LAYERS;

#endif /* VERIFY */

  /* no output type specified */
  if(Output_Type==-1)
  {
    Output_Type = 9; 
    Output_Picture_Filename = "";
  }


#ifdef DISPLAY
  if (Output_Type==T_X11)
  {
    if(Frame_Store_Flag)
      Display_Progressive_Flag = 1;
    else
      Display_Progressive_Flag = 0;

    Frame_Store_Flag = 1; /* to avoid calling dither() twice */
  }
#endif


}


#ifdef OLD
/* 
   this is an old routine used to convert command line arguments
   into integers 
*/
static int Get_Val(argv)
char *argv[];
{
  int val;

  if (sscanf(argv[1]+2,"%d",&val)!=1)
    return 0;

  while (isdigit(argv[1][2]))
    argv[1]++;

  return val;
}
#endif



static int Headers()
{
  int ret;

  ld = &base;
  

  /* return when end of sequence (0) or picture
     header has been parsed (1) */

  ret = Get_Hdr();


  if (Two_Streams)
  {
    ld = &enhan;
    if (Get_Hdr()!=ret && !Quiet_Flag)
      fprintf(stderr,"streams out of sync\n");
    ld = &base;
  }

  return ret;
}



static int Decode_Bitstream()
{
  int ret;
  int Bitstream_Framenum;

  Bitstream_Framenum = 0;

  for(;;)
  {

#ifdef VERIFY
    Clear_Verify_Headers();
#endif /* VERIFY */

    ret = Headers();
    
    if(ret==1)
    {
      ret = video_sequence(&Bitstream_Framenum);
    }
    else
      return(ret);
  }

}


static void Deinitialize_Sequence()
{
  int i;

  /* clear flags */
  base.MPEG2_Flag=0;

  for(i=0;i<3;i++)
  {
    _mm_free(backward_reference_frame[i]);
    _mm_free(forward_reference_frame[i]);
    _mm_free(auxframe[i]);

    if (base.scalable_mode==SC_SPAT)
    {
     _mm_free(llframe0[i]);
     _mm_free(llframe1[i]);
    }
  }

  if (base.scalable_mode==SC_SPAT)
    _mm_free(lltmp);

#ifdef DISPLAY
  if (Output_Type==T_X11) 
    Terminate_Display_Process();
#endif
}


static int video_sequence(Bitstream_Framenumber)
int *Bitstream_Framenumber;
{
  int Bitstream_Framenum;
  int Sequence_Framenum;
  int Return_Value;

  Bitstream_Framenum = *Bitstream_Framenumber;
  Sequence_Framenum=0;

  Initialize_Sequence();

  /* decode picture whose header has already been parsed in 
     Decode_Bitstream() */


  Decode_Picture(Bitstream_Framenum, Sequence_Framenum);

  /* update picture numbers */
  if (!Second_Field)
  {
    Bitstream_Framenum++;
    Sequence_Framenum++;
  }

  /* loop through the rest of the pictures in the sequence */
  while ((Return_Value=Headers()))
  {
    Decode_Picture(Bitstream_Framenum, Sequence_Framenum);

    if (!Second_Field)
    {
      Bitstream_Framenum++;
      Sequence_Framenum++;
    }
  }

  /* put last frame */
  if (Sequence_Framenum!=0)
  {
    Output_Last_Frame_of_Sequence(Bitstream_Framenum);
  }

  Deinitialize_Sequence();

#ifdef VERIFY
    Clear_Verify_Headers();
#endif /* VERIFY */

  *Bitstream_Framenumber = Bitstream_Framenum;
  return(Return_Value);
}



static void Clear_Options()
{
  Verbose_Flag = 0;
  Output_Type = 0;
  Output_Picture_Filename = " ";
  hiQdither  = 0;
  Output_Type = 0;
  Frame_Store_Flag = 0;
  Spatial_Flag = 0;
  Lower_Layer_Picture_Filename = " ";
  Reference_IDCT_Flag = 0;
  Trace_Flag = 0;
  Quiet_Flag = 0;
  Ersatz_Flag = 0;
  Substitute_Picture_Filename  = " ";
  Two_Streams = 0;
  Enhancement_Layer_Bitstream_Filename = " ";
  Big_Picture_Flag = 0;
  Main_Bitstream_Flag = 0;
  Main_Bitstream_Filename = " ";
  Verify_Flag = 0;
  Stats_Flag  = 0;
  User_Data_Flag = 0; 
}


#ifdef DEBUG
static void Print_Options()
{
  
  printf("Verbose_Flag                         = %d\n", Verbose_Flag);
  printf("Output_Type                          = %d\n", Output_Type);
  printf("Output_Picture_Filename              = %s\n", Output_Picture_Filename);
  printf("hiQdither                            = %d\n", hiQdither);
  printf("Output_Type                          = %d\n", Output_Type);
  printf("Frame_Store_Flag                     = %d\n", Frame_Store_Flag);
  printf("Spatial_Flag                         = %d\n", Spatial_Flag);
  printf("Lower_Layer_Picture_Filename         = %s\n", Lower_Layer_Picture_Filename);
  printf("Reference_IDCT_Flag                  = %d\n", Reference_IDCT_Flag);
  printf("Trace_Flag                           = %d\n", Trace_Flag);
  printf("Quiet_Flag                           = %d\n", Quiet_Flag);
  printf("Ersatz_Flag                          = %d\n", Ersatz_Flag);
  printf("Substitute_Picture_Filename          = %s\n", Substitute_Picture_Filename);
  printf("Two_Streams                          = %d\n", Two_Streams);
  printf("Enhancement_Layer_Bitstream_Filename = %s\n", Enhancement_Layer_Bitstream_Filename);
  printf("Big_Picture_Flag                     = %d\n", Big_Picture_Flag);
  printf("Main_Bitstream_Flag                  = %d\n", Main_Bitstream_Flag);
  printf("Main_Bitstream_Filename              = %s\n", Main_Bitstream_Filename);
  printf("Verify_Flag                          = %d\n", Verify_Flag);
  printf("Stats_Flag                           = %d\n", Stats_Flag);
  printf("User_Data_Flag                       = %d\n", User_Data_Flag);

}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* mpeg2dec.h, MPEG specific defines                                        */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#define ERROR (-1)

#define PICTURE_START_CODE      0x100
#define SLICE_START_CODE_MIN    0x101
#define SLICE_START_CODE_MAX    0x1AF
#define USER_DATA_START_CODE    0x1B2
#define SEQUENCE_HEADER_CODE    0x1B3
#define SEQUENCE_ERROR_CODE     0x1B4
#define EXTENSION_START_CODE    0x1B5
#define SEQUENCE_END_CODE       0x1B7
#define GROUP_START_CODE        0x1B8
#define SYSTEM_START_CODE_MIN   0x1B9
#define SYSTEM_START_CODE_MAX   0x1FF

#define ISO_END_CODE            0x1B9
#define PACK_START_CODE         0x1BA
#define SYSTEM_START_CODE       0x1BB

#define VIDEO_ELEMENTARY_STREAM 0x1e0

/* scalable_mode */
#define SC_NONE 0
#define SC_DP   1
#define SC_SPAT 2
#define SC_SNR  3
#define SC_TEMP 4

/* picture coding type */
#define I_TYPE 1
#define P_TYPE 2
#define B_TYPE 3
#define D_TYPE 4

/* picture structure */
#define TOP_FIELD     1
#define BOTTOM_FIELD  2
#define FRAME_PICTURE 3

/* macroblock type */
#define MACROBLOCK_INTRA                        1
#define MACROBLOCK_PATTERN                      2
#define MACROBLOCK_MOTION_BACKWARD              4
#define MACROBLOCK_MOTION_FORWARD               8
#define MACROBLOCK_QUANT                        16
#define SPATIAL_TEMPORAL_WEIGHT_CODE_FLAG       32
#define PERMITTED_SPATIAL_TEMPORAL_WEIGHT_CLASS 64


/* motion_type */
#define MC_FIELD 1
#define MC_FRAME 2
#define MC_16X8  2
#define MC_DMV   3

/* mv_format */
#define MV_FIELD 0
#define MV_FRAME 1

/* chroma_format */
#define CHROMA420 1
#define CHROMA422 2
#define CHROMA444 3

/* extension start code IDs */

#define SEQUENCE_EXTENSION_ID                    1
#define SEQUENCE_DISPLAY_EXTENSION_ID            2
#define QUANT_MATRIX_EXTENSION_ID                3
#define COPYRIGHT_EXTENSION_ID                   4
#define SEQUENCE_SCALABLE_EXTENSION_ID           5
#define PICTURE_DISPLAY_EXTENSION_ID             7
#define PICTURE_CODING_EXTENSION_ID              8
#define PICTURE_SPATIAL_SCALABLE_EXTENSION_ID    9
#define PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID  10

#define ZIG_ZAG                                  0

#define PROFILE_422                             (128+5)
#define MAIN_LEVEL                              8

/* Layers: used by Verbose_Flag, Verifier_Flag, Stats_Flag, and Trace_Flag */
#define NO_LAYER                                0
#define SEQUENCE_LAYER                          1
#define PICTURE_LAYER                           2
#define SLICE_LAYER                             3    
#define MACROBLOCK_LAYER                        4    
#define BLOCK_LAYER                             5
#define EVENT_LAYER                             6
#define ALL_LAYERS                              7



#define FILENAME_LENGTH                       256




#define MB_WEIGHT                  32
#define MB_CLASS4                  64

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* Predict.c, motion compensation routines                                    */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>

#include "config.h"
#include "global.h"

#define FP_OPT 1
#define PRED_TEST_CODE 0

/* private prototypes */
static void form_prediction _ANSI_ARGS_((unsigned char *src[], int sfield,
  unsigned char *dst[], int dfield,
  int lx, int lx2, int w, int h, int x, int y, int dx, int dy,
  int average_flag));

static void form_component_prediction _ANSI_ARGS_((unsigned char *src, 
unsigned char *dst, int lx, int lx2, int w, int h, int x, int y, int dx, int dy,
 int average_flag));

#if FP_OPT
static void form_component_prediction2 _ANSI_ARGS_((unsigned char *src, 
unsigned char *dst, int lx, int lx2, int w, int h, int dx, int dy, 
int average_flag));
#else
static void form_component_prediction2 _ANSI_ARGS_((unsigned char *src, 
unsigned char *dst, int lx, int lx2, int w, int h, int x, int y, int dx, int dy,
 int average_flag));
#endif

extern int phase;

void form_predictions(bx,by,macroblock_type,motion_type,PMV,
		      motion_vertical_field_select,dmvector,stwtype)
int bx, by;
int macroblock_type;
int motion_type;
int PMV[2][2][2], motion_vertical_field_select[2][2], dmvector[2];
int stwtype;
{
  int currentfield;
  unsigned char **predframe;
  int DMV[2][2];
  int stwtop, stwbot;


  stwtop = stwtype%3; /* 0:temporal, 1:(spat+temp)/2, 2:spatial */
  stwbot = stwtype/3;

  if ((macroblock_type & MACROBLOCK_MOTION_FORWARD) 
   || (picture_coding_type==P_TYPE))
  {
    if (picture_structure==FRAME_PICTURE)
    {
      if ((motion_type==MC_FRAME) 
        || !(macroblock_type & MACROBLOCK_MOTION_FORWARD))
      {
        /* frame-based prediction (broken into top and bottom halves
             for spatial scalability prediction purposes) */
        if (stwtop<2)
          form_prediction(forward_reference_frame,0,current_frame,0,
            Coded_Picture_Width,Coded_Picture_Width<<1,16,8,bx,by,
            PMV[0][0][0],PMV[0][0][1],stwtop);

        if (stwbot<2)
          form_prediction(forward_reference_frame,1,current_frame,1,
            Coded_Picture_Width,Coded_Picture_Width<<1,16,8,bx,by,
            PMV[0][0][0],PMV[0][0][1],stwbot);
      }
      else if (motion_type==MC_FIELD) /* field-based prediction */
      {
        /* top field prediction */
        if (stwtop<2)
          form_prediction(forward_reference_frame,motion_vertical_field_select[0][0],
            current_frame,0,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
            bx,by>>1,PMV[0][0][0],PMV[0][0][1]>>1,stwtop);

        /* bottom field prediction */
        if (stwbot<2)
          form_prediction(forward_reference_frame,motion_vertical_field_select[1][0],
            current_frame,1,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
            bx,by>>1,PMV[1][0][0],PMV[1][0][1]>>1,stwbot);
      }
      else if (motion_type==MC_DMV) /* dual prime prediction */
      {
        /* calculate derived motion vectors */
        Dual_Prime_Arithmetic(DMV,dmvector,PMV[0][0][0],PMV[0][0][1]>>1);

        if (stwtop<2)
        {
          /* predict top field from top field */
          form_prediction(forward_reference_frame,0,current_frame,0,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by>>1,
            PMV[0][0][0],PMV[0][0][1]>>1,0);

          /* predict and add to top field from bottom field */
          form_prediction(forward_reference_frame,1,current_frame,0,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by>>1,
            DMV[0][0],DMV[0][1],1);
        }

        if (stwbot<2)
        {
          /* predict bottom field from bottom field */
          form_prediction(forward_reference_frame,1,current_frame,1,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by>>1,
            PMV[0][0][0],PMV[0][0][1]>>1,0);

          /* predict and add to bottom field from top field */
          form_prediction(forward_reference_frame,0,current_frame,1,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by>>1,
            DMV[1][0],DMV[1][1],1);
        }
      }
      else
        /* invalid motion_type */
        printf("invalid motion_type\n");
    }
    else /* TOP_FIELD or BOTTOM_FIELD */
    {
      /* field picture */
      currentfield = (picture_structure==BOTTOM_FIELD);

      /* determine which frame to use for prediction */
      if ((picture_coding_type==P_TYPE) && Second_Field
         && (currentfield!=motion_vertical_field_select[0][0]))
        predframe = backward_reference_frame; /* same frame */
      else
        predframe = forward_reference_frame; /* previous frame */

      if ((motion_type==MC_FIELD)
        || !(macroblock_type & MACROBLOCK_MOTION_FORWARD))
      {
        /* field-based prediction */
        if (stwtop<2)
          form_prediction(predframe,motion_vertical_field_select[0][0],current_frame,0,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,16,bx,by,
            PMV[0][0][0],PMV[0][0][1],stwtop);
      }
      else if (motion_type==MC_16X8)
      {
        if (stwtop<2)
        {
          form_prediction(predframe,motion_vertical_field_select[0][0],current_frame,0,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by,
            PMV[0][0][0],PMV[0][0][1],stwtop);

          /* determine which frame to use for lower half prediction */
          if ((picture_coding_type==P_TYPE) && Second_Field
             && (currentfield!=motion_vertical_field_select[1][0]))
            predframe = backward_reference_frame; /* same frame */
          else
            predframe = forward_reference_frame; /* previous frame */

          form_prediction(predframe,motion_vertical_field_select[1][0],current_frame,0,
            Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,bx,by+8,
            PMV[1][0][0],PMV[1][0][1],stwtop);
        }
      }
      else if (motion_type==MC_DMV) /* dual prime prediction */
      {
        if (Second_Field)
          predframe = backward_reference_frame; /* same frame */
        else
          predframe = forward_reference_frame; /* previous frame */

        /* calculate derived motion vectors */
        Dual_Prime_Arithmetic(DMV,dmvector,PMV[0][0][0],PMV[0][0][1]);

        /* predict from field of same parity */
        form_prediction(forward_reference_frame,currentfield,current_frame,0,
          Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,16,bx,by,
          PMV[0][0][0],PMV[0][0][1],0);

        /* predict from field of opposite parity */
        form_prediction(predframe,!currentfield,current_frame,0,
          Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,16,bx,by,
          DMV[0][0],DMV[0][1],1);
      }
      else
        /* invalid motion_type */
        printf("invalid motion_type\n");
    }
    stwtop = stwbot = 1;
  }

  if (macroblock_type & MACROBLOCK_MOTION_BACKWARD)
  {
    if (picture_structure==FRAME_PICTURE)
    {
      if (motion_type==MC_FRAME)
      {
        /* frame-based prediction */
        if (stwtop<2)
          form_prediction(backward_reference_frame,0,current_frame,0,
            Coded_Picture_Width,Coded_Picture_Width<<1,16,8,bx,by,
            PMV[0][1][0],PMV[0][1][1],stwtop);

        if (stwbot<2)
          form_prediction(backward_reference_frame,1,current_frame,1,
            Coded_Picture_Width,Coded_Picture_Width<<1,16,8,bx,by,
            PMV[0][1][0],PMV[0][1][1],stwbot);
      }
      else /* field-based prediction */
      {
        /* top field prediction */
        if (stwtop<2)
          form_prediction(backward_reference_frame,motion_vertical_field_select[0][1],
            current_frame,0,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
            bx,by>>1,PMV[0][1][0],PMV[0][1][1]>>1,stwtop);

        /* bottom field prediction */
        if (stwbot<2)
          form_prediction(backward_reference_frame,motion_vertical_field_select[1][1],
            current_frame,1,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
            bx,by>>1,PMV[1][1][0],PMV[1][1][1]>>1,stwbot);
      }
    }
    else /* TOP_FIELD or BOTTOM_FIELD */
    {
      /* field picture */
      if (motion_type==MC_FIELD)
      {
        /* field-based prediction */
        form_prediction(backward_reference_frame,motion_vertical_field_select[0][1],
          current_frame,0,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,16,
          bx,by,PMV[0][1][0],PMV[0][1][1],stwtop);
      }
      else if (motion_type==MC_16X8)
      {
        form_prediction(backward_reference_frame,motion_vertical_field_select[0][1],
          current_frame,0,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
          bx,by,PMV[0][1][0],PMV[0][1][1],stwtop);

        form_prediction(backward_reference_frame,motion_vertical_field_select[1][1],
          current_frame,0,Coded_Picture_Width<<1,Coded_Picture_Width<<1,16,8,
          bx,by+8,PMV[1][1][0],PMV[1][1][1],stwtop);
      }
      else
        /* invalid motion_type */
        printf("invalid motion_type\n");
    }
  }
}

#if FP_OPT

static void form_prediction(src,sfield,dst,dfield,lx,lx2,w,h,x,y,dx,dy,average_flag)
unsigned char *src[]; /* prediction source buffer */
int sfield;           /* prediction source field number (0 or 1) */
unsigned char *dst[]; /* prediction destination buffer */
int dfield;           /* prediction destination field number (0 or 1)*/
int lx,lx2;           /* line strides */
int w,h;              /* prediction block/sub-block width, height */
int x,y;              /* pixel co-ordinates of top-left sample in current MB */
int dx,dy;            /* horizontal, vertical prediction address */
int average_flag;     /* add prediction error to prediction ? */
{
  int sf_val,df_val,sly_val, dly_val, slx_val,xh,yh;
  /* Y */
  form_component_prediction(src[0]+(sfield?lx2>>1:0),dst[0]+(dfield?lx2>>1:0),
    lx,lx2,w,h,x,y,dx,dy,average_flag);

  if (chroma_format!=CHROMA444)
  {
    lx>>=1; lx2>>=1; w>>=1; x>>=1; dx/=2;
  }

  if (chroma_format==CHROMA420)
  {
    h>>=1; y>>=1; dy/=2;
  }
  
  sf_val = sfield?lx2>>1:0;
  df_val = dfield?lx2>>1:0;
  sly_val = lx * (y+(dy>>1));
  dly_val = lx * y;
  slx_val = x + (dx>>1);
  xh = dx & 1;
  yh = dy & 1;
  
  /* Cb */
  form_component_prediction2(src[1]+sf_val+sly_val+slx_val,
			     dst[1]+df_val+dly_val+x,
			     lx,lx2,w,h,xh,yh,average_flag);

  /* Cr */
  form_component_prediction2(src[2]+sf_val+sly_val+slx_val,
			     dst[2]+df_val+dly_val+x,
			     lx,lx2,w,h,xh,yh,average_flag);

}

#else /* not FP_OPT */

static void form_prediction(src,sfield,dst,dfield,lx,lx2,w,h,x,y,dx,dy,average_flag)
unsigned char *src[]; /* prediction source buffer */
int sfield;           /* prediction source field number (0 or 1) */
unsigned char *dst[]; /* prediction destination buffer */
int dfield;           /* prediction destination field number (0 or 1)*/
int lx,lx2;           /* line strides */
int w,h;              /* prediction block/sub-block width, height */
int x,y;              /* pixel co-ordinates of top-left sample in current MB */
int dx,dy;            /* horizontal, vertical prediction address */
int average_flag;     /* add prediction error to prediction ? */
{
  /* Y */
  form_component_prediction(src[0]+(sfield?lx2>>1:0),dst[0]+(dfield?lx2>>1:0),
    lx,lx2,w,h,x,y,dx,dy,average_flag);

  if (chroma_format!=CHROMA444)
  {
    lx>>=1; lx2>>=1; w>>=1; x>>=1; dx/=2;
  }

  if (chroma_format==CHROMA420)
  {
    h>>=1; y>>=1; dy/=2;
  }

  /* Cb */
  form_component_prediction2(src[1]+(sfield?lx2>>1:0),dst[1]+(dfield?lx2>>1:0),
    lx,lx2,w,h,x,y,dx,dy,average_flag);

  /* Cr */
  form_component_prediction2(src[2]+(sfield?lx2>>1:0),dst[2]+(dfield?lx2>>1:0),
    lx,lx2,w,h,x,y,dx,dy,average_flag);
}

#endif /* end not FP_OPT */

/* ISO/IEC 13818-2 section 7.6.4: Forming predictions */
/* NOTE: the arithmetic below produces numerically equivalent results
 *  to 7.6.4, yet is more elegant. It differs in the following ways:
 *
 *   1. the vectors (dx, dy) are based on cartesian frame 
 *      coordiantes along a half-pel grid (always positive numbers)
 *      In contrast, vector[r][s][t] are differential (with positive and 
 *      negative values). As a result, deriving the integer vectors 
 *      (int_vec[t]) from dx, dy is accomplished by a simple right shift.
 *
 *   2. Half pel flags (xh, yh) are equivalent to the LSB (Least
 *      Significant Bit) of the half-pel coordinates (dx,dy).
 * 
 *
 *  NOTE: the work of combining predictions (ISO/IEC 13818-2 section 7.6.7)
 *  is distributed among several other stages.  This is accomplished by 
 *  folding line offsets into the source and destination (src,dst)
 *  addresses (note the call arguments to form_prediction() in Predict()),
 *  line stride variables lx and lx2, the block dimension variables (w,h), 
 *  average_flag, and by the very order in which Predict() is called.  
 *  This implementation design (implicitly different than the spec) 
 *  was chosen for its elegance.
*/

/* assumption - processes 16x8 blocks - ruchira */
#include<assert.h>

static void form_component_prediction(src,dst,lx,lx2,w,h,x,y,dx,dy,average_flag)
unsigned char *src;
unsigned char *dst;
int lx;          /* raster line increment */ 
int lx2;
int w,h;
int x,y;
int dx,dy;
int average_flag;      /* flag that signals bi-directional or Dual-Prime 
                          averaging (7.6.7.1 and 7.6.7.4). if average_flag==1,
                          a previously formed prediction has been stored in 
                          pel_pred[] */
{
  int xint;      /* horizontal integer sample vector: analogous to int_vec[0] */
  int yint;      /* vertical integer sample vectors: analogous to int_vec[1] */
  int xh;        /* horizontal half sample flag: analogous to half_flag[0]  */
  int yh;        /* vertical half sample flag: analogous to half_flag[1]  */
  int i, j, v;
  unsigned char *s;    /* source pointer: analogous to pel_ref[][]   */
  unsigned char *d;    /* destination pointer:  analogous to pel_pred[][]  */

  /* half pel scaling for integer vectors */
  xint = dx>>1;
  yint = dy>>1;


  /* compute the linear address of pel_ref[][] and pel_pred[][] 
     based on cartesian/raster cordinates provided */
  s = src + lx*(y+yint) + x + xint;
  d = dst + lx*y + x;



  /* derive half pel flags */
  xh = dx & 1;
  yh = dy & 1;

  assert(s!=d);

  if (!xh && !yh) /* no horizontal nor vertical half-pel */
    {
      if (average_flag)
    {
#ifdef SSE2

#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = s[j*lx2+i] + d[j*lx2+i];
          tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	
      fcp_loop1:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqa xmm1, [edx] ; /* load dst blk */
	pavgb  xmm1, xmm0  ; /* find avg */
	movdqa [edx], xmm1 ;
	add    edx, ebx    ;
	add    eax, ebx    ;
	loop fcp_loop1     ;
      }
#if (PRED_TEST_CODE)
     for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("1 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
      {

        for (i=0; i<w; i++)
        {
          v = d[i]+s[i];
          d[i] = (v+(v>=0?1:0))>>1;
        }

        s+= lx2;
        d+= lx2;

      }
#endif
	
    }
    else
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
     unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {

        for (i=0; i<w; i++)
        {

          tmp[j*w+i] = s[j*lx2+i];
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	
      fcp_loop2:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqa [edx], xmm0 ; /* copy over */
	add    edx, ebx    ;
	add    eax, ebx    ;
	loop fcp_loop2     ;
      }
#if (PRED_TEST_CODE)      
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("2 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
      {

        for (i=0; i<w; i++)
        {
          d[i] = s[i];
        }
        
        s+= lx2;
        d+= lx2;

      }
#endif

    }




  }
  else if (!xh && yh) /* no horizontal but vertical half-pel */
  {
    if (average_flag)
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
       unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[j*lx2+i] + ((unsigned int)(s[j*lx2+i]+s[j*lx2+i+lx]+1)>>1);
          tmp[j*w+i]=(v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
	
      fcp_loop3:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [esi] ; /* load s+lx blk */
	movdqa xmm2, [edx] ; /* load dest blk */
	pavgb  xmm1, xmm0  ; /* avg(s,s+lx) */
	pavgb  xmm2, xmm1  ; /* avg(d, avg(s,s+lx)) */
	movdqa [edx], xmm2 ; /* copy over */
	add    edx, ebx    ;
	add    eax, ebx    ;
	add    esi, ebx    ;
	loop fcp_loop3     ;
      }  
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
	  for (i=0; i<w; i++)
	    {
	      if (d[j*lx2+i]!=tmp[j*w+i])
		printf("3 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	    }
	}
#endif
#else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+lx]+1)>>1);
          d[i]=(v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;

      }
#endif      
    }
    else
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] =  (unsigned int)(s[j*lx2+i]+s[j*lx2+i+lx]+1)>>1;
        }
      }
#endif
     /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
	
      fcp_loop4:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [esi] ; /* load s+lx blk */
	pavgb  xmm1, xmm0  ; /* avg(s,s+lx) */
	movdqa [edx], xmm1 ; /* copy over */
	add    edx, ebx    ;
	add    eax, ebx    ;
	add    esi, ebx    ;
	loop fcp_loop4     ;
      }          
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("4 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
	{
	  for (i=0; i<w; i++)
	    {
	      d[i] = (unsigned int)(s[i]+s[i+lx]+1)>>1;
	    }

	  s+= lx2;
	  d+= lx2;

	}

#endif

    }
  }


  else if (xh && !yh) /* horizontal but no vertical half-pel */
  {
    if (average_flag)
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
	  int offset = j*lx2;
	  v =  d[offset+i] + ((unsigned int)(s[offset+i]+s[offset+i+1]+1)>>1);
          tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	
      fcp_loop5:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [eax+1] ; /* load s+1 blk */
	movdqa xmm2, [edx] ; /* load dest blk */
	pavgb  xmm1, xmm0  ; /* avg(s,s+1) */
	pavgb  xmm2, xmm1  ;
	movdqa [edx], xmm2 ; /* copy over */
	add    edx, ebx    ;
	add    eax, ebx    ;
	loop fcp_loop5     ;
      }          

#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("5 d %d:%d ref %d\n",j*lx2+i,d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+1)>>1);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;
      }
#endif
    }
    else
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
       unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] =  (unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+1)>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	
      fcp_loop6:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [eax+1] ; /* load s+1 blk */
	pavgb  xmm1, xmm0  ; /* avg(s,s+1) */
	movdqa [edx], xmm1 ; /* copy over */
	add    edx, ebx    ;
	add    eax, ebx    ;
	loop fcp_loop6     ;
      }
#if (PRED_TEST_CODE)
       for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("6 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }          
#endif
#else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          d[i] = (unsigned int)(s[i]+s[i+1]+1)>>1;
        }

        s+= lx2;
        d+= lx2;
      }
#endif


    }
  }
  else /* if (xh && yh) horizontal and vertical half-pel */
  {
    if (average_flag)
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
	  v = d[j*lx2+i] + ((unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+s[j*lx2+i+lx]+s[j*lx2+i+lx+1]+2)>>2);
	  tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
 	
      fcp_loop7:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [eax+1] ; /* load s+1 blk */
	movdqu xmm2, [esi]  ;
	movdqu xmm3, [esi+1]  ;
	movdqa xmm4, [edx] ; /* load dest blk */

	pavgb  xmm0, xmm1  ; /* avg(s,s+1)*/
	pavgb  xmm2, xmm3  ; /* avg(s+lx, s+lx+1) */
	pavgb  xmm0, xmm2  ; 
	pavgb  xmm0, xmm4  ; /* avg(d, all s) */
	movdqa [edx], xmm0 ; /* store to d */
	add    edx, ebx    ;
	add    eax, ebx    ;
	add    esi, ebx    ;
	loop fcp_loop7     ;
      }

#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i] - tmp[j*w+i] > 1) {
	      printf("7 d %d:%d ref %d\n",j*lx2+i,d[j*lx2+i],tmp[j*w+i]);
	    }
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;
      }
#endif
    }
    else
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] = (unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+s[j*lx2+i+lx]+s[j*lx2+i+lx+1]+2)>>2;

        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* load lx */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
 	
      fcp_loop8:
	movdqu xmm0, [eax] ; /* load src blk */
	movdqu xmm1, [eax+1] ; /* load s+1 blk */
	movdqu xmm2, [esi]  ;
	movdqu xmm3, [esi+1]  ;

	pavgb  xmm0, xmm1  ; /* avg(s,s+1)*/
	pavgb  xmm2, xmm3  ; /* avg(s+lx, s+lx+1) */
	pavgb  xmm0, xmm2  ; 
	movdqa [edx], xmm0 ; /* store to d */
	add    edx, ebx    ;
	add    eax, ebx    ;
	add    esi, ebx    ;
	loop fcp_loop8     ;
      }
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i] - tmp[j*w+i] > 1)
	      printf("8 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j++)
      {
	for (i=0; i<w; i++)
	  {
	    d[i] = (unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2;
	  }
	
        s+= lx2;
        d+= lx2;
      }

#endif
    }
  }

}


/* assumption - processes 8x4 blocks 
   This method calls the same blocks of the above function since we
   unroll twice - ruchira */
#if FP_OPT
static void form_component_prediction2(src,dst,lx,lx2,w,h,dx,dy,average_flag)
unsigned char *src;
unsigned char *dst;
int lx;          /* raster line increment */ 
int lx2;
int w,h;
int dx,dy;
int average_flag;      /* flag that signals bi-directional or Dual-Prime 
                          averaging (7.6.7.1 and 7.6.7.4). if average_flag==1,
                          a previously formed prediction has been stored in 
                          pel_pred[] */
#else
static void form_component_prediction2(src,dst,lx,lx2,w,h,x,y,dx,dy,average_flag)
unsigned char *src;
unsigned char *dst;
int lx;          /* raster line increment */ 
int lx2;
int w,h;
int x,y;
int dx,dy;
int average_flag;      /* flag that signals bi-directional or Dual-Prime 
                          averaging (7.6.7.1 and 7.6.7.4). if average_flag==1,
                          a previously formed prediction has been stored in 
                          pel_pred[] */
#endif
{
  int xint;      /* horizontal integer sample vector: analogous to int_vec[0] */
  int yint;      /* vertical integer sample vectors: analogous to int_vec[1] */
  int xh;        /* horizontal half sample flag: analogous to half_flag[0]  */
  int yh;        /* vertical half sample flag: analogous to half_flag[1]  */
  int i, j, v;
  unsigned char *s;    /* source pointer: analogous to pel_ref[][]   */
  unsigned char *d;    /* destination pointer:  analogous to pel_pred[][]  */

#if FP_OPT
  s = src;
  d = dst;

  xh = dx;
  yh = dy;
#else
  /* half pel scaling for integer vectors */
  xint = dx>>1;
  yint = dy>>1;

  /* compute the linear address of pel_ref[][] and pel_pred[][] 
     based on cartesian/raster cordinates provided */
  s = src + lx*(y+yint) + x + xint;
  d = dst + lx*y + x;

  /* derive half pel flags */
  xh = dx & 1;
  yh = dy & 1;
#endif

  if (!xh && !yh) /* no horizontal nor vertical half-pel */
  {
    if (average_flag)
    {

#ifdef SSE2

#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = s[j*lx2+i] + d[j*lx2+i];
          tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h==4 w==8 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	mov    esi, ebx    ;
	sal    esi, 1      ;
	sar    ecx, 1      ; /* unroll twice */
	
      fcp2_loop1:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm2, [edx]       ; /* load 8B from dest blk */
	movq xmm3, [edx+ebx]   ; /* load 8 bytes from dest + lx2 blk */

	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;	

	pavgb  xmm2, xmm0  ; /* find avg */

	movq [edx], xmm2  ;
	psrldq xmm2, 8     ;
	movq [edx+ebx], xmm2   ;
	add    edx, esi    ;
	add    eax, esi    ;
	loop fcp2_loop1     ;
      }
#if (PRED_TEST_CODE)
     for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("p2:1 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif

#else /* NON-SSE2 code */
#if 1
     unsigned char *s1,*d1; 
     int v1;
     
     for (j=0; j<h; j+=2) {
       s1 = s+lx2;
       d1 = d+lx2;
	 
       for (i=0; i<w; i++) {
	 v = d[i]+s[i];
	 v1 = d1[i] + s1[i];
	 d[i] = (v+(v>=0?1:0))>>1;
	 d1[i] = (v1+(v1>=0?1:0))>>1;
       }
       s = s1+lx2;
       d = d1+lx2;
     }
#else /* original code */
     for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[i]+s[i];
          d[i] = (v+(v>=0?1:0))>>1;
        }
      
        s+= lx2;
        d+= lx2;
      }
#endif
#endif	
    }
    else
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
     unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {

        for (i=0; i<w; i++)
        {

          tmp[j*w+i] = s[j*lx2+i];
        }
      }
#endif
      /* h=4 w==8 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	mov    esi, ebx    ;
	sar    ecx, 1      ;
	sal    esi, 1      ;
	
      fcp2_loop2:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ;
	movq [edx], xmm0       ;
	movq [edx+ebx], xmm1   ;

	add    edx, esi    ;
	add    eax, esi    ;
	loop fcp2_loop2     ;
      }
#if (PRED_TEST_CODE)      
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("p2:2 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j+=2)
      {
        for (i=0; i<w; i++)
        {
          d[i] = s[i];
        }
        
        s+= lx2;
        d+= lx2;

        for (i=0; i<w; i++)
        {
          d[i] = s[i];
        }
        
        s+= lx2;
        d+= lx2;

      }
#endif
    }




  }
  else if (!xh && yh) /* no horizontal but vertical half-pel */
  {
    if (average_flag)
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
       unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          v = d[j*lx2+i] + ((unsigned int)(s[j*lx2+i]+s[j*lx2+i+lx]+1)>>1);
          tmp[j*w+i]=(v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* w==8 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;
	add    esi, eax    ; /* esi has s+lx */
	
      fcp2_loop3:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm4, [esi]       ; /* load 8B from src+lx blk */
	movq xmm5, [esi+ebx]   ; /* load 8 bytes from src+lx+lx2 blk */
	movq xmm2, [edx]       ; /* load 8B from dest blk */
	movq xmm3, [edx+ebx]   ; /* load 8 bytes from dest + lx2 blk */

	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm4, xmm5 ;
	punpcklqdq xmm2, xmm3 ;

	pavgb xmm0, xmm4   ;
	pavgb xmm2, xmm0   ;
	
	movq [edx], xmm2   ;
	psrldq xmm2, 8     ;
	movq [edx+ebx], xmm2   ;
	add    edx, edi    ;
	add    eax, edi    ;	
	add    esi, edi    ;
	loop fcp2_loop3    ;
      }  
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
	  for (i=0; i<w; i++)
	    {
	      if (d[j*lx2+i]!=tmp[j*w+i])
		printf("p2:3 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	    }
	}
#endif
#else
      for (j=0; j<h; j+=2)
      {
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+lx]+1)>>1);
          d[i]=(v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;

        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+lx]+1)>>1);
          d[i]=(v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;

      }
#endif
    }
    else
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] =  (unsigned int)(s[j*lx2+i]+s[j*lx2+i+lx]+1)>>1;
        }
      }
#endif
     /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;
	
      fcp2_loop4:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm2, [esi]       ; /* load 8B from src+lx blk */
	movq xmm3, [esi+ebx]   ; /* load 8 bytes from src+lx+lx2 blk */
	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;

	pavgb xmm2, xmm0   ;
	movq [edx], xmm2   ;
	psrldq xmm2, 8     ;
	movq [edx+ebx], xmm2   ;

	add    edx, edi    ;
	add    eax, edi    ;	
	add    esi, edi    ;
	loop fcp2_loop4     ;
      }          
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("p2:4 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j+=2)
      {
        for (i=0; i<w; i++)
        {
          d[i] = (unsigned int)(s[i]+s[i+lx]+1)>>1;
        }

        s+= lx2;
        d+= lx2;

        for (i=0; i<w; i++)
        {
          d[i] = (unsigned int)(s[i]+s[i+lx]+1)>>1;
        }

        s+= lx2;
        d+= lx2;

      }
#endif


    }
  }


  else if (xh && !yh) /* horizontal but no vertical half-pel */
  {
    if (average_flag)
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
	  int offset = j*lx2;
	  v =  d[offset+i] + ((unsigned int)(s[offset+i]+s[offset+i+1]+1)>>1);
          tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;
	
      fcp2_loop5:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm2, [eax+1]       ; /* load 8B from src+1 blk */
	movq xmm3, [eax+ebx+1]   ; /* load 8 bytes from src+1+lx2 blk */
	movq xmm4, [edx]   ; /* load 8 bytes from dst blk */
	movq xmm5, [edx+ebx]   ; /* load 8 bytes from dst + lx2 blk */
	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;
	punpcklqdq xmm4, xmm5 ;

	pavgb  xmm2, xmm0  ; /* avg(s,s+1) */
	pavgb  xmm2, xmm4  ;

	movq [edx], xmm2   ;
	psrldq xmm2, 8     ;
	movq [edx+ebx], xmm2   ;
	add    eax, edi    ;
	add    edx, edi    ;
	loop fcp2_loop5     ;
      }          

#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("p2:5 d %d:%d ref %d\n",j*lx2+i,d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j+=2)
      {

        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+1)>>1);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;


        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+1)>>1);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;

      }
#endif
    }
    else
    {

#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;
      
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] =  (unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+1)>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;	
	
      fcp2_loop6:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm2, [eax+1]       ; /* load 8B from src+1 blk */
	movq xmm3, [eax+ebx+1]   ; /* load 8 bytes from src+1+lx2 blk */
	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;

	pavgb  xmm2, xmm0  ; /* avg(s,s+1) */
	movq [edx], xmm2   ;
	psrldq xmm2, 8     ;
	movq [edx+ebx], xmm2   ;
	add    edx, edi    ;
	add    eax, edi    ;
	loop fcp2_loop6     ;
      }
#if (PRED_TEST_CODE)
       for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i]!=tmp[j*w+i])
	      printf("p2:6 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }          
#endif
#else
       for (j=0; j<h; j+=2)
	 {
	   for (i=0; i<w; i++)
	     {
	       d[i] = (unsigned int)(s[i]+s[i+1]+1)>>1;
	     }

	   s+= lx2;
	   d+= lx2;

	   for (i=0; i<w; i++)
	     {
	       d[i] = (unsigned int)(s[i]+s[i+1]+1)>>1;
	     }

	   s+= lx2;
	   d+= lx2;

	 }

#endif

    }
  }
  else /* if (xh && yh) horizontal and vertical half-pel */
  {
    if (average_flag)
    {
 
#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
	  v = d[j*lx2+i] + ((unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+s[j*lx2+i+lx]+s[j*lx2+i+lx+1]+2)>>2);
	  tmp[j*w+i] = (v+(v>=0?1:0))>>1;
        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* for vertical half pel */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
 	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;	
	
      fcp2_loop7:
	movq xmm0, [eax]   ; /* load 8 bytes from src blk */
	movq xmm1, [eax+ebx]   ; /* load 8 bytes from src + lx2 blk */
	movq xmm2, [eax+1]       ; /* load 8B from src+1 blk */
	movq xmm3, [eax+ebx+1]   ; /* load 8 bytes from src+1+lx2 blk */
	movq xmm4, [esi]   ; /* load 8 bytes from src+lx blk */
	movq xmm5, [esi+ebx]   ; /* load 8 bytes from src+lx + lx2 blk */
	movq xmm6, [esi+1]   ; /* load 8 bytes from src+lx blk */
	movq xmm7, [esi+ebx+1]   ; /* load 8 bytes from src+lx + lx2 blk */

	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;
	movq xmm1, [edx]      ;
	movq xmm3, [edx+ebx]  ;
	punpcklqdq xmm4, xmm5 ;
	punpcklqdq xmm6, xmm7 ;
	punpcklqdq xmm1, xmm3 ;

	pavgb xmm0, xmm2   ;
	pavgb xmm4, xmm6   ;
	pavgb xmm0, xmm4   ;
	pavgb xmm1, xmm0   ;

	movq [edx], xmm1   ;
	psrldq xmm1, 8     ;
	movq [edx+ebx], xmm1   ;

	add    edx, edi    ;
	add    eax, edi    ;
	add    esi, edi    ;
	loop fcp2_loop7     ;
      }

#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i] -tmp[j*w+i]>1) {
	      printf("p2:7 d %d:%d ref %d\n",j*lx2+i,d[j*lx2+i],tmp[j*w+i]);
	    }
	  }
      }
#endif
#else
      for (j=0; j<h; j+=2)
      {
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;
	
        for (i=0; i<w; i++)
        {
          v = d[i] + ((unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2);
          d[i] = (v+(v>=0?1:0))>>1;
        }
     
        s+= lx2;
        d+= lx2;

      }
#endif
    }
    else
    {
#ifdef SSE2
#if (PRED_TEST_CODE)
      unsigned char tmp[128];
      unsigned char *s_t=s, *d_t=d;

      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
        {
          tmp[j*w+i] = (unsigned int)(s[j*lx2+i]+s[j*lx2+i+1]+s[j*lx2+i+lx]+s[j*lx2+i+lx+1]+2)>>2;

        }
      }
#endif
      /* h%4=0 w==16 */
      __asm {
	mov    ecx, [h]    ; /* load in loop counter */
	mov    ebx, [lx2]  ; /* load width of row */
	mov    esi, [lx]   ; /* load lx */
	mov    eax, [s]    ; /* load source addr */
	mov    edx, [d]    ; /* load dest addr */
	add    esi, eax    ; /* esi has s+lx */
 	sar    ecx, 1      ;
	mov    edi, ebx    ;
	sal    edi, 1      ;	
 	
      fcp2_loop8:
	movq xmm0, [eax] ; /* load src blk */
	movq xmm1, [eax+ebx] ; /* load src blk */
	movq xmm2, [eax+1] ; /* load s+1 blk */
	movq xmm3, [eax+ebx+1] ; /* load s+1 blk */
	movq xmm4, [esi]  ;
	movq xmm5, [esi+ebx]  ;
	movq xmm6, [esi+1]  ;
	movq xmm7, [esi+ebx+1]  ;

	punpcklqdq xmm0, xmm1 ;
	punpcklqdq xmm2, xmm3 ;
	punpcklqdq xmm4, xmm5 ;
	punpcklqdq xmm6, xmm7 ;

	pavgb  xmm0, xmm2  ; /* avg(s,s+1)*/
	pavgb  xmm4, xmm6  ; /* avg(s+lx, s+lx+1) */
	pavgb  xmm0, xmm4  ; 

	movq [edx], xmm0 ; /* store to d */
	psrldq xmm0, 8     ;
	movq [edx+ebx], xmm0   ;
	add    edx, edi    ;
	add    eax, edi    ;
	add    esi, edi    ;
	loop fcp2_loop8     ;
      }
#if (PRED_TEST_CODE)
      for (j=0; j<h; j++)
	{
        for (i=0; i<w; i++)
	  {
	    if (d[j*lx2+i] -tmp[j*w+i]>1)
	      printf("p2:8 d %d ref %d\n",d[j*lx2+i],tmp[j*w+i]);
	  }
      }
#endif
#else
      for (j=0; j<h; j+=2)
      {
	for (i=0; i<w; i++){
	    d[i] = (unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2;
	  }
	
        s+= lx2;
        d+= lx2;
	for (i=0; i<w; i++){
	    d[i] = (unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2;
	  }
	
        s+= lx2;
        d+= lx2;
      }
#endif
    }
  }


}






/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */



#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "global.h"

/* private prototypes */
static void Read_Lower_Layer_Component_Framewise _ANSI_ARGS_((int comp, int lw, int lh));
static void Read_Lower_Layer_Component_Fieldwise _ANSI_ARGS_((int comp, int lw, int lh));
static void Make_Spatial_Prediction_Frame _ANSI_ARGS_((int progressive_frame,
  int llprogressive_frame, unsigned char *fld0, unsigned char *fld1, 
  short *tmp, unsigned char *dst, int llx0, int lly0, int llw, int llh, 
  int horizontal_size, int vertical_size, int vm, int vn, int hm, int hn, 
  int aperture));
static void Deinterlace _ANSI_ARGS_((unsigned char *fld0, unsigned char *fld1,
  int j0, int lx, int ly, int aperture));
static void Subsample_Vertical _ANSI_ARGS_((unsigned char *s, short *d,
  int lx, int lys, int lyd, int m, int n, int j0, int dj));
static void Subsample_Horizontal _ANSI_ARGS_((short *s, unsigned char *d,
  int x0, int lx, int lxs, int lxd, int ly, int m, int n));



/* get reference frame */
void Spatial_Prediction()
{
  
  if(Frame_Store_Flag)
  {
    Read_Lower_Layer_Component_Framewise(0,lower_layer_prediction_horizontal_size, 
      lower_layer_prediction_vertical_size);      /* Y */
    Read_Lower_Layer_Component_Framewise(1,lower_layer_prediction_horizontal_size>>1,
      lower_layer_prediction_vertical_size>>1);   /* Cb ("U") */
    Read_Lower_Layer_Component_Framewise(2,lower_layer_prediction_horizontal_size>>1,
      lower_layer_prediction_vertical_size>>1);   /* Cr ("V") */
  }
  else
  {
    Read_Lower_Layer_Component_Fieldwise(0,lower_layer_prediction_horizontal_size, 
      lower_layer_prediction_vertical_size);      /* Y */
    Read_Lower_Layer_Component_Fieldwise(1,lower_layer_prediction_horizontal_size>>1,
      lower_layer_prediction_vertical_size>>1);   /* Cb ("U") */
    Read_Lower_Layer_Component_Fieldwise(2,lower_layer_prediction_horizontal_size>>1,
      lower_layer_prediction_vertical_size>>1);   /* Cr ("V") */
  }


  Make_Spatial_Prediction_Frame  /* Y */
    (progressive_frame,lower_layer_progressive_frame,llframe0[0],llframe1[0],
     lltmp,current_frame[0],lower_layer_horizontal_offset,
     lower_layer_vertical_offset,
     lower_layer_prediction_horizontal_size,
     lower_layer_prediction_vertical_size,
     horizontal_size,vertical_size,vertical_subsampling_factor_m,
     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,
     horizontal_subsampling_factor_n,
     picture_structure!=FRAME_PICTURE); /* this changed from CD to DIS */

  Make_Spatial_Prediction_Frame  /* Cb */
    (progressive_frame,lower_layer_progressive_frame,llframe0[1],llframe1[1],
     lltmp,current_frame[1],lower_layer_horizontal_offset/2,
     lower_layer_vertical_offset/2,
     lower_layer_prediction_horizontal_size>>1,
     lower_layer_prediction_vertical_size>>1,
     horizontal_size>>1,vertical_size>>1,vertical_subsampling_factor_m,
     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,
     horizontal_subsampling_factor_n,1);

  Make_Spatial_Prediction_Frame  /* Cr */
    (progressive_frame,lower_layer_progressive_frame,llframe0[2],llframe1[2],
     lltmp,current_frame[2],lower_layer_horizontal_offset/2,
     lower_layer_vertical_offset/2,
     lower_layer_prediction_horizontal_size>>1,
     lower_layer_prediction_vertical_size>>1,
     horizontal_size>>1,vertical_size>>1,vertical_subsampling_factor_m,
     vertical_subsampling_factor_n,horizontal_subsampling_factor_m,
     horizontal_subsampling_factor_n,1);

}

static void Read_Lower_Layer_Component_Framewise(comp,lw,lh)
     int comp;
     int lw, lh;
{
  FILE *fd;
  char fname[256];
  char ext[3][3] = {".Y",".U",".V"}; 
/*  char *ext = {".Y",".U",".V"}; */
  int i,j;

  sprintf(fname,Lower_Layer_Picture_Filename,True_Framenum);
  strcat(fname,ext[comp]);
#ifdef VERBOSE
  if (Verbose_Flag>1)
    printf("reading %s\n",fname);
#endif /*VERBOSE*/
  fd=fopen(fname,"rb");
  if (fd==NULL) exit(-1);
  for (j=0; j<lh; j++) {
     for (i=0; i<lw; i++)
       llframe0[comp][lw*j+i]=fgetc(fd);
     if (! lower_layer_progressive_frame) {
	j++;
	for (i=0; i<lw; i++)
	  llframe1[comp][lw*j+i]=fgetc(fd);
     }
  }
  fclose(fd);
}


static void Read_Lower_Layer_Component_Fieldwise(comp,lw,lh)
     int comp;
     int lw, lh;
{
  FILE *fd;
  char fname[256];
  char ext[3][3] = {".Y",".U",".V"}; 
/*  char *ext = {".Y",".U",".V"}; */
  int i,j;

  sprintf(fname,Lower_Layer_Picture_Filename,True_Framenum,lower_layer_progressive_frame ? 'f':'a');
  strcat(fname,ext[comp]);
#ifdef VERBOSE
  if (Verbose_Flag>1)
    printf("reading %s\n",fname);
#endif /*VERBOSE*/
  fd=fopen(fname,"rb");
  if (fd==NULL) exit(-1);
  for (j=0; j<lh; j+=lower_layer_progressive_frame?1:2)
    for (i=0; i<lw; i++)
      llframe0[comp][lw*j+i]=fgetc(fd);
  fclose(fd);

  if (! lower_layer_progressive_frame) {
    sprintf(fname,Lower_Layer_Picture_Filename,True_Framenum,'b');
    strcat(fname,ext[comp]);
#ifdef VERBOSE
    if (Verbose_Flag>1)
      printf("reading %s\n",fname);
#endif /*VERBOSE*/
    fd=fopen(fname,"rb");
    if (fd==NULL) exit(-1);
    for (j=1; j<lh; j+=2)
      for (i=0; i<lw; i++)
        llframe1[comp][lw*j+i]=fgetc(fd);
    fclose(fd);
  }
}


/* form spatial prediction */
static void Make_Spatial_Prediction_Frame(progressive_frame,
  llprogressive_frame,fld0,fld1,tmp,dst,llx0,lly0,llw,llh,horizontal_size,
  vertical_size,vm,vn,hm,hn,aperture)
int progressive_frame,llprogressive_frame;
unsigned char *fld0,*fld1;
short *tmp;
unsigned char *dst;
int llx0,lly0,llw,llh,horizontal_size,vertical_size,vm,vn,hm,hn,aperture;
{
  int w, h, x0, llw2, llh2;

  llw2 = (llw*hn)/hm;
  llh2 = (llh*vn)/vm;

  if (llprogressive_frame)
  {
    /* progressive -> progressive / interlaced */
    Subsample_Vertical(fld0,tmp,llw,llh,llh2,vm,vn,0,1);
  }
  else if (progressive_frame)
  {
    /* interlaced -> progressive */
    if (lower_layer_deinterlaced_field_select)
    {
      Deinterlace(fld1,fld0,0,llw,llh,aperture);
      Subsample_Vertical(fld1,tmp,llw,llh,llh2,vm,vn,0,1);
    }
    else
    {
      Deinterlace(fld0,fld1,1,llw,llh,aperture);
      Subsample_Vertical(fld0,tmp,llw,llh,llh2,vm,vn,0,1);
    }
  }
  else
  {
    /* interlaced -> interlaced */
    Deinterlace(fld0,fld1,1,llw,llh,aperture);
    Deinterlace(fld1,fld0,0,llw,llh,aperture);
    Subsample_Vertical(fld0,tmp,llw,llh,llh2,vm,vn,0,2);
    Subsample_Vertical(fld1,tmp,llw,llh,llh2,vm,vn,1,2);
  }

    /* vertical limits */
    if (lly0<0)
    {
      tmp-= llw*lly0;
      llh2+= lly0;
      if (llh2<0)
        llh2 = 0;
      h = (vertical_size<llh2) ? vertical_size : llh2;
    }
    else
    {
      dst+= horizontal_size*lly0;
      h= vertical_size - lly0;
      if (h>llh2)
        h = llh2;
    }

    /* horizontal limits */
    if (llx0<0)
    {
      x0 = -llx0;
      llw2+= llx0;
      if (llw2<0)
        llw2 = 0;
      w = (horizontal_size<llw2) ? horizontal_size : llw2;
    }
    else
    {
      dst+= llx0;
      x0 = 0;
      w = horizontal_size - llx0;
      if (w>llw2)
        w = llw2;
    }
  
  Subsample_Horizontal(tmp,dst,x0,w,llw,horizontal_size,h,hm,hn);
}

/* deinterlace one field (interpolate opposite parity samples)
 *
 * deinterlacing is done in-place: if j0=1, fld0 contains the input field in
 * its even lines and the odd lines are interpolated by this routine
 * if j0=0, the input field is in the odd lines and the even lines are
 * interpolated
 *
 * fld0: field to be deinterlaced
 * fld1: other field (referenced by the two field aperture filter)
 * j0:   0: interpolate even (top) lines, 1: interpolate odd (bottom) lines
 * lx:   width of fld0 and fld1
 * ly:   height of the deinterlaced field (has to be even)
 * aperture: 1: use one field aperture filter (two field otherwise)
 */
static void Deinterlace(fld0,fld1,j0,lx,ly,aperture)
unsigned char *fld0,*fld1;
int j0,lx,ly; /* ly has to be even */
int aperture;
{
  int i,j,v;
  unsigned char *p0, *p0m1, *p0p1, *p1, *p1m2, *p1p2;

  /* deinterlace one field */
  for (j=j0; j<ly; j+=2)
  {
    p0 = fld0+lx*j;
    p0m1 = (j==0)    ? p0+lx : p0-lx;
    p0p1 = (j==ly-1) ? p0-lx : p0+lx;

    if (aperture)
      for (i=0; i<lx; i++)
        p0[i] = (unsigned int)(p0m1[i] + p0p1[i] + 1)>>1;
    else
    {
      p1 = fld1 + lx*j;
      p1m2 = (j<2)     ? p1 : p1-2*lx;
      p1p2 = (j>=ly-2) ? p1 : p1+2*lx;
      for (i=0; i<lx; i++)
      {
        v = 8*(p0m1[i]+p0p1[i]) + 2*p1[i] - p1m2[i] - p1p2[i];
        p0[i] = Clip[(v + ((v>=0) ? 8 : 7))>>4];
      }
    }
  }
}

/* vertical resampling */
static void Subsample_Vertical(s,d,lx,lys,lyd,m,n,j0,dj)
unsigned char *s;
short *d;
int lx, lys, lyd, m, n, j0, dj;
{
  int i, j, c1, c2, jd;
  unsigned char *s1, *s2;
  short *d1;

  for (j=j0; j<lyd; j+=dj)
  {
    d1 = d + lx*j;
    jd = (j*m)/n;
    s1 = s + lx*jd;
    s2 = (jd<lys-1)? s1+lx : s1;
    c2 = (16*((j*m)%n) + (n>>1))/n;
    c1 = 16 - c2;
    for (i=0; i<lx; i++)
      d1[i] = c1*s1[i] + c2*s2[i];
  }
}

/* horizontal resampling */
static void Subsample_Horizontal(s,d,x0,lx,lxs,lxd,ly,m,n)
short *s;
unsigned char *d;
int x0, lx, lxs, lxd, ly, m, n;
{
  int i, i1, j, id, c1, c2, v;
  short *s1, *s2;
  unsigned char *d1;

  for (i1=0; i1<lx; i1++)
  {
    d1 = d + i1;
    i = x0 + i1;
    id = (i*m)/n;
    s1 = s+id;
    s2 = (id<lxs-1) ? s1+1 : s1;
    c2 = (16*((i*m)%n) + (n>>1))/n;
    c1 = 16 - c2;
    for (j=0; j<ly; j++)
    {
      v = c1*(*s1) + c2*(*s2);
      *d1 = (v + ((v>=0) ? 128 : 127))>>8;
      d1+= lxd;
      s1+= lxs;
      s2+= lxs;
    }
  }
}


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* store.c, picture output routines                                         */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>

#include "config.h"
#include "global.h"

/* private prototypes */
static void store_one _ANSI_ARGS_((char *outname, unsigned char *src[],
  int offset, int incr, int height));
static void store_yuv _ANSI_ARGS_((char *outname, unsigned char *src[],
  int offset, int incr, int height));
static void store_sif _ANSI_ARGS_((char *outname, unsigned char *src[],
  int offset, int incr, int height));
static void store_ppm_tga _ANSI_ARGS_((char *outname, unsigned char *src[],
  int offset, int incr, int height, int tgaflag));
static void store_yuv1 _ANSI_ARGS_((char *name, unsigned char *src,
  int offset, int incr, int width, int height));
static void putbyte _ANSI_ARGS_((int c));
static void putword _ANSI_ARGS_((int w));
static void conv422to444 _ANSI_ARGS_((unsigned char *src, unsigned char *dst));
static void conv420to422 _ANSI_ARGS_((unsigned char *src, unsigned char *dst));

static void store_yuv_progressive _ANSI_ARGS_((char *outname, unsigned char *src[],
				   int offset, int incr, int height));

#define OBFRSIZE 8192 /*4096*/
static unsigned char obfr[OBFRSIZE];
static unsigned char *optr;
static int outfile;

/*
 * store a picture as either one frame or two fields
 */
void Write_Frame(src,frame)
unsigned char *src[];
int frame;
{
  char outname[FILENAME_LENGTH];

  if (progressive_sequence || progressive_frame || Frame_Store_Flag)
  {
    /* progressive */
    sprintf(outname,Output_Picture_Filename,frame,'f');
    store_one(outname,src,0,Coded_Picture_Width,vertical_size);
  }
  else
  {
    /* interlaced */
    sprintf(outname,Output_Picture_Filename,frame,'a');
    store_one(outname,src,0,Coded_Picture_Width<<1,vertical_size>>1);

    sprintf(outname,Output_Picture_Filename,frame,'b');
    store_one(outname,src,
      Coded_Picture_Width,Coded_Picture_Width<<1,vertical_size>>1);
  }
}

/*
 * store one frame or one field
 */
static void store_one(outname,src,offset,incr,height)
char *outname;
unsigned char *src[];
int offset, incr, height;
{
  switch (Output_Type)
  {
  case T_YUV:
    if (incr==Coded_Picture_Width)
      store_yuv_progressive(outname,src,offset,incr,height);
    else
      store_yuv(outname,src,offset,incr,height);
    break;
  case T_SIF:
    store_sif(outname,src,offset,incr,height);
    break;
  case T_TGA:
    store_ppm_tga(outname,src,offset,incr,height,1);
    break;
  case T_PPM:
    store_ppm_tga(outname,src,offset,incr,height,0);
    break;
#ifdef DISPLAY
  case T_X11:
    dither(src);
    break;
#endif
  default:
    break;
  }
}

static void store_yuvp(name,src,offset,incr,width,height)
char *name;
unsigned char *src;
int offset,incr,width,height;
{
  int i, j;
  unsigned char *p;

  if (!Quiet_Flag)
    fprintf(stderr,"saving %s\n",name);

  if ((outfile = open(name,O_CREAT|O_TRUNC|O_WRONLY|O_BINARY,0666))==-1)
  {
    sprintf(Error_Text,"Couldn't create %s\n",name);
    Error(Error_Text);
  }

  assert(write(outfile,src,width*height)==width*height && "frame write problem\n");
  close(outfile);
}

/* separate headerless files for y, u and v */
static void store_yuv_progressive(outname,src,offset,incr,height)
char *outname;
unsigned char *src[];
int offset,incr,height;
{
  int hsize;
  char tmpname[FILENAME_LENGTH];

  hsize = horizontal_size;

  sprintf(tmpname,"%s.Y",outname);
  store_yuvp(tmpname,src[0],offset,incr,hsize,height);

  if (chroma_format!=CHROMA444)
  {
    offset>>=1; incr>>=1; hsize>>=1;
  }

  if (chroma_format==CHROMA420)
  {
    height>>=1;
  }

  sprintf(tmpname,"%s.U",outname);
  store_yuvp(tmpname,src[1],offset,incr,hsize,height);

  sprintf(tmpname,"%s.V",outname);
  store_yuvp(tmpname,src[2],offset,incr,hsize,height);
}

/* separate headerless files for y, u and v */
static void store_yuv(outname,src,offset,incr,height)
char *outname;
unsigned char *src[];
int offset,incr,height;
{
  int hsize;
  char tmpname[FILENAME_LENGTH];

  hsize = horizontal_size;

  sprintf(tmpname,"%s.Y",outname);
  store_yuv1(tmpname,src[0],offset,incr,hsize,height);

  if (chroma_format!=CHROMA444)
  {
    offset>>=1; incr>>=1; hsize>>=1;
  }

  if (chroma_format==CHROMA420)
  {
    height>>=1;
  }

  sprintf(tmpname,"%s.U",outname);
  store_yuv1(tmpname,src[1],offset,incr,hsize,height);

  sprintf(tmpname,"%s.V",outname);
  store_yuv1(tmpname,src[2],offset,incr,hsize,height);
}

/* auxiliary routine */
static void store_yuv1(name,src,offset,incr,width,height)
char *name;
unsigned char *src;
int offset,incr,width,height;
{
  int i, j;
  unsigned char *p;

  if (!Quiet_Flag)
    fprintf(stderr,"saving %s\n",name);

  if ((outfile = open(name,O_CREAT|O_TRUNC|O_WRONLY|O_BINARY,0666))==-1)
  {
    sprintf(Error_Text,"Couldn't create %s\n",name);
    Error(Error_Text);
  }

  optr=obfr;

  for (i=0; i<height; i++)
  {
    p = src + offset + incr*i;
    for (j=0; j<width; j++)
      putbyte(*p++);
  }

  if (optr!=obfr)
    write(outfile,obfr,optr-obfr);

  close(outfile);
}

/*
 * store as headerless file in U,Y,V,Y format
 */
static void store_sif (outname,src,offset,incr,height)
char *outname;
unsigned char *src[];
int offset, incr, height;
{
  int i,j;
  unsigned char *py, *pu, *pv;
  static unsigned char *u422, *v422;

  if (chroma_format==CHROMA444)
    Error("4:4:4 not supported for SIF format");

  if (chroma_format==CHROMA422)
  {
    u422 = src[1];
    v422 = src[2];
  }
  else
  {
    if (!u422)
    {
      if (!(u422 = (unsigned char *)malloc((Coded_Picture_Width>>1)
                                           *Coded_Picture_Height)))
        Error("malloc failed");
      if (!(v422 = (unsigned char *)malloc((Coded_Picture_Width>>1)
                                           *Coded_Picture_Height)))
        Error("malloc failed");
    }
  
    conv420to422(src[1],u422);
    conv420to422(src[2],v422);
  }

  strcat(outname,".SIF");

  if (!Quiet_Flag)
    fprintf(stderr,"saving %s\n",outname);

  if ((outfile = open(outname,O_CREAT|O_TRUNC|O_WRONLY|O_BINARY,0666))==-1)
  {
    sprintf(Error_Text,"Couldn't create %s\n",outname);
    Error(Error_Text);
  }

  optr = obfr;

  for (i=0; i<height; i++)
  {
    py = src[0] + offset + incr*i;
    pu = u422 + (offset>>1) + (incr>>1)*i;
    pv = v422 + (offset>>1) + (incr>>1)*i;

    for (j=0; j<horizontal_size; j+=2)
    {
      putbyte(*pu++);
      putbyte(*py++);
      putbyte(*pv++);
      putbyte(*py++);
    }
  }

  if (optr!=obfr)
    write(outfile,obfr,optr-obfr);

  close(outfile);
}

/*
 * store as PPM (PBMPLUS) or uncompressed Truevision TGA ('Targa') file
 */
static void store_ppm_tga(outname,src,offset,incr,height,tgaflag)
char *outname;
unsigned char *src[];
int offset, incr, height;
int tgaflag;
{
  int i, j;
  int y, u, v, r, g, b;
  int crv, cbu, cgu, cgv;
  unsigned char *py, *pu, *pv;
  static unsigned char tga24[14] = {0,0,2,0,0,0,0, 0,0,0,0,0,24,32};
  char header[FILENAME_LENGTH];
  static unsigned char *u422, *v422, *u444, *v444;

  if (chroma_format==CHROMA444)
  {
    u444 = src[1];
    v444 = src[2];
  }
  else
  {
    if (!u444)
    {
      if (chroma_format==CHROMA420)
      {
        if (!(u422 = (unsigned char *)malloc((Coded_Picture_Width>>1)
                                             *Coded_Picture_Height)))
          Error("malloc failed");
        if (!(v422 = (unsigned char *)malloc((Coded_Picture_Width>>1)
                                             *Coded_Picture_Height)))
          Error("malloc failed");
      }

      if (!(u444 = (unsigned char *)malloc(Coded_Picture_Width
                                           *Coded_Picture_Height)))
        Error("malloc failed");

      if (!(v444 = (unsigned char *)malloc(Coded_Picture_Width
                                           *Coded_Picture_Height)))
        Error("malloc failed");
    }

    if (chroma_format==CHROMA420)
    {
      conv420to422(src[1],u422);
      conv420to422(src[2],v422);
      conv422to444(u422,u444);
      conv422to444(v422,v444);
    }
    else
    {
      conv422to444(src[1],u444);
      conv422to444(src[2],v444);
    }
  }

  strcat(outname,tgaflag ? ".tga" : ".ppm");

  if (!Quiet_Flag)
    fprintf(stderr,"saving %s\n",outname);

  if ((outfile = open(outname,O_CREAT|O_TRUNC|O_WRONLY|O_BINARY,0666))==-1)
  {
    sprintf(Error_Text,"Couldn't create %s\n",outname);
    Error(Error_Text);
  }

  optr = obfr;

  if (tgaflag)
  {
    /* TGA header */
    for (i=0; i<12; i++)
      putbyte(tga24[i]);

    putword(horizontal_size); putword(height);
    putbyte(tga24[12]); putbyte(tga24[13]);
  }
  else
  {
    /* PPM header */
    sprintf(header,"P6\n%d %d\n255\n",horizontal_size,height);

    for (i=0; header[i]!=0; i++)
      putbyte(header[i]);
  }

  /* matrix coefficients */
  crv = Inverse_Table_6_9[matrix_coefficients][0];
  cbu = Inverse_Table_6_9[matrix_coefficients][1];
  cgu = Inverse_Table_6_9[matrix_coefficients][2];
  cgv = Inverse_Table_6_9[matrix_coefficients][3];
  
  for (i=0; i<height; i++)
  {
    py = src[0] + offset + incr*i;
    pu = u444 + offset + incr*i;
    pv = v444 + offset + incr*i;

    for (j=0; j<horizontal_size; j++)
    {
      u = *pu++ - 128;
      v = *pv++ - 128;
      y = 76309 * (*py++ - 16); /* (255/219)*65536 */
      r = Clip[(y + crv*v + 32768)>>16];
      g = Clip[(y - cgu*u - cgv*v + 32768)>>16];
      b = Clip[(y + cbu*u + 32786)>>16];

      if (tgaflag)
      {
        putbyte(b); putbyte(g); putbyte(r);
      }
      else
      {
        putbyte(r); putbyte(g); putbyte(b);
      }
    }
  }

  if (optr!=obfr)
    write(outfile,obfr,optr-obfr);

  close(outfile);
}

static void putbyte(c)
int c;
{
  *optr++ = c;

  if (optr == obfr+OBFRSIZE)
  {
    write(outfile,obfr,OBFRSIZE);
    optr = obfr;
  }
}

static void putword(w)
int w;
{
  putbyte(w); putbyte(w>>8);
}

/* horizontal 1:2 interpolation filter */
static void conv422to444(src,dst)
unsigned char *src,*dst;
{
  int i, i2, w, j, im3, im2, im1, ip1, ip2, ip3;

  w = Coded_Picture_Width>>1;

  if (base.MPEG2_Flag)
  {
    for (j=0; j<Coded_Picture_Height; j++)
    {
      for (i=0; i<w; i++)
      {
        i2 = i<<1;
        im2 = (i<2) ? 0 : i-2;
        im1 = (i<1) ? 0 : i-1;
        ip1 = (i<w-1) ? i+1 : w-1;
        ip2 = (i<w-2) ? i+2 : w-1;
        ip3 = (i<w-3) ? i+3 : w-1;

        /* FIR filter coefficients (*256): 21 0 -52 0 159 256 159 0 -52 0 21 */
        /* even samples (0 0 256 0 0) */
        dst[i2] = src[i];

        /* odd samples (21 -52 159 159 -52 21) */
        dst[i2+1] = Clip[(int)(21*(src[im2]+src[ip3])
                        -52*(src[im1]+src[ip2]) 
                       +159*(src[i]+src[ip1])+128)>>8];
      }
      src+= w;
      dst+= Coded_Picture_Width;
    }
  }
  else
  {
    for (j=0; j<Coded_Picture_Height; j++)
    {
      for (i=0; i<w; i++)
      {

        i2 = i<<1;
        im3 = (i<3) ? 0 : i-3;
        im2 = (i<2) ? 0 : i-2;
        im1 = (i<1) ? 0 : i-1;
        ip1 = (i<w-1) ? i+1 : w-1;
        ip2 = (i<w-2) ? i+2 : w-1;
        ip3 = (i<w-3) ? i+3 : w-1;

        /* FIR filter coefficients (*256): 5 -21 70 228 -37 11 */
        dst[i2] =   Clip[(int)(  5*src[im3]
                         -21*src[im2]
                         +70*src[im1]
                        +228*src[i]
                         -37*src[ip1]
                         +11*src[ip2]+128)>>8];

       dst[i2+1] = Clip[(int)(  5*src[ip3]
                         -21*src[ip2]
                         +70*src[ip1]
                        +228*src[i]
                         -37*src[im1]
                         +11*src[im2]+128)>>8];
      }
      src+= w;
      dst+= Coded_Picture_Width;
    }
  }
}

/* vertical 1:2 interpolation filter */
static void conv420to422(src,dst)
unsigned char *src,*dst;
{
  int w, h, i, j, j2;
  int jm6, jm5, jm4, jm3, jm2, jm1, jp1, jp2, jp3, jp4, jp5, jp6, jp7;

  w = Coded_Picture_Width>>1;
  h = Coded_Picture_Height>>1;

  if (progressive_frame)
  {
    /* intra frame */
    for (i=0; i<w; i++)
    {
      for (j=0; j<h; j++)
      {
        j2 = j<<1;
        jm3 = (j<3) ? 0 : j-3;
        jm2 = (j<2) ? 0 : j-2;
        jm1 = (j<1) ? 0 : j-1;
        jp1 = (j<h-1) ? j+1 : h-1;
        jp2 = (j<h-2) ? j+2 : h-1;
        jp3 = (j<h-3) ? j+3 : h-1;

        /* FIR filter coefficients (*256): 5 -21 70 228 -37 11 */
        /* New FIR filter coefficients (*256): 3 -16 67 227 -32 7 */
        dst[w*j2] =     Clip[(int)(  3*src[w*jm3]
                             -16*src[w*jm2]
                             +67*src[w*jm1]
                            +227*src[w*j]
                             -32*src[w*jp1]
                             +7*src[w*jp2]+128)>>8];

        dst[w*(j2+1)] = Clip[(int)(  3*src[w*jp3]
                             -16*src[w*jp2]
                             +67*src[w*jp1]
                            +227*src[w*j]
                             -32*src[w*jm1]
                             +7*src[w*jm2]+128)>>8];
      }
      src++;
      dst++;
    }
  }
  else
  {
    /* intra field */
    for (i=0; i<w; i++)
    {
      for (j=0; j<h; j+=2)
      {
        j2 = j<<1;

        /* top field */
        jm6 = (j<6) ? 0 : j-6;
        jm4 = (j<4) ? 0 : j-4;
        jm2 = (j<2) ? 0 : j-2;
        jp2 = (j<h-2) ? j+2 : h-2;
        jp4 = (j<h-4) ? j+4 : h-2;
        jp6 = (j<h-6) ? j+6 : h-2;

        /* Polyphase FIR filter coefficients (*256): 2 -10 35 242 -18 5 */
        /* New polyphase FIR filter coefficients (*256): 1 -7 30 248 -21 5 */
        dst[w*j2] = Clip[(int)(  1*src[w*jm6]
                         -7*src[w*jm4]
                         +30*src[w*jm2]
                        +248*src[w*j]
                         -21*src[w*jp2]
                          +5*src[w*jp4]+128)>>8];

        /* Polyphase FIR filter coefficients (*256): 11 -38 192 113 -30 8 */
        /* New polyphase FIR filter coefficients (*256):7 -35 194 110 -24 4 */
        dst[w*(j2+2)] = Clip[(int)( 7*src[w*jm4]
                             -35*src[w*jm2]
                            +194*src[w*j]
                            +110*src[w*jp2]
                             -24*src[w*jp4]
                              +4*src[w*jp6]+128)>>8];

        /* bottom field */
        jm5 = (j<5) ? 1 : j-5;
        jm3 = (j<3) ? 1 : j-3;
        jm1 = (j<1) ? 1 : j-1;
        jp1 = (j<h-1) ? j+1 : h-1;
        jp3 = (j<h-3) ? j+3 : h-1;
        jp5 = (j<h-5) ? j+5 : h-1;
        jp7 = (j<h-7) ? j+7 : h-1;

        /* Polyphase FIR filter coefficients (*256): 11 -38 192 113 -30 8 */
        /* New polyphase FIR filter coefficients (*256):7 -35 194 110 -24 4 */
        dst[w*(j2+1)] = Clip[(int)( 7*src[w*jp5]
                             -35*src[w*jp3]
                            +194*src[w*jp1]
                            +110*src[w*jm1]
                             -24*src[w*jm3]
                              +4*src[w*jm5]+128)>>8];

        dst[w*(j2+3)] = Clip[(int)(  1*src[w*jp7]
                             -7*src[w*jp5]
                             +30*src[w*jp3]
                            +248*src[w*jp1]
                             -21*src[w*jm1]
                              +5*src[w*jm3]+128)>>8];
      }
      src++;
      dst++;
    }
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* #define DEBUG */
/* subspic.c, Frame buffer substitution routines */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#include "config.h"
#include "global.h"

/* private prototypes*/
static void Read_Frame _ANSI_ARGS_((char *filename, 
  unsigned char *frame_buffer[], int framenum));
static void Copy_Frame _ANSI_ARGS_((unsigned char *src, unsigned char *dst, 
  int width, int height, int parity, int incr));
static int Read_Components _ANSI_ARGS_ ((char *filename, 
  unsigned char *frame[3], int framenum));
static int Read_Component _ANSI_ARGS_ ((char *fname, unsigned char *frame, 
  int width, int height));
static int Extract_Components _ANSI_ARGS_ ((char *filename,
  unsigned char *frame[3], int framenum));


/* substitute frame buffer routine */
void Substitute_Frame_Buffer (bitstream_framenum, sequence_framenum)
int bitstream_framenum;
int sequence_framenum;
{
  /* static tracking variables */
  static int previous_temporal_reference;
  static int previous_bitstream_framenum;
  static int previous_anchor_temporal_reference;
  static int previous_anchor_bitstream_framenum;
  static int previous_picture_coding_type;
  static int bgate;
  
  /* local temporary variables */
  int substitute_display_framenum;


#ifdef DEBUG
  printf("SUB: seq fn(%d) bitfn(%d) tempref(%d) picstr(%d) type(%d)\n", 
    sequence_framenum, bitstream_framenum, temporal_reference, 
    picture_structure, picture_coding_type);
#endif

  /* we don't substitute at the first picture of a sequence */
  if((sequence_framenum!=0)||(Second_Field))
  {
    /* only at the start of the frame */
    if ((picture_structure==FRAME_PICTURE)||(!Second_Field))
    {
      if(picture_coding_type==P_TYPE)
      {
        /* the most recently decoded reference frame needs substituting */
        substitute_display_framenum = bitstream_framenum - 1;
        
        Read_Frame(Substitute_Picture_Filename, forward_reference_frame, 
          substitute_display_framenum);
      }
      /* only the first B frame in a consequitve set of B pictures
         loads a substitute backward_reference_frame since all subsequent
         B frames predict from the same reference pictures */
      else if((picture_coding_type==B_TYPE)&&(bgate!=1))
      {
        substitute_display_framenum = 
          (previous_temporal_reference - temporal_reference) 
            + bitstream_framenum - 1;

        Read_Frame(Substitute_Picture_Filename, backward_reference_frame, 
          substitute_display_framenum);
      }
    } /* P fields can predict from the two most recently decoded fields, even
         from the first field of the same frame being decoded */
    else if(Second_Field && (picture_coding_type==P_TYPE))
    {
      /* our favourite case: the IP field picture pair */
      if((previous_picture_coding_type==I_TYPE)&&(picture_coding_type==P_TYPE))
      {
        substitute_display_framenum = bitstream_framenum;
      }
      else /* our more generic P field picture pair */
      {
        substitute_display_framenum = 
          (temporal_reference - previous_anchor_temporal_reference) 
            + bitstream_framenum - 1;
      }

      Read_Frame(Substitute_Picture_Filename, current_frame, substitute_display_framenum);
    }
#ifdef DEBUG
    else if((picture_coding_type!=B_TYPE)||(picture_coding_type!=D_TYPE))
    {
      printf("NO SUBS FOR THIS PICTURE\n");
    }
#endif
  }


  /* set b gate so we don't redundantly load next time around */
  if(picture_coding_type==B_TYPE)
    bgate = 1;
  else
    bgate = 0;

  /* update general tracking variables */
  if((picture_structure==FRAME_PICTURE)||(!Second_Field))
  {
    previous_temporal_reference  = temporal_reference;
    previous_bitstream_framenum  = bitstream_framenum;
  }
  
  /* update reference frame tracking variables */
  if((picture_coding_type!=B_TYPE) && 
    ((picture_structure==FRAME_PICTURE)||Second_Field))
  {
    previous_anchor_temporal_reference  = temporal_reference;
    previous_anchor_bitstream_framenum  = bitstream_framenum;
  }

  previous_picture_coding_type = picture_coding_type;

}


/* Note: fields are only read to serve as the same-frame reference for 
   a second field */
static void Read_Frame(fname,frame,framenum)
char *fname;
unsigned char *frame[];
int framenum;
{
  int parity;
  int rerr = 0;
  int field_mode;

  if(framenum<0)
    printf("ERROR: framenum (%d) is less than zero\n", framenum);


  if(Big_Picture_Flag)
    rerr = Extract_Components(fname, substitute_frame, framenum);
  else
    rerr = Read_Components(fname, substitute_frame, framenum);

  if(rerr!=0)
  {
    printf("was unable to substitute frame\n");
  }

  /* now copy to the appropriate buffer */
  /* first field (which we are attempting to substitute) must be
     of opposite field parity to the current one */
  if((Second_Field)&&(picture_coding_type==P_TYPE))
  {
    parity      = (picture_structure==TOP_FIELD ? 1:0);      
    field_mode  = (picture_structure==FRAME_PICTURE ? 0:1);
  }
  else
  {
    /* Like frame structued pictures, B pictures only substitute an entire frame 
       since both fields always predict from the same frame (with respect 
       to forward/backwards directions) */
    parity = 0;
    field_mode = 0;
  }


  Copy_Frame(substitute_frame[0], frame[0], Coded_Picture_Width, 
    Coded_Picture_Height, parity, field_mode);
  
  Copy_Frame(substitute_frame[1], frame[1], Chroma_Width, Chroma_Height, 
    parity, field_mode);
  
  Copy_Frame(substitute_frame[2], frame[2], Chroma_Width, Chroma_Height,
    parity, field_mode);

#ifdef VERBOSE
  if(Verbose_Flag > NO_LAYER)
    printf("substituted %s %d\n",
      (field_mode ? (parity?"bottom field":"bottom field"):"frame"), framenum);
#endif
}




static int Read_Components(filename, frame, framenum) 
char *filename;
unsigned char *frame[3];
int framenum;
{
  int err = 0;
  char outname[FILENAME_LENGTH];
  char name[FILENAME_LENGTH];

  sprintf(outname,filename,framenum);


  sprintf(name,"%s.Y",outname);
  err += Read_Component(name, frame[0], Coded_Picture_Width, 
    Coded_Picture_Height);

  sprintf(name,"%s.U",outname);
  err += Read_Component(name, frame[1], Chroma_Width, Chroma_Height);

  sprintf(name,"%s.V",outname);
  err += Read_Component(name, frame[2], Chroma_Width, Chroma_Height);

  return(err);
}


static int Read_Component(Filename, Frame, Width, Height)
char *Filename;
unsigned char *Frame;
int Width;
int Height;
{
  int Size;
  int Bytes_Read;
  int Infile;

  Size = Width*Height;

#ifdef DEBUG
  printf("SUBS: reading %s\n", filename);
#endif

  if(!(Infile=open(Filename,O_RDONLY|O_BINARY))<0)
  {
    printf("ERROR: unable to open reference filename (%s)\n", Filename);
	return(-1);
  }

  Bytes_Read = read(Infile, Frame, Size);
  
  if(Bytes_Read!=Size)
  {
    printf("was able to read only %d bytes of %d of file %s\n",
      Bytes_Read, Size, Filename);
  }
 
  close(Infile); 
  return(0);
}


/* optimization: do not open the big file each time. Open once at start
   of decoder, and close at the very last frame */

/* Note: "big" files were used in E-mail exchanges almost exclusively by the 
   MPEG Committee's syntax validation and conformance ad-hoc groups from 
   the year 1993 until 1995 */
static int Extract_Components(filename, frame, framenum) 
char *filename;
unsigned char *frame[3];
int framenum;
{
/*  int err = 0; */
  FILE *fd;
  int line;
  int size, offset;


  if (!(fd = fopen(filename,"rb")))
  {
    sprintf(Error_Text,"Couldn't open %s\n",filename);
    return(-1);
  }

  /* compute size of each frame (in bytes) */
  size = (Coded_Picture_Width*Coded_Picture_Height);

  if(chroma_format==CHROMA444)
    size = (size * 3);
  else if(chroma_format==CHROMA422)
    size = (size * 2);
  else if(chroma_format==CHROMA420)
    size = ((size*3)>>1);
  else
    printf("ERROR: chroma_format (%d) not recognized\n", chroma_format);


  /* compute distance into "big" file */
  offset = size*framenum;

#ifdef DEBUG
  printf("EXTRACTING: frame(%d) offset(%d), size (%d) from %s\n", 
    framenum, offset, size, filename);
#endif

  /* seek to location in big file where desired frame begins */
  /* note: this offset cannot exceed a few billion bytes due to the */
  /*       obvious limitations of 32-bit integers */
  fseek(fd, offset, 0);

  /* Y  */
  for (line=0; line<Coded_Picture_Height; line++)
  {
    fread(frame[0]+(line*Coded_Picture_Width),1,Coded_Picture_Width,fd);
  }

  /* Cb */
  for (line=0; line<Chroma_Height; line++)
  {
    fread(frame[1]+(line*Chroma_Width),1,Chroma_Width,fd);
  }

  /* Cr */
  for (line=0; line<Chroma_Height; line++)
  {
    fread(frame[2]+(line*Chroma_Width),1,Chroma_Width,fd);
  }


  fclose(fd);
  return(0);
}


static void Copy_Frame(src, dst, width, height, parity, field_mode)
unsigned char *src;
unsigned char *dst;
int width;
int height;
int parity;        /* field parity (top or bottom) to overwrite */
int field_mode;    /* 0 = frame, 1 = field                      */
{
  int row, col;
  int s, d;
  int incr;

  s = d = 0;

#ifdef DEBUG
  printf("COPYING (w=%d, h=%d, parity=%d, field_mode=%d)\n",
    width,height,parity,field_mode);
#endif /* DEBUG */

  if(field_mode)
  {
    incr = 2;

    if(parity==0)
      s += width;
  }
  else
  {
    incr = 1;
  }

  for(row=0; row<height; row+=incr) 
  {
    for(col=0; col<width; col++)
    {
      dst[d+col] = src[s+col];
    }
    
    d += (width*incr);
    s += (width*incr);
  }

}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* systems.c, systems-specific routines                                 */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include "config.h"
#include "global.h"

/* initialize buffer, call once before first getbits or showbits */

/* parse system layer, ignore everything we don't need */
void Next_Packet()
{
  unsigned int code;
  int l;

  for(;;)
  {
    code = Get_Long();

    /* remove system layer byte stuffing */
    while ((code & 0xffffff00) != 0x100)
      code = (code<<8) | Get_Byte();

    switch(code)
    {
    case PACK_START_CODE: /* pack header */
      /* skip pack header (system_clock_reference and mux_rate) */
      ld->Rdptr += 8;
      break;
    case VIDEO_ELEMENTARY_STREAM:   
      code = Get_Word();             /* packet_length */
      ld->Rdmax = ld->Rdptr + code;

      code = Get_Byte();

      if((code>>6)==0x02)
      {
        ld->Rdptr++;
        code=Get_Byte();  /* parse PES_header_data_length */
        ld->Rdptr+=code;    /* advance pointer by PES_header_data_length */
        printf("MPEG-2 PES packet\n");
        return;
      }
      else if(code==0xff)
      {
        /* parse MPEG-1 packet header */
        while((code=Get_Byte())== 0xFF);
      }
       
      /* stuffing bytes */
      if(code>=0x40)
      {
        if(code>=0x80)
        {
          fprintf(stderr,"Error in packet header\n");
          exit(1);
        }
        /* skip STD_buffer_scale */
        ld->Rdptr++;
        code = Get_Byte();
      }

      if(code>=0x30)
      {
        if(code>=0x40)
        {
          fprintf(stderr,"Error in packet header\n");
          exit(1);
        }
        /* skip presentation and decoding time stamps */
        ld->Rdptr += 9;
      }
      else if(code>=0x20)
      {
        /* skip presentation time stamps */
        ld->Rdptr += 4;
      }
      else if(code!=0x0f)
      {
        fprintf(stderr,"Error in packet header\n");
        exit(1);
      }
      return;
    case ISO_END_CODE: /* end */
      /* simulate a buffer full of sequence end codes */
      l = 0;
      while (l<2048)
      {
        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>24;
        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>16;
        ld->Rdbfr[l++] = SEQUENCE_END_CODE>>8;
        ld->Rdbfr[l++] = SEQUENCE_END_CODE&0xff;
      }
      ld->Rdptr = ld->Rdbfr;
      ld->Rdmax = ld->Rdbfr + 2048;
      return;
    default:
      if(code>=SYSTEM_START_CODE)
      {
        /* skip system headers and non-video packets*/
        code = Get_Word();
        ld->Rdptr += code;
      }
      else
      {
        fprintf(stderr,"Unexpected startcode %08x in system layer\n",code);
        exit(1);
      }
      break;
    }
  }
}



void Flush_Buffer32()
{
  int Incnt;

  ld->Bfr = 0;

  Incnt = ld->Incnt;
  Incnt -= 32;

  if (System_Stream_Flag && (ld->Rdptr >= ld->Rdmax-4))
  {
    while (Incnt <= 24)
    {
      if (ld->Rdptr >= ld->Rdmax)
        Next_Packet();
      ld->Bfr |= Get_Byte() << (24 - Incnt);
      Incnt += 8;
    }
  }
  else
  {
    while (Incnt <= 24)
    {
      if (ld->Rdptr >= ld->Rdbfr+2048)
        Fill_Buffer();
      ld->Bfr |= *ld->Rdptr++ << (24 - Incnt);
      Incnt += 8;
    }
  }
  ld->Incnt = Incnt;

#ifdef VERIFY 
  ld->Bitcnt += 32;
#endif /* VERIFY */
}


unsigned int Get_Bits32()
{
  unsigned int l;

  l = Show_Bits(32);
  Flush_Buffer32();

  return l;
}


int Get_Long()
{
  int i;

  i = Get_Word();
  return (i<<16) | Get_Word();
}


#ifdef THRD
void Thrd_Flush_Buffer32(int t)
{
  int Incnt;

  thrd_buf[t] = 0;

  Incnt = thrd_Incnt[t];
  Incnt -= 32;

  if (System_Stream_Flag && (ld->Rdptr >= ld->Rdmax-4))
  {
    if (System_Stream_Flag) { printf("System_Stream_Flag is 1\n"); exit(1); }
    while (Incnt <= 24)
    {
      if (ld->Rdptr >= ld->Rdmax)
        Next_Packet();
      ld->Bfr |= Get_Byte() << (24 - Incnt);
      Incnt += 8;
    }
  }
  else
  {
    while (Incnt <= 24)
    {
      thrd_buf[t] |= *thrd_ptr[t]++ << (24 - Incnt);
      Incnt += 8;
    }
  }
  thrd_Incnt[t] = Incnt;

}


unsigned int Thrd_Get_Bits32(int t)
{
  unsigned int l;

  l = Thrd_Show_Bits(t,32);
  Thrd_Flush_Buffer32(t);

  return l;
}


int Thrd_Get_Long(t)
int t;
{
  int i;

  i = Thrd_Get_Word(t);
  return (i<<16) | Thrd_Get_Word(t);
}

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#ifdef RSIM

#define VEC_STRIDE_SET   0
#define VEC_CLEAR_BLK    1
#define VEC_SATURATE     2
#define VEC_IDCT         5

#define VEC_FLUSH           14

#define VEC_FORM_COMP_PRED  15
#define VEC_FORM_COMP_PRED2 30
#define VEC_FORM_COMP_PRED3 45

#define SIMD_SATURATE          60
#define SIMD_IDCT              64
#define SIMD_FORM_COMP_PRED    70

#define SIMD_ADD_BLK  80
#define VEC_ADD_BLK   90
#define SIMD_CLEAR_BLK 85

#define BEGIN_VEC1Arg(x)           BeginVec1Arg(x);
#define BEGIN_VEC2Arg(x,y)         BeginVec2Arg(x,y);
#define BEGIN_VEC3Arg(x,y,z)       BeginVec3Arg(x,y,z);
#define BEGIN_VEC4Arg(x,y,z,p)     BeginVec4Arg(x,y,z,p);
#define BEGIN_VEC5Arg(x,y,z,p,q)   BeginVec5Arg(x,y,z,p,q);
#define BEGIN_VEC6Arg(x,y,z,p,q,r) BeginVec5Arg(x,y,z,p,q,r);
#define END_VECNoRet()             EndVecNoRet();
#define END_VEC()                  EndVec();

#else /* NotRSIM */

#define BEGIN_VEC1Arg(x)           0
#define BEGIN_VEC2Arg(x,y)         0
#define BEGIN_VEC3Arg(x,y,z)       0
#define BEGIN_VEC4Arg(x,y,z,p)     0
#define BEGIN_VEC5Arg(x,y,z,p,q)   0
#define BEGIN_VEC6Arg(x,y,z,p,q,r) 0
#define END_VECNoRet()             (0)
#define END_VEC()                  (0)

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* verify.c 
 *
 * Bitstream verification routines
 *
 *
 */
#ifdef VERIFY 

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>
#include <math.h>     /* needed for ceil() */

#include "config.h"
#include "global.h"

/* #define DEBUG  */
#ifdef DEBUG
#define PC 
#endif

#ifdef PC
#include <conio.h>    /* needed for getch() */
#endif /* PC */

/* 
   Check picture headers:  due to the VBV definition of picture data,
   this routine must be called immediately before any picture data 
   is parsed. (before the first slice start code, including any slice 
   start code stuffing).
*/


static void Check_VBV_Delay _ANSI_ARGS_((int Bitstream_Framenum, int Sequence_Framenum));


void Check_Headers(Bitstream_Framenum, Sequence_Framenum)
int Bitstream_Framenum;
int Sequence_Framenum;
{


  if((!low_delay)&&(vbv_delay!=0)&&(vbv_delay!=0xFFFF))
    Check_VBV_Delay(Bitstream_Framenum, Sequence_Framenum);

  /* clear out the header tracking variables so we have an accurate 
     count next time */
  Clear_Verify_Headers();
}



/* 
 * Verify vbv_delay value in picture header 
 * (low_delay==1 checks not implemented. this does not exhaustively test all 
 *  possibilities suggested in ISO/IEC 13818-2 Annex C.  It only checks
 *  for constant rate streams)
 *
 * Q:how do we tell a variable rate stream from a constant rate stream anyway?
 *   it's not as simple as vbv_delay==0xFFFF, since we need meaningful 
 *   vbv_delay values to calculate the piecewise rate in the first place!
 *
 * Also: no special provisions at the beginning or end of a sequence
 */

static void Check_VBV_Delay(Bitstream_Framenum, Sequence_Framenum)
int Bitstream_Framenum;
int Sequence_Framenum;
{
  double B;   /* buffer size                   */
  double Bn;  /* buffer fullness for picture n */
  double R;   /* bitrate                       */
  double I;   /* time interval (t[n+1] - t[n]) */
  double T;   /* inverse of the frame rate (frame period) */

  int d;
  int internal_vbv_delay;
  
  static int previous_IorP_picture_structure;
  static int previous_IorP_repeat_first_field;
  static int previous_IorP_top_field_first;
  static int previous_vbv_delay;
  static int previous_bitstream_position;

  static double previous_Bn;
  static double E;      /* maximum quantization error or mismatch */

  

  if((Sequence_Framenum==0)&&(!Second_Field)) 
  {  /* first coded picture of sequence */

    R = bit_rate;

    /* the initial buffer occupancy is taken on faith
       that is, we believe what is transmitted in the first coded picture header
       to be the true/actual buffer occupancy */
    
    Bn = (R * (double) vbv_delay) / 90000.0;
    B = 16 * 1024 * vbv_buffer_size;

    
    /* maximum quantization error in bitrate (bit_rate_value is quantized/
       rounded-up to units of 400 bits/sec as per ISO/IEC 13818-2 
       section 6.3.3 */
    
    E = (400.0/frame_rate) + 400;

#ifdef DEBUG
    printf("vbv_buffer_size (B) = %.0f, Bn=%f, E=%f, \nbitrate=%f, vbv_delay=%d frame_rate=%f\n", 
      B, Bn, E, bit_rate, vbv_delay, frame_rate); 
#endif

  }
  else /* not the first coded picture of sequence */
  {

    /* derive the interval (I).  The interval tells us how many constant rate bits
     * will have been downloaded to the buffer during the current picture period
     *
     * interval assumes that: 
     *  1. whilst we are decoding the current I or P picture, we are displaying 
     *     the previous I or P picture which was stored in the reorder
     *     buffer (pointed to by forward_reference_frame in this implementation)
     *
     *  2. B pictures are output ("displayed") at the time when they are decoded 
     * 
     */

    if(progressive_sequence) /* Annex C.9 (progressive_sequence==1, low_delay==0) */
    {

      T = 1/frame_rate; /* inverse of the frame rate (frame period) */

      if(picture_coding_type==B_TYPE)
      {
        if(repeat_first_field==1)
        {
          if(top_field_first==1)
            I = T*3;  /* three frame periods */
          else
            I = T*2;  /* two frame periods */
        }
        else
          I = T;      /* one frame period */
      }
      else /* P or I frame */
      {
        if(previous_IorP_repeat_first_field==1)
        {
          if(previous_IorP_top_field_first==1)
            I = 3*T;
          else
            I = 2*T;
        }
        else
          I = T;
      }
    }
    else /* Annex C.11 (progressive_sequence==0, low_delay==0) */
    {
      
      T = 1/(2*frame_rate); /* inverse of two times the frame rate (field period) */

      if(picture_coding_type==B_TYPE)
      {
        if(picture_structure==FRAME_PICTURE)
        {
          if(repeat_first_field==0)
            I = 2*T;  /* two field periods */
          else
            I = 3*T;  /* three field periods */
        }
        else /* B field */
        {
          I = T;      /* one field period */
        }
      }
      else /* I or P picture */
      {
        if(picture_structure==FRAME_PICTURE)
        {
          if(previous_IorP_repeat_first_field==0)
            I = 2*T;
          else
            I = 3*T;
        }
        else
        {
          if(Second_Field==0)  /* first field of current frame */
            I = T;
          else /* second field of current frame */
          {
            /* formula: previous I or P display period (2*T or 3*T) minus the 
               very recent decode period (T) of the first field of the current 
               frame */

            if(previous_IorP_picture_structure!=FRAME_PICTURE 
              || previous_IorP_repeat_first_field==0)
              I = 2*T - T;  /* a net of one field period */ 
            else if(previous_IorP_picture_structure==FRAME_PICTURE 
              && previous_IorP_repeat_first_field==1)
              I = 3*T - T;  /* a net of two field periods */
          }
        }
      }
    }

    /* derive coded size of previous picture */
    d  = ld->Bitcnt - previous_bitstream_position;

    /* Rate = Distance/Time */

    /* piecewise constant rate (variable rate stream) calculation
     * R =  ((double) d /((previous_vbv_delay - vbv_delay)/90000 + I));
     */

    R = bit_rate;

    /* compute buffer fullness just before removing picture n 
     *
     * Bn = previous_Bn + (I*R) - d;     (recursive formula)
     * 
     *   where:
     *
     *    n           is the current picture
     *
     *    Bn          is the buffer fullness for the current picture
     *
     *    previous_Bn is the buffer fullness of the previous picture
     *
     *    (I*R )      is the bits accumulated during the current picture 
     *                period
     *
     *    d           is the number of bits removed during the decoding of the 
     *                previous picture
     */

    Bn = previous_Bn + (I*R) - d;

    /* compute internally derived vbv_delay (rouding up with ceil()) */
    internal_vbv_delay = (int) ceil((90000 * Bn / bit_rate));

#ifdef DEBUG
    printf("\nvbv_delay: internal=%d, bitstream=%d\n", internal_vbv_delay, vbv_delay);
    
    printf("Bn=%f, prevBn=%f, I=%f, R=%f, d=%d\n", Bn, previous_Bn, I, R, d);
    printf("frame(%d), pictstruct(%d), picttype(%d)\n", Sequence_Framenum, 
      picture_structure, picture_coding_type);

    /* report error */
    if(internal_vbv_delay != vbv_delay)
    {
      printf("WARNING: internal_vbv_delay(%d) != vbv_delay(%d)\n",
        internal_vbv_delay, vbv_delay);
    }
#endif

  } /* not the first coded picture of sequence */


#ifdef PC
  getch();
#endif /* PC */
  
  /* update generic tracking variables */
  previous_bitstream_position = ld->Bitcnt ;
  previous_vbv_delay          = vbv_delay;
  previous_Bn                 = Bn;

  /* reference picture: reordered/delayed output picture */
  if(picture_coding_type!=B_TYPE)
  {
    previous_IorP_repeat_first_field = repeat_first_field;
    previous_IorP_top_field_first    = top_field_first;
    previous_IorP_picture_structure  = picture_structure;
  }

}



/* variables to keep track of the occurance of redundant headers between pictures */
void Clear_Verify_Headers()
{
  verify_sequence_header = 0;
  verify_group_of_pictures_header = 0;
  verify_picture_header = 0;
  verify_slice_header = 0;
  verify_sequence_extension = 0;
  verify_sequence_display_extension = 0;
  verify_quant_matrix_extension = 0;
  verify_sequence_scalable_extension = 0;
  verify_picture_display_extension = 0;
  verify_picture_coding_extension = 0;
  verify_picture_spatial_scalable_extension = 0;
  verify_picture_temporal_scalable_extension = 0;
  verify_copyright_extension = 0;
}

#endif /* VERIFY */

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* config.h, configuration defines                                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/* define NON_ANSI_COMPILER for compilers without function prototyping */
/* #define NON_ANSI_COMPILER */

#ifdef NON_ANSI_COMPILER
#define _ANSI_ARGS_(x) ()
#else
#define _ANSI_ARGS_(x) x
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* conform.c, conformance checks                                            */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include "config.h"
#include "global.h"

/* check for (level independent) parameter limits */
void range_checks()
{
  int i;

  /* range and value checks */

  if (horizontal_size<1 || horizontal_size>16383)
    error("horizontal_size must be between 1 and 16383");
  if (mpeg1 && horizontal_size>4095)
    error("horizontal_size must be less than 4096 (MPEG-1)");
  if ((horizontal_size&4095)==0)
    error("horizontal_size must not be a multiple of 4096");
  if (chroma_format!=CHROMA444 && horizontal_size%2 != 0)
    error("horizontal_size must be a even (4:2:0 / 4:2:2)");

  if (vertical_size<1 || vertical_size>16383)
    error("vertical_size must be between 1 and 16383");
  if (mpeg1 && vertical_size>4095)
    error("vertical size must be less than 4096 (MPEG-1)");
  if ((vertical_size&4095)==0)
    error("vertical_size must not be a multiple of 4096");
  if (chroma_format==CHROMA420 && vertical_size%2 != 0)
    error("vertical_size must be a even (4:2:0)");
  if(fieldpic)
  {
    if (vertical_size%2 != 0)
      error("vertical_size must be a even (field pictures)");
    if (chroma_format==CHROMA420 && vertical_size%4 != 0)
      error("vertical_size must be a multiple of 4 (4:2:0 field pictures)");
  }

  if (mpeg1)
  {
    if (aspectratio<1 || aspectratio>14)
      error("pel_aspect_ratio must be between 1 and 14 (MPEG-1)");
  }
  else
  {
    if (aspectratio<1 || aspectratio>4)
      error("aspect_ratio_information must be 1, 2, 3 or 4");
  }

  if (frame_rate_code<1 || frame_rate_code>8)
    error("frame_rate code must be between 1 and 8");

  if (bit_rate<=0.0)
    error("bit_rate must be positive");
  if (bit_rate > ((1<<30)-1)*400.0)
    error("bit_rate must be less than 429 Gbit/s");
  if (mpeg1 && bit_rate > ((1<<18)-1)*400.0)
    error("bit_rate must be less than 104 Mbit/s (MPEG-1)");

  if (vbv_buffer_size<1 || vbv_buffer_size>0x3ffff)
    error("vbv_buffer_size must be in range 1..(2^18-1)");
  if (mpeg1 && vbv_buffer_size>=1024)
    error("vbv_buffer_size must be less than 1024 (MPEG-1)");

  if (chroma_format<CHROMA420 || chroma_format>CHROMA444)
    error("chroma_format must be in range 1...3");

  if (video_format<0 || video_format>4)
    error("video_format must be in range 0...4");

  if (color_primaries<1 || color_primaries>7 || color_primaries==3)
    error("color_primaries must be in range 1...2 or 4...7");

  if (transfer_characteristics<1 || transfer_characteristics>7
      || transfer_characteristics==3)
    error("transfer_characteristics must be in range 1...2 or 4...7");

  if (matrix_coefficients<1 || matrix_coefficients>7 || matrix_coefficients==3)
    error("matrix_coefficients must be in range 1...2 or 4...7");

  if (display_horizontal_size<0 || display_horizontal_size>16383)
    error("display_horizontal_size must be in range 0...16383");
  if (display_vertical_size<0 || display_vertical_size>16383)
    error("display_vertical_size must be in range 0...16383");

  if (dc_prec<0 || dc_prec>3)
    error("intra_dc_precision must be in range 0...3");

  for (i=0; i<M; i++)
  {
    if (motion_data[i].forw_hor_f_code<1 || motion_data[i].forw_hor_f_code>9)
      error("f_code must be between 1 and 9");
    if (motion_data[i].forw_vert_f_code<1 || motion_data[i].forw_vert_f_code>9)
      error("f_code must be between 1 and 9");
    if (mpeg1 && motion_data[i].forw_hor_f_code>7)
      error("f_code must be le less than 8");
    if (mpeg1 && motion_data[i].forw_vert_f_code>7)
      error("f_code must be le less than 8");
    if (motion_data[i].sxf<=0)
      error("search window must be positive"); /* doesn't belong here */
    if (motion_data[i].syf<=0)
      error("search window must be positive");
    if (i!=0)
    {
      if (motion_data[i].back_hor_f_code<1 || motion_data[i].back_hor_f_code>9)
        error("f_code must be between 1 and 9");
      if (motion_data[i].back_vert_f_code<1 || motion_data[i].back_vert_f_code>9)
        error("f_code must be between 1 and 9");
      if (mpeg1 && motion_data[i].back_hor_f_code>7)
        error("f_code must be le less than 8");
      if (mpeg1 && motion_data[i].back_vert_f_code>7)
        error("f_code must be le less than 8");
      if (motion_data[i].sxb<=0)
        error("search window must be positive");
      if (motion_data[i].syb<=0)
        error("search window must be positive");
    }
  }
}

/* identifies valid profile / level combinations */
static char profile_level_defined[5][4] =
{
/* HL   H-14 ML   LL  */
  {1,   1,   1,   0},  /* HP   */
  {0,   1,   0,   0},  /* Spat */
  {0,   0,   1,   1},  /* SNR  */
  {1,   1,   1,   1},  /* MP   */
  {0,   0,   1,   0}   /* SP   */
};

static struct level_limits {
  int hor_f_code;
  int vert_f_code;
  int hor_size;
  int vert_size;
  int sample_rate;
  int bit_rate; /* Mbit/s */
  int vbv_buffer_size; /* 16384 bit steps */
} maxval_tab[4] =
{
  {9, 5, 1920, 1152, 62668800, 80, 597}, /* HL */
  {9, 5, 1440, 1152, 47001600, 60, 448}, /* H-14 */
  {8, 5, 1920/*720*/,  1152/*576*/, 620000000/*10368000*/, 15, 112}, /* ML */
  {7, 4,  352,  288,  3041280,  4,  29}  /* LL */
};

#define SP   5
#define MP   4
#define SNR  3
#define SPAT 2
#define HP   1

#define LL  10
#define ML   8
#define H14  6
#define HL   4

void profile_and_level_checks()
{
  int i;
  struct level_limits *maxval;

  if (profile<0 || profile>15)
    error("profile must be between 0 and 15");

  if (level<0 || level>15)
    error("level must be between 0 and 15");

  if (profile>=8)
  {
    if (!quiet)
      fprintf(stderr,"Warning: profile uses a reserved value, conformance checks skipped\n");
    return;
  }

  if (profile<HP || profile>SP)
    error("undefined Profile");

  if (profile==SNR || profile==SPAT)
    error("This encoder currently generates no scalable bitstreams");

  if (level<HL || level>LL || level&1)
    error("undefined Level");

  maxval = &maxval_tab[(level-4) >> 1];

  /* check profile@level combination */
  if(!profile_level_defined[profile-1][(level-4) >> 1])
    error("undefined profile@level combination");
  

  /* profile (syntax) constraints */

  if (profile==SP && M!=1)
    error("Simple Profile does not allow B pictures");

  if (profile!=HP && chroma_format!=CHROMA420)
    error("chroma format must be 4:2:0 in specified Profile");

  if (profile==HP && chroma_format==CHROMA444)
    error("chroma format must be 4:2:0 or 4:2:2 in High Profile");

  if (profile>=MP) /* SP, MP: constrained repeat_first_field */
  {
    if (frame_rate_code<=2 && repeatfirst)
      error("repeat_first_first must be zero");
    if (frame_rate_code<=6 && prog_seq && repeatfirst)
      error("repeat_first_first must be zero");
  }

  if (profile!=HP && dc_prec==3)
    error("11 bit DC precision only allowed in High Profile");


  /* level (parameter value) constraints */

  /* Table 8-8 */
  if (frame_rate_code>5 && level>=ML)
    error("Picture rate greater than permitted in specified Level");

  for (i=0; i<M; i++)
  {
    if (motion_data[i].forw_hor_f_code > maxval->hor_f_code)
      error("forward horizontal f_code greater than permitted in specified Level");

    if (motion_data[i].forw_vert_f_code > maxval->vert_f_code)
      error("forward vertical f_code greater than permitted in specified Level");

    if (i!=0)
    {
      if (motion_data[i].back_hor_f_code > maxval->hor_f_code)
        error("backward horizontal f_code greater than permitted in specified Level");
  
      if (motion_data[i].back_vert_f_code > maxval->vert_f_code)
        error("backward vertical f_code greater than permitted in specified Level");
    }
  }

  /* Table 8-10 */
  if (horizontal_size > maxval->hor_size)
    error("Horizontal size is greater than permitted in specified Level");

  if (vertical_size > maxval->vert_size)
    error("Horizontal size is greater than permitted in specified Level");

  /* Table 8-11 */
  if (horizontal_size*vertical_size*frame_rate > maxval->sample_rate)
    error("Sample rate is greater than permitted in specified Level");

  /* Table 8-12 */
  if (bit_rate> 1.0e6 * maxval->bit_rate)
    error("Bit rate is greater than permitted in specified Level");

  /* Table 8-13 */
  if (vbv_buffer_size > maxval->vbv_buffer_size)
    error("vbv_buffer_size exceeds High Level limit");
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* fdctref.c, forward discrete cosine transform, double precision           */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <math.h>

#include "config.h"
#include "global.h"

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

/* global declarations */
void init_fdct _ANSI_ARGS_((void));
void fdct _ANSI_ARGS_((short *block));

/*#define INTEL_FAST_DCT !(ORIGINAL_IDCT)*/

/* private data */
#ifndef INT_DCT
static double c[8][8]; /* transform coefficients */
#endif


void init_fdct()
{
  int i, j;
  double s;

#if !(INTEL_FAST_DCT)
  for (i=0; i<8; i++)
  {
    s = (i==0) ? sqrt(0.125) : 0.5;

    for (j=0; j<8; j++){

#ifdef INT_DCT
      /* scaled with 2^15*/
      c[i][j] = (short) ((s * cos((PI/8.0)*i*(j+0.5)) * 32768) + 0.5); 
      ic[j][i] = c[i][j];
#else
      c[i][j] = s * cos((PI/8.0)*i*(j+0.5));
#endif
    }
      
  }
#endif

}


#ifdef INT_DCT

#if (INTEL_FAST_DCT)
/*
////////////////////////////////////////////////////////////////////////
//
// DCT_8_FRW_COL(), equivalent c_code
//
// This C-code can be substituted for the same __asm block
//
// I found several *DISCREPANCIES* between the AP-922 C-listing 
// and actual corrected code (shown below).
//
////////////////////////////////////////////////////////////////////////
*/

#define BITS_FRW_ACC	2 //; 2 or 3 for accuracy
#define SHIFT_FRW_COL	BITS_FRW_ACC
#define SHIFT_FRW_ROW	(BITS_FRW_ACC + 17)
#define RND_FRW_ROW	(1 << (SHIFT_FRW_ROW-1))

#define LEFT_SHIFT( x ) ((x) << (SHIFT_FRW_COL) )   /* left shift*/
#define LEFT_SHIFT1( x ) ((x) << (SHIFT_FRW_COL+1) ) /* left shift+1*/
/* pmulhw/pmulhrw emulation macros */
#define X86_PMULHW( X ) ((short) ( ((int)X)>>16 ))   /*Intel MMX*/

const static short _tg_1_16   = 13036;  /* tg * (2<<16) + 0.5 */
const static short _tg_2_16   = 27146;  /* tg * (2<<16) + 0.5 */
const static short _tg_3_16   =-21746;  /* tg * (2<<16) + 0.5 */
const static short _cos_4_16  =-19195;  /* cos * (2<<16) + 0.5 */
const static short _ocos_4_16 = 23170;  /* cos * (2<<15) + 0.5 */
const static short _one_corr  =     1;  /* rounding compensation */
#define SHIFT_AND_ROUND_FRW_ROW( x )  ( ((x)+RND_FRW_ROW) >> SHIFT_FRW_ROW )

static short tab_frw_01234567[] = {  /* forward_dct coeff table */
16384, 16384, 21407, -8867,
16384, -16384, 8867, 21407,
16384, 16384, 8867, -21407,
-16384, 16384, -21407, -8867,
22725, 12873, 19266, -22725,
12873, 4520, 4520, 19266,
19266, 4520, -4520, -12873,
-22725, 19266, -12873, -22725,

22725, 22725, 29692, -12299,
22725, -22725, 12299, 29692,
22725, 22725, 12299, -29692,
-22725, 22725, -29692, -12299,
31521, 17855, 26722, -31521,
17855, 6270, 6270, 26722,
26722, 6270, -6270, -17855,
-31521, 26722, -17855, -31521,

21407, 21407, 27969, -11585,
21407, -21407, 11585, 27969,
21407, 21407, 11585, -27969,
-21407, 21407, -27969, -11585,
29692, 16819, 25172, -29692,
16819, 5906, 5906, 25172,
25172, 5906, -5906, -16819,
-29692, 25172, -16819, -29692,

19266, 19266, 25172, -10426,
19266, -19266, 10426, 25172,
19266, 19266, 10426, -25172,
-19266, 19266, -25172, -10426,
26722, 15137, 22654, -26722,
15137, 5315, 5315, 22654,
22654, 5315, -5315, -15137,
-26722, 22654, -15137, -26722,

16384, 16384, 21407, -8867,
16384, -16384, 8867, 21407,
16384, 16384, 8867, -21407,
-16384, 16384, -21407, -8867,
22725, 12873, 19266, -22725,
12873, 4520, 4520, 19266,
19266, 4520, -4520, -12873,
-22725, 19266, -12873, -22725,

19266, 19266, 25172, -10426,
19266, -19266, 10426, 25172,
19266, 19266, 10426, -25172,
-19266, 19266, -25172, -10426,
26722, 15137, 22654, -26722,
15137, 5315, 5315, 22654,
22654, 5315, -5315, -15137,
-26722, 22654, -15137, -26722,

21407, 21407, 27969, -11585,
21407, -21407, 11585, 27969,
21407, 21407, 11585, -27969,
-21407, 21407, -27969, -11585,
29692, 16819, 25172, -29692,
16819, 5906, 5906, 25172,
25172, 5906, -5906, -16819,
-29692, 25172, -16819, -29692,

22725, 22725, 29692, -12299,
22725, -22725, 12299, 29692,
22725, 22725, 12299, -29692,
-22725, 22725, -29692, -12299,
31521, 17855, 26722, -31521,
17855, 6270, 6270, 26722,
26722, 6270, -6270, -17855,
-31521, 26722, -17855, -31521,

};

#ifdef SSE2

#define INP eax		// pointer to (short *blk)
#define OUT ecx		// pointer to output (temporary store space qwTemp[])
#define TABLE ebx	// pointer to tab_frw_01234567[]
#define TABLEF ebx  // pointer to tg_all_16
#define round_frw_row edx
//#define round_frw_col edx

#define x0 INP + 0*16
#define x1 INP + 1*16
#define x2 INP + 2*16
#define x3 INP + 3*16
#define x4 INP + 4*16
#define x5 INP + 5*16
#define x6 INP + 6*16
#define x7 INP + 7*16
#define y0 OUT + 0*16
#define y1 OUT + 1*16
#define y2 OUT + 2*16
#define y3 OUT + 3*16
#define y4 OUT + 4*16
#define y5 OUT + 5*16
#define y6 OUT + 6*16
#define y7 OUT + 7*16

#define SHIFT_FRW_ROW_CLIP2	(4)  // 4-bit shift -> { 32768 <> 2048 }
#define SHIFT_FRW_ROW_CLIP1	( SHIFT_FRW_ROW - SHIFT_FRW_ROW_CLIP2 )

__declspec(align(16)) const static short one_corr[8] = {1,1,1,1,1,1,1,1};/* = 0x0001000100010001;*/
const static int r_frw_row[4] = {RND_FRW_ROW, RND_FRW_ROW, RND_FRW_ROW, RND_FRW_ROW};

__declspec(align(16)) const static short tg_all_16[] = {
  13036, 13036, 13036, 13036, 13036, 13036, 13036, 13036,		/* tg * (2<<16) + 0.5*/
  27146, 27146, 27146, 27146, 27146, 27146, 27146, 27146, 		// tg * (2<<16) + 0.5 
  -21746, -21746, -21746, -21746, -21746, -21746, -21746, -21746,	// tg * (2<<16) + 0.5
  -19195, -19195, -19195, -19195, -19195, -19195, -19195, -19195,	//cos * (2<<16) + 0.5
  23170, 23170, 23170, 23170, 23170, 23170, 23170, 23170 };	//cos * (2<<15) + 0.5

#define tg_1_16 TABLEF + 0
#define tg_2_16 TABLEF + 16
#define tg_3_16 TABLEF + 32
#define cos_4_16 TABLEF + 48
#define ocos_4_16 TABLEF + 64


void
fdct( short *block )
{
    static __int64 xt70[2]; // xt7xt6xt5xt4, xt3xt2xt1xt0
    static int a0, a1, a2, a3, b0, b1, b2, b3;
    static short *sptr, *optr, *tf; // tf = table_ptr
    static short *xt = (short *) &xt70[0];
    static int j;
    
    const static short _tg_1_16   = 13036;  //tg * (2<<16) + 0.5
    const static short _tg_2_16   = 27146;  //tg * (2<<16) + 0.5
    const static short _tg_3_16   =-21746;  //tg * (2<<16) + 0.5
    const static short _cos_4_16  =-19195;  //cos * (2<<16) + 0.5
    const static short _ocos_4_16 = 23170;  //cos * (2<<15) + 0.5
    const static short _one_corr  =     1;  //rounding compensation

    static short t0, t1, t2, t3, t4, t5, t6, t7;
    static short tp03, tm03, tp12, tm12, tp65, tm65;
    static short tp465, tm465, tp765, tm765;

    __asm {

    ////////////////////////////////////////////////////////////////////////
    //
    // The high-level pseudocode for the fdct_mm32() routine :
    //
    // fdct_mm32()
    // {
    //    forward_dct_col03(); // dct_column transform on cols 0-3
    //    forward_dct_col47(); // dct_column transform on cols 4-7
    //    for ( j = 0; j < 8; j=j+1 )
    //      forward_dct_row1(j); // dct_row transform on row #j
    // }

	mov INP, dword ptr [block];		;// input data is row 0 of block[]
    ;// transform the left half of the matrix (4 columns)

    lea TABLEF, dword ptr [tg_all_16];
     mov OUT, INP;

//	lea round_frw_col, dword ptr [r_frw_col]
    // for ( i = 0; i < 2; i = i + 1)
    // the for-loop is executed twice.  We are better off unrolling the 
    // loop to avoid branch misprediction.

  mmx32_fdct_col07: // begin processing columns 0-3
    movdqa xmm0, [x1] ; 0 ; x1

    movdqa xmm1, [x6] ; 1 ; x6
     movdqa xmm2, xmm0 ; 2 ; x1

    movdqa xmm3, [x2] ; 3 ; x2
     paddsw xmm0, xmm1 ; t1 = x[1] + x[6]

    movdqa xmm4, [x5] ; 4 ; x5
     psllw xmm0, SHIFT_FRW_COL ; t1

    movdqa xmm5, [x0] ; 5 ; x0
     paddsw xmm4, xmm3 ; t2 = x[2] + x[5]

    paddsw xmm5, [x7] ; t0 = x[0] + x[7]
     psllw xmm4, SHIFT_FRW_COL ; t2

    movdqa xmm6, xmm0 ; 6 ; t1
     psubsw xmm2, xmm1 ; 1 ; t6 = x[1] - x[6]

   movdqa xmm1, xmmword ptr [tg_2_16] ; 1 ; tg_2_16
     psubsw xmm0, xmm4 ; tm12 = t1 - t2

    movdqa xmm7, [x3] ; 7 ; x3
     pmulhw xmm1, xmm0 ; tm12*tg_2_16

    paddsw xmm7, [x4] ; t3 = x[3] + x[4]
     psllw xmm5, SHIFT_FRW_COL ; t0

    paddsw xmm6, xmm4 ; 4 ; tp12 = t1 + t2
     psllw xmm7, SHIFT_FRW_COL ; t3

    movdqa xmm4, xmm5 ; 4 ; t0
     psubsw xmm5, xmm7 ; tm03 = t0 - t3

    paddsw xmm1, xmm5 ; y2 = tm03 + tm12*tg_2_16
     paddsw xmm4, xmm7 ; 7 ; tp03 = t0 + t3

    por xmm1, xmmword ptr one_corr ; correction y2 +0.5
     psllw xmm2, SHIFT_FRW_COL+1 ; t6

    pmulhw xmm5, xmmword ptr [tg_2_16] ; tm03*tg_2_16
     movdqa xmm7, xmm4 ; 7 ; tp03

    psubsw xmm3, [x5] ; t5 = x[2] - x[5]
     psubsw xmm4, xmm6 ; y4 = tp03 - tp12

    movdqa [y2], xmm1 ; 1 ; save y2
     paddsw xmm7, xmm6 ; 6 ; y0 = tp03 + tp12
     
    movdqa xmm1, [x3] ; 1 ; x3
     psllw xmm3, SHIFT_FRW_COL+1 ; t5

    psubsw xmm1, [x4] ; t4 = x[3] - x[4]
     movdqa xmm6, xmm2 ; 6 ; t6
    
    movdqa [y4], xmm4 ; 4 ; save y4
     paddsw xmm2, xmm3 ; t6 + t5

    pmulhw xmm2, xmmword ptr [ocos_4_16] ; tp65 = (t6 + t5)*cos_4_16
     psubsw xmm6, xmm3 ; 3 ; t6 - t5

    pmulhw xmm6, xmmword ptr [ocos_4_16] ; tm65 = (t6 - t5)*cos_4_16
     psubsw xmm5, xmm0 ; 0 ; y6 = tm03*tg_2_16 - tm12

    por xmm5, xmmword ptr one_corr ; correction y6 +0.5
     psllw xmm1, SHIFT_FRW_COL ; t4

    por xmm2, xmmword ptr one_corr ; correction tp65 +0.5
     movdqa xmm4, xmm1 ; 4 ; t4

    movdqa xmm3, [x0] ; 3 ; x0
     paddsw xmm1, xmm6 ; tp465 = t4 + tm65

    psubsw xmm3, [x7] ; t7 = x[0] - x[7]
     psubsw xmm4, xmm6 ; 6 ; tm465 = t4 - tm65

    movdqa xmm0, xmmword ptr [tg_1_16] ; 0 ; tg_1_16
     psllw xmm3, SHIFT_FRW_COL ; t7

    movdqa xmm6, xmmword ptr [tg_3_16] ; 6 ; tg_3_16
     pmulhw xmm0, xmm1 ; tp465*tg_1_16

    movdqa [y0], xmm7 ; 7 ; save y0
     pmulhw xmm6, xmm4 ; tm465*tg_3_16

    movdqa [y6], xmm5 ; 5 ; save y6
     movdqa xmm7, xmm3 ; 7 ; t7

    movdqa xmm5, xmmword ptr [tg_3_16] ; 5 ; tg_3_16
     psubsw xmm7, xmm2 ; tm765 = t7 - tp65

    paddsw xmm3, xmm2 ; 2 ; tp765 = t7 + tp65
     pmulhw xmm5, xmm7 ; tm765*tg_3_16

    paddsw xmm0, xmm3 ; y1 = tp765 + tp465*tg_1_16
     paddsw xmm6, xmm4 ; tm465*tg_3_16

    pmulhw xmm3, xmmword ptr [tg_1_16] ; tp765*tg_1_16
     ;//

    por xmm0, xmmword ptr one_corr ; correction y1 +0.5
     paddsw xmm5, xmm7 ; tm765*tg_3_16

    psubsw xmm7, xmm6 ; 6 ; y3 = tm765 - tm465*tg_3_16
     add INP, 0x08   ; // increment pointer

    movdqa [y1], xmm0 ; 0 ; save y1
     paddsw xmm5, xmm4 ; 4 ; y5 = tm765*tg_3_16 + tm465

    movdqa [y3], xmm7 ; 7 ; save y3
     psubsw xmm3, xmm1 ; 1 ; y7 = tp765*tg_1_16 - tp465

    movdqa [y5], xmm5 ; 5 ; save y5
    movdqa [y7], xmm3 ; 3 ; save y7 (columns 0-4)

    // end of forward_dct_col07() 
    //  done with dct_col transform


  ////////////////////////////////////////////////////////////////////////
  //
  // fdct_mmx32_rows() --
  // the following subroutine performs the row-transform operation,
  //
  //  The output is stored into block[], destroying the original
  //  source data.

  //  v1.01 - output is range-clipped to {-2048, +2047}

	mov INP, dword ptr [block];		;// row 0
	 mov edi, 0x08;	//x = 8

	lea TABLE, dword ptr [tab_frw_01234567]; // row 0
	 mov OUT, INP;

	lea round_frw_row, dword ptr [r_frw_row];
	// for ( x = 8; x > 0; --x )  // transform 1 row per iteration

// ---------- loop begin
  lp_mmx_fdct_row1:
    movq xmm0, xmmword ptr [INP]   ; /* xmm0 = 3 2 1 0 */
    movq xmm1, xmmword ptr [INP+8] ; /* xmm1 = 7 6 5 4 */

    pxor   xmm2, xmm2            ;
    pshufd xmm0, xmm0, 0x44      ; /* xmm0 = 3 2 1 0 3 2 1 0 */
    pshuflw xmm1, xmm1, 0x1b     ; /*xmm1 = 4 5 6 7 */
    psubsw  xmm2, xmm1           ; /*xmm2 = -4 -5 -6 -7 */
    punpcklqdq xmm1, xmm2        ; /* xmm1 = -4 -5 -6 -7 4 5 6 7*/
    paddsw  xmm0, xmm1           ; /* xmm0 = [3-4, 2-5, 1-6, 0-7, 3+4, 2+5, 1+6, 0+7] */
    
    pshuflw xmm0, xmm0, 0xd8     ; /* xmm0 = 7 6 5 4 3 1 2 0 */
    pshufd xmm1, xmm0, 0         ; /* xmm1 = 2 0 2 0 2 0 2 0*/
    pmaddwd xmm1, [TABLE]        ;
    pshufd  xmm2, xmm0, 0x55     ;
    pshufhw xmm0, xmm0, 0xd8     ;
    pshufd  xmm3, xmm0, 0xaa     ;
    pmaddwd xmm3, [TABLE+32]     ;
    pmaddwd xmm2, [TABLE+16]     ;
    paddd   xmm1, [round_frw_row] ;
    paddd   xmm3, [round_frw_row] ;
    pshufd  xmm0, xmm0, 0xff     ;
    pmaddwd xmm0, [TABLE+48]     ;

    paddd   xmm1, xmm2           ; /* xmm1 = a3 a2 a1 a0 */
    paddd   xmm0, xmm3           ; /* xmm0 = b3 b2 b1 b0 */

    psrad xmm1, SHIFT_FRW_ROW_CLIP1 ;
    psrad xmm0, SHIFT_FRW_ROW_CLIP1 ;

    movdqa xmm2, xmm1   ;
    punpckldq xmm1, xmm0   ;
    punpckhdq xmm2, xmm0   ;
    packssdw xmm1, xmm2    ;
    psraw xmm1, SHIFT_FRW_ROW_CLIP2;

    movdqa [OUT], xmm1             ;
    add OUT, 16;  // increment row-output address by 1 row
    add INP, 16;  // increment row-address by 1 row
    sub edi, 0x01;   // i = i - 1
    add TABLE,64;  // increment to next table
    cmp edi, 0x00;
    jg lp_mmx_fdct_row1;  // begin fdct processing on next row
    }
    
/*
    ////////////////////////////////////////////////////////////////////////
    //
    // DCT_8_FRW_COL(), equivalent c_code
    //
    // This C-code can be substituted for the same __asm block
    //
    // I found several *DISCREPANCIES* between the AP-922 C-listing 
    // and actual corrected code (shown below).
    //
    ////////////////////////////////////////////////////////////////////////

    sptr = (short *) block;
    optr = (short *) block; // output will overwrite source data!

    for ( j = 0; j < 8; j=j+1 ) // dct_frw_col1 loop
    {
      // read source-data column #j into xt[0..7]
      xt[7] = sptr[7*8];
      xt[6] = sptr[6*8];
      xt[5] = sptr[5*8];
      xt[4] = sptr[4*8];

      xt[3] = sptr[3*8];
      xt[2] = sptr[2*8];
      xt[1] = sptr[1*8];
      xt[0] = sptr[0*8];
 
#define  LEFT_SHIFT( x ) ((x) << (SHIFT_FRW_COL) )   // left shift
#define LEFT_SHIFT1( x ) ((x) << (SHIFT_FRW_COL+1) ) // left shift+1

      t0 = LEFT_SHIFT ( xt[0] + xt[7] );
      t1 = LEFT_SHIFT ( xt[1] + xt[6] );
      t2 = LEFT_SHIFT ( xt[2] + xt[5] );
      t3 = LEFT_SHIFT ( xt[3] + xt[4] );
      t4 = LEFT_SHIFT ( xt[3] - xt[4] );
      t5 = LEFT_SHIFT1( xt[2] - xt[5] ); // *** DISCREPANCY
      t6 = LEFT_SHIFT1( xt[1] - xt[6] ); // *** DISCREPANCY
      t7 = LEFT_SHIFT ( xt[0] - xt[7] );
 
      tp03 = t0 + t3;
      tm03 = t0 - t3;
      tp12 = t1 + t2;
      tm12 = t1 - t2;

// pmulhw/pmulhrw emulation macros 
#define X86_PMULHW( X ) ((short) ( ((int)X)>>16 ))   //Intel MMX
//#define X86_PMULHRW( X ) ((short) ( ( (((int)X)>>15)+1) >>1) ) //3DNow-MMX

      optr[0*8] = tp03 + tp12;
      optr[4*8] = tp03 - tp12;
      optr[2*8] = tm03 + X86_PMULHW( tm12 * _tg_2_16 );
      optr[2*8] = optr[2*8] | _one_corr; // one_correction
      optr[6*8] = X86_PMULHW( tm03 * _tg_2_16 ) - tm12;
      optr[6*8] = optr[6*8] | _one_corr; // one_correction
 
      tp65 = X86_PMULHW( (t6 +t5 )*_ocos_4_16 ); // *** DISCREPANCY
      tp65 = tp65 | _one_corr; // one_correction
      tm65 = X86_PMULHW( (t6 -t5 )*_ocos_4_16 ); // *** DISCREPANCY
  
      tp765 = t7 + tp65;
      tm765 = t7 - tp65;
      tp465 = t4 + tm65;
      tm465 = t4 - tm65;
 
      optr[1*8]  = tp765 + X86_PMULHW( tp465 * _tg_1_16 );
      optr[1*8]  = optr[1*8] | _one_corr; // one_correction
      optr[7*8] = X86_PMULHW( tp765 * _tg_1_16 ) - tp465;

//    optr[5*8] = X86_PMULHW( tm765 * _tg_3_16 ) + tm465; // *** DISCREPANCY
      // from pg8 of AP-922,  ICONST = [ const*(2^16) + 0.5 ]
      //                      const * x = PMULHW( ICONST,x ) + x
      // The constant "tg_3_16" > 0.5, thus _tg_3_16 is encoded as tg_3_16-1.0
      // optr[5*8] = X86_PMULHW( tm765 * ( tg_3_16 - 1.0 ) ) + tm465
      //           = [tm765*tg_3_16 - tm765] + tm465
      //
      // optr[5*8] + tm765 = [ tm765*tg_3_16 ] + tm465 + tm765
      //                   = [ tm765*tg_3_16 ] + tm465 <-- what we want

      optr[5*8] = X86_PMULHW( tm765 * _tg_3_16 ) + tm465 + tm765;

//    optr[3*8] = tm765 - X86_PMULHW( tm465 * _tg_3_16 ); // *** DISCREPANCY
      // The following operations must be performed in the shown order!
      // same trick (as shown for optr[5*8]) applies to optr[3*8]

      optr[3*8] = X86_PMULHW( tm465 * _tg_3_16 ) + tm465;
      optr[3*8] = tm765 - optr[3*8];

    ++sptr;   // increment source pointer +1 column
    ++optr;   // increment output pointer +1 column
  } // end for ( j = 0 ..., end of C_equivalent code for forward_dct_col_1
 
    ////////////////////////////////////////////////////////////////////////
    //
    // DCT8_FRW_ROW1(), equivalent c_code
    //
    // This C-code can be substituted for the same __asm block
    // For a derivation of this code, please read fdctmm32.doc
    ////////////////////////////////////////////////////////////////////////

    sptr = (short *) block;
    optr = (short *) block; // output will overwrite source data!
    tf = &tab_frw_01234567[ 0 ]; // fdct_row load table_forward_w

    for ( j = 0; j < 8; j=j+1 ) // dct_frw_row1 loop
    {
        // forward_dct_row input arithmetic + shuffle
        xt[3] = sptr[3] + sptr[4];
        xt[2] = sptr[2] + sptr[5];
        xt[1] = sptr[1] + sptr[6];
        xt[0] = sptr[0] + sptr[7];

        xt[7] = sptr[3] - sptr[4];
        xt[6] = sptr[2] - sptr[5];
        xt[5] = sptr[1] - sptr[6];
        xt[4] = sptr[0] - sptr[7];
  

        a3 = ( xt[0]*tf[10]+ xt[2]*tf[11]) + ( xt[1]*tf[14]+ xt[3]*tf[15]);
        a2 = ( xt[0]*tf[8] + xt[2]*tf[9] ) + ( xt[1]*tf[12]+ xt[3]*tf[13]);
        a1 = ( xt[0]*tf[2] + xt[2]*tf[3] ) + ( xt[1]*tf[6] + xt[3]*tf[7] );
        a0 = ( xt[0]*tf[0] + xt[2]*tf[1] ) + ( xt[1]*tf[4] + xt[3]*tf[5] );
        tf += 16;  // increment table pointer

        b3 = ( xt[4]*tf[10]+ xt[6]*tf[11]) + ( xt[5]*tf[14]+ xt[7]*tf[15]);
        b2 = ( xt[4]*tf[8] + xt[6]*tf[9] ) + ( xt[5]*tf[12]+ xt[7]*tf[13]);
        b1 = ( xt[4]*tf[2] + xt[6]*tf[3] ) + ( xt[5]*tf[6] + xt[7]*tf[7] );
        b0 = ( xt[4]*tf[0] + xt[6]*tf[1] ) + ( xt[5]*tf[4] + xt[7]*tf[5] );
        tf += 16;  // increment table pointer

        // apply rounding constants to scaled elements
        // note, in the MMX implementation, the shift&round is done *last.*
        // Here, the C-code applies the shifts 1st, then the clipping.
#define SHIFT_AND_ROUND_FRW_ROW( x )  ( ((x)+RND_FRW_ROW) >> SHIFT_FRW_ROW )

        a3 = SHIFT_AND_ROUND_FRW_ROW( a3 );
        a2 = SHIFT_AND_ROUND_FRW_ROW( a2 );
        a1 = SHIFT_AND_ROUND_FRW_ROW( a1 );
        a0 = SHIFT_AND_ROUND_FRW_ROW( a0 );

        b3 = SHIFT_AND_ROUND_FRW_ROW( b3 );
        b2 = SHIFT_AND_ROUND_FRW_ROW( b2 );
        b1 = SHIFT_AND_ROUND_FRW_ROW( b1 );
        b0 = SHIFT_AND_ROUND_FRW_ROW( b0 );

        // v1.01, clip output results to range {-2048, +2047}

        // In the MMX implementation, the "clipper" is integrated into
        // the shift&round operation (thanks to packssdw)
        a3 = (a3 > 2047) ?  2047 : a3; // ceiling @ +2047
        a2 = (a2 > 2047) ?  2047 : a2; // ceiling @ +2047
        a1 = (a1 > 2047) ?  2047 : a1; // ceiling @ +2047
        a0 = (a0 > 2047) ?  2047 : a0; // ceiling @ +2047
        b3 = (b3 > 2047) ?  2047 : b3; // ceiling @ +2047
        b2 = (b2 > 2047) ?  2047 : b2; // ceiling @ +2047
        b1 = (b1 > 2047) ?  2047 : b1; // ceiling @ +2047
        b0 = (b0 > 2047) ?  2047 : b0; // ceiling @ +2047

        a3 = (a3 <-2048) ? -2048 : a3; // floor   @ -2048
        a2 = (a2 <-2048) ? -2048 : a2; // floor   @ -2048
        a1 = (a1 <-2048) ? -2048 : a1; // floor   @ -2048
        a0 = (a0 <-2048) ? -2048 : a0; // floor   @ -2048
        b3 = (b3 <-2048) ? -2048 : b3; // floor   @ -2048
        b2 = (b2 <-2048) ? -2048 : b2; // floor   @ -2048
        b1 = (b1 <-2048) ? -2048 : b1; // floor   @ -2048
        b0 = (b0 <-2048) ? -2048 : b0; // floor   @ -2048


        // forward_dct_row, assign outputs
        optr[ 3 ] = b1;
        optr[ 2 ] = a1;
        optr[ 1 ] = b0;
        optr[ 0 ] = a0;

        optr[ 7 ] = b3;
        optr[ 6 ] = a3;
        optr[ 5 ] = b2;
        optr[ 4 ] = a2;

        sptr += 8;   // increment source pointer +1 row
        optr += 8;   // increment output pointer +1 row
    } // end for ( j = 0 ..., end of C_equivalent code for forward_dct_row_1
  */  
} // fdct_mm32( short *block )

#else /* non-SIMD code */

void fdct(block)
short *block;
{
  int a0, a1, a2, a3, b0, b1, b2, b3;
  short *sptr, *optr, *tf; /* tf = table_ptr*/
  int j;
  short t0, t1, t2, t3, t4, t5, t6, t7;
  short tp03, tm03, tp12, tm12, tp65, tm65;
  short tp465, tm465, tp765, tm765;
  short xt[80];

  sptr = (short *) block;
  optr = (short *) block; /* output will overwrite source data!*/
  
  for ( j = 0; j < 8; j++ ) /* dct_frw_col1 loop*/
    {      /* read source-data column #j into xt[0..7]*/
      xt[7] = sptr[7*8];
      xt[6] = sptr[6*8];
      xt[5] = sptr[5*8];
      xt[4] = sptr[4*8];
      
      xt[3] = sptr[3*8];
      xt[2] = sptr[2*8];
      xt[1] = sptr[1*8];
      xt[0] = sptr[0*8];
      
      
      t0 = LEFT_SHIFT ( xt[0] + xt[7] );
      t1 = LEFT_SHIFT ( xt[1] + xt[6] );
      t2 = LEFT_SHIFT ( xt[2] + xt[5] );
      t3 = LEFT_SHIFT ( xt[3] + xt[4] );
      t4 = LEFT_SHIFT ( xt[3] - xt[4] );
      t5 = LEFT_SHIFT1 ( xt[2] - xt[5] ); /*** DISCREPANCY*/
      t6 = LEFT_SHIFT1 ( xt[1] - xt[6] ); /*** DISCREPANCY*/
      t7 = LEFT_SHIFT ( xt[0] - xt[7] );
      
      tp03 = t0 + t3;
      tm03 = t0 - t3;
      tp12 = t1 + t2;
      tm12 = t1 - t2;

      optr[0*8] = tp03 + tp12;
      optr[4*8] = tp03 - tp12;
      optr[2*8] = tm03 + X86_PMULHW( tm12 * _tg_2_16 );
      optr[2*8] = optr[2*8] | _one_corr; /* one_correction*/
      optr[6*8] = X86_PMULHW( tm03 * _tg_2_16 ) - tm12;
      optr[6*8] = optr[6*8] | _one_corr; /* one_correction */
 
      tp65 = X86_PMULHW( (t6 +t5 )*_ocos_4_16 ); /* *** DISCREPANCY */
      tp65 = tp65 | _one_corr; /* one_correction */
      tm65 = X86_PMULHW( (t6 -t5 )*_ocos_4_16 ); /* *** DISCREPANCY */
  
      tp765 = t7 + tp65;
      tm765 = t7 - tp65;
      tp465 = t4 + tm65;
      tm465 = t4 - tm65;
 
      optr[1*8]  = tp765 + X86_PMULHW( tp465 * _tg_1_16 );
      optr[1*8]  = optr[1*8] | _one_corr; /* one_correction */
      optr[7*8] = X86_PMULHW( tp765 * _tg_1_16 ) - tp465;

      optr[5*8] = X86_PMULHW( tm765 * _tg_3_16 ) + tm465 + tm765;

      optr[3*8] = X86_PMULHW( tm465 * _tg_3_16 ) + tm465;
      optr[3*8] = tm765 - optr[3*8];

      ++sptr;   /* increment source pointer +1 column */
      ++optr;   /* increment output pointer +1 column */
    } /* end for ( j = 0 ..., end of C_equivalent code for forward_dct_col_1 */
    
  /* ////////////////////////////////////////////////////////////////////////
  //
  // DCT8_FRW_ROW1(), equivalent c_code
  //
  // This C-code can be substituted for the same __asm block
  // For a derivation of this code, please read fdctmm32.doc
  ////////////////////////////////////////////////////////////////////////
  */

  sptr = (short *) block;
  optr = (short *) block; /* output will overwrite source data! */
  tf = &tab_frw_01234567[ 0 ]; /* fdct_row load table_forward_w */

  for ( j = 0; j < 8; j++ ) /* dct_frw_row1 loop */
    {
      /* forward_dct_row input arithmetic + shuffle */
      xt[3] = sptr[3] + sptr[4];
      xt[2] = sptr[2] + sptr[5];
      xt[1] = sptr[1] + sptr[6];
      xt[0] = sptr[0] + sptr[7];
      
      xt[7] = sptr[3] - sptr[4];
      xt[6] = sptr[2] - sptr[5];
      xt[5] = sptr[1] - sptr[6];
      xt[4] = sptr[0] - sptr[7];
  
      /*
	6 7 14 15
	4 5 13 12
	2 3 10 11
	0 1 8 9

	22 23 30 31
	20 21 28 29
	18 19 26 27
	16 17 24 25
       */
      a3 = ( xt[0]*tf[6]+ xt[2]*tf[7]) + ( xt[1]*tf[14]+ xt[3]*tf[15]);
      a2 = ( xt[0]*tf[4] + xt[2]*tf[5] ) + ( xt[1]*tf[12]+ xt[3]*tf[13]);
      a1 = ( xt[0]*tf[2] + xt[2]*tf[3] ) + ( xt[1]*tf[10]+ xt[3]*tf[11] );
      a0 = ( xt[0]*tf[0] + xt[2]*tf[1] ) + ( xt[1]*tf[8] + xt[3]*tf[9] );

      b3 = ( xt[4]*tf[22] + xt[6]*tf[23]) + ( xt[5]*tf[30]+ xt[7]*tf[31]);
      b2 = ( xt[4]*tf[20] + xt[6]*tf[21] ) + ( xt[5]*tf[28]+ xt[7]*tf[29]);
      b1 = ( xt[4]*tf[18] + xt[6]*tf[19] ) + ( xt[5]*tf[26] + xt[7]*tf[27] );
      b0 = ( xt[4]*tf[16] + xt[6]*tf[17] ) + ( xt[5]*tf[24] + xt[7]*tf[25] );

      tf += 32;  /* increment table pointer */
      /*
      // apply rounding constants to scaled elements
      // note, in the MMX implementation, the shift&round is done *last.*
      // Here, the C-code applies the shifts 1st, then the clipping.
      */

      a3 = SHIFT_AND_ROUND_FRW_ROW( a3 );
      a2 = SHIFT_AND_ROUND_FRW_ROW( a2 );
      a1 = SHIFT_AND_ROUND_FRW_ROW( a1 );
      a0 = SHIFT_AND_ROUND_FRW_ROW( a0 );

      b3 = SHIFT_AND_ROUND_FRW_ROW( b3 );
      b2 = SHIFT_AND_ROUND_FRW_ROW( b2 );
      b1 = SHIFT_AND_ROUND_FRW_ROW( b1 );
      b0 = SHIFT_AND_ROUND_FRW_ROW( b0 );
      /*
      // v1.01, clip output results to range {-2048, +2047}

      // In the MMX implementation, the "clipper" is integrated into
      // the shift&round operation (thanks to packssdw)
      */
      a3 = (a3 > 2047) ?  2047 : a3; /* ceiling @ +2047 */
      a2 = (a2 > 2047) ?  2047 : a2; 
      a1 = (a1 > 2047) ?  2047 : a1; 
      a0 = (a0 > 2047) ?  2047 : a0; 
      b3 = (b3 > 2047) ?  2047 : b3; 
      b2 = (b2 > 2047) ?  2047 : b2; 
      b1 = (b1 > 2047) ?  2047 : b1; 
      b0 = (b0 > 2047) ?  2047 : b0; 

      a3 = (a3 <-2048) ? -2048 : a3; /* floor   @ -2048 */
      a2 = (a2 <-2048) ? -2048 : a2; 
      a1 = (a1 <-2048) ? -2048 : a1; 
      a0 = (a0 <-2048) ? -2048 : a0; 
      b3 = (b3 <-2048) ? -2048 : b3; 
      b2 = (b2 <-2048) ? -2048 : b2; 
      b1 = (b1 <-2048) ? -2048 : b1; 
      b0 = (b0 <-2048) ? -2048 : b0; 


      /* forward_dct_row, assign outputs*/
      optr[ 3 ] = b1;
      optr[ 2 ] = a1;
      optr[ 1 ] = b0;
      optr[ 0 ] = a0;

      optr[ 7 ] = b3;
      optr[ 6 ] = a3;
      optr[ 5 ] = b2;
      optr[ 4 ] = a2;

      sptr += 8;   /* increment source pointer +1 row*/
      optr += 8;   /* increment output pointer +1 row*/
    } /* end for ( j = 0 ..., end of C_equivalent code for forward_dct_row_1 */
} /* fdct_mm32( short *block )*/


#endif /* end non-SIMD code */


#else

void fdct(block)
short *block;
{
  __declspec(align(16)) short tmp[64];
  
#ifdef SSE2
    short *b_p, *cp, *tmp_p, *b2_p;

    /* not the most elegant approach, can be improved with other fast IDCT 
       methods out there */
    
    b_p = block;/*block+8*i;*/
    cp = &c[0][0];
    tmp_p = &tmp[0]; /*&tmp[8*i];*/
    b2_p = &block[63];

    /*	
    for (i=0; i<8; i++) {

      for (j=0; j<8; j++) {
      
        s=0;

        for (k=0; k<8; k++)
          s += ic[j][k] * block[8*i+k];          

        tmp[8*i+j] = s >> 15;
      }
    }
    */
    __asm 
	{
	  mov   ecx, [b2_p]          ;
	  mov   ebx, [b_p]        ; /*load blk ptr*/
	  mov   edx, [cp]       ; /*load ic ptr */
	  mov   eax, [tmp_p]    ;
      
	idct_row_loop:
	  movdqa   xmm0, [ebx]      ; /*load 8 shorts from block*/
	  movdqa   xmm1, [edx]         ; /*ic[0][0..7]*/
	  movdqa   xmm2, [edx+16]      ; /*ic[1][0..7]*/
	  movdqa   xmm3, [edx+32]      ; /*ic[2][0..7]*/
	  movdqa   xmm4, [edx+48]      ; /*ic[3][0..7]*/

	  movdqa   xmm7, [edx+64]      ; /*ic[4][0..7]*/

	  pmaddwd xmm1, xmm0     ; /* xmms : 4 32-bit partial sums */
	  pmaddwd xmm2, xmm0     ;
	  pmaddwd xmm3, xmm0     ;
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm7, xmm0     ;

	  movdqa  xmm5, xmm1     ;
	  movdqa  xmm6, xmm3     ;

	  unpcklpd xmm1, xmm2    ; /*xmm1: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm5, xmm2    ; /*xmm5: 2.3 2.2 1.3 1.2 */

	  movdqa   xmm2, [edx+80]      ; /*ic[5][0..7]*/

	  unpcklpd xmm3, xmm4    ;
	  unpckhpd xmm6, xmm4    ;

	  movdqa   xmm4, [edx+96]      ; /*ic[6][0..7]*/
	  pmaddwd  xmm2, xmm0    ;

	  paddd  xmm6, xmm3      ; 

	  movdqa   xmm3, [edx+112]      ; /*ic[7][0..7]*/
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm3, xmm0     ; /*2nd batch, 7,2,4,3 */

	  paddd  xmm5, xmm1      ; /*xmm5: 2.a 2.b | 1.a 1.b */

	  movdqa xmm1, xmm5      ;
	  shufps  xmm1, xmm6, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm5, xmm6, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */
	  
	  movdqa xmm6, xmm7      ;

	  paddd  xmm1, xmm5      ;

	  movdqa xmm5, xmm4      ;
	  
	  unpcklpd xmm7, xmm2    ; /*xmm7: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm6, xmm2    ; /*xmm6: 2.3 2.2 1.3 1.2 */

	  unpcklpd xmm4, xmm3    ;
	  unpckhpd xmm5, xmm3    ;

	  paddd xmm6, xmm7       ;
	  paddd xmm5, xmm4       ;

	  movdqa xmm2, xmm6      ;
	  shufps  xmm2, xmm5, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm6, xmm5, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */

	  paddd xmm2, xmm6       ;

	  psrad  xmm1, 15        ;
	  psrad  xmm2, 15         ;

	  packssdw xmm1, xmm2    ;

	  movdqa [eax], xmm1     ;

	  add   ebx, 16         ;
	  add   eax, 16         ;

	  cmp   ebx, ecx        ;
	  jb    idct_row_loop   ;
	  
	  ; /* start of second phase */
	mov edx, [tmp_p]        ; /* load tmp blk ptr */
	mov eax, [cp]          ; /* load coeffs table ptr*/
	mov ebx, [b_p]          ;
	mov edi, [b2_p]         ;

      idct_col_outer:
	movdqa xmm6, [eax]      ; /* load ic[0][0..7] */
	
	pxor xmm4, xmm4         ;
	pxor xmm5, xmm5         ;
	mov  ecx, 8             ;

      idct_col_loop:
	movdqa xmm1, [edx]      ; /* load tmp[0][0..7] */
	pshuflw xmm0, xmm6, 0   ; /* copy the lowest word to all positions */
	pshufd xmm0, xmm0, 0
	psrldq  xmm6, 2         ; /* prepare for next word*/
	
	movdqa xmm2, xmm0       ;
	pmulhw xmm2, xmm1       ; /*multiply them */
	pmullw xmm0, xmm1       ; /*2 :high words 1: low words */

	movdqa xmm3, xmm0       ; /*3 : low words */
	punpckhwd xmm0,xmm2     ; /*1 : left half, 4 32-bit */
	punpcklwd xmm3,xmm2    ; /*3 : right half, 4 32-bit */

	paddd xmm4, xmm0      ; /*accumulate */
	paddd xmm5, xmm3      ; /*4 : left, 5 : right*/

	add  edx, 16          ;
	
	loop idct_col_loop    ; /* end of inner loop */

	sub  edx, 128           ;
	psrad xmm4, 15        ; /*s >> 15 */
	psrad xmm5, 15        ;
	
	packssdw xmm5, xmm4   ;

	movdqa [ebx], xmm5    ; /*store to block[i][j]*/

	add  ebx, 16          ;
	add  eax, 16          ;
	cmp  ebx, edi         ;
	jb   idct_col_outer   ;
      }


#else /* NON-SSE2 code */

  int i, j, k;
  int s;

  for (i=0; i<8; i++) { 

 
    for (j=0; j<8; j++) { 


      s = 0;
      for (k=0; k<8; k++)
        s += c[j][k] * block[8*i+k];          /* this is block[i][k] */

      tmp[8*i+j] = s >> 15;                         /* this is block[i][j] */
    }
  }
  for (j=0; j<8; j++) {

    for (i=0; i<8; i++) {

      s = 0;

      for (k=0; k<8; k++)
        s += c[i][k] * tmp[8*k+j];

      block[8*i+j] =  s >> 15;

    } /* end of i */
    
    
  } /* end of j */
#endif
}

#endif /* end non INTEL_FAST_DCT*/

#else /* NOT INT_DCT */
/* The following code comes with the original MSSG implementation */

void fdct(block)
short *block;
{

  double s;
  double tmp[64];
  int i, j,k;


  for (i=0; i<8; i++) { 

 
    for (j=0; j<8; j++) { 

      s = 0.0;
      for (k=0; k<8; k++)
        s += c[j][k] * block[8*i+k];          /* this is block[i][k] */
      tmp[8*i+j] = s;

    }  /* for j */
  

  } /* for i */


  for (j=0; j<8; j++) {

    for (i=0; i<8; i++) {

      s = 0.0;

      for (k=0; k<8; k++)
        s += c[i][k] * tmp[8*k+j];

      block[8*i+j] = (int)floor(s+0.499999);

      /*
       * reason for adding 0.499999 instead of 0.5:
       * s is quite often x.5 (at least for i and/or j = 0 or 4)
       * and setting the rounding threshold exactly to 0.5 leads to an
       * extremely high arithmetic implementation dependency of the result;
       * s being between x.5 and x.500001 (which is now incorrectly rounded
       * downwards instead of upwards) is assumed to occur less often
       * (if at all)
       */

    } /* end of i */


  } /* end of j */



}

#endif


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* global.h, global variables, function prototypes                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "mpeg2enc.h"

/* choose between declaration (GLOBAL undefined)
 * and definition (GLOBAL defined)
 * GLOBAL is defined in exactly one file (mpeg2enc.c)
 */

#ifndef GLOBAL
#define EXTERN extern
#else
#define EXTERN
#endif

/* prototypes of global functions */

/* conform.c */
void range_checks _ANSI_ARGS_((void));
void profile_and_level_checks _ANSI_ARGS_((void));

/* fdctref.c */
void init_fdct _ANSI_ARGS_((void));
void fdct _ANSI_ARGS_((short *block));

/* idct.c */
void idct _ANSI_ARGS_((short *block));
void init_idct _ANSI_ARGS_((void));

/* motion.c */
void motion_estimation _ANSI_ARGS_((unsigned char *oldorg, unsigned char *neworg,
  unsigned char *oldref, unsigned char *newref, unsigned char *cur,
  unsigned char *curref, int sxf, int syf, int sxb, int syb,
  struct mbinfo *mbi, int secondfield, int ipflag));
#ifdef LTHREAD
void ptmotion_estimation _ANSI_ARGS_((unsigned char *oldorg, unsigned char *neworg,
  unsigned char *oldref, unsigned char *newref, unsigned char *cur,
  unsigned char *curref, int sxf, int syf, int sxb, int syb,
  struct mbinfo *mbi, int secondfield, int ipflag, int start_height, int end_height));
#endif

/* mpeg2enc.c */
void error _ANSI_ARGS_((char *text));

/* predict.c */
void predict _ANSI_ARGS_((unsigned char *reff[], unsigned char *refb[],
  unsigned char *cur[3], int secondfield, struct mbinfo *mbi));
#ifdef LTHREAD
void ptpredict _ANSI_ARGS_((unsigned char *reff[], unsigned char *refb[],
  unsigned char *cur[3], int secondfield, struct mbinfo *mbi, int start_height, int end_height));
#endif

/* putbits.c */
void initbits _ANSI_ARGS_((void));
void putbits _ANSI_ARGS_((int val, int n));
void alignbits _ANSI_ARGS_((void));
int bitcount _ANSI_ARGS_((void));
void flushbits _ANSI_ARGS_((int id));
#ifdef LTHREAD
void put_bits _ANSI_ARGS_((int val, int n, int id));
void align_bits _ANSI_ARGS_((int id));
#endif

/* puthdr.c */
void putseqhdr _ANSI_ARGS_((void));
void putseqext _ANSI_ARGS_((void));
void putseqdispext _ANSI_ARGS_((void));
void putuserdata _ANSI_ARGS_((char *userdata));
void putgophdr _ANSI_ARGS_((int frame, int closed_gop));
void putpicthdr _ANSI_ARGS_((void));
void putpictcodext _ANSI_ARGS_((void));
void putseqend _ANSI_ARGS_((void));

/* putmpg.c */
void putintrablk _ANSI_ARGS_((short *blk, int cc));
void putnonintrablk _ANSI_ARGS_((short *blk));
void putmv _ANSI_ARGS_((int dmv, int f_code));
#ifdef LTHREAD
void put_intrablk _ANSI_ARGS_((short *blk, int cc, int id));
void put_nonintrablk _ANSI_ARGS_((short *blk, int id));
void put_mv _ANSI_ARGS_((int dmv, int f_code, int id));
#endif

/* putpic.c */
void putpict _ANSI_ARGS_((unsigned char *frame));
#ifdef LTHREAD
void ptputpict _ANSI_ARGS_((unsigned char *frame, int start_mbh, int end_mbh, \
		int pmq, int id));
void putpichelper _ANSI_ARGS_((unsigned char *frame));
#endif

/* putseq.c */
void putseq _ANSI_ARGS_((void));

/* putvlc.c */
void putDClum _ANSI_ARGS_((int val));
void putDCchrom _ANSI_ARGS_((int val));
void putACfirst _ANSI_ARGS_((int run, int val));
void putAC _ANSI_ARGS_((int run, int signed_level, int vlcformat));
void putaddrinc _ANSI_ARGS_((int addrinc));
void putmbtype _ANSI_ARGS_((int pict_type, int mb_type));
void putmotioncode _ANSI_ARGS_((int motion_code));
void putdmv _ANSI_ARGS_((int dmv));
void putcbp _ANSI_ARGS_((int cbp));
#ifdef LTHREAD
void put_DClum _ANSI_ARGS_((int val,int id));
void put_DCchrom _ANSI_ARGS_((int val,int id));
void put_ACfirst _ANSI_ARGS_((int run, int val,int id));
void put_AC _ANSI_ARGS_((int run, int signed_level, int vlcformat,int id));
void put_addrinc _ANSI_ARGS_((int addrinc,int id));
void put_mbtype _ANSI_ARGS_((int pict_type, int mb_type,int id));
void put_motioncode _ANSI_ARGS_((int motion_code,int id));
void put_dmv _ANSI_ARGS_((int dmv,int id));
void put_cbp _ANSI_ARGS_((int cbp,int id));
#endif

/* quantize.c */
int quant_intra _ANSI_ARGS_((short *src, short *dst, int dc_prec,
  unsigned char *quant_mat, int mquant));
int quant_non_intra _ANSI_ARGS_((short *src, short *dst,
  unsigned char *quant_mat, int mquant));
void iquant_intra _ANSI_ARGS_((short *src, short *dst, int dc_prec,
  unsigned char *quant_mat, int mquant));
void iquant_non_intra _ANSI_ARGS_((short *src, short *dst,
  unsigned char *quant_mat, int mquant));
#ifdef LTHREAD
void ptiquant _ANSI_ARGS_((int start_k, int end_k));
void ptquant _ANSI_ARGS_((int start_k, int end_k));
#endif


/* ratectl.c */
void rc_init_seq _ANSI_ARGS_((void));
void rc_init_GOP _ANSI_ARGS_((int np, int nb));
void rc_init_pict _ANSI_ARGS_((unsigned char *frame));
void rc_update_pict _ANSI_ARGS_((void));
int rc_start_mb _ANSI_ARGS_((void));
int rc_calc_mquant _ANSI_ARGS_((int j));
void vbv_end_of_picture _ANSI_ARGS_((void));
void calc_vbv_delay _ANSI_ARGS_((void));

/* readpic.c */
void readframe _ANSI_ARGS_((char *fname, unsigned char *frame[]));

/* stats.c */
void calcSNR _ANSI_ARGS_((unsigned char *org[3], unsigned char *rec[3]));
void stats _ANSI_ARGS_((void));

/* transfrm.c */
void transform _ANSI_ARGS_((unsigned char *pred[], unsigned char *cur[],
  struct mbinfo *mbi, short blocks[][64]));
void itransform _ANSI_ARGS_((unsigned char *pred[], unsigned char *cur[],
  struct mbinfo *mbi, short blocks[][64]));
void dct_type_estimation _ANSI_ARGS_((unsigned char *pred, unsigned char *cur,
  struct mbinfo *mbi));
#ifdef LTHREAD
void ptdct_type_estimation _ANSI_ARGS_((unsigned char *pred, unsigned char *cur,
  struct mbinfo *mbi, int start_height, int end_height));
void pttransform _ANSI_ARGS_((unsigned char *pred[], unsigned char *cur[],
  struct mbinfo *mbi, short blocks[][64], int start_height, int end_height));
void ptitransform _ANSI_ARGS_((unsigned char *pred[], unsigned char *cur[],
  struct mbinfo *mbi, short blocks[][64], int start_height, int end_height));
#endif

/* writepic.c */
void writeframe _ANSI_ARGS_((char *fname, unsigned char *frame[]));


/* global variables */

EXTERN char version[]
#ifdef GLOBAL
  ="mpeg2encode V1.2, 96/07/19"
#endif
;

EXTERN char author[]
#ifdef GLOBAL
  ="(C) 1996, MPEG Software Simulation Group"
#endif
;

/* zig-zag scan */
EXTERN unsigned char zig_zag_scan[64]
#ifdef GLOBAL
=
{
  0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,
  12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
  35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,
  58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63
}
#endif
;

/* alternate scan */
EXTERN unsigned char alternate_scan[64]
#ifdef GLOBAL
=
{
  0,8,16,24,1,9,2,10,17,25,32,40,48,56,57,49,
  41,33,26,18,3,11,4,12,19,27,34,42,50,58,35,43,
  51,59,20,28,5,13,6,14,21,29,36,44,52,60,37,45,
  53,61,22,30,7,15,23,31,38,46,54,62,39,47,55,63
}
#endif
;

/* default intra quantization matrix */
EXTERN unsigned char default_intra_quantizer_matrix[64]
#ifdef GLOBAL
=
{
   8, 16, 19, 22, 26, 27, 29, 34,
  16, 16, 22, 24, 27, 29, 34, 37,
  19, 22, 26, 27, 29, 34, 34, 38,
  22, 22, 26, 27, 29, 34, 37, 40,
  22, 26, 27, 29, 32, 35, 40, 48,
  26, 27, 29, 32, 35, 40, 48, 58,
  26, 27, 29, 34, 38, 46, 56, 69,
  27, 29, 35, 38, 46, 56, 69, 83
}
#endif
;

/* non-linear quantization coefficient table */
EXTERN unsigned char non_linear_mquant_table[32]
#ifdef GLOBAL
=
{
   0, 1, 2, 3, 4, 5, 6, 7,
   8,10,12,14,16,18,20,22,
  24,28,32,36,40,44,48,52,
  56,64,72,80,88,96,104,112
}
#endif
;

/* non-linear mquant table for mapping from scale to code
 * since reconstruction levels are not bijective with the index map,
 * it is up to the designer to determine most of the quantization levels
 */

EXTERN unsigned char map_non_linear_mquant[113] 
#ifdef GLOBAL
=
{
0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,
16,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,
22,22,23,23,23,23,24,24,24,24,24,24,24,25,25,25,25,25,25,25,26,26,
26,26,26,26,26,26,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,29,
29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,31,31,31,31,31
}
#endif
;

/* picture data arrays */

/* reconstructed frames */
EXTERN unsigned char *newrefframe[3], *oldrefframe[3], *auxframe[3];
/* original frames */
EXTERN unsigned char *neworgframe[3], *oldorgframe[3], *auxorgframe[3];
/* prediction of current frame */
EXTERN unsigned char *predframe[3];
/* 8*8 block data */
EXTERN short (*blocks)[64];
/* intra / non_intra quantization matrices */
EXTERN unsigned char intra_q[64], inter_q[64];
EXTERN unsigned char chrom_intra_q[64],chrom_inter_q[64];
/* prediction values for DCT coefficient (0,0) */
EXTERN int dc_dct_pred[3];
#ifdef LTHREAD
EXTERN int pt_dc_dct_pred[NUM_THREADS][3];
#endif
/* macroblock side information array */
EXTERN struct mbinfo *mbinfo;
/* motion estimation parameters */
EXTERN struct motion_data *motion_data;
/* clipping (=saturation) table */
EXTERN unsigned char *clp;

/* name strings */
EXTERN char id_string[256], tplorg[256], tplref[256];
EXTERN char iqname[256], niqname[256];
EXTERN char statname[256];
EXTERN char errortext[256];

EXTERN FILE *outfile, *statfile; /* file descriptors */
EXTERN int inputtype; /* format of input frames */

EXTERN int quiet; /* suppress warnings */

/* coding model parameters */

EXTERN int N; /* number of frames in Group of Pictures */
EXTERN int M; /* distance between I/P frames */
EXTERN int P; /* intra slice refresh interval */
EXTERN int nframes; /* total number of frames to encode */
EXTERN int frame0, tc0; /* number and timecode of first frame */
EXTERN int mpeg1; /* ISO/IEC IS 11172-2 sequence */
EXTERN int fieldpic; /* use field pictures */

/* sequence specific data (sequence header) */

EXTERN int horizontal_size, vertical_size; /* frame size (pels) */
EXTERN int width, height; /* encoded frame size (pels) multiples of 16 or 32 */
EXTERN int chrom_width,chrom_height,block_count;
EXTERN int mb_width, mb_height; /* frame size (macroblocks) */
EXTERN int width2, height2, mb_height2, chrom_width2; /* picture size */
EXTERN int aspectratio; /* aspect ratio information (pel or display) */
EXTERN int frame_rate_code; /* coded value of frame rate */
EXTERN double frame_rate; /* frames per second */
EXTERN double bit_rate; /* bits per second */
EXTERN int vbv_buffer_size; /* size of VBV buffer (* 16 kbit) */
EXTERN int constrparms; /* constrained parameters flag (MPEG-1 only) */
EXTERN int load_iquant, load_niquant; /* use non-default quant. matrices */
EXTERN int load_ciquant,load_cniquant;


/* sequence specific data (sequence extension) */

EXTERN int profile, level; /* syntax / parameter constraints */
EXTERN int prog_seq; /* progressive sequence */
EXTERN int chroma_format;
EXTERN int low_delay; /* no B pictures, skipped pictures */


/* sequence specific data (sequence display extension) */

EXTERN int video_format; /* component, PAL, NTSC, SECAM or MAC */
EXTERN int color_primaries; /* source primary chromaticity coordinates */
EXTERN int transfer_characteristics; /* opto-electronic transfer char. (gamma) */
EXTERN int matrix_coefficients; /* Eg,Eb,Er / Y,Cb,Cr matrix coefficients */
EXTERN int display_horizontal_size, display_vertical_size; /* display size */


/* picture specific data (picture header) */

EXTERN int temp_ref; /* temporal reference */
EXTERN int pict_type; /* picture coding type (I, P or B) */
EXTERN int vbv_delay; /* video buffering verifier delay (1/90000 seconds) */


/* picture specific data (picture coding extension) */

EXTERN int forw_hor_f_code, forw_vert_f_code;
EXTERN int back_hor_f_code, back_vert_f_code; /* motion vector ranges */
EXTERN int dc_prec; /* DC coefficient precision for intra coded blocks */
EXTERN int pict_struct; /* picture structure (frame, top / bottom field) */
EXTERN int topfirst; /* display top field first */
/* use only frame prediction and frame DCT (I,P,B,current) */
EXTERN int frame_pred_dct_tab[3], frame_pred_dct;
EXTERN int conceal_tab[3]; /* use concealment motion vectors (I,P,B) */
EXTERN int qscale_tab[3], q_scale_type; /* linear/non-linear quantizaton table */
EXTERN int intravlc_tab[3], intravlc; /* intra vlc format (I,P,B,current) */
EXTERN int altscan_tab[3], altscan; /* alternate scan (I,P,B,current) */
EXTERN int repeatfirst; /* repeat first field after second field */
EXTERN int prog_frame; /* progressive frame */

EXTERN int QUANT_THRESHOLD;

#ifndef USE_ICC
#define __declspec(x)
#define align(x)
#define _mm_malloc(x,y) malloc(x)
#define _mm_free(x) free(x)
#endif

#ifdef INT_DCT
EXTERN __declspec(align(16)) short c[8][8];
EXTERN __declspec(align(16)) short ic[8][8];
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* idct.c, inverse fast discrete cosine transform                           */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/*
 * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
 * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
 *
 * This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
 * See http://libmpeg2.sourceforge.net/ for updates.
 *
 * mpeg2dec is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * mpeg2dec is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/**********************************************************/
/* inverse two dimensional DCT, Chen-Wang algorithm       */
/* (cf. IEEE ASSP-32, pp. 803-816, Aug. 1984)             */
/* 32-bit integer arithmetic (8 bit coefficients)         */
/* 11 mults, 29 adds per DCT                              */
/*                                      sE, 18.8.91       */
/**********************************************************/
/* coefficients extended to 12 bit for IEEE1180-1990      */
/* compliance                           sE,  2.1.94       */
/**********************************************************/

/* this code assumes >> to be a two's-complement arithmetic */
/* right shift: (-2)>>1 == -1 , (-3)>>1 == -2               */

#include <stdio.h>
#include "config.h"
#include "global.h"

#define W1 2841 /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676 /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408 /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609 /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108 /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565  /* 2048*sqrt(2)*cos(7*pi/16) */

#define CLIP_BYTE(i)  (((i)<-256) ? -256 : (((i)>255) ? 255 : (i)))

/* global declarations */
void init_idct _ANSI_ARGS_((void));
void idct _ANSI_ARGS_((short *block));
/*
#define ORIGINAL_IDCT 0
#define MATRIX_IDCT 0
*/
#if 0 
/* private data */
static short iclip[1024]; /* clipping table */
static short *iclp;
#endif

#if (ORIGINAL_IDCT)
/* private prototypes */
static void idctrow _ANSI_ARGS_((short *blk));
static void idctcol _ANSI_ARGS_((short *blk));

/* row (horizontal) IDCT
 *
 *           7                       pi         1
 * dst[k] = sum c[l] * src[l] * cos( -- * ( k + - ) * l )
 *          l=0                      8          2
 *
 * where: c[0]    = 128
 *        c[1..7] = 128*sqrt(2)
 */

static void idctrow(blk)
short *blk;
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = blk[4]<<11) | (x2 = blk[6]) | (x3 = blk[2]) |
        (x4 = blk[1]) | (x5 = blk[7]) | (x6 = blk[5]) | (x7 = blk[3])))
  {
    blk[0]=blk[1]=blk[2]=blk[3]=blk[4]=blk[5]=blk[6]=blk[7]=blk[0]<<3;
    return;
  }

  x0 = (blk[0]<<11) + 128; /* for proper rounding in the fourth stage */

  /* first stage */
  x8 = W7*(x4+x5);
  x4 = x8 + (W1-W7)*x4;
  x5 = x8 - (W1+W7)*x5;
  x8 = W3*(x6+x7);
  x6 = x8 - (W3-W5)*x6;
  x7 = x8 - (W3+W5)*x7;
  
  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2);
  x2 = x1 - (W2+W6)*x2;
  x3 = x1 + (W2-W6)*x3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;
  
  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;
  
  /* fourth stage */
  blk[0] = (x7+x1)>>8;
  blk[1] = (x3+x2)>>8;
  blk[2] = (x0+x4)>>8;
  blk[3] = (x8+x6)>>8;
  blk[4] = (x8-x6)>>8;
  blk[5] = (x0-x4)>>8;
  blk[6] = (x3-x2)>>8;
  blk[7] = (x7-x1)>>8;
}

/* column (vertical) IDCT
 *
 *             7                         pi         1
 * dst[8*k] = sum c[l] * src[8*l] * cos( -- * ( k + - ) * l )
 *            l=0                        8          2
 *
 * where: c[0]    = 1/1024
 *        c[1..7] = (1/1024)*sqrt(2)
 */
static void idctcol(blk)
short *blk;
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = (blk[8*4]<<8)) | (x2 = blk[8*6]) | (x3 = blk[8*2]) |
        (x4 = blk[8*1]) | (x5 = blk[8*7]) | (x6 = blk[8*5]) | (x7 = blk[8*3])))
  {
    blk[8*0]=blk[8*1]=blk[8*2]=blk[8*3]=blk[8*4]=blk[8*5]=blk[8*6]=blk[8*7]=
      CLIP_BYTE((blk[8*0]+32)>>6);/*iclp[(blk[8*0]+32)>>6];*/
    return;
  }

  x0 = (blk[8*0]<<8) + 8192;

  /* first stage */
  x8 = W7*(x4+x5) + 4;
  x4 = (x8+(W1-W7)*x4)>>3;
  x5 = (x8-(W1+W7)*x5)>>3;
  x8 = W3*(x6+x7) + 4;
  x6 = (x8-(W3-W5)*x6)>>3;
  x7 = (x8-(W3+W5)*x7)>>3;
  
  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2) + 4;
  x2 = (x1-(W2+W6)*x2)>>3;
  x3 = (x1+(W2-W6)*x3)>>3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;
  
  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;
  
  /* fourth stage */
  blk[8*0] = CLIP_BYTE((x7+x1)>>14);    /*iclp[(x7+x1)>>14];*/
  blk[8*1] = CLIP_BYTE((x3+x2)>>14);    /*iclp[(x3+x2)>>14];*/
  blk[8*2] = CLIP_BYTE((x0+x4)>>14);    /*iclp[(x0+x4)>>14];*/
  blk[8*3] = CLIP_BYTE((x8+x6)>>14);    /*iclp[(x8+x6)>>14];*/
  blk[8*4] = CLIP_BYTE((x8-x6)>>14);    /*iclp[(x8-x6)>>14];*/
  blk[8*5] = CLIP_BYTE((x0-x4)>>14);    /*iclp[(x0-x4)>>14];*/
  blk[8*6] = CLIP_BYTE((x3-x2)>>14);    /*iclp[(x3-x2)>>14];*/
  blk[8*7] = CLIP_BYTE((x7-x1)>>14);    /*iclp[(x7-x1)>>14];*/
}

#else

#if !(MATRIX_IDCT)

// Intel's SSE2 implementation of iDCT
// AP-945
// http://cache-www.intel.com/cd/00/00/01/76/17680_w_idct.pdf

#define BITS_INV_ACC 4 // 4 or 5 for IEEE
#define SHIFT_INV_ROW 16 - BITS_INV_ACC
#define SHIFT_INV_COL 1 + BITS_INV_ACC
const short RND_INV_ROW = 1024 * (6 - BITS_INV_ACC); //1 << (SHIFT_INV_ROW-1)
#define RND_INV_COL (16 * (BITS_INV_ACC - 3)) // 1 << (SHIFT_INV_COL-1)
const short RND_INV_CORR = RND_INV_COL - 1; // correction -1.0 and round

#ifdef SSE2

__declspec(align(16)) short M128_one_corr[8] = {1,1,1,1,1,1,1,1};
__declspec(align(16)) short M128_round_inv_row[8] = {RND_INV_ROW, 0, RND_INV_ROW, 0, RND_INV_ROW, 0, RND_INV_ROW, 0};
__declspec(align(16)) short M128_round_inv_col[8] = {RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL, RND_INV_COL};
__declspec(align(16)) short M128_round_inv_corr[8]= {RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR, RND_INV_CORR};
__declspec(align(16)) short M128_tg_1_16[8] = {13036, 13036, 13036, 13036, 13036, 13036, 13036, 13036}; // tg * (2<<16) + 0.5
__declspec(align(16)) short M128_tg_2_16[8] = {27146, 27146, 27146, 27146, 27146, 27146, 27146, 27146}; // tg * (2<<16) + 0.5
__declspec(align(16)) short M128_tg_3_16[8] = {-21746, -21746, -21746, -21746, -21746, -21746, -21746, -21746}; // tg * (2<<16) + 0.5
__declspec(align(16)) short M128_cos_4_16[8] = {-19195, -19195, -19195, -19195, -19195, -19195, -19195, -19195};// cos * (2<<16) + 0.5

//-----------------------------------------------------------------------------
// Table for rows 0,4 - constants are multiplied on cos_4_16
//movq -> w13 w12 w09 w08 w05 w04 w01 w00
// w15 w14 w11 w10 w07 w06 w03 w02
// w29 w28 w25 w24 w21 w20 w17 w16
// w31 w30 w27 w26 w23 w22 w19 w18

__declspec(align(16)) short M128_tab_i_04[] = 
{
	16384, 21407, 16384, 8867, //movq -> w05 w04 w01 w00
	16384, -8867, 16384, -21407, // w13 w12 w09 w08
	16384, 8867, -16384, -21407, // w07 w06 w03 w02
	-16384, 21407, 16384, -8867, // w15 w14 w11 w10
	22725, 19266, 19266, -4520, // w21 w20 w17 w16
	12873, -22725, 4520, -12873, // w29 w28 w25 w24
	12873, 4520, -22725, -12873, // w23 w22 w19 w18
	4520, 19266, 19266, -22725  // w31 w30 w27 w26
};

// Table for rows 1,7 - constants are multiplied on cos_1_16

__declspec(align(16)) short M128_tab_i_17[] =
{
	22725, 29692, 22725, 12299, //movq -> w05 w04 w01 w00
	22725, -12299, 22725, -29692, // w13 w12 w09 w08
	22725, 12299, -22725, -29692, // w07 w06 w03 w02
	-22725, 29692, 22725, -12299, // w15 w14 w11 w10
	31521, 26722, 26722, -6270, // w21 w20 w17 w16
	17855, -31521, 6270, -17855, // w29 w28 w25 w24
	17855, 6270, -31521, -17855, // w23 w22 w19 w18
	6270, 26722, 26722, -31521 // w31 w30 w27 w26
};

// Table for rows 2,6 - constants are multiplied on cos_2_16

__declspec(align(16)) short M128_tab_i_26[] =
{
	21407, 27969, 21407, 11585, //movq -> w05 w04 w01 w00
	21407, -11585, 21407, -27969, // w13 w12 w09 w08
	21407, 11585, -21407, -27969, // w07 w06 w03 w02
	-21407, 27969, 21407, -11585, // w15 w14 w11 w10
	29692, 25172, 25172, -5906, // w21 w20 w17 w16
	16819, -29692, 5906, -16819, // w29 w28 w25 w24
	16819, 5906, -29692, -16819, // w23 w22 w19 w18
	5906, 25172, 25172, -29692 // w31 w30 w27 w26
};

// Table for rows 3,5 - constants are multiplied on cos_3_16

__declspec(align(16)) short M128_tab_i_35[] = 
{
	19266, 25172, 19266, 10426, //movq -> w05 w04 w01 w00
	19266, -10426, 19266, -25172, // w13 w12 w09 w08
	19266, 10426, -19266, -25172, // w07 w06 w03 w02
	-19266, 25172, 19266, -10426, // w15 w14 w11 w10
	26722, 22654, 22654, -5315, // w21 w20 w17 w16
	15137, -26722, 5315, -15137, // w29 w28 w25 w24
	15137, 5315, -26722, -15137, // w23 w22 w19 w18
	5315, 22654, 22654, -26722 // w31 w30 w27 w26
};

//xmm7 = round_inv_row
#define DCT_8_INV_ROW __asm{ \
	__asm pshuflw xmm0, xmm0, 0xD8 \
	__asm pshufd xmm1, xmm0, 0 \
	__asm pmaddwd xmm1, [esi] \
	__asm pshufd xmm3, xmm0, 0x55 \
	__asm pshufhw xmm0, xmm0, 0xD8 \
	__asm pmaddwd xmm3, [esi+32] \
	__asm pshufd xmm2, xmm0, 0xAA \
	__asm pshufd xmm0, xmm0, 0xFF \
	__asm pmaddwd xmm2, [esi+16] \
	__asm pshufhw xmm4, xmm4, 0xD8 \
	__asm paddd xmm1, M128_round_inv_row \
	__asm pshuflw xmm4, xmm4, 0xD8 \
	__asm pmaddwd xmm0, [esi+48] \
	__asm pshufd xmm5, xmm4, 0 \
	__asm pshufd xmm6, xmm4, 0xAA \
	__asm pmaddwd xmm5, [ecx] \
	__asm paddd xmm1, xmm2 \
	__asm movdqa xmm2, xmm1 \
	__asm pshufd xmm7, xmm4, 0x55 \
	__asm pmaddwd xmm6, [ecx+16] \
	__asm paddd xmm0, xmm3 \
	__asm pshufd xmm4, xmm4, 0xFF \
	__asm psubd xmm2, xmm0 \
	__asm pmaddwd xmm7, [ecx+32] \
	__asm paddd xmm0, xmm1 \
	__asm psrad xmm2, 12 \
	__asm paddd xmm5, M128_round_inv_row \
	__asm pmaddwd xmm4, [ecx+48] \
	__asm paddd xmm5, xmm6 \
	__asm movdqa xmm6, xmm5 \
	__asm psrad xmm0, 12 \
	__asm pshufd xmm2, xmm2, 0x1B \
	__asm packssdw xmm0, xmm2 \
	__asm paddd xmm4, xmm7 \
	__asm psubd xmm6, xmm4 \
	__asm paddd xmm4, xmm5 \
	__asm psrad xmm6, 12 \
	__asm psrad xmm4, 12 \
	__asm pshufd xmm6, xmm6, 0x1B \
	__asm packssdw xmm4, xmm6 \
}
#define DCT_8_INV_COL_8 __asm{ \
	__asm movdqa xmm1, XMMWORD PTR M128_tg_3_16 \
	__asm movdqa xmm2, xmm0 \
	__asm movdqa xmm3, XMMWORD PTR [edx+3*16] \
	__asm pmulhw xmm0, xmm1 \
	__asm pmulhw xmm1, xmm3 \
	__asm movdqa xmm5, XMMWORD PTR M128_tg_1_16 \
	__asm movdqa xmm6, xmm4 \
	__asm pmulhw xmm4, xmm5 \
	__asm paddsw xmm0, xmm2 \
	__asm pmulhw xmm5, [edx+1*16] \
	__asm paddsw xmm1, xmm3 \
	__asm movdqa xmm7, XMMWORD PTR [edx+6*16] \
	__asm paddsw xmm0, xmm3 \
	__asm movdqa xmm3, XMMWORD PTR M128_tg_2_16 \
	__asm psubsw xmm2, xmm1 \
	__asm pmulhw xmm7, xmm3 \
	__asm movdqa xmm1, xmm0 \
	__asm pmulhw xmm3, [edx+2*16] \
	__asm psubsw xmm5, xmm6 \
	__asm paddsw xmm4, [edx+1*16] \
	__asm paddsw xmm0, xmm4 \
	__asm paddsw xmm0, XMMWORD PTR M128_one_corr \
	__asm psubsw xmm4, xmm1 \
	__asm movdqa xmm6, xmm5 \
	__asm psubsw xmm5, xmm2 \
	__asm paddsw xmm5, XMMWORD PTR M128_one_corr \
	__asm paddsw xmm6, xmm2 \
	__asm movdqa [edx+7*16], xmm0 \
	__asm movdqa xmm1, xmm4 \
	__asm movdqa xmm0, XMMWORD PTR M128_cos_4_16 \
	__asm paddsw xmm4, xmm5 \
	__asm movdqa xmm2, XMMWORD PTR M128_cos_4_16 \
	__asm pmulhw xmm2, xmm4 \
	__asm movdqa [edx+3*16], xmm6 \
	__asm psubsw xmm1, xmm5 \
	__asm paddsw xmm7, [edx+2*16] \
	__asm psubsw xmm3, [edx+6*16] \
	__asm movdqa xmm6, [edx] \
	__asm pmulhw xmm0, xmm1 \
	__asm movdqa xmm5, [edx+4*16] \
	__asm paddsw xmm5, xmm6 \
	__asm psubsw xmm6, [edx+4*16] \
	__asm paddsw xmm4, xmm2 \
	__asm por xmm4, XMMWORD PTR M128_one_corr \
	__asm paddsw xmm0, xmm1 \
	__asm por xmm0, XMMWORD PTR M128_one_corr \
	__asm movdqa xmm2, xmm5 \
	__asm paddsw xmm5, xmm7 \
	__asm movdqa xmm1, xmm6 \
	__asm paddsw xmm5, XMMWORD PTR M128_round_inv_col \
	__asm psubsw xmm2, xmm7 \
	__asm movdqa xmm7, [edx+7*16] \
	__asm paddsw xmm6, xmm3 \
	__asm paddsw xmm6, XMMWORD PTR M128_round_inv_col \
	__asm paddsw xmm7, xmm5 \
	__asm psraw xmm7, SHIFT_INV_COL \
	__asm psubsw xmm1, xmm3 \
	__asm paddsw xmm1, XMMWORD PTR M128_round_inv_corr \
	__asm movdqa xmm3, xmm6 \
	__asm paddsw xmm2, XMMWORD PTR M128_round_inv_corr \
	__asm paddsw xmm6, xmm4 \
	__asm movdqa [edx], xmm7 \
	__asm psraw xmm6, SHIFT_INV_COL \
	__asm movdqa xmm7, xmm1 \
	__asm paddsw xmm1, xmm0 \
	__asm movdqa [edx+1*16], xmm6 \
	__asm psraw xmm1, SHIFT_INV_COL \
	__asm movdqa xmm6, [edx+3*16] \
	__asm psubsw xmm7, xmm0 \
	__asm psraw xmm7, SHIFT_INV_COL \
	__asm movdqa [edx+2*16], xmm1 \
	__asm psubsw xmm5, [edx+7*16] \
	__asm psraw xmm5, SHIFT_INV_COL \
	__asm movdqa [edx+7*16], xmm5 \
	__asm psubsw xmm3, xmm4 \
	__asm paddsw xmm6, xmm2 \
	__asm psubsw xmm2, [edx+3*16] \
	__asm psraw xmm6, SHIFT_INV_COL \
	__asm psraw xmm2, SHIFT_INV_COL \
	__asm movdqa [edx+3*16], xmm6 \
	__asm psraw xmm3, SHIFT_INV_COL \
	__asm movdqa [edx+4*16], xmm2 \
	__asm movdqa [edx+5*16], xmm7 \
	__asm movdqa [edx+6*16], xmm3 \
}

//assumes src and destination are aligned on a 16-byte boundary

static void idct_M128ASM(short* src)
{
  /*ASSERT(((DWORD)src & 0xf) == 0);*/ //aligned on 16-byte boundary

	__asm mov edx, src

	__asm movdqa xmm0, XMMWORD PTR[edx] //row 1
	__asm lea esi, M128_tab_i_04
	__asm movdqa xmm4, XMMWORD PTR[edx+16*2] //row 3
	__asm lea ecx, M128_tab_i_26
	DCT_8_INV_ROW; //Row 1, tab_i_04 and Row 3, tab_i_26
	__asm movdqa XMMWORD PTR[edx], xmm0
	__asm movdqa XMMWORD PTR[edx+16*2], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*4] //row 5
	//__asm lea esi, M128_tab_i_04
	__asm movdqa xmm4, XMMWORD PTR[edx+16*6] //row 7
	//__asm lea ecx, M128_tab_i_26
	DCT_8_INV_ROW; //Row 5, tab_i_04 and Row 7, tab_i_26
	__asm movdqa XMMWORD PTR[edx+16*4], xmm0
	__asm movdqa XMMWORD PTR[edx+16*6], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*3] //row 4
	__asm lea esi, M128_tab_i_35
	__asm movdqa xmm4, XMMWORD PTR[edx+16*1] //row 2
	__asm lea ecx, M128_tab_i_17
	DCT_8_INV_ROW; //Row 4, tab_i_35 and Row 2, tab_i_17
	__asm movdqa XMMWORD PTR[edx+16*3], xmm0
	__asm movdqa XMMWORD PTR[edx+16*1], xmm4

	__asm movdqa xmm0, XMMWORD PTR[edx+16*5] //row 6
	//__asm lea esi, M128_tab_i_35
	__asm movdqa xmm4, XMMWORD PTR[edx+16*7] //row 8
	//__asm lea ecx, M128_tab_i_17
	DCT_8_INV_ROW; //Row 6, tab_i_35 and Row 8, tab_i_17
	//__asm movdqa XMMWORD PTR[edx+80], xmm0
	//__asm movdqa xmm0, XMMWORD PTR [edx+80] /* 0 /* x5 */
	//__asm movdqa XMMWORD PTR[edx+16*7], xmm4
	//__asm movdqa xmm4, XMMWORD PTR [edx+7*16]/* 4 ; x7 */
	DCT_8_INV_COL_8
	// __asm emms
}



#else

//-----------------------------------------------------------------------------
/*
;=============================================================================
;=============================================================================
;=============================================================================
;
; Inverse DCT
;
;-----------------------------------------------------------------------------
;
; This implementation calculates iDCT-2D by a row-column method.
; On the first stage the iDCT-1D is calculated for each row with use
; direct algorithm, on the second stage the calculation is executed
; at once for four columns with use of scaled iDCT-1D algorithm.
; Base R&Y algorithm for iDCT-1D is modified for second stage.
;
;=============================================================================
;-----------------------------------------------------------------------------
;
; The first stage - inverse DCTs of rows
;
;-----------------------------------------------------------------------------
; The 8-point inverse DCT direct algorithm
;-----------------------------------------------------------------------------
;*/

__declspec(align(16)) short tab_i_04[] = 
{
  16384, 21407, 16384, 8867,
  16384, 8867, -16384, -21407,
  16384, -8867, -16384, 21407,
  16384, -21407, 16384, -8867,
  22725, 19266, 12873, 4520,
  19266, -4520, -22725, -12873,
  12873, -22725, 4520, 19266,
  4520, -12873, 19266, -22725,
};

// Table for rows 1,7 - constants are multiplied on cos_1_16

__declspec(align(16)) short tab_i_17[] =
{
  22725, 29692, 22725, 12299,
  22725, 12299, -22725, -29692,
  22725, -12299, -22725, 29692,
  22725, -29692, 22725, -12299,
  31521, 26722, 17855, 6270,
  26722, -6270, -31521, -17855,
  17855, -31521, 6270, 26722,
  6270, -17855, 26722, -31521,
};

// Table for rows 2,6 - constants are multiplied on cos_2_16

__declspec(align(16)) short tab_i_26[] =
{
  21407, 27969, 21407, 11585,
  21407, 11585, -21407, -27969,
  21407, -11585, -21407, 27969,
  21407, -27969, 21407, -11585,
  29692, 25172, 16819, 5906,
  25172, -5906, -29692, -16819,
  16819, -29692, 5906, 25172,
  5906, -16819, 25172, -29692,
};

// Table for rows 3,5 - constants are multiplied on cos_3_16

__declspec(align(16)) short tab_i_35[] = 
{
  19266, 25172, 19266, 10426,
  19266, 10426, -19266, -25172,
  19266, -10426, -19266, 25172,
  19266, -25172, 19266, -10426,
  26722, 22654, 15137, 5315,
  22654, -5315, -26722, -15137,
  15137, -26722, 5315, 22654,
  5315, -15137, 22654, -26722,
};


#define SHIFT_ROUND_ROW(x) (((x)+RND_INV_ROW)>>SHIFT_INV_ROW)

/*
  static const short w[32] = {
  FIX(cos_4_16), FIX(cos_2_16), FIX(cos_4_16), FIX(cos_6_16),
  FIX(cos_4_16), FIX(cos_6_16), -FIX(cos_4_16), -FIX(cos_2_16),
  FIX(cos_4_16), -FIX(cos_6_16), -FIX(cos_4_16), FIX(cos_2_16),
  FIX(cos_4_16), -FIX(cos_2_16), FIX(cos_4_16), -FIX(cos_6_16),
  FIX(cos_1_16), FIX(cos_3_16), FIX(cos_5_16), FIX(cos_7_16),
  FIX(cos_3_16), -FIX(cos_7_16), -FIX(cos_1_16), -FIX(cos_5_16),
  FIX(cos_5_16), -FIX(cos_1_16), FIX(cos_7_16), FIX(cos_3_16),
  FIX(cos_7_16), -FIX(cos_5_16), FIX(cos_3_16), -FIX(cos_1_16) };
*/

#define DCT_8_INV_ROW_SCALAR(x, y, w) \
{ \
  int a0, a1, a2, a3, b0, b1, b2, b3; \
 \
  a0 = x[0] * w[ 0] + x[2] * w[ 1] + x[4] * w[ 2] + x[6] * w[ 3]; \
  a1 = x[0] * w[ 4] + x[2] * w[ 5] + x[4] * w[ 6] + x[6] * w[ 7]; \
  a2 = x[0] * w[ 8] + x[2] * w[ 9] + x[4] * w[10] + x[6] * w[11];\
  a3 = x[0] * w[12] + x[2] * w[13] + x[4] * w[14] + x[6] * w[15];\
  b0 = x[1] * w[16] + x[3] * w[17] + x[5] * w[18] + x[7] * w[19];\
  b1 = x[1] * w[20] + x[3] * w[21] + x[5] * w[22] + x[7] * w[23];\
  b2 = x[1] * w[24] + x[3] * w[25] + x[5] * w[26] + x[7] * w[27];\
  b3 = x[1] * w[28] + x[3] * w[29] + x[5] * w[30] + x[7] * w[31];\
\
  y[0] = SHIFT_ROUND_ROW ( a0 + b0 );\
  y[1] = SHIFT_ROUND_ROW ( a1 + b1 );\
  y[2] = SHIFT_ROUND_ROW ( a2 + b2 );\
  y[3] = SHIFT_ROUND_ROW ( a3 + b3 );\
  y[4] = SHIFT_ROUND_ROW ( a3 - b3 );\
  y[5] = SHIFT_ROUND_ROW ( a2 - b2 );\
  y[6] = SHIFT_ROUND_ROW ( a1 - b1 );\
  y[7] = SHIFT_ROUND_ROW ( a0 - b0 );\
}

/*
;-----------------------------------------------------------------------------
;
; In this implementation the outputs of the iDCT-1D are multiplied
; for rows 0,4 - on cos_4_16,
; for rows 1,7 - on cos_1_16,
; for rows 2,6 - on cos_2_16,
; for rows 3,5 - on cos_3_16
; and are shifted to the left for rise of accuracy
;
; For used constants
; FIX(float_const) = (short) (float_const * (1<<15) + 0.5)
;
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;
; The second stage - inverse DCTs of columns
;
; The inputs are multiplied
; for rows 0,4 - on cos_4_16,
; for rows 1,7 - on cos_1_16,
; for rows 2,6 - on cos_2_16,
; for rows 3,5 - on cos_3_16
; and are shifted to the left for rise of accuracy
;
;-----------------------------------------------------------------------------
;
; The 8-point scaled inverse DCT algorithm (26a8m)
;
;-----------------------------------------------------------------------------
;
*/

#define SHIFT_COL(x)  ((x)>>SHIFT_INV_COL)
#define CLIP(x)  ((x)>32767?32767:(((x)<-32768)?-32768:(x)))
#define tg_1_16 13036
#define tg_2_16  27146
#define tg_3_16  -21746
#define cos_4_16 -19195

#define DCT_8_INV_COL(x, y)				\
  {							\
    int t0, t1, t2, t3, t4, t5, t6, t7;			\
    int tp03, tm03, tp12, tm12, tp65, tm65;		\
    int tp465, tm465, tp765, tm765;			\
							\
    tp765 = x[8*1] + (((int) x[8*7] * tg_1_16)>>16);		\
    tp465 = (((int)x[8*1] * tg_1_16)>>16) - x[8*7];		\
    tm765 = (((int)x[8*5] * tg_3_16)>>16) + x[8*5] + x[8*3];	\
    tm465 = x[8*5] - (((int)x[8*3] * tg_3_16)>>16)-x[8*3];		\
								\
    t7 = tp765 + tm765 + 1;					\
    tp65 = tp765 - tm765;				\
    t4 = tp465 + tm465;					\
    tm65 = tp465 - tm465 + 1;				\
							\
    t6 = (((int)( tp65 + tm65 ) * cos_4_16)>>16)|0x1;	\
    t6 += tp65+tm65;					\
    t5 = (((int)( tp65 - tm65 ) * cos_4_16)>>16)|0x1;	\
    t5 += (tp65-tm65);					\
							\
    tp03 = x[8*0] + x[8*4];				\
    tp12 = x[8*0] - x[8*4];				\
							\
    tm03 = x[8*2] + (((int)x[8*6] * tg_2_16)>>16);	\
    tm12 = (((int)x[8*2] * tg_2_16)>>16) - x[8*6];	\
    							\
    t0 = tp03 + tm03+RND_INV_COL;			\
    t3 = tp03 - tm03+RND_INV_CORR;			\
    t1 = tp12 + tm12+RND_INV_COL;			\
    t2 = tp12 - tm12+RND_INV_CORR;   			\
    							\
    y[8*0] = SHIFT_COL ( CLIP(t0 + t7 ));		\
    y[8*7] = SHIFT_COL (  CLIP(t0 - t7 ));	\
    y[8*1] = SHIFT_COL (  CLIP(t1 + t6 ));	\
    y[8*6] = SHIFT_COL (  CLIP(t1 - t6 ));	\
    y[8*2] = SHIFT_COL (  CLIP(t2 + t5 ));	\
    y[8*5] = SHIFT_COL (  CLIP(t2 - t5 ));	\
    y[8*3] = SHIFT_COL (  CLIP(t3 + t4 ));	\
    y[8*4] = SHIFT_COL (  CLIP(t3 - t4 ));	\
  }



static void idct_M128ASM_scalar(short* src)
{
  /*04 17 26 35 */
  DCT_8_INV_ROW_SCALAR(src,src,tab_i_04);
  DCT_8_INV_ROW_SCALAR((src+8*4),(src+8*4),tab_i_04);

  DCT_8_INV_ROW_SCALAR((src+8),(src+8),tab_i_17);
  DCT_8_INV_ROW_SCALAR((src+8*7),(src+8*7),tab_i_17);

  DCT_8_INV_ROW_SCALAR((src+8*2),(src+8*2),tab_i_26);
  DCT_8_INV_ROW_SCALAR((src+8*6),(src+8*6),tab_i_26);

  DCT_8_INV_ROW_SCALAR((src+8*3),(src+8*3),tab_i_35);
  DCT_8_INV_ROW_SCALAR((src+8*5),(src+8*5),tab_i_35);

  DCT_8_INV_COL(src, src);
  DCT_8_INV_COL((src+1),(src+1));
  DCT_8_INV_COL((src+2),(src+2));
  DCT_8_INV_COL((src+3),(src+3));
  DCT_8_INV_COL((src+4),(src+4));
  DCT_8_INV_COL((src+5),(src+5));
  DCT_8_INV_COL((src+6),(src+6));
  DCT_8_INV_COL((src+7),(src+7));
}

#endif
#endif
#endif
/*
  ;
  ;-----------------------------------------------------------------------------
*/



/* two dimensional inverse discrete cosine transform */
void idct(block)
short *block;
{
#if (ORIGINAL_IDCT)
    int i;
    for (i=0; i<8; i++)
      idctrow(block+8*i);
    
    for (i=0; i<8; i++)
      idctcol(block+i);
#elif (MATRIX_IDCT)
    int i, j, k;
    int s;
    __declspec(align(16)) short tmp[64];
#ifdef SSE2

    short *b_p, *icp, *tmp_p, *b2_p;

    /* not the most elegant approach, can be improved with other fast IDCT 
       methods out there */
    
    b_p = block;/*block+8*i;*/
    icp = &ic[0][0];
    tmp_p = &tmp[0]; /*&tmp[8*i];*/
    b2_p = &block[63];

    /*	
    for (i=0; i<8; i++) {

      for (j=0; j<8; j++) {
      
        s=0;

        for (k=0; k<8; k++)
          s += ic[j][k] * block[8*i+k];          

        tmp[8*i+j] = s >> 15;
      }
    }
    */
    __asm 
	{
	  mov   ecx, [b2_p]          ;
	  mov   ebx, [b_p]        ; /*load blk ptr*/
	  mov   edx, [icp]       ; /*load ic ptr */
	  mov   eax, [tmp_p]    ;
      
	idct_row_loop:
	  movdqa   xmm0, [ebx]      ; /*load 8 shorts from block*/
	  movdqa   xmm1, [edx]         ; /*ic[0][0..7]*/
	  movdqa   xmm2, [edx+16]      ; /*ic[1][0..7]*/
	  movdqa   xmm3, [edx+32]      ; /*ic[2][0..7]*/
	  movdqa   xmm4, [edx+48]      ; /*ic[3][0..7]*/

	  movdqa   xmm7, [edx+64]      ; /*ic[4][0..7]*/

	  pmaddwd xmm1, xmm0     ; /* xmms : 4 32-bit partial sums */
	  pmaddwd xmm2, xmm0     ;
	  pmaddwd xmm3, xmm0     ;
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm7, xmm0     ;

	  movdqa  xmm5, xmm1     ;
	  movdqa  xmm6, xmm3     ;

	  unpcklpd xmm1, xmm2    ; /*xmm1: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm5, xmm2    ; /*xmm5: 2.3 2.2 1.3 1.2 */

	  movdqa   xmm2, [edx+80]      ; /*ic[5][0..7]*/

	  unpcklpd xmm3, xmm4    ;
	  unpckhpd xmm6, xmm4    ;

	  movdqa   xmm4, [edx+96]      ; /*ic[6][0..7]*/
	  pmaddwd  xmm2, xmm0    ;

	  paddd  xmm6, xmm3      ; 

	  movdqa   xmm3, [edx+112]      ; /*ic[7][0..7]*/
	  pmaddwd xmm4, xmm0     ;
	  pmaddwd xmm3, xmm0     ; /*2nd batch, 7,2,4,3 */

	  paddd  xmm5, xmm1      ; /*xmm5: 2.a 2.b | 1.a 1.b */

	  movdqa xmm1, xmm5      ;
	  shufps  xmm1, xmm6, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm5, xmm6, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */
	  
	  movdqa xmm6, xmm7      ;

	  paddd  xmm1, xmm5      ;

	  movdqa xmm5, xmm4      ;
	  
	  unpcklpd xmm7, xmm2    ; /*xmm7: 2.1 2.0 1.1 1.0 */
	  unpckhpd xmm6, xmm2    ; /*xmm6: 2.3 2.2 1.3 1.2 */

	  unpcklpd xmm4, xmm3    ;
	  unpckhpd xmm5, xmm3    ;

	  paddd xmm6, xmm7       ;
	  paddd xmm5, xmm4       ;

	  movdqa xmm2, xmm6      ;
	  shufps  xmm2, xmm5, 0x8d ; /* 1: 3.a, 2.a, 1.a, 0.a */
	  shufps  xmm6, xmm5, 0xd8 ; /* 5: 3.b, 2.b, 1.b, 0.b */

	  paddd xmm2, xmm6       ;

	  psrad  xmm1, 15        ;
	  psrad  xmm2, 15         ;

	  packssdw xmm1, xmm2    ;

	  movdqa [eax], xmm1     ;

	  add   ebx, 16         ;
	  add   eax, 16         ;

	  cmp   ebx, ecx        ;
	  jb    idct_row_loop   ;
	  
	  ; /* start of second phase */
	mov edx, [tmp_p]        ; /* load tmp blk ptr */
	mov eax, [icp]          ; /* load coeffs table ptr*/
	mov ebx, [b_p]          ;
	mov edi, [b2_p]         ;

      idct_col_outer:
	movdqa xmm6, [eax]      ; /* load ic[0][0..7] */
	
	pxor xmm4, xmm4         ;
	pxor xmm5, xmm5         ;
	mov  ecx, 8             ;

      idct_col_loop:
	movdqa xmm1, [edx]      ; /* load tmp[0][0..7] */
	pshuflw xmm0, xmm6, 0   ; /* copy the lowest word to all positions */
	;pshuflw xmm0, xmm0, 0   ;
	pshufd xmm0, xmm0, 0
	psrldq  xmm6, 2         ; /* prepare for next word*/
	
	movdqa xmm2, xmm0       ;
	pmulhw xmm2, xmm1       ; /*multiply them */
	pmullw xmm0, xmm1       ; /*2 :high words 1: low words */

	movdqa xmm3, xmm0       ; /*3 : low words */
	punpckhwd xmm0,xmm2     ; /*1 : left half, 4 32-bit */
	punpcklwd xmm3,xmm2    ; /*3 : right half, 4 32-bit */

	paddd xmm4, xmm0      ; /*accumulate */
	paddd xmm5, xmm3      ; /*4 : left, 5 : right*/

	add  edx, 16          ;
	
	loop idct_col_loop    ; /* end of inner loop */

	sub  edx, 128           ;
	psrad xmm4, 15        ; /*s >> 15 */
	psrad xmm5, 15        ;
	
	packssdw xmm5, xmm4   ;

	movdqa [ebx], xmm5    ; /*store to block[i][j]*/

	add  ebx, 16          ;
	add  eax, 16          ;
	cmp  ebx, edi         ;
	jb   idct_col_outer   ;
      }
#else /* NON-SSE2 code */

    for (i=0; i<8; i++) { 

      for (j=0; j<8; j++) { 

	s = 0;
	
	for (k=0; k<8; k++)
	  s += ic[j][k] * block[8*i+k];          /* this is block[i][k] */
	tmp[8*i+j] = s >> 15;                         /* this is block[i][j] */

      }  /* for j */

    } /* for i */
    

    /* 	simd multiplication of AxB = C is done as follows:
	If col_dim(A) == N
  	To produce row C[0]

	For i=0 to N-1 {

		// each element in the 0th row of A is multiplied by
		// all elements in row B[i] and a running sum is kep in sum

		sum[0..N-1] = A[0][i] * B[k][0..N-1]   

	} 

	C[0][0..N]  = sum[0..N];

        If we do the above loop for all rows of A, we can produce C entirely.
   */



    for (j=0; j<8; j++) {
      

      for (i=0; i<8; i++) {

	s = 0;
	
	for (k=0; k<8; k++)
	  s += ic[i][k] * tmp[8*k+j];
	block[8*i+j] =  s >> 15;
	
      } /* end of i */

    } /* end of j */

#endif /* end non-SSE2 */

#else /* INTEL IDCT */
#ifdef SSE2
    idct_M128ASM(block);
#else
    idct_M128ASM_scalar(block);
#endif
#endif
}

void init_idct()
{
#if 0
  int i;

  iclp = iclip+512;
  for (i= -512; i<512; i++)
    iclp[i] = (i<-256) ? -256 : ((i>255) ? 255 : i);
#endif
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* motion.c, motion estimation                                              */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "config.h"
#include "global.h"

#define THRESHOLD 64

/* private prototypes */

static void frame_ME _ANSI_ARGS_((unsigned char *oldorg, unsigned char *neworg,
  unsigned char *oldref, unsigned char *newref, unsigned char *cur,
  int i, int j, int sxf, int syf, int sxb, int syb, struct mbinfo *mbi));

static void field_ME _ANSI_ARGS_((unsigned char *oldorg, unsigned char *neworg,
  unsigned char *oldref, unsigned char *newref, unsigned char *cur,
  unsigned char *curref, int i, int j, int sxf, int syf, int sxb, int syb,
  struct mbinfo *mbi, int secondfield, int ipflag));

static void frame_estimate _ANSI_ARGS_((unsigned char *org,
  unsigned char *ref, unsigned char *mb,
  int i, int j,
  int sx, int sy, int *iminp, int *jminp, int *imintp, int *jmintp,
  int *iminbp, int *jminbp, int *dframep, int *dfieldp,
  int *tselp, int *bselp, int imins[2][2], int jmins[2][2]));

static void field_estimate _ANSI_ARGS_((unsigned char *toporg,
  unsigned char *topref, unsigned char *botorg, unsigned char *botref,
  unsigned char *mb, int i, int j, int sx, int sy, int ipflag,
  int *iminp, int *jminp, int *imin8up, int *jmin8up, int *imin8lp,
  int *jmin8lp, int *dfieldp, int *d8p, int *selp, int *sel8up, int *sel8lp,
  int *iminsp, int *jminsp, int *dsp));

static void dpframe_estimate _ANSI_ARGS_((unsigned char *ref,
  unsigned char *mb, int i, int j, int iminf[2][2], int jminf[2][2],
  int *iminp, int *jminp, int *imindmvp, int *jmindmvp,
  int *dmcp, int *vmcp));

static void dpfield_estimate _ANSI_ARGS_((unsigned char *topref,
  unsigned char *botref, unsigned char *mb,
  int i, int j, int imins, int jmins, int *imindmvp, int *jmindmvp,
  int *dmcp, int *vmcp));

static int fullsearch _ANSI_ARGS_((unsigned char *org, unsigned char *ref,
  unsigned char *blk,
  int lx, int i0, int j0, int sx, int sy, int h, int xmax, int ymax,
  int *iminp, int *jminp));

static int dist1 _ANSI_ARGS_((unsigned char *blk1, unsigned char *blk2,
  int lx, int hx, int hy, int h, int distlim));

static int dist2 _ANSI_ARGS_((unsigned char *blk1, unsigned char *blk2,
  int lx, int hx, int hy, int h));

static int bdist1 _ANSI_ARGS_((unsigned char *pf, unsigned char *pb,
  unsigned char *p2, int lx, int hxf, int hyf, int hxb, int hyb, int h));

static int bdist2 _ANSI_ARGS_((unsigned char *pf, unsigned char *pb,
  unsigned char *p2, int lx, int hxf, int hyf, int hxb, int hyb, int h));

static int variance _ANSI_ARGS_((unsigned char *p, int lx));


/*
 * motion estimation for progressive and interlaced frame pictures
 *
 * oldorg: source frame for forward prediction (used for P and B frames)
 * neworg: source frame for backward prediction (B frames only)
 * oldref: reconstructed frame for forward prediction (P and B frames)
 * newref: reconstructed frame for backward prediction (B frames only)
 * cur:    current frame (the one for which the prediction is formed)
 * sxf,syf: forward search window (frame coordinates)
 * sxb,syb: backward search window (frame coordinates)
 * mbi:    pointer to macroblock info structure
 *
 * results:
 * mbi->
 *  mb_type: 0, MB_INTRA, MB_FORWARD, MB_BACKWARD, MB_FORWARD|MB_BACKWARD
 *  MV[][][]: motion vectors (frame format)
 *  mv_field_sel: top/bottom field (for field prediction)
 *  motion_type: MC_FRAME, MC_FIELD
 *
 * uses global vars: pict_type, frame_pred_dct
 */

void motion_estimation(oldorg,neworg,oldref,newref,cur,curref,
  sxf,syf,sxb,syb,mbi,secondfield,ipflag)
unsigned char *oldorg,*neworg,*oldref,*newref,*cur,*curref;
int sxf,syf,sxb,syb;
struct mbinfo *mbi;
int secondfield,ipflag;
{
  int i, j;

  /* loop through all macroblocks of the picture */
  for (j=0; j<height2; j+=16)
  {
    for (i=0; i<width; i+=16)
    {

      if (pict_struct==FRAME_PICTURE)
        frame_ME(oldorg,neworg,oldref,newref,cur,i,j,sxf,syf,sxb,syb,mbi);
      else
        field_ME(oldorg,neworg,oldref,newref,cur,curref,i,j,sxf,syf,sxb,syb,
		 mbi,secondfield,ipflag);
      mbi++;
    }
    

  }
  
}

#ifdef LTHREAD

void ptmotion_estimation(oldorg,neworg,oldref,newref,cur,curref,
  sxf,syf,sxb,syb,mbi,secondfield,ipflag,start_height, end_height)
unsigned char *oldorg,*neworg,*oldref,*newref,*cur,*curref;
int sxf,syf,sxb,syb;
struct mbinfo *mbi;
int secondfield,ipflag;
int start_height, end_height;
{
  int i, j;
  struct mbinfo *local_mbi;

  local_mbi = mbi + (start_height>>4) * (width>>4);

  /* loop through all macroblocks of the picture */
  for (j=start_height; j<end_height; j+=16)
  {
    for (i=0; i<width; i+=16)
    {

      if (pict_struct==FRAME_PICTURE)
        frame_ME(oldorg,neworg,oldref,newref,cur,i,j,sxf,syf,sxb,syb,local_mbi);
      else
        field_ME(oldorg,neworg,oldref,newref,cur,curref,i,j,sxf,syf,sxb,syb,
		 local_mbi,secondfield,ipflag);
      
      local_mbi++;
    }
  }

  if (!quiet)
    fputc('\n',stderr);


}


#endif

static void frame_ME(oldorg,neworg,oldref,newref,cur,i,j,sxf,syf,sxb,syb,mbi)
unsigned char *oldorg,*neworg,*oldref,*newref,*cur;
int i,j,sxf,syf,sxb,syb;
struct mbinfo *mbi;
{
  int imin,jmin,iminf,jminf,iminr,jminr;
  int imint,jmint,iminb,jminb;
  int imintf,jmintf,iminbf,jminbf;
  int imintr,jmintr,iminbr,jminbr;
  int var,v0;
  int dmc,dmcf,dmcr,dmci,vmc,vmcf,vmcr,vmci;
  int dmcfield,dmcfieldf,dmcfieldr,dmcfieldi;
  int tsel,bsel,tself,bself,tselr,bselr;
  unsigned char *mb;
  int imins[2][2],jmins[2][2];
  int imindp,jmindp,imindmv,jmindmv,dmc_dp,vmc_dp;

  mb = cur + i + width*j;

  var = variance(mb,width);

  if (pict_type==I_TYPE)
    mbi->mb_type = MB_INTRA;
  else if (pict_type==P_TYPE)
  {
    if (frame_pred_dct)
    {
      dmc = fullsearch(oldorg,oldref,mb,
                       width,i,j,sxf,syf,16,width,height,&imin,&jmin);
      vmc = dist2(oldref+(imin>>1)+width*(jmin>>1),mb,
                  width,imin&1,jmin&1,16);
      mbi->motion_type = MC_FRAME;
    }
    else
    {
      frame_estimate(oldorg,oldref,mb,i,j,sxf,syf,
        &imin,&jmin,&imint,&jmint,&iminb,&jminb,
        &dmc,&dmcfield,&tsel,&bsel,imins,jmins);

      if (M==1)
        dpframe_estimate(oldref,mb,i,j>>1,imins,jmins,
          &imindp,&jmindp,&imindmv,&jmindmv,&dmc_dp,&vmc_dp);

      /* select between dual prime, frame and field prediction */
      if (M==1 && dmc_dp<dmc && dmc_dp<dmcfield)
      {
        mbi->motion_type = MC_DMV;
        dmc = dmc_dp;
        vmc = vmc_dp;
      }
      else if (dmc<=dmcfield)
      {
        mbi->motion_type = MC_FRAME;
        vmc = dist2(oldref+(imin>>1)+width*(jmin>>1),mb,
                    width,imin&1,jmin&1,16);
      }
      else
      {
        mbi->motion_type = MC_FIELD;
        dmc = dmcfield;
        vmc = dist2(oldref+(tsel?width:0)+(imint>>1)+(width<<1)*(jmint>>1),
                    mb,width<<1,imint&1,jmint&1,8);
        vmc+= dist2(oldref+(bsel?width:0)+(iminb>>1)+(width<<1)*(jminb>>1),
                    mb+width,width<<1,iminb&1,jminb&1,8);
      }
    }

    /* select between intra or non-intra coding:
     *
     * selection is based on intra block variance (var) vs.
     * prediction error variance (vmc)
     *
     * blocks with small prediction error are always coded non-intra
     * even if variance is smaller (is this reasonable?)
     */
    if (vmc>var && vmc>=9*256)
      mbi->mb_type = MB_INTRA;
    else
    {
      /* select between MC / No-MC
       *
       * use No-MC if var(No-MC) <= 1.25*var(MC)
       * (i.e slightly biased towards No-MC)
       *
       * blocks with small prediction error are always coded as No-MC
       * (requires no motion vectors, allows skipping)
       */
      v0 = dist2(oldref+i+width*j,mb,width,0,0,16);
      if (4*v0>5*vmc && v0>=9*256)
      {
        /* use MC */
        var = vmc;
        mbi->mb_type = MB_FORWARD;
        if (mbi->motion_type==MC_FRAME)
        {
          mbi->MV[0][0][0] = imin - (i<<1);
          mbi->MV[0][0][1] = jmin - (j<<1);
        }
        else if (mbi->motion_type==MC_DMV)
        {
          /* these are FRAME vectors */
          /* same parity vector */
          mbi->MV[0][0][0] = imindp - (i<<1);
          mbi->MV[0][0][1] = (jmindp<<1) - (j<<1);

          /* opposite parity vector */
          mbi->dmvector[0] = imindmv;
          mbi->dmvector[1] = jmindmv;
        }
        else
        {
          /* these are FRAME vectors */
          mbi->MV[0][0][0] = imint - (i<<1);
          mbi->MV[0][0][1] = (jmint<<1) - (j<<1);
          mbi->MV[1][0][0] = iminb - (i<<1);
          mbi->MV[1][0][1] = (jminb<<1) - (j<<1);
          mbi->mv_field_sel[0][0] = tsel;
          mbi->mv_field_sel[1][0] = bsel;
        }
      }
      else
      {
        /* No-MC */
        var = v0;
        mbi->mb_type = 0;
        mbi->motion_type = MC_FRAME;
        mbi->MV[0][0][0] = 0;
        mbi->MV[0][0][1] = 0;
      }
    }
  }
  else /* if (pict_type==B_TYPE) */
  {
    if (frame_pred_dct)
    {
      /* forward */
      dmcf = fullsearch(oldorg,oldref,mb,
                        width,i,j,sxf,syf,16,width,height,&iminf,&jminf);
      vmcf = dist2(oldref+(iminf>>1)+width*(jminf>>1),mb,
                   width,iminf&1,jminf&1,16);

      /* backward */
      dmcr = fullsearch(neworg,newref,mb,
                        width,i,j,sxb,syb,16,width,height,&iminr,&jminr);
      vmcr = dist2(newref+(iminr>>1)+width*(jminr>>1),mb,
                   width,iminr&1,jminr&1,16);

      /* interpolated (bidirectional) */
      vmci = bdist2(oldref+(iminf>>1)+width*(jminf>>1),
                    newref+(iminr>>1)+width*(jminr>>1),
                    mb,width,iminf&1,jminf&1,iminr&1,jminr&1,16);

      /* decisions */

      /* select between forward/backward/interpolated prediction:
       * use the one with smallest mean sqaured prediction error
       */
      if (vmcf<=vmcr && vmcf<=vmci)
      {
        vmc = vmcf;
        mbi->mb_type = MB_FORWARD;
      }
      else if (vmcr<=vmci)
      {
        vmc = vmcr;
        mbi->mb_type = MB_BACKWARD;
      }
      else
      {
        vmc = vmci;
        mbi->mb_type = MB_FORWARD|MB_BACKWARD;
      }

      mbi->motion_type = MC_FRAME;
    }
    else
    {
      /* forward prediction */
      frame_estimate(oldorg,oldref,mb,i,j,sxf,syf,
        &iminf,&jminf,&imintf,&jmintf,&iminbf,&jminbf,
        &dmcf,&dmcfieldf,&tself,&bself,imins,jmins);

      /* backward prediction */
      frame_estimate(neworg,newref,mb,i,j,sxb,syb,
        &iminr,&jminr,&imintr,&jmintr,&iminbr,&jminbr,
        &dmcr,&dmcfieldr,&tselr,&bselr,imins,jmins);

      /* calculate interpolated distance */
      /* frame */
      dmci = bdist1(oldref+(iminf>>1)+width*(jminf>>1),
                    newref+(iminr>>1)+width*(jminr>>1),
                    mb,width,iminf&1,jminf&1,iminr&1,jminr&1,16);

      /* top field */
      dmcfieldi = bdist1(
                    oldref+(imintf>>1)+(tself?width:0)+(width<<1)*(jmintf>>1),
                    newref+(imintr>>1)+(tselr?width:0)+(width<<1)*(jmintr>>1),
                    mb,width<<1,imintf&1,jmintf&1,imintr&1,jmintr&1,8);

      /* bottom field */
      dmcfieldi+= bdist1(
                    oldref+(iminbf>>1)+(bself?width:0)+(width<<1)*(jminbf>>1),
                    newref+(iminbr>>1)+(bselr?width:0)+(width<<1)*(jminbr>>1),
                    mb+width,width<<1,iminbf&1,jminbf&1,iminbr&1,jminbr&1,8);

      /* select prediction type of minimum distance from the
       * six candidates (field/frame * forward/backward/interpolated)
       */
      if (dmci<dmcfieldi && dmci<dmcf && dmci<dmcfieldf
          && dmci<dmcr && dmci<dmcfieldr)
      {
        /* frame, interpolated */
        mbi->mb_type = MB_FORWARD|MB_BACKWARD;
        mbi->motion_type = MC_FRAME;
        vmc = bdist2(oldref+(iminf>>1)+width*(jminf>>1),
                     newref+(iminr>>1)+width*(jminr>>1),
                     mb,width,iminf&1,jminf&1,iminr&1,jminr&1,16);
      }
      else if (dmcfieldi<dmcf && dmcfieldi<dmcfieldf
               && dmcfieldi<dmcr && dmcfieldi<dmcfieldr)
      {
        /* field, interpolated */
        mbi->mb_type = MB_FORWARD|MB_BACKWARD;
        mbi->motion_type = MC_FIELD;
        vmc = bdist2(oldref+(imintf>>1)+(tself?width:0)+(width<<1)*(jmintf>>1),
                     newref+(imintr>>1)+(tselr?width:0)+(width<<1)*(jmintr>>1),
                     mb,width<<1,imintf&1,jmintf&1,imintr&1,jmintr&1,8);
        vmc+= bdist2(oldref+(iminbf>>1)+(bself?width:0)+(width<<1)*(jminbf>>1),
                     newref+(iminbr>>1)+(bselr?width:0)+(width<<1)*(jminbr>>1),
                     mb+width,width<<1,iminbf&1,jminbf&1,iminbr&1,jminbr&1,8);
      }
      else if (dmcf<dmcfieldf && dmcf<dmcr && dmcf<dmcfieldr)
      {
        /* frame, forward */
        mbi->mb_type = MB_FORWARD;
        mbi->motion_type = MC_FRAME;
        vmc = dist2(oldref+(iminf>>1)+width*(jminf>>1),mb,
                    width,iminf&1,jminf&1,16);
      }
      else if (dmcfieldf<dmcr && dmcfieldf<dmcfieldr)
      {
        /* field, forward */
        mbi->mb_type = MB_FORWARD;
        mbi->motion_type = MC_FIELD;
        vmc = dist2(oldref+(tself?width:0)+(imintf>>1)+(width<<1)*(jmintf>>1),
                    mb,width<<1,imintf&1,jmintf&1,8);
        vmc+= dist2(oldref+(bself?width:0)+(iminbf>>1)+(width<<1)*(jminbf>>1),
                    mb+width,width<<1,iminbf&1,jminbf&1,8);
      }
      else if (dmcr<dmcfieldr)
      {
        /* frame, backward */
        mbi->mb_type = MB_BACKWARD;
        mbi->motion_type = MC_FRAME;
        vmc = dist2(newref+(iminr>>1)+width*(jminr>>1),mb,
                    width,iminr&1,jminr&1,16);
      }
      else
      {
        /* field, backward */
        mbi->mb_type = MB_BACKWARD;
        mbi->motion_type = MC_FIELD;
        vmc = dist2(newref+(tselr?width:0)+(imintr>>1)+(width<<1)*(jmintr>>1),
                    mb,width<<1,imintr&1,jmintr&1,8);
        vmc+= dist2(newref+(bselr?width:0)+(iminbr>>1)+(width<<1)*(jminbr>>1),
                    mb+width,width<<1,iminbr&1,jminbr&1,8);
      }
    }

    /* select between intra or non-intra coding:
     *
     * selection is based on intra block variance (var) vs.
     * prediction error variance (vmc)
     *
     * blocks with small prediction error are always coded non-intra
     * even if variance is smaller (is this reasonable?)
     */
    if (vmc>var && vmc>=9*256)
      mbi->mb_type = MB_INTRA;
    else
    {
      var = vmc;
      if (mbi->motion_type==MC_FRAME)
      {
        /* forward */
        mbi->MV[0][0][0] = iminf - (i<<1);
        mbi->MV[0][0][1] = jminf - (j<<1);
        /* backward */
        mbi->MV[0][1][0] = iminr - (i<<1);
        mbi->MV[0][1][1] = jminr - (j<<1);
      }
      else
      {
        /* these are FRAME vectors */
        /* forward */
        mbi->MV[0][0][0] = imintf - (i<<1);
        mbi->MV[0][0][1] = (jmintf<<1) - (j<<1);
        mbi->MV[1][0][0] = iminbf - (i<<1);
        mbi->MV[1][0][1] = (jminbf<<1) - (j<<1);
        mbi->mv_field_sel[0][0] = tself;
        mbi->mv_field_sel[1][0] = bself;
        /* backward */
        mbi->MV[0][1][0] = imintr - (i<<1);
        mbi->MV[0][1][1] = (jmintr<<1) - (j<<1);
        mbi->MV[1][1][0] = iminbr - (i<<1);
        mbi->MV[1][1][1] = (jminbr<<1) - (j<<1);
        mbi->mv_field_sel[0][1] = tselr;
        mbi->mv_field_sel[1][1] = bselr;
      }
    }
  }

  mbi->var = var;
}

/*
 * motion estimation for field pictures
 *
 * oldorg: original frame for forward prediction (P and B frames)
 * neworg: original frame for backward prediction (B frames only)
 * oldref: reconstructed frame for forward prediction (P and B frames)
 * newref: reconstructed frame for backward prediction (B frames only)
 * cur:    current original frame (the one for which the prediction is formed)
 * curref: current reconstructed frame (to predict second field from first)
 * sxf,syf: forward search window (frame coordinates)
 * sxb,syb: backward search window (frame coordinates)
 * mbi:    pointer to macroblock info structure
 * secondfield: indicates second field of a frame (in P fields this means
 *              that reference field of opposite parity is in curref instead
 *              of oldref)
 * ipflag: indicates a P type field which is the second field of a frame
 *         in which the first field is I type (this restricts predictions
 *         to be based only on the opposite parity (=I) field)
 *
 * results:
 * mbi->
 *  mb_type: 0, MB_INTRA, MB_FORWARD, MB_BACKWARD, MB_FORWARD|MB_BACKWARD
 *  MV[][][]: motion vectors (field format)
 *  mv_field_sel: top/bottom field
 *  motion_type: MC_FIELD, MC_16X8
 *
 * uses global vars: pict_type, pict_struct
 */
static void field_ME(oldorg,neworg,oldref,newref,cur,curref,i,j,
  sxf,syf,sxb,syb,mbi,secondfield,ipflag)
unsigned char *oldorg,*neworg,*oldref,*newref,*cur,*curref;
int i,j,sxf,syf,sxb,syb;
struct mbinfo *mbi;
int secondfield,ipflag;
{
  int w2;
  unsigned char *mb, *toporg, *topref, *botorg, *botref;
  int var,vmc,v0,dmc,dmcfieldi,dmc8i;
  int imin,jmin,imin8u,jmin8u,imin8l,jmin8l,dmcfield,dmc8,sel,sel8u,sel8l;
  int iminf,jminf,imin8uf,jmin8uf,imin8lf,jmin8lf,dmcfieldf,dmc8f,self,sel8uf,sel8lf;
  int iminr,jminr,imin8ur,jmin8ur,imin8lr,jmin8lr,dmcfieldr,dmc8r,selr,sel8ur,sel8lr;
  int imins,jmins,ds,imindmv,jmindmv,vmc_dp,dmc_dp;

  w2 = width<<1;

  mb = cur + i + w2*j;
  if (pict_struct==BOTTOM_FIELD)
    mb += width;

  var = variance(mb,w2);

  if (pict_type==I_TYPE)
    mbi->mb_type = MB_INTRA;
  else if (pict_type==P_TYPE)
  {
    toporg = oldorg;
    topref = oldref;
    botorg = oldorg + width;
    botref = oldref + width;

    if (secondfield)
    {
      /* opposite parity field is in same frame */
      if (pict_struct==TOP_FIELD)
      {
        /* current is top field */
        botorg = cur + width;
        botref = curref + width;
      }
      else
      {
        /* current is bottom field */
        toporg = cur;
        topref = curref;
      }
    }

    field_estimate(toporg,topref,botorg,botref,mb,i,j,sxf,syf,ipflag,
                   &imin,&jmin,&imin8u,&jmin8u,&imin8l,&jmin8l,
                   &dmcfield,&dmc8,&sel,&sel8u,&sel8l,&imins,&jmins,&ds);

    if (M==1 && !ipflag)  /* generic condition which permits Dual Prime */
      dpfield_estimate(topref,botref,mb,i,j,imins,jmins,&imindmv,&jmindmv,
        &dmc_dp,&vmc_dp);

    /* select between dual prime, field and 16x8 prediction */
    if (M==1 && !ipflag && dmc_dp<dmc8 && dmc_dp<dmcfield)
    {
      /* Dual Prime prediction */
      mbi->motion_type = MC_DMV;
      dmc = dmc_dp;     /* L1 metric */
      vmc = vmc_dp;     /* we already calculated L2 error for Dual */

    }
    else if (dmc8<dmcfield)
    {
      /* 16x8 prediction */
      mbi->motion_type = MC_16X8;
      /* upper half block */
      vmc = dist2((sel8u?botref:topref) + (imin8u>>1) + w2*(jmin8u>>1),
                  mb,w2,imin8u&1,jmin8u&1,8);
      /* lower half block */
      vmc+= dist2((sel8l?botref:topref) + (imin8l>>1) + w2*(jmin8l>>1),
                  mb+8*w2,w2,imin8l&1,jmin8l&1,8);
    }
    else
    {
      /* field prediction */
      mbi->motion_type = MC_FIELD;
      vmc = dist2((sel?botref:topref) + (imin>>1) + w2*(jmin>>1),
                  mb,w2,imin&1,jmin&1,16);
    }

    /* select between intra and non-intra coding */
    if (vmc>var && vmc>=9*256)
      mbi->mb_type = MB_INTRA;
    else
    {
      /* zero MV field prediction from same parity ref. field
       * (not allowed if ipflag is set)
       */
      if (!ipflag)
        v0 = dist2(((pict_struct==BOTTOM_FIELD)?botref:topref) + i + w2*j,
                   mb,w2,0,0,16);
      if (ipflag || (4*v0>5*vmc && v0>=9*256))
      {
        var = vmc;
        mbi->mb_type = MB_FORWARD;
        if (mbi->motion_type==MC_FIELD)
        {
          mbi->MV[0][0][0] = imin - (i<<1);
          mbi->MV[0][0][1] = jmin - (j<<1);
          mbi->mv_field_sel[0][0] = sel;
        }
        else if (mbi->motion_type==MC_DMV)
        {
          /* same parity vector */
          mbi->MV[0][0][0] = imins - (i<<1);
          mbi->MV[0][0][1] = jmins - (j<<1);

          /* opposite parity vector */
          mbi->dmvector[0] = imindmv;
          mbi->dmvector[1] = jmindmv;
        }
        else
        {
          mbi->MV[0][0][0] = imin8u - (i<<1);
          mbi->MV[0][0][1] = jmin8u - (j<<1);
          mbi->MV[1][0][0] = imin8l - (i<<1);
          mbi->MV[1][0][1] = jmin8l - ((j+8)<<1);
          mbi->mv_field_sel[0][0] = sel8u;
          mbi->mv_field_sel[1][0] = sel8l;
        }
      }
      else
      {
        /* No MC */
        var = v0;
        mbi->mb_type = 0;
        mbi->motion_type = MC_FIELD;
        mbi->MV[0][0][0] = 0;
        mbi->MV[0][0][1] = 0;
        mbi->mv_field_sel[0][0] = (pict_struct==BOTTOM_FIELD);
      }
    }
  }
  else /* if (pict_type==B_TYPE) */
  {
    /* forward prediction */
    field_estimate(oldorg,oldref,oldorg+width,oldref+width,mb,
                   i,j,sxf,syf,0,
                   &iminf,&jminf,&imin8uf,&jmin8uf,&imin8lf,&jmin8lf,
                   &dmcfieldf,&dmc8f,&self,&sel8uf,&sel8lf,&imins,&jmins,&ds);

    /* backward prediction */
    field_estimate(neworg,newref,neworg+width,newref+width,mb,
                   i,j,sxb,syb,0,
                   &iminr,&jminr,&imin8ur,&jmin8ur,&imin8lr,&jmin8lr,
                   &dmcfieldr,&dmc8r,&selr,&sel8ur,&sel8lr,&imins,&jmins,&ds);

    /* calculate distances for bidirectional prediction */
    /* field */
    dmcfieldi = bdist1(oldref + (self?width:0) + (iminf>>1) + w2*(jminf>>1),
                       newref + (selr?width:0) + (iminr>>1) + w2*(jminr>>1),
                       mb,w2,iminf&1,jminf&1,iminr&1,jminr&1,16);

    /* 16x8 upper half block */
    dmc8i = bdist1(oldref + (sel8uf?width:0) + (imin8uf>>1) + w2*(jmin8uf>>1),
                   newref + (sel8ur?width:0) + (imin8ur>>1) + w2*(jmin8ur>>1),
                   mb,w2,imin8uf&1,jmin8uf&1,imin8ur&1,jmin8ur&1,8);

    /* 16x8 lower half block */
    dmc8i+= bdist1(oldref + (sel8lf?width:0) + (imin8lf>>1) + w2*(jmin8lf>>1),
                   newref + (sel8lr?width:0) + (imin8lr>>1) + w2*(jmin8lr>>1),
                   mb+8*w2,w2,imin8lf&1,jmin8lf&1,imin8lr&1,jmin8lr&1,8);

    /* select prediction type of minimum distance */
    if (dmcfieldi<dmc8i && dmcfieldi<dmcfieldf && dmcfieldi<dmc8f
        && dmcfieldi<dmcfieldr && dmcfieldi<dmc8r)
    {
      /* field, interpolated */
      mbi->mb_type = MB_FORWARD|MB_BACKWARD;
      mbi->motion_type = MC_FIELD;
      vmc = bdist2(oldref + (self?width:0) + (iminf>>1) + w2*(jminf>>1),
                   newref + (selr?width:0) + (iminr>>1) + w2*(jminr>>1),
                   mb,w2,iminf&1,jminf&1,iminr&1,jminr&1,16);
    }
    else if (dmc8i<dmcfieldf && dmc8i<dmc8f
             && dmc8i<dmcfieldr && dmc8i<dmc8r)
    {
      /* 16x8, interpolated */
      mbi->mb_type = MB_FORWARD|MB_BACKWARD;
      mbi->motion_type = MC_16X8;

      /* upper half block */
      vmc = bdist2(oldref + (sel8uf?width:0) + (imin8uf>>1) + w2*(jmin8uf>>1),
                   newref + (sel8ur?width:0) + (imin8ur>>1) + w2*(jmin8ur>>1),
                   mb,w2,imin8uf&1,jmin8uf&1,imin8ur&1,jmin8ur&1,8);

      /* lower half block */
      vmc+= bdist2(oldref + (sel8lf?width:0) + (imin8lf>>1) + w2*(jmin8lf>>1),
                   newref + (sel8lr?width:0) + (imin8lr>>1) + w2*(jmin8lr>>1),
                   mb+8*w2,w2,imin8lf&1,jmin8lf&1,imin8lr&1,jmin8lr&1,8);
    }
    else if (dmcfieldf<dmc8f && dmcfieldf<dmcfieldr && dmcfieldf<dmc8r)
    {
      /* field, forward */
      mbi->mb_type = MB_FORWARD;
      mbi->motion_type = MC_FIELD;
      vmc = dist2(oldref + (self?width:0) + (iminf>>1) + w2*(jminf>>1),
                  mb,w2,iminf&1,jminf&1,16);
    }
    else if (dmc8f<dmcfieldr && dmc8f<dmc8r)
    {
      /* 16x8, forward */
      mbi->mb_type = MB_FORWARD;
      mbi->motion_type = MC_16X8;

      /* upper half block */
      vmc = dist2(oldref + (sel8uf?width:0) + (imin8uf>>1) + w2*(jmin8uf>>1),
                  mb,w2,imin8uf&1,jmin8uf&1,8);

      /* lower half block */
      vmc+= dist2(oldref + (sel8lf?width:0) + (imin8lf>>1) + w2*(jmin8lf>>1),
                  mb+8*w2,w2,imin8lf&1,jmin8lf&1,8);
    }
    else if (dmcfieldr<dmc8r)
    {
      /* field, backward */
      mbi->mb_type = MB_BACKWARD;
      mbi->motion_type = MC_FIELD;
      vmc = dist2(newref + (selr?width:0) + (iminr>>1) + w2*(jminr>>1),
                  mb,w2,iminr&1,jminr&1,16);
    }
    else
    {
      /* 16x8, backward */
      mbi->mb_type = MB_BACKWARD;
      mbi->motion_type = MC_16X8;

      /* upper half block */
      vmc = dist2(newref + (sel8ur?width:0) + (imin8ur>>1) + w2*(jmin8ur>>1),
                  mb,w2,imin8ur&1,jmin8ur&1,8);

      /* lower half block */
      vmc+= dist2(newref + (sel8lr?width:0) + (imin8lr>>1) + w2*(jmin8lr>>1),
                  mb+8*w2,w2,imin8lr&1,jmin8lr&1,8);
    }

    /* select between intra and non-intra coding */
    if (vmc>var && vmc>=9*256)
      mbi->mb_type = MB_INTRA;
    else
    {
      var = vmc;
      if (mbi->motion_type==MC_FIELD)
      {
        /* forward */
        mbi->MV[0][0][0] = iminf - (i<<1);
        mbi->MV[0][0][1] = jminf - (j<<1);
        mbi->mv_field_sel[0][0] = self;
        /* backward */
        mbi->MV[0][1][0] = iminr - (i<<1);
        mbi->MV[0][1][1] = jminr - (j<<1);
        mbi->mv_field_sel[0][1] = selr;
      }
      else /* MC_16X8 */
      {
        /* forward */
        mbi->MV[0][0][0] = imin8uf - (i<<1);
        mbi->MV[0][0][1] = jmin8uf - (j<<1);
        mbi->mv_field_sel[0][0] = sel8uf;
        mbi->MV[1][0][0] = imin8lf - (i<<1);
        mbi->MV[1][0][1] = jmin8lf - ((j+8)<<1);
        mbi->mv_field_sel[1][0] = sel8lf;
        /* backward */
        mbi->MV[0][1][0] = imin8ur - (i<<1);
        mbi->MV[0][1][1] = jmin8ur - (j<<1);
        mbi->mv_field_sel[0][1] = sel8ur;
        mbi->MV[1][1][0] = imin8lr - (i<<1);
        mbi->MV[1][1][1] = jmin8lr - ((j+8)<<1);
        mbi->mv_field_sel[1][1] = sel8lr;
      }
    }
  }

  mbi->var = var;
}

/*
 * frame picture motion estimation
 *
 * org: top left pel of source reference frame
 * ref: top left pel of reconstructed reference frame
 * mb:  macroblock to be matched
 * i,j: location of mb relative to ref (=center of search window)
 * sx,sy: half widths of search window
 * iminp,jminp,dframep: location and value of best frame prediction
 * imintp,jmintp,tselp: location of best field pred. for top field of mb
 * iminbp,jminbp,bselp: location of best field pred. for bottom field of mb
 * dfieldp: value of field prediction
 */
static void frame_estimate(org,ref,mb,i,j,sx,sy,
  iminp,jminp,imintp,jmintp,iminbp,jminbp,dframep,dfieldp,tselp,bselp,
  imins,jmins)
unsigned char *org,*ref,*mb;
int i,j,sx,sy;
int *iminp,*jminp;
int *imintp,*jmintp,*iminbp,*jminbp;
int *dframep,*dfieldp;
int *tselp,*bselp;
int imins[2][2],jmins[2][2];
{
  int dt,db,dmint,dminb;
  int imint,iminb,jmint,jminb;

  /* frame prediction */
  *dframep = fullsearch(org,ref,mb,width,i,j,sx,sy,16,width,height,
                        iminp,jminp);

  /* predict top field from top field */
  dt = fullsearch(org,ref,mb,width<<1,i,j>>1,sx,sy>>1,8,width,height>>1,
                  &imint,&jmint);

  /* predict top field from bottom field */
  db = fullsearch(org+width,ref+width,mb,width<<1,i,j>>1,sx,sy>>1,8,width,height>>1,
                  &iminb,&jminb);

  imins[0][0] = imint;
  jmins[0][0] = jmint;
  imins[1][0] = iminb;
  jmins[1][0] = jminb;

  /* select prediction for top field */
  if (dt<=db)
  {
    dmint=dt; *imintp=imint; *jmintp=jmint; *tselp=0;
  }
  else
  {
    dmint=db; *imintp=iminb; *jmintp=jminb; *tselp=1;
  }

  /* predict bottom field from top field */
  dt = fullsearch(org,ref,mb+width,width<<1,i,j>>1,sx,sy>>1,8,width,height>>1,
                  &imint,&jmint);

  /* predict bottom field from bottom field */
  db = fullsearch(org+width,ref+width,mb+width,width<<1,i,j>>1,sx,sy>>1,8,width,height>>1,
                  &iminb,&jminb);

  imins[0][1] = imint;
  jmins[0][1] = jmint;
  imins[1][1] = iminb;
  jmins[1][1] = jminb;

  /* select prediction for bottom field */
  if (db<=dt)
  {
    dminb=db; *iminbp=iminb; *jminbp=jminb; *bselp=1;
  }
  else
  {
    dminb=dt; *iminbp=imint; *jminbp=jmint; *bselp=0;
  }

  *dfieldp=dmint+dminb;
}

/*
 * field picture motion estimation subroutine
 *
 * toporg: address of original top reference field
 * topref: address of reconstructed top reference field
 * botorg: address of original bottom reference field
 * botref: address of reconstructed bottom reference field
 * mb:  macroblock to be matched
 * i,j: location of mb (=center of search window)
 * sx,sy: half width/height of search window
 *
 * iminp,jminp,selp,dfieldp: location and distance of best field prediction
 * imin8up,jmin8up,sel8up: location of best 16x8 pred. for upper half of mb
 * imin8lp,jmin8lp,sel8lp: location of best 16x8 pred. for lower half of mb
 * d8p: distance of best 16x8 prediction
 * iminsp,jminsp,dsp: location and distance of best same parity field
 *                    prediction (needed for dual prime, only valid if
 *                    ipflag==0)
 */
static void field_estimate(toporg,topref,botorg,botref,mb,i,j,sx,sy,ipflag,
  iminp,jminp,imin8up,jmin8up,imin8lp,jmin8lp,dfieldp,d8p,selp,sel8up,sel8lp,
  iminsp,jminsp,dsp)
unsigned char *toporg, *topref, *botorg, *botref, *mb;
int i,j,sx,sy;
int ipflag;
int *iminp, *jminp;
int *imin8up, *jmin8up, *imin8lp, *jmin8lp;
int *dfieldp,*d8p;
int *selp, *sel8up, *sel8lp;
int *iminsp, *jminsp, *dsp;
{
  int dt, db, imint, jmint, iminb, jminb, notop, nobot;

  /* if ipflag is set, predict from field of opposite parity only */
  notop = ipflag && (pict_struct==TOP_FIELD);
  nobot = ipflag && (pict_struct==BOTTOM_FIELD);

  /* field prediction */

  /* predict current field from top field */
  if (notop)
    dt = 65536; /* infinity */
  else
    dt = fullsearch(toporg,topref,mb,width<<1,
                    i,j,sx,sy>>1,16,width,height>>1,
                    &imint,&jmint);

  /* predict current field from bottom field */
  if (nobot)
    db = 65536; /* infinity */
  else
    db = fullsearch(botorg,botref,mb,width<<1,
                    i,j,sx,sy>>1,16,width,height>>1,
                    &iminb,&jminb);

  /* same parity prediction (only valid if ipflag==0) */
  if (pict_struct==TOP_FIELD)
  {
    *iminsp = imint; *jminsp = jmint; *dsp = dt;
  }
  else
  {
    *iminsp = iminb; *jminsp = jminb; *dsp = db;
  }

  /* select field prediction */
  if (dt<=db)
  {
    *dfieldp = dt; *iminp = imint; *jminp = jmint; *selp = 0;
  }
  else
  {
    *dfieldp = db; *iminp = iminb; *jminp = jminb; *selp = 1;
  }


  /* 16x8 motion compensation */

  /* predict upper half field from top field */
  if (notop)
    dt = 65536;
  else
    dt = fullsearch(toporg,topref,mb,width<<1,
                    i,j,sx,sy>>1,8,width,height>>1,
                    &imint,&jmint);

  /* predict upper half field from bottom field */
  if (nobot)
    db = 65536;
  else
    db = fullsearch(botorg,botref,mb,width<<1,
                    i,j,sx,sy>>1,8,width,height>>1,
                    &iminb,&jminb);

  /* select prediction for upper half field */
  if (dt<=db)
  {
    *d8p = dt; *imin8up = imint; *jmin8up = jmint; *sel8up = 0;
  }
  else
  {
    *d8p = db; *imin8up = iminb; *jmin8up = jminb; *sel8up = 1;
  }

  /* predict lower half field from top field */
  if (notop)
    dt = 65536;
  else
    dt = fullsearch(toporg,topref,mb+(width<<4),width<<1,
                    i,j+8,sx,sy>>1,8,width,height>>1,
                    &imint,&jmint);

  /* predict lower half field from bottom field */
  if (nobot)
    db = 65536;
  else
    db = fullsearch(botorg,botref,mb+(width<<4),width<<1,
                    i,j+8,sx,sy>>1,8,width,height>>1,
                    &iminb,&jminb);

  /* select prediction for lower half field */
  if (dt<=db)
  {
    *d8p += dt; *imin8lp = imint; *jmin8lp = jmint; *sel8lp = 0;
  }
  else
  {
    *d8p += db; *imin8lp = iminb; *jmin8lp = jminb; *sel8lp = 1;
  }
}

static void dpframe_estimate(ref,mb,i,j,iminf,jminf,
  iminp,jminp,imindmvp, jmindmvp, dmcp, vmcp)
unsigned char *ref, *mb;
int i,j;
int iminf[2][2], jminf[2][2];
int *iminp, *jminp;
int *imindmvp, *jmindmvp;
int *dmcp,*vmcp;
{
  int pref,ppred,delta_x,delta_y;
  int is,js,it,jt,ib,jb,it0,jt0,ib0,jb0;
  int imins,jmins,imint,jmint,iminb,jminb,imindmv,jmindmv;
  int vmc,local_dist;

  /* Calculate Dual Prime distortions for 9 delta candidates
   * for each of the four minimum field vectors
   * Note: only for P pictures!
   */

  /* initialize minimum dual prime distortion to large value */
  vmc = 1 << 30;

  for (pref=0; pref<2; pref++)
  {
    for (ppred=0; ppred<2; ppred++)
    {
      /* convert Cartesian absolute to relative motion vector
       * values (wrt current macroblock address (i,j)
       */
      is = iminf[pref][ppred] - (i<<1);
      js = jminf[pref][ppred] - (j<<1);

      if (pref!=ppred)
      {
        /* vertical field shift adjustment */
        if (ppred==0)
          js++;
        else
          js--;

        /* mvxs and mvys scaling*/
        is<<=1;
        js<<=1;
        if (topfirst == ppred)
        {
          /* second field: scale by 1/3 */
          is = (is>=0) ? (is+1)/3 : -((-is+1)/3);
          js = (js>=0) ? (js+1)/3 : -((-js+1)/3);
        }
        else
          continue;
      }

      /* vector for prediction from field of opposite 'parity' */
      if (topfirst)
      {
        /* vector for prediction of top field from bottom field */
        it0 = ((is+(is>0))>>1);
        jt0 = ((js+(js>0))>>1) - 1;

        /* vector for prediction of bottom field from top field */
        ib0 = ((3*is+(is>0))>>1);
        jb0 = ((3*js+(js>0))>>1) + 1;
      }
      else
      {
        /* vector for prediction of top field from bottom field */
        it0 = ((3*is+(is>0))>>1);
        jt0 = ((3*js+(js>0))>>1) - 1;

        /* vector for prediction of bottom field from top field */
        ib0 = ((is+(is>0))>>1);
        jb0 = ((js+(js>0))>>1) + 1;
      }

      /* convert back to absolute half-pel field picture coordinates */
      is += i<<1;
      js += j<<1;
      it0 += i<<1;
      jt0 += j<<1;
      ib0 += i<<1;
      jb0 += j<<1;

      if (is >= 0 && is <= (width-16)<<1 &&
          js >= 0 && js <= (height-16))
      {
        for (delta_y=-1; delta_y<=1; delta_y++)
        {
          for (delta_x=-1; delta_x<=1; delta_x++)
          {
            /* opposite field coordinates */
            it = it0 + delta_x;
            jt = jt0 + delta_y;
            ib = ib0 + delta_x;
            jb = jb0 + delta_y;

            if (it >= 0 && it <= (width-16)<<1 &&
                jt >= 0 && jt <= (height-16) &&
                ib >= 0 && ib <= (width-16)<<1 &&
                jb >= 0 && jb <= (height-16))
            {
              /* compute prediction error */
              local_dist = bdist2(
                ref + (is>>1) + (width<<1)*(js>>1),
                ref + width + (it>>1) + (width<<1)*(jt>>1),
                mb,             /* current mb location */
                width<<1,       /* adjacent line distance */
                is&1, js&1, it&1, jt&1, /* half-pel flags */
                8);             /* block height */
              local_dist += bdist2(
                ref + width + (is>>1) + (width<<1)*(js>>1),
                ref + (ib>>1) + (width<<1)*(jb>>1),
                mb + width,     /* current mb location */
                width<<1,       /* adjacent line distance */
                is&1, js&1, ib&1, jb&1, /* half-pel flags */
                8);             /* block height */

              /* update delta with least distortion vector */
              if (local_dist < vmc)
              {
                imins = is;
                jmins = js;
                imint = it;
                jmint = jt;
                iminb = ib;
                jminb = jb;
                imindmv = delta_x;
                jmindmv = delta_y;
                vmc = local_dist;
              }
            }
          }  /* end delta x loop */
        } /* end delta y loop */
      }
    }
  }

  /* Compute L1 error for decision purposes */
  local_dist = bdist1(
    ref + (imins>>1) + (width<<1)*(jmins>>1),
    ref + width + (imint>>1) + (width<<1)*(jmint>>1),
    mb,
    width<<1,
    imins&1, jmins&1, imint&1, jmint&1,
    8);
  local_dist += bdist1(
    ref + width + (imins>>1) + (width<<1)*(jmins>>1),
    ref + (iminb>>1) + (width<<1)*(jminb>>1),
    mb + width,
    width<<1,
    imins&1, jmins&1, iminb&1, jminb&1,
    8);

  *dmcp = local_dist;
  *iminp = imins;
  *jminp = jmins;
  *imindmvp = imindmv;
  *jmindmvp = jmindmv;
  *vmcp = vmc;
}

static void dpfield_estimate(topref,botref,mb,i,j,imins,jmins,
  imindmvp, jmindmvp, dmcp, vmcp)
unsigned char *topref, *botref, *mb;
int i,j;
int imins, jmins;
int *imindmvp, *jmindmvp;
int *dmcp,*vmcp;
{
  unsigned char *sameref, *oppref;
  int io0,jo0,io,jo,delta_x,delta_y,mvxs,mvys,mvxo0,mvyo0;
  int imino,jmino,imindmv,jmindmv,vmc_dp,local_dist;

  /* Calculate Dual Prime distortions for 9 delta candidates */
  /* Note: only for P pictures! */

  /* Assign opposite and same reference pointer */
  if (pict_struct==TOP_FIELD)
  {
    sameref = topref;    
    oppref = botref;
  }
  else 
  {
    sameref = botref;
    oppref = topref;
  }

  /* convert Cartesian absolute to relative motion vector
   * values (wrt current macroblock address (i,j)
   */
  mvxs = imins - (i<<1);
  mvys = jmins - (j<<1);

  /* vector for prediction from field of opposite 'parity' */
  mvxo0 = (mvxs+(mvxs>0)) >> 1;  /* mvxs // 2 */
  mvyo0 = (mvys+(mvys>0)) >> 1;  /* mvys // 2 */

  /* vertical field shift correction */
  if (pict_struct==TOP_FIELD)
    mvyo0--;
  else
    mvyo0++;

  /* convert back to absolute coordinates */
  io0 = mvxo0 + (i<<1);
  jo0 = mvyo0 + (j<<1);

  /* initialize minimum dual prime distortion to large value */
  vmc_dp = 1 << 30;

  for (delta_y = -1; delta_y <= 1; delta_y++)
  {
    for (delta_x = -1; delta_x <=1; delta_x++)
    {
      /* opposite field coordinates */
      io = io0 + delta_x;
      jo = jo0 + delta_y;

      if (io >= 0 && io <= (width-16)<<1 &&
          jo >= 0 && jo <= (height2-16)<<1)
      {
        /* compute prediction error */
        local_dist = bdist2(
          sameref + (imins>>1) + width2*(jmins>>1),
          oppref  + (io>>1)    + width2*(jo>>1),
          mb,             /* current mb location */
          width2,         /* adjacent line distance */
          imins&1, jmins&1, io&1, jo&1, /* half-pel flags */
          16);            /* block height */

        /* update delta with least distortion vector */
        if (local_dist < vmc_dp)
        {
          imino = io;
          jmino = jo;
          imindmv = delta_x;
          jmindmv = delta_y;
          vmc_dp = local_dist;
        }
      }
    }  /* end delta x loop */
  } /* end delta y loop */

  /* Compute L1 error for decision purposes */
  *dmcp = bdist1(
    sameref + (imins>>1) + width2*(jmins>>1),
    oppref  + (imino>>1) + width2*(jmino>>1),
    mb,             /* current mb location */
    width2,         /* adjacent line distance */
    imins&1, jmins&1, imino&1, jmino&1, /* half-pel flags */
    16);            /* block height */

  *imindmvp = imindmv;
  *jmindmvp = jmindmv;
  *vmcp = vmc_dp;
}




/*
 * Three step block matching algorithm - though it is called "fullsearch"
 *
 * blk: top left pel of (16*h) block
 * h: height of block
 * lx: distance (in bytes) of vertically adjacent pels in ref,blk
 * org: top left pel of source reference picture
 * ref: top left pel of reconstructed reference picture
 * i0,j0: center of search window
 * sx,sy: half widths of search window
 * xmax,ymax: right/bottom limits of search area
 * iminp,jminp: pointers to where the result is stored
 *              result is given as half pel offset from ref(0,0)
 *              i.e. NOT relative to (i0,j0)
 */

/*

Search window in ref image:

                     2sx
(ilow,jlow)                          (ihigh,jlow)  
   | ------------------------------------|
   |                                     |
   |                                     |
   |                                     |
   |                                     |
   |               (i0,j0)               |
   |                                     | 2sy
   |                                     |
   |                                     |
   |                                     |
   |                                     |
   | ------------------------------------|(xmax, ymax)
(jhihg, ilow)                       (ihigh, jhigh)   

Block (stored at memory address blk)
| ------|
|       |
|       | h    
|       |     
| ------|

*/



static int fullsearch(org,ref,blk,lx,i0,j0,sx,sy,h,xmax,ymax,iminp,jminp)
     unsigned char *org,*ref,*blk;
     int lx,i0,j0,sx,sy,h,xmax,ymax;
     int *iminp,*jminp;
{
  int i,j,imin,jmin,ilow,ihigh,jlow,jhigh;
  int d,dmin;
  /* int sxy; not used */
  int p;

  /* STEP ONE: 
     search at the center of the reference image */

  imin = i0;
  jmin = j0;
  dmin = dist1(org+imin+lx*jmin, /* mem address of ref block */
	       blk,              /* mem address of macro block to be found */
	       lx,               /* distance (in bytes) of vertically adjacent pels */
	       0,                /* no horiz interpolation */ 
	       0,                /* no vertical interpolation */ 
	       h, 
	       65536);           /*  bail out if sum exceeds 65536 */


  /* now dmin contains the distance between block and the block
     in the center of the ref image */


  /*  sxy = (sx>sy) ? sx : sy;  -- not used */


  /* STEP TWO:
     If we did not find a good match at the center of 
     the reference image from the first step we do this step.
     We search starting at the end of the lower bottom
     of the reference frame to the upper right of the 
     reference frame, advancing FOUR PELS in each step */



  if (dmin > 64) {

    int w,z;
    int limitx, limity;
    

    /* calculate the low and upper pixels of the reference 
       image - ilow, jlow, ihigh, jhigh */
    
    ilow = i0 - sx;
    ihigh = i0 + sx;

    if (ilow<0)
      ilow = 0;

    if (ihigh>xmax-16)
      ihigh = xmax-16;

    jlow = j0 - sy;
    jhigh = j0 + sy;

    if (jlow<0)
      jlow = 0;

    if (jhigh>ymax-h)
      jhigh = ymax-h;


    limitx = (sx/4);
    limity= (sy/4);
    

    
    /* Now do the search around the center */

    for (w = -limitx; w<= limitx; w++)  {
  
      for( z = -limity; z<=limity; z++)
	{

	  i=i0+(4*w);
	  j=j0+(4*z);

	  if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	    {
	      d = dist1(org+i+lx*j, blk, lx, 0, 0, h, dmin);
	      if (d<dmin)
		{
		  imin=i;
		  jmin=j;
		  dmin=d;
		  
		}
	    }
	}
		  	  
    }  /* end for */




    /* STEP THREE:
       Search around the center: First we will start at a distance
       from center of 2 (p), then move to 1. So, do the following
       while-loop two times. Each iteration compares 8 blocks.
    */

    p = 2;
    i0 = imin;
    j0 = jmin;

    while(p>0) {

      i=i0-p;   /* 1: top left block */
      j=j0-p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0-p;   /* 2: bottom left */
      j=j0+p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0+p;  /* 3: top right */
      j=j0-p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0+p; /* 4: bottom right */
      j=j0+p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0+p; /* 5: center right */
      j=j0;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0;  /* 6: bottom center */
      j=j0-p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0-p;  /* 7: center left */
      j=j0;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
      i=i0;  /* 8: bottom center */
      j=j0+p;
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh)
	{
	  d = dist1(org+i+lx*j,blk,lx,0,0,h,dmin);
	  if (d<dmin)
	    {
	      imin=i;
	      jmin=j;
	      dmin=d;
	    }
	}
		   

      i0=imin;
      j0=jmin;
      p/=2;


    } /* end while */

  } /* if dmin > 64 */	
   


  /* HALF PEL:
     Now do half pel around the (imin, jmin) found from above
     steps to refine the motion vector further.
  */

  dmin = 65536;
  imin <<= 1;
  jmin <<= 1;
  ilow = imin - (imin>0);
  ihigh = imin + (imin<((xmax-16)<<1));
  jlow = jmin - (jmin>0);
  jhigh = jmin + (jmin<((ymax-h)<<1));

  for (j=jlow; j<=jhigh; j++) {
    for (i=ilow; i<=ihigh; i++) { 

      d = dist1(ref+(i>>1)+lx*(j>>1),blk,lx,i&1,j&1,h,dmin);

	if (d<dmin)
	  {
	    dmin = d;
	    imin = i;
	    jmin = j;
	  }
    }
  }


  /* Now store the motion vector at the corresponding 
     location */

  *iminp = imin;
  *jminp = jmin;
  
  return dmin;
}

#if 0
      __asm
	{
	  mov	  ebx,	[p1]	; /*load the address of p1 in ebx*/
	  mov	  edx,	[p2]	;/*  load the address of p2 in edx */
	  mov     eax,  [lx]    ;
	  mov     ecx,  [h]     ; /* loop counter */
	  pxor    xmm2, xmm2    ;
	  
	dist1_x0_y0:
	  movdqu  xmm0, [ebx]     ;/* load 16 pixels from p1 */
	  movdqu  xmm1, [edx]     ;/* load 16 pixels from p2 */
	  psadbw  xmm0, xmm1	;/* results are in [15:0] and [79:64] */
	  paddusw xmm2, xmm0    ; /* keep 2 partial sums */

	  add     ebx, eax      ;
	  add     edx, eax      ;
	  sub     ecx, 1        ;
	  cmp     ecx, 0        ;
	  jnz     dist1_x0_y0   ;

	  pshufd      xmm1, xmm2, 0xe  ; /* reduction */
	  paddd       xmm1, xmm2       ;
	  movd        [s],  xmm1       ;
	}
#endif

/*  

 * total absolute difference between two (16*h) blocks
 * including optional half pel interpolation of blk1 (hx,hy)
 * blk1,blk2: addresses of top left pels of both blocks
 * lx:        distance (in bytes) of vertically adjacent pels
 * hx,hy:     flags for horizontal and/or vertical interpolation
 * h:         height of block (usually 8 or 16)
 * distlim:   bail out if sum exceeds this value
 */

static int dist1(blk1,blk2,lx,hx,hy,h,distlim)
     unsigned char *blk1,*blk2;  /* blk1 ref, blk2 macroblock */
     int lx,hx,hy,h;
     int distlim;
{
  unsigned char *p1,*p1a,*p2;
  int i,j;

  int s;
  int v;
  int sa=0;

  if (!hx && !hy){


    s = 0;
    p1 = blk1;
    p2 = blk2;

#ifdef SSE2
      __asm
	{
	  mov	  ebx,	[p1]	; /*load the address of p1 in ebx*/
	  mov	  edx,	[p2]	;/*  load the address of p2 in edx */
	  mov     eax,  [lx]    ;
	  mov     ecx,  [h]     ; /* loop counter */
	  mov     esi, [distlim] ;
	  pxor    xmm3, xmm3    ;
	  movd    xmm3, esi     ;
	  pshufd  xmm3, xmm3, 0x44 ;
	  pxor    xmm2, xmm2    ;
	  
	dist1_x0_y0:
	  movdqu  xmm0, [ebx]     ;/* load 16 pixels from p1 */
	  movdqu  xmm1, [edx]     ;/* load 16 pixels from p2 */
	  psadbw  xmm0, xmm1	;/* results are in [15:0] and [79:64] */
	  paddusw xmm2, xmm0    ; /* keep 2 partial sums */

	  movdqa  xmm4, xmm2    ;
	  pcmpgtw xmm4, xmm3    ;
	  movd    esi, xmm4     ;
	  cmp     esi, 0xffffffff ;
	  je      dist1_branch_out    ;

	  add     ebx, eax      ;
	  add     edx, eax      ;
	  sub     ecx, 1        ;
	  cmp     ecx, 0        ;
	  jnz     dist1_x0_y0   ;
	dist1_branch_out:
	  pshufd      xmm1, xmm2, 0xe  ; /* reduction */
	  paddd       xmm1, xmm2       ;
	  movd        [s],  xmm1       ;
	}

#else
    for (j=0; j<h; j++) {
      for (i=0; i<16; i++) {
       	v = p1[i] - p2[i];
	s += (v >= 0) ? v : -v;
      }
      /*if (s >= distlim)
	break;*/
     
      p1+= lx;
      p2+= lx;
    }
#endif
    
    
  }



  else if (hx && !hy) {


       
    s = 0;         
    p1 = blk1;
    p2 = blk2;

#ifdef SSE2
    __asm
      {
	mov	eax,	[p1]			;
	mov	ebx,	[p2]			;
	mov     ecx,    [h]                     ;
	mov     edx,    [lx]                    ;
	pxor    xmm3, xmm3                      ; /*partial sums */

      dist1_x1_y0:
	movdqu	xmm0,	[eax]			;/*16 pixels of p1[i] in mm0*/
	movdqu	xmm1,	[eax+1]			;/*16 pixels of p1[i+1] in mm1*/
	movdqu	xmm2,	[ebx]			;/*16 pixels of p2[i] in mm2*/
	pavgb	xmm0,	xmm1			;/* xmm0 has the average of the 16 pixels*/
	psadbw	xmm0,	xmm2			;/* xmm0 has the abs diff of p1 half pel and p2*/
	paddd   xmm3, xmm0                      ;/*accumulate partial sums*/
	add     eax, edx       ;
	add     ebx, edx       ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz     dist1_x1_y0       ;

	pshufd      xmm1, xmm3, 0xe  ;
	paddd       xmm1, xmm3       ;
	movd        [s],  xmm1       ;
      }	
#else
    for (j=0; j<h; j++) {

     for (i=0; i<16; i++) {
       
	v = ((unsigned int)(p1[i]+p1[i+1]+1)>>1) - p2[i];
	if (v>=0)
	  s+= v;
	else
          s-= v;
      }

      p1+= lx; 
      p2+= lx;
     



    } /* end of outer foor loop */
#endif
  }




  else if (!hx && hy) {

    s = 0;
    p1 = blk1;
    p2 = blk2;
    p1a = p1 + lx;
   

#ifdef SSE2
    __asm
      {	
	mov	eax,	[p1]	;
	mov	ebx,	[p1a]	;
	mov	edx,	[p2]	;
	mov     esi,    [lx]    ;
	mov     ecx,  [h]   ;
	pxor    xmm3,   xmm3    ; /*running sums */

      dist1_x0_y1:
	movdqu	xmm0,	[eax]	;/*16 pixels of p1 in xmm0*/
	movdqu	xmm1,	[ebx]	;/*16 pixels of p1a in xmm1*/
	movdqu	xmm2,	[edx]	;/*16 pixels of p2 in xmm2*/
	pavgb	xmm0,	xmm1	;/* xmm0 has the average of the 16 pixels btwn p1 & p1a*/
	psadbw	xmm0,	xmm2	;/* xmm0 has the abs diff of p1 half pel and p2*/
	paddd   xmm3, xmm0    ;
	mov     eax, ebx      ;
	add     ebx, esi      ;
	add     edx, esi      ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz dist1_x0_y1

	pshufd      xmm1, xmm3, 0xe  ;
	paddd       xmm1, xmm3       ;
	movd        [s],  xmm1       ;
      }
#else
    for (j=0; j<h; j++) {

	for (i=0; i<16; i++) {
	  
	    v = ((unsigned int)(p1[i]+p1a[i]+1)>>1) - p2[i];
	    if (v>=0)
	      s+= v;
	    else
	      s-= v;
	    
	} /* end of inner for */

	p1 = p1a;
	p1a+= lx;
	p2+= lx;


    } /* end of outer for */
#endif
    
  }




  else {  /* if (hx && hy) */
  

    s = 0;
    p1 = blk1;
    p2 = blk2;
    p1a = p1 + lx;

#ifdef SSE2

    __asm
      {
	mov	eax,	[p1]			;
	mov	ebx,	[p1a]			;
	mov	edx,	[p2]            ;
	mov     ecx,    [h]             ;
	mov     esi,    [lx]            ;
	pxor    xmm5, xmm5              ;
      dist1_x1_y1:
	movdqu	xmm0,	[eax]			;/*	16 pixels of p1[i] in xmm0*/
	movdqu	xmm1,	[eax+1]			;/*	16 pixels of p1[i+1] in xmm1*/
	movdqu	xmm2,	[ebx]			;/*	16 pixels of p1a[i] in xmm2*/
	movdqu	xmm3,	[ebx+1]			;/*	16 pixels of p1a[i+1] in xmm3*/
	movdqu	xmm4,	[edx]			;/*	16 pixels of p2[i] in xmm4*/
	pavgb	xmm0,	xmm1			;/* xmm0 has the average of the 16 pixels btwn p1[i] & p1[i+1]*/
	pavgb	xmm2,	xmm3			;/* xmm2 has the avg of the 16 pels btwn btwn p1a[i] & p1a[i+1]*/
	pavgb	xmm0,	xmm2			;/* xmm0 has the avg of all 4*/
	psadbw	xmm0,	xmm4			;/* xmm0 has the abs diff*/
	paddd   xmm5, xmm0    ;
	mov     eax, ebx      ;
	add     ebx, esi      ;
	add     edx, esi      ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz dist1_x1_y1      ;

	pshufd      xmm1, xmm5, 0xe  ;
	paddd       xmm1, xmm5       ;
	movd        [s],  xmm1       ;
      }
#else

    for (j=0; j<h; j++) {
      for (i=0; i<16; i++) {
        v = ((unsigned int)(p1[i]+p1[i+1]+p1a[i]+p1a[i+1]+2)>>2) - p2[i];
        if (v>=0)
          s+= v;
        else
          s-= v;
      }
      p1 = p1a;
      p1a+= lx;
      p2+= lx;

    } /* end of outer for */
#endif
  }

  return s;
}



#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))




/*
 * total squared difference between two (16*h) blocks
 * including optional half pel interpolation of blk1 (hx,hy)
 * blk1,blk2: addresses of top left pels of both blocks
 * lx:        distance (in bytes) of vertically adjacent pels
 * hx,hy:     flags for horizontal and/or vertical interpolation
 * h:         height of block (usually 8 or 16)
 */
static int dist2(blk1,blk2,lx,hx,hy,h)
     unsigned char *blk1,*blk2;  /* blk1 ref, blk2 macroblock */
     int lx,hx,hy,h;
{
  unsigned char *p1,*p1a,*p2;
  int i,j;

  int s;
  int v;
  int sa=0;


  if (!hx && !hy){

    s = 0;
    p1 = blk1;
    p2 = blk2;

#ifdef SSE2

      __asm
	{	   
	  mov		ebx,	[p1]	; /*load the address of p1 in ecx */
	  mov		edx,	[p2]	; /*load the address of p2 in edx*/
	  mov           ecx,    [h]     ; /*load loop counter */
	  mov           eax,    [lx]    ;
	  pxor	       xmm6, xmm6    ; /*initialize it to zero*/
	  pxor	       xmm4, xmm4    ; /*running sum: initialize it to zero*/

	dist2_x0_y0:
	  movdqu       xmm0, [ebx]     ; /*load 16 pixels from p1*/
	  movdqu       xmm1, [edx]     ; /*load 16 pixels from p2*/
	  movdqa       xmm2, xmm0    ; /*make a copy of p1 in xmm2*/
	  psubusb      xmm0, xmm1    ; /*p1 - p2*/
	  psubusb      xmm1, xmm2    ; /*p2 - p1*/
	  por	       xmm0, xmm1    ; /*xmm0 has the absolute diff for the 16 pixels*/
	  movdqa	xmm3, xmm0    ; /*make a copy of the result*/
	  punpcklbw     xmm0, xmm6  ; /*unpack bytes to words*/
	  punpckhbw    xmm3, xmm6  ;
	  pmaddwd	xmm0,	xmm0		; /*xmm0 contains 4 double words d1*d1+d2*d2, d3*d3+d4*d4, ..., d6*d6+d7*d7*/
	  pmaddwd       xmm3,	xmm3		; /*xmm3 contains 4 double words d8*d8+d9*d9, ..., d14*d14+d15*d15*/
	  paddd	        xmm0,	xmm3		; /*add double words*/
	  paddd         xmm4,   xmm0            ; /* accumulate */
	  add           ebx, eax       ;
	  add           edx, eax       ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	  jnz          dist2_x0_y0    ;

	  pshufd        xmm0, xmm4, 0xe  ;
	  paddd         xmm4, xmm0      ; /* contains 2 32-bit words */
	  pshuflw        xmm0, xmm4, 0xe ;
	  paddd         xmm4, xmm0      ; /* contains 1 32-bit words */
	  movd          [s], xmm4       ;
	}
#else
    for (j=0; j<h; j++) {
      for (i=0; i<16; i++) {
       	v = p1[i] - p2[i];
	s += v*v;
      }

      p1+= lx;
      p2+= lx;
    }
#endif
  }



  else if (hx && !hy) {

    s = 0;
    p1 = blk1;
    p2 = blk2;

#ifdef SSE2
    __asm
      {
	mov     eax,	[p1]	;
	mov	ebx,	[p2]	;
	mov     ecx,    [h]     ;       
	mov     edx,    [lx]    ;
	pxor	xmm6,	xmm6		;/*initialize xmm6 to zero*/
	pxor	xmm4,	xmm4		;/*initialize xmm6 to zero*/
	
      dist2_x1_y0:
	movdqu	xmm0,	[eax]		;/* 16 pixels of p1[i] in mm0*/
	movdqu	xmm1,	[eax+1]	        ;/*	16 pixels of p1[i+1] in mm1*/
        movdqu	xmm2,	[ebx]		;/*	16 pixels of p2[i] in mm2*/
	pavgb	xmm0,	xmm1            ;/**/
	movdqa	xmm1,	xmm0		;/*p1[i]/2 + p1[i+1]/2 in xmm1*/
	psubusb	xmm0,	xmm2		;/*xmm0 = positive values of p1[i]/2 + p1[i+1]/2 - p2[i], else = 0*/
	psubusb	xmm2,	xmm1		;/*xmm2 = positive values of p2[i] - {p1[i]/2 + p1[i+1]/2} else = 0*/
	por	xmm0,	xmm2		;/*xmm0 contains the absolute difference for 16 pels*/
	movdqa	xmm3,	xmm0		;/*xmm1 contains the absolute difference for 16 pels*/
	punpcklbw	xmm0,	xmm6	;/*unpack low part from byte to word */
	punpckhbw	xmm3,	xmm6	;/*unpack high part from byte to word */
	pmaddwd	xmm0,	xmm0		;/* xmm0 contains 4 double words d1*d1+d2*d2, d3*d3+d4*d4, ..., d6*d6+d7*d7*/
	pmaddwd xmm3,	xmm3		;/* xmm3 contains 4 double words d8*d8+d9*d9, ..., d14*d14+d15*d15*/
	paddd	xmm0,	xmm3		;/* add double words*/
	paddd   xmm4,   xmm0            ;/* running partial sums */
	add     eax, edx                ;
	add     ebx, edx                ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz dist2_x1_y0                ;

	pshufd        xmm0, xmm4, 0xe  ;
	paddd         xmm4, xmm0      ; /* contains 2 32-bit words */
	pshuflw        xmm0, xmm4, 0xe ;
	paddd         xmm4, xmm0      ; /* contains 1 32-bit words */
	movd          [s], xmm4       ;
      }
#else

    for (j=0; j<h; j++) {

      for (i=0; i<16; i++) {
       
	v = ((unsigned int)(p1[i]+p1[i+1]+1)>>1) - p2[i];
	s += v*v;

      }

      p1+= lx;
      p2+= lx;
     
    } /* end of outer foor loop */
#endif
  }


  else if (!hx && hy) {


    s = 0;
    p1 = blk1;
    p2 = blk2;
    p1a = p1 + lx;
#ifdef SSE2
    __asm
      {			
	mov	eax,	[p1]	;
	mov	ebx,	[p1a]	;
	mov	edx,	[p2]	;
	mov     ecx,    [h]     ;
	mov     esi,    [lx]    ;
	pxor	xmm6,	xmm6		;/*	initialize xmm6 to zero*/
	pxor	xmm4,	xmm4		;/*running sum:initialize xmm4 to zero*/

      dist2_x0_y1:
	movdqu	xmm0,	[eax]		;/*	16 pixels of p1[i] in mm0*/
	movdqu	xmm1,	[ebx]		;/*	16 pixels of p1a[i] in mm1*/
	movdqu	xmm2,	[edx]		;/*	16 pixels of p2[i] in mm2*/
	pavgb	xmm0,	xmm1            ;
	movdqa	xmm1,	xmm0		;/*	p1[i]/2 + p1a[i]/2 in xmm1*/
	psubusb	xmm0,	xmm2		;/*	xmm0 = positive values of p1[i]/2 + p1a[i]/2 - p2[i], else = 0*/
	psubusb	xmm2,	xmm1		;/*	xmm2 = positive values of p2[i] - {p1[i]/2 + p1a[i]/2} else = 0*/
	por	xmm0,	xmm2		;/*	xmm0 contains the absolute difference for 16 pels*/
	movdqa	xmm3,	xmm0		;/*	xmm1 contains the absolute difference for 16 pels*/
	punpcklbw	xmm0,	xmm6	;/*	unpack low part from byte to word */
	punpckhbw	xmm3,	xmm6	;/*	unpack high part from byte to word */
	pmaddwd	xmm0,	xmm0		;/* xmm0 contains 4 double words d1*d1+d2*d2, d3*d3+d4*d4, ..., d6*d6+d7*d7*/
	pmaddwd xmm3,	xmm3		;/* xmm3 contains 4 double words d8*d8+d9*d9, ..., d14*d14+d15*d15*/
	paddd	xmm0,	xmm3		;/* add double words*/
	paddd   xmm4,   xmm0            ;
	add     eax, esi                ;
	add     ebx, esi                ;
	add     edx, esi                ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz dist2_x0_y1                ;

	pshufd      xmm0, xmm4, 0xe  ;
	paddd       xmm4, xmm0      ; /* contains 2 32-bit words */
	pshuflw     xmm0, xmm4, 0xe ;
	paddd       xmm4, xmm0      ; /* contains 1 32-bit words */
	movd        [s], xmm4       ;
      }
#else

    for (j=0; j<h; j++) {

	for (i=0; i<16; i++) {
	  
	    v = ((unsigned int)(p1[i]+p1a[i]+1)>>1) - p2[i];
	    s += v*v;


	} /* end of inner for */


	p1 = p1a;
	p1a+= lx;
	p2+= lx;



    } /* end of outer for */
#endif  
  }




  else {  /* if (hx && hy) */
  

    s = 0;
    p1 = blk1;
    p2 = blk2;
    p1a = p1 + lx;

#ifdef SSE2
    __asm
      {
	mov	eax,	[p1]	;
	mov	ebx,	[p1a]	;
	mov	edx,	[p2]    ;
	mov     ecx,    [h]     ;
	mov     esi,    [lx]    ;
	pxor	xmm6,	xmm6		;/*	initialize xmm6 to zero*/
	pxor	xmm5,	xmm5		;/*	initialize xmm5 to zero*/

      dist2_x1_y1:
	movdqu	xmm0,	[eax]		;/*	16 pixels of p1[i] in xmm0*/
	movdqu	xmm1,	[eax+1]		;/*	16 pixels of p1[i+1] in xmm1*/
	movdqu	xmm2,	[ebx]		;/*	16 pixels of p1a[i] in xmm2*/
	movdqu	xmm3,	[ebx+1]		;/*	16 pixels of p1a[i+1] in xmm3*/
	movdqu	xmm4,	[edx]		;/*	16 pixels of p2[i] in xmm4*/
	pavgb	xmm0,	xmm1            ;
	pavgb	xmm2,	xmm3  ;
	pavgb	xmm0,	xmm2  ;
	movdqa	xmm1,	xmm0		;/*	p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4 in xmm1*/
	psubusb	xmm0,	xmm4		;/*	xmm0 = positive values of p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4 - p2[i], else = 0*/
	psubusb	xmm4,	xmm1		;/*	xmm4 = positive values of p2[i] - {p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4} else = 0*/
	por	xmm0,	xmm4		;/*	xmm0 contains the absolute difference for 16 pixels*/
	movdqa	xmm1,	xmm0		;/*	xmm1 contains the absolute difference for 16 pels*/
	punpcklbw	xmm0,	xmm6	;/*	unpack low part from byte to word */
	punpckhbw	xmm1,	xmm6	;/*	unpack high part from byte to word */
	pmaddwd	xmm0,	xmm0		;/* xmm0 contains 4 double words d1*d1+d2*d2, d3*d3+d4*d4, ..., d6*d6+d7*d7*/
	pmaddwd xmm1,	xmm1		;/* xmm1 contains 4 double words d8*d8+d9*d9, ..., d14*d14+d15*d15*/
	paddd	xmm0,	xmm1		;/* add double words*/
	paddd   xmm5,   xmm0            ;
	add     eax, esi                ;
	add     ebx, esi                ;
	add     edx, esi                ;
	sub     ecx, 1        ;
	cmp     ecx, 0        ;
	jnz dist2_x1_y1              ;
	
	pshufd      xmm0, xmm5, 0xe  ; /* reduction */
	paddd       xmm5, xmm0      ; /* contains 2 32-bit words */
	pshuflw     xmm0, xmm5, 0xe ;
	paddd       xmm5, xmm0      ; /* contains 1 32-bit words */
	movd        [s], xmm5       ;
      }
#else
    for (j=0; j<h; j++) {

      for (i=0; i<16; i++) {
        v = ((unsigned int)(p1[i]+p1[i+1]+p1a[i]+p1a[i+1]+2)>>2) - p2[i];
        s += v*v;

      }


      p1 = p1a;
      p1a+= lx;
      p2+= lx;



    } /* end of outer for */
#endif
  }

  return s;
}

#include<assert.h>

/*
 * absolute difference error between a (16*h) block and a bidirectional
 * prediction
 *
 * p2: address of top left pel of block
 * pf,hxf,hyf: address and half pel flags of forward ref. block
 * pb,hxb,hyb: address and half pel flags of backward ref. block
 * h: height of block
 * lx: distance (in bytes) of vertically adjacent pels in p2,pf,pb
 */
static int bdist1(pf,pb,p2,lx,hxf,hyf,hxb,hyb,h)
unsigned char *pf,*pb,*p2;
int lx,hxf,hyf,hxb,hyb,h;
{
  unsigned char *pfa,*pfb,*pfc,*pba,*pbb,*pbc;
  int i,j;
  int s,v;
  int sa=0;

  pfa = pf + hxf;
  pfb = pf + lx*hyf;
  pfc = pfb + hxf;

  pba = pb + hxb;
  pbb = pb + lx*hyb;
  pbc = pbb + hxb;

  s = 0;

#ifdef SSE2
  __asm 
    {
      pxor xmm7, xmm7    ; /* initialize running sum */
    }
  
  for (j=0; j<h; j++) {
    __asm
      {
	mov	eax,	[pf]	;
	mov	ebx,	[pfa]	;
	mov	edx,	[pfb]    ;
	mov     edi,    [pfc]    ;
	mov     esi,    [p2]
	movdqu	xmm0,	[eax]		;
	movdqu	xmm1,	[ebx]		;
	movdqu	xmm2,	[edx]		;
	movdqu	xmm3,	[edi]		;
	mov	eax,	[pb]	;
	mov	ebx,	[pba]	;
	mov	edx,	[pbb]    ;
	mov     edi,    [pbc]    ;
	movdqu	xmm4,	[eax]		;
	movdqu	xmm5,	[ebx]		;
	movdqu	xmm6,	[edx]		;

	pavgb	xmm0,	xmm1            ; /* avg(pf,pfa) */
	movdqu	xmm1,	[edi]		;
	pavgb	xmm2,	xmm3            ; /* avg(pfb, pfc)*/
	movdqu	xmm3,	[esi]		; /* load p2 */
	pavgb   xmm0,   xmm2            ; /* avg(pf, pfa, pfb, pfc) */

	pavgb   xmm4,   xmm5            ; /* avg(pb, pba) */
	pavgb   xmm6,   xmm1            ; /* avg(pbb, pbc) */
	pavgb   xmm4,   xmm6            ; /* avg(pb, pba, pbb, pbc) */
	pavgb   xmm0,   xmm4            ; /* avg(pfx, pbx) */

	psadbw	xmm0,	xmm3	;/* xmm0 has the abs diff of p1 half pel and p2*/
	paddd   xmm7, xmm0      ;
      }
    p2+= lx-16;
    pf+= lx-16;
    pfa+= lx-16;
    pfb+= lx-16;
    pfc+= lx-16;
    pb+= lx-16;
    pba+= lx-16;
    pbb+= lx-16;
    pbc+= lx-16;
  }
  __asm 
    {
      pshufd      xmm1, xmm7, 0xe  ; /* reduction */
      paddd       xmm1, xmm7       ;
      movd        [s],  xmm1       ;
    }

#else
  for (j=0; j<h; j++)
  {

    for (i=0; i<16; i++)
    {
      v = ((((unsigned int)(*pf++ + *pfa++ + *pfb++ + *pfc++ + 2)>>2) +
            ((unsigned int)(*pb++ + *pba++ + *pbb++ + *pbc++ + 2)>>2) + 1)>>1)
           - *p2++;
      if (v>=0)
        s+= v;
      else
        s-= v;
    }
    p2+= lx-16;
    pf+= lx-16;
    pfa+= lx-16;
    pfb+= lx-16;
    pfc+= lx-16;
    pb+= lx-16;
    pba+= lx-16;
    pbb+= lx-16;
    pbc+= lx-16;
  }
#endif

  return s;
}







/*
 * squared error between a (16*h) block and a bidirectional
 * prediction
 *
 * p2: address of top left pel of block
 * pf,hxf,hyf: address and half pel flags of forward ref. block
 * pb,hxb,hyb: address and half pel flags of backward ref. block
 * h: height of block
 * lx: distance (in bytes) of vertically adjacent pels in p2,pf,pb
 */
static int bdist2(pf,pb,p2,lx,hxf,hyf,hxb,hyb,h)
unsigned char *pf,*pb,*p2;
int lx,hxf,hyf,hxb,hyb,h;
{
  unsigned char *pfa,*pfb,*pfc,*pba,*pbb,*pbc;
  int i,j;
  int s,v;
  int sa=0;

  pfa = pf + hxf;
  pfb = pf + lx*hyf;
  pfc = pfb + hxf;

  pba = pb + hxb;
  pbb = pb + lx*hyb;
  pbc = pbb + hxb;

#ifdef SSE2
  __asm 
    {
      pxor xmm7, xmm7    ; /* initialize running sum */
      pxor xmm6, xmm6    ; /* for unpacking */
    }
  
  for (j=0; j<h; j++) {
    __asm
      {
	mov	eax,	[pf]	;
	mov	ebx,	[pfa]	;
	mov	edx,	[pfb]    ;
	mov     edi,    [pfc]    ;
	mov     esi,    [p2]
	movdqu	xmm0,	[eax]		;
	movdqu	xmm1,	[ebx]		;
	movdqu	xmm2,	[edx]		;
	movdqu	xmm3,	[edi]		;
	mov	eax,	[pb]	;
	mov	ebx,	[pba]	;
	mov	edx,	[pbb]    ;
	mov     edi,    [pbc]    ;
	movdqu	xmm4,	[eax]		;
	movdqu	xmm5,	[ebx]		;

	pavgb	xmm0,	xmm1            ; /* avg(pf,pfa) */
	movdqu	xmm1,	[edi]		;
	pavgb	xmm2,	xmm3            ; /* avg(pfb, pfc)*/
	movdqu	xmm3,	[esi]		; /* load p2 */
	pavgb   xmm0,   xmm2            ; /* avg(pf, pfa, pfb, pfc) */
	movdqu	xmm2,	[edx]		;

	pavgb   xmm4,   xmm5            ; /* avg(pb, pba) */
	pavgb   xmm2,   xmm1            ; /* avg(pbb, pbc) */
	pavgb   xmm4,   xmm2            ; /* avg(pb, pba, pbb, pbc) */
	pavgb   xmm0,   xmm4            ; /* avg(pfx, pbx) */

	movdqa	xmm1,	xmm0		;/*	p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4 in xmm1*/
	psubusb	xmm0,	xmm3		;/*	xmm0 = positive values of p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4 - p2[i], else = 0*/
	psubusb	xmm3,	xmm1		;/*	xmm3 = positive values of p2[i] - {p1[i]/4 + p1[i+1]/4 + p1a[i]/4 + p1a[i+1]/4} else = 0*/
	por	xmm0,	xmm3		;/*	xmm0 contains the absolute difference for 16 pixels*/
	movdqa	xmm1,	xmm0		;/*	xmm1 contains the absolute difference for 16 pels*/
	punpcklbw	xmm0,	xmm6	;/*	unpack low part from byte to word */
	punpckhbw	xmm1,	xmm6	;/*	unpack high part from byte to word */
	pmaddwd	xmm0,	xmm0		;/* xmm0 contains 4 double words d1*d1+d2*d2, d3*d3+d4*d4, ..., d6*d6+d7*d7*/
	pmaddwd xmm1,	xmm1		;/* xmm1 contains 4 double words d8*d8+d9*d9, ..., d14*d14+d15*d15*/
	paddd	xmm0,	xmm1		;/* add double words*/
	paddd   xmm7, xmm0      ;
      }
    p2+= lx-16;
    pf+= lx-16;
    pfa+= lx-16;
    pfb+= lx-16;
    pfc+= lx-16;
    pb+= lx-16;
    pba+= lx-16;
    pbb+= lx-16;
    pbc+= lx-16;
  }
  __asm 
    {
      pshufd      xmm0, xmm7, 0xe  ; /* reduction */
      paddd       xmm7, xmm0      ; /* contains 2 32-bit words */
      pshuflw     xmm0, xmm7, 0xe ;
      paddd       xmm7, xmm0      ; /* contains 1 32-bit words */
      movd        [s], xmm7       ;
    }
#else

  s = 0;

  for (j=0; j<h; j++)
  {
    for (i=0; i<16; i++)
    {
      v = ((((unsigned int)(*pf++ + *pfa++ + *pfb++ + *pfc++ + 2)>>2) +
            ((unsigned int)(*pb++ + *pba++ + *pbb++ + *pbc++ + 2)>>2) + 1)>>1)
          - *p2++;
      s+=v*v;
    }
    p2+= lx-16;
    pf+= lx-16;
    pfa+= lx-16;
    pfb+= lx-16;
    pfc+= lx-16;
    pb+= lx-16;
    pba+= lx-16;
    pbb+= lx-16;
    pbc+= lx-16;
  }
#endif



  return s;
}



  
/* variance of a (16*16) block, multiplied by 256
 * p:  address of top left pel of block
 * lx: distance (in bytes) of vertically adjacent pels
 */
static int variance(p,lx)
unsigned char *p;
int lx;
{
  int i,j;
  unsigned int v,s,s2;
  unsigned int sa, s2a;

  sa=s2a=0;
  s = s2 = 0;

#ifdef SSE2
  __asm
    {	    
      mov	eax,	[p]		;/* load the address of p1 in ecx*/
      mov       ecx,    16              ;
      mov       ebx,    [lx]            ;
      pxor	xmm6,	xmm6		;/* initialize xmm6 to zero*/
      pxor      xmm3,   xmm3            ;
      pxor      xmm4,   xmm4            ;

    variance_loop:
      movdqu	xmm0,	[eax]		;/* loads the 16 pixels from p : p[1]...p[16]*/

      movdqa	xmm1,	xmm0		;/* make a copy of xmm0*/
      movdqa	xmm2,	xmm0            ;
      psadbw	xmm2,	xmm6		;/* collapsing 16 bytes into two words      		        */
      paddd     xmm3,   xmm2            ;/* 2 32-bit running sums */

      punpckhbw	xmm0,	xmm6		;/* xmm0 : contains p[0] to p[7] in words*/
      punpcklbw	xmm1,	xmm6		;/* xmm1 : contains p[8] to p[15] in words*/
      pmaddwd	xmm0,	xmm0		;/* xmm0 contains 4 double words p[1]^2+p[2]^2, ..., p[6]^2+p[7]^2*/
      pmaddwd	xmm1,	xmm1		;/* xmm1 contains 4 double words p[8]^2+p[9]^2, ..., p[14]^2+p[15]^2*/
      paddd	xmm0,	xmm1		;/* add double words*/
      paddd     xmm4,   xmm0            ;/* 4 32-bit running sums */
      add       eax, ebx                ;
      sub     ecx, 1        ;
      cmp     ecx, 0        ;
      jnz variance_loop                ;

      pshufd      xmm1, xmm3, 0xe  ;
      paddd       xmm1, xmm3       ;
      movd        [s],  xmm1       ;
      pshufd      xmm0, xmm4, 0xe  ;
      paddd       xmm4, xmm0      ; /* contains 2 32-bit words */
      pshuflw     xmm0, xmm4, 0xe ;
      paddd       xmm4, xmm0      ; /* contains 1 32-bit words */
      movd        [s2], xmm4       ;
    }
#else
  for (j=0; j<16; j++) {

    for (i=0; i<16; i++) {
      v = *p++;
      s+= v;
      s2+= v*v;
    }

    p+= lx-16;
  }
#endif
  return s2 - (s*s)/256;
}





/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* mpeg2enc.c, main() and parameter file reading                            */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#define GLOBAL /* used by global.h */
#include "config.h"
#include "global.h"

/* private prototypes */
static void init _ANSI_ARGS_((void));
static void readparmfile _ANSI_ARGS_((char *fname));
static void readquantmat _ANSI_ARGS_((void));


int main(argc,argv)
int argc;
char *argv[];
{

#ifdef QUIET
  quiet = 1;
#else
 if(argc > 3 && strcmp(argv[3],"-q") == 0){
    quiet = 1;
    argc--;
  }
#endif

  if (argc!=3)
  {
    printf("\n%s, %s\n",version,author);
    printf("Usage: mpeg2encode in.par out.m2v\n");
    exit(0);
  }

  /* read parameter file */
  readparmfile(argv[1]);

  /* read quantization matrices */
  readquantmat();

  /* open output file */
  if (!(outfile=fopen(argv[2],"wb")))
  {
    sprintf(errortext,"Couldn't create output file %s",argv[2]);
    error(errortext);
  }

  init();
  QUANT_THRESHOLD = (mpeg1) ? 255 : 2047;

  putseq();

  fclose(outfile);
  fclose(statfile);

  return 0;
}

static void init()
{
  int i, size;
  static int block_count_tab[3] = {6,8,12};

  initbits();
  init_fdct();
  init_idct();

  /* round picture dimensions to nearest multiple of 16 or 32 */
  mb_width = (horizontal_size+15)/16;
  mb_height = prog_seq ? (vertical_size+15)/16 : 2*((vertical_size+31)/32);
  mb_height2 = fieldpic ? mb_height>>1 : mb_height; /* for field pictures */
  width = 16*mb_width;
  height = 16*mb_height;

  chrom_width = (chroma_format==CHROMA444) ? width : width>>1;
  chrom_height = (chroma_format!=CHROMA420) ? height : height>>1;

  height2 = fieldpic ? height>>1 : height;
  width2 = fieldpic ? width<<1 : width;
  chrom_width2 = fieldpic ? chrom_width<<1 : chrom_width;
  
  block_count = block_count_tab[chroma_format-1];

  /* clip table */
  if (!(clp = (unsigned char *)malloc(1024)))
    error("malloc failed\n");
  clp+= 384;
  for (i=-384; i<640; i++)
    clp[i] = (i<0) ? 0 : ((i>255) ? 255 : i);

  for (i=0; i<3; i++)
  {
    size = (i==0) ? width*height : chrom_width*chrom_height;

    if (!(newrefframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(oldrefframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(auxframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(neworgframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(oldorgframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(auxorgframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
    if (!(predframe[i] = (unsigned char *)malloc(size)))
      error("malloc failed\n");
  }

  mbinfo = (struct mbinfo *)malloc(mb_width*mb_height2*sizeof(struct mbinfo));

  if (!mbinfo)
    error("malloc failed\n");

#if 1
  blocks =
    (short (*)[64])_mm_malloc(mb_width*mb_height2*block_count*sizeof(short [64]),16);
#else
  blocks =
    (short (*)[64])malloc(mb_width*mb_height2*block_count*sizeof(short [64]));
#endif

  if (!blocks)
    error("malloc failed\n");
  /* open statistics output file */
  if (statname[0]=='-')
    statfile = stdout;
  else if (!(statfile = fopen(statname,"w")))
  {
    sprintf(errortext,"Couldn't create statistics output file %s",statname);
    error(errortext);
  }
}

void error(text)
char *text;
{
  fprintf(stderr,text);
  fputc('\n',stderr);
  exit(1);
}

static void readparmfile(fname)
char *fname;
{
  int i;
  int h,m,s,f;
  FILE *fd;
  char line[256];
  static double ratetab[8]=
    {24000.0/1001.0,24.0,25.0,30000.0/1001.0,30.0,50.0,60000.0/1001.0,60.0};
  extern int r,Xi,Xb,Xp,d0i,d0p,d0b; /* rate control */
  extern double avg_act; /* rate control */

  if (!(fd = fopen(fname,"r")))
  {
    sprintf(errortext,"Couldn't open parameter file %s",fname);
    error(errortext);
  }

  fgets(id_string,254,fd);
  fgets(line,254,fd); sscanf(line,"%s",tplorg);
  fgets(line,254,fd); sscanf(line,"%s",tplref);
  fgets(line,254,fd); sscanf(line,"%s",iqname);
  fgets(line,254,fd); sscanf(line,"%s",niqname);
  fgets(line,254,fd); sscanf(line,"%s",statname);
  fgets(line,254,fd); sscanf(line,"%d",&inputtype);
  fgets(line,254,fd); sscanf(line,"%d",&nframes);
  fgets(line,254,fd); sscanf(line,"%d",&frame0);
  fgets(line,254,fd); sscanf(line,"%d:%d:%d:%d",&h,&m,&s,&f);
  fgets(line,254,fd); sscanf(line,"%d",&N);
  fgets(line,254,fd); sscanf(line,"%d",&M);
  fgets(line,254,fd); sscanf(line,"%d",&mpeg1);
  fgets(line,254,fd); sscanf(line,"%d",&fieldpic);
  fgets(line,254,fd); sscanf(line,"%d",&horizontal_size);
  fgets(line,254,fd); sscanf(line,"%d",&vertical_size);
  fgets(line,254,fd); sscanf(line,"%d",&aspectratio);
  fgets(line,254,fd); sscanf(line,"%d",&frame_rate_code);
  fgets(line,254,fd); sscanf(line,"%lf",&bit_rate);
  fgets(line,254,fd); sscanf(line,"%d",&vbv_buffer_size);   
  fgets(line,254,fd); sscanf(line,"%d",&low_delay);     
  fgets(line,254,fd); sscanf(line,"%d",&constrparms);
  fgets(line,254,fd); sscanf(line,"%d",&profile);
  fgets(line,254,fd); sscanf(line,"%d",&level);
  fgets(line,254,fd); sscanf(line,"%d",&prog_seq);
  fgets(line,254,fd); sscanf(line,"%d",&chroma_format);
  fgets(line,254,fd); sscanf(line,"%d",&video_format);
  fgets(line,254,fd); sscanf(line,"%d",&color_primaries);
  fgets(line,254,fd); sscanf(line,"%d",&transfer_characteristics);
  fgets(line,254,fd); sscanf(line,"%d",&matrix_coefficients);
  fgets(line,254,fd); sscanf(line,"%d",&display_horizontal_size);
  fgets(line,254,fd); sscanf(line,"%d",&display_vertical_size);
  fgets(line,254,fd); sscanf(line,"%d",&dc_prec);
  fgets(line,254,fd); sscanf(line,"%d",&topfirst);
  fgets(line,254,fd); sscanf(line,"%d %d %d",
    frame_pred_dct_tab,frame_pred_dct_tab+1,frame_pred_dct_tab+2);
  
  fgets(line,254,fd); sscanf(line,"%d %d %d",
    conceal_tab,conceal_tab+1,conceal_tab+2);
  
  fgets(line,254,fd); sscanf(line,"%d %d %d",
    qscale_tab,qscale_tab+1,qscale_tab+2);

  fgets(line,254,fd); sscanf(line,"%d %d %d",
    intravlc_tab,intravlc_tab+1,intravlc_tab+2);
  fgets(line,254,fd); sscanf(line,"%d %d %d",
    altscan_tab,altscan_tab+1,altscan_tab+2);
  fgets(line,254,fd); sscanf(line,"%d",&repeatfirst);
  fgets(line,254,fd); sscanf(line,"%d",&prog_frame);
/* intra slice interval refresh period */  
  fgets(line,254,fd); sscanf(line,"%d",&P);
  fgets(line,254,fd); sscanf(line,"%d",&r);
  fgets(line,254,fd); sscanf(line,"%lf",&avg_act);
  fgets(line,254,fd); sscanf(line,"%d",&Xi);
  fgets(line,254,fd); sscanf(line,"%d",&Xp);
  fgets(line,254,fd); sscanf(line,"%d",&Xb);
  fgets(line,254,fd); sscanf(line,"%d",&d0i);
  fgets(line,254,fd); sscanf(line,"%d",&d0p);
  fgets(line,254,fd); sscanf(line,"%d",&d0b);

  if (N<1)
    error("N must be positive");
  if (M<1)
    error("M must be positive");
  if (N%M != 0)
    error("N must be an integer multiple of M");

  motion_data = (struct motion_data *)malloc(M*sizeof(struct motion_data));
  if (!motion_data)
    error("malloc failed\n");

  for (i=0; i<M; i++)
  {
    fgets(line,254,fd);
    sscanf(line,"%d %d %d %d",
      &motion_data[i].forw_hor_f_code, &motion_data[i].forw_vert_f_code,
      &motion_data[i].sxf, &motion_data[i].syf);

    if (i!=0)
    {
      fgets(line,254,fd);
      sscanf(line,"%d %d %d %d",
        &motion_data[i].back_hor_f_code, &motion_data[i].back_vert_f_code,
        &motion_data[i].sxb, &motion_data[i].syb);
    }
  }

  fclose(fd);

  /* make flags boolean (x!=0 -> x=1) */
  mpeg1 = !!mpeg1;
  fieldpic = !!fieldpic;
  low_delay = !!low_delay;
  constrparms = !!constrparms;
  prog_seq = !!prog_seq;
  topfirst = !!topfirst;

  for (i=0; i<3; i++)
  {
    frame_pred_dct_tab[i] = !!frame_pred_dct_tab[i];
    conceal_tab[i] = !!conceal_tab[i];
    qscale_tab[i] = !!qscale_tab[i];
    intravlc_tab[i] = !!intravlc_tab[i];
    altscan_tab[i] = !!altscan_tab[i];
  }
  repeatfirst = !!repeatfirst;
  prog_frame = !!prog_frame;

  /* make sure MPEG specific parameters are valid */
  range_checks();

  frame_rate = ratetab[frame_rate_code-1];

  /* timecode -> frame number */
  tc0 = h;
  tc0 = 60*tc0 + m;
  tc0 = 60*tc0 + s;
  tc0 = (int)(frame_rate+0.5)*tc0 + f;

  if (!mpeg1)
  {
    profile_and_level_checks();
  }
  else
  {
    /* MPEG-1 */
    if (constrparms)
    {
      if (horizontal_size>768
          || vertical_size>576
          || ((horizontal_size+15)/16)*((vertical_size+15)/16)>396
          || ((horizontal_size+15)/16)*((vertical_size+15)/16)*frame_rate>396*25.0
          || frame_rate>30.0)
      {
        if (!quiet)
          fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
        constrparms = 0;
      }
    }

    if (constrparms)
    {
      for (i=0; i<M; i++)
      {
        if (motion_data[i].forw_hor_f_code>4)
        {
          if (!quiet)
            fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
          constrparms = 0;
          break;
        }

        if (motion_data[i].forw_vert_f_code>4)
        {
          if (!quiet)
            fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
          constrparms = 0;
          break;
        }

        if (i!=0)
        {
          if (motion_data[i].back_hor_f_code>4)
          {
            if (!quiet)
              fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
            constrparms = 0;
            break;
          }

          if (motion_data[i].back_vert_f_code>4)
          {
            if (!quiet)
              fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
            constrparms = 0;
            break;
          }
        }
      }
    }
  }

  /* relational checks */

  if (mpeg1)
  {
    if (!prog_seq)
    {
      if (!quiet)
        fprintf(stderr,"Warning: setting progressive_sequence = 1\n");
      prog_seq = 1;
    }

    if (chroma_format!=CHROMA420)
    {
      if (!quiet)
        fprintf(stderr,"Warning: setting chroma_format = 1 (4:2:0)\n");
      chroma_format = CHROMA420;
    }

    if (dc_prec!=0)
    {
      if (!quiet)
        fprintf(stderr,"Warning: setting intra_dc_precision = 0\n");
      dc_prec = 0;
    }

    for (i=0; i<3; i++)
      if (qscale_tab[i])
      {
        if (!quiet)
          fprintf(stderr,"Warning: setting qscale_tab[%d] = 0\n",i);
        qscale_tab[i] = 0;
      }

    for (i=0; i<3; i++)
      if (intravlc_tab[i])
      {
        if (!quiet)
          fprintf(stderr,"Warning: setting intravlc_tab[%d] = 0\n",i);
        intravlc_tab[i] = 0;
      }

    for (i=0; i<3; i++)
      if (altscan_tab[i])
      {
        if (!quiet)
          fprintf(stderr,"Warning: setting altscan_tab[%d] = 0\n",i);
        altscan_tab[i] = 0;
      }
  }

  if (!mpeg1 && constrparms)
  {
    if (!quiet)
      fprintf(stderr,"Warning: setting constrained_parameters_flag = 0\n");
    constrparms = 0;
  }

  if (prog_seq && !prog_frame)
  {
    if (!quiet)
      fprintf(stderr,"Warning: setting progressive_frame = 1\n");
    prog_frame = 1;
  }

  if (prog_frame && fieldpic)
  {
    if (!quiet)
      fprintf(stderr,"Warning: setting field_pictures = 0\n");
    fieldpic = 0;
  }

  if (!prog_frame && repeatfirst)
  {
    if (!quiet)
      fprintf(stderr,"Warning: setting repeat_first_field = 0\n");
    repeatfirst = 0;
  }

  if (prog_frame)
  {
    for (i=0; i<3; i++)
      if (!frame_pred_dct_tab[i])
      {
        if (!quiet)
          fprintf(stderr,"Warning: setting frame_pred_frame_dct[%d] = 1\n",i);
        frame_pred_dct_tab[i] = 1;
      }
  }

  if (prog_seq && !repeatfirst && topfirst)
  {
    if (!quiet)
      fprintf(stderr,"Warning: setting top_field_first = 0\n");
    topfirst = 0;
  }

  /* search windows */
  for (i=0; i<M; i++)
  {
    if (motion_data[i].sxf > (4<<motion_data[i].forw_hor_f_code)-1)
    {
      if (!quiet)
        fprintf(stderr,
          "Warning: reducing forward horizontal search width to %d\n",
          (4<<motion_data[i].forw_hor_f_code)-1);
      motion_data[i].sxf = (4<<motion_data[i].forw_hor_f_code)-1;
    }

    if (motion_data[i].syf > (4<<motion_data[i].forw_vert_f_code)-1)
    {
      if (!quiet)
        fprintf(stderr,
          "Warning: reducing forward vertical search width to %d\n",
          (4<<motion_data[i].forw_vert_f_code)-1);
      motion_data[i].syf = (4<<motion_data[i].forw_vert_f_code)-1;
    }

    if (i!=0)
    {
      if (motion_data[i].sxb > (4<<motion_data[i].back_hor_f_code)-1)
      {
        if (!quiet)
          fprintf(stderr,
            "Warning: reducing backward horizontal search width to %d\n",
            (4<<motion_data[i].back_hor_f_code)-1);
        motion_data[i].sxb = (4<<motion_data[i].back_hor_f_code)-1;
      }

      if (motion_data[i].syb > (4<<motion_data[i].back_vert_f_code)-1)
      {
        if (!quiet)
          fprintf(stderr,
            "Warning: reducing backward vertical search width to %d\n",
            (4<<motion_data[i].back_vert_f_code)-1);
        motion_data[i].syb = (4<<motion_data[i].back_vert_f_code)-1;
      }
    }
  }

}

static void readquantmat()
{
  int i,v;
  FILE *fd;

  if (iqname[0]=='-')
  {
    /* use default intra matrix */
    load_iquant = 0;
    for (i=0; i<64; i++)
      intra_q[i] = default_intra_quantizer_matrix[i];
  }
  else
  {
    /* read customized intra matrix */
    load_iquant = 1;
    if (!(fd = fopen(iqname,"r")))
    {
      sprintf(errortext,"Couldn't open quant matrix file %s",iqname);
      error(errortext);
    }

    for (i=0; i<64; i++)
    {
      fscanf(fd,"%d",&v);
      if (v<1 || v>255)
        error("invalid value in quant matrix");
      intra_q[i] = v;
    }

    fclose(fd);
  }

  if (niqname[0]=='-')
  {
    /* use default non-intra matrix */
    load_niquant = 0;
    for (i=0; i<64; i++)
      inter_q[i] = 16;
  }
  else
  {
    /* read customized non-intra matrix */
    load_niquant = 1;
    if (!(fd = fopen(niqname,"r")))
    {
      sprintf(errortext,"Couldn't open quant matrix file %s",niqname);
      error(errortext);
    }

    for (i=0; i<64; i++)
    {
      fscanf(fd,"%d",&v);
      if (v<1 || v>255)
        error("invalid value in quant matrix");
      inter_q[i] = v;
    }

    fclose(fd);
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* mpg2enc.h, defines and types                                             */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#define PICTURE_START_CODE 0x100L
#define SLICE_MIN_START    0x101L
#define SLICE_MAX_START    0x1AFL
#define USER_START_CODE    0x1B2L
#define SEQ_START_CODE     0x1B3L
#define EXT_START_CODE     0x1B5L
#define SEQ_END_CODE       0x1B7L
#define GOP_START_CODE     0x1B8L
#define ISO_END_CODE       0x1B9L
#define PACK_START_CODE    0x1BAL
#define SYSTEM_START_CODE  0x1BBL

/* picture coding type */
#define I_TYPE 1
#define P_TYPE 2
#define B_TYPE 3
#define D_TYPE 4

/* picture structure */
#define TOP_FIELD     1
#define BOTTOM_FIELD  2
#define FRAME_PICTURE 3

/* macroblock type */
#define MB_INTRA    1
#define MB_PATTERN  2
#define MB_BACKWARD 4
#define MB_FORWARD  8
#define MB_QUANT    16

/* motion_type */
#define MC_FIELD 1
#define MC_FRAME 2
#define MC_16X8  2
#define MC_DMV   3

/* mv_format */
#define MV_FIELD 0
#define MV_FRAME 1

/* chroma_format */
#define CHROMA420 1
#define CHROMA422 2
#define CHROMA444 3

/* extension start code IDs */

#define SEQ_ID       1
#define DISP_ID      2
#define QUANT_ID     3
#define SEQSCAL_ID   5
#define PANSCAN_ID   7
#define CODING_ID    8
#define SPATSCAL_ID  9
#define TEMPSCAL_ID 10

/* inputtype */
#define T_Y_U_V 0
#define T_YUV   1
#define T_PPM   2

/* macroblock information */
struct mbinfo {
  int mb_type; /* intra/forward/backward/interpolated */
  int motion_type; /* frame/field/16x8/dual_prime */
  int dct_type; /* field/frame DCT */
  int mquant; /* quantization parameter */
  int cbp; /* coded block pattern */
  int skipped; /* skipped macroblock */
  int MV[2][2][2]; /* motion vectors */
  int mv_field_sel[2][2]; /* motion vertical field select */
  int dmvector[2]; /* dual prime vectors */
  double act; /* activity measure */
  int var; /* for debugging */
};

/* motion data */
struct motion_data {
  int forw_hor_f_code,forw_vert_f_code; /* vector range */
  int sxf,syf; /* search range */
  int back_hor_f_code,back_vert_f_code;
  int sxb,syb;
};

#ifdef LTHREAD
/* struct ME_Args { */
/*   unsigned char *oldorg,*neworg,*oldref,*newref,*cur,*curref; */
/*   int sxf,syf,sxb,syb; */
/*   struct mbinfo *mbi; */
/*   int secondfield,ipflag; */
/* }; */

/* struct Pred_Args { */
/*   unsigned char **reff,**refb,**cur; */
/*   int secondfield; */
/*   struct mbinfo *mbi; */
/* }; */

/* struct DTE_Args { */
/*   unsigned char *pred,*cur; */
/*   struct mbinfo *mbi; */
/* }; */

/* struct Trfm_Args { */
/*   unsigned char **pred, **cur; */
/*   struct mbinfo *mbi; */
/*   short **blocks; */
/* }; */

/* struct IQunt_Args { */
/*   short **blk; */
/*   int dc_prec; */
/*   unsigned char *quant_mat; */
/*   int mquant; */
/* }; */

/* struct PPict_Args { */
/*   int prev_mquant; */
/*   unsigned char *frame; */
/* }; */

struct Data_Args {
  unsigned char *oldorg,*neworg,*oldref,*newref,*cur,*curref;
  int sxf,syf,sxb,syb;
  struct mbinfo *mbi;
  int secondfield,ipflag;
  
  unsigned char **reff, **refb, **pd_cur;
  unsigned char *pred,*dte_cur, **trfm_cur;
  short **blocks;
  int prev_mquant;

  unsigned char **itrfm_cur;
  
};

struct thread_data {
  struct ME_Args *me_ptr;
  struct Pred_Args *pd_ptr;
  struct DTE_Args *dte_ptr;
  struct Trfm_Args *trfm_ptr;
  struct IQunt_Args *iqt_ptr;
  struct Trfm_Args *itrfm_ptr;
  struct PPict_Args *pp_ptr;

  struct Data_Args *data_ptr;

  int s_height, e_height;
  int s_mbh, e_mbh, mode, id;
  int pp_smbh, pp_embh;
};

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* predict.c, motion compensated prediction                                 */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "config.h"
#include "global.h"

/* private prototypes */
static void predict_mb _ANSI_ARGS_((
  unsigned char *oldref[], unsigned char *newref[], unsigned char *cur[],
  int lx, int bx, int by, int pict_type, int pict_struct, int mb_type,
  int motion_type, int secondfield,
  int PMV[2][2][2], int mv_field_sel[2][2], int dmvector[2]));

static void pred _ANSI_ARGS_((unsigned char *src[], int sfield,
  unsigned char *dst[], int dfield,
  int lx, int w, int h, int x, int y, int dx, int dy, int addflag));

static void pred_comp _ANSI_ARGS_((unsigned char *src, unsigned char *dst,
  int lx, int w, int h, int x, int y, int dx, int dy, int addflag));

static void calc_DMV _ANSI_ARGS_((int DMV[][2], int *dmvector, int mvx,
  int mvy));

static void clearblock _ANSI_ARGS_((unsigned char *cur[], int i0, int j0));


/* form prediction for a complete picture (frontend for predict_mb)
 *
 * reff: reference frame for forward prediction
 * refb: reference frame for backward prediction
 * cur:  destination (current) frame
 * secondfield: predict second field of a frame
 * mbi:  macroblock info
 *
 * Notes:
 * - cf. predict_mb
 */

void predict(reff,refb,cur,secondfield,mbi)
unsigned char *reff[],*refb[],*cur[3];
int secondfield;
struct mbinfo *mbi;
{
  int i, j, k;

  k = 0;

  /* loop through all macroblocks of the picture */
  for (j=0; j<height2; j+=16)
    for (i=0; i<width; i+=16)
    {
      predict_mb(reff,refb,cur,width,i,j,pict_type,pict_struct,
                 mbi[k].mb_type,mbi[k].motion_type,secondfield,
                 mbi[k].MV,mbi[k].mv_field_sel,mbi[k].dmvector);

      k++;
    }
}

#ifdef LTHREAD
void ptpredict(reff,refb,cur,secondfield,mbi,start_height,end_height)
unsigned char *reff[],*refb[],*cur[3];
int secondfield;
struct mbinfo *mbi;
int start_height, end_height;
{
    int i, j, k;

    k = (start_height>>4)*(width>>4);
  /* loop through all macroblocks of the picture */
  for (j=start_height; j<end_height; j+=16)
    for (i=0; i<width; i+=16)
    {
      predict_mb(reff,refb,cur,width,i,j,pict_type,pict_struct,
                 mbi[k].mb_type,mbi[k].motion_type,secondfield,
                 mbi[k].MV,mbi[k].mv_field_sel,mbi[k].dmvector);

      k++;
    }
}
#endif

/* form prediction for one macroblock
 *
 * oldref: reference frame for forward prediction
 * newref: reference frame for backward prediction
 * cur:    destination (current) frame
 * lx:     frame width (identical to global var `width')
 * bx,by:  picture (field or frame) coordinates of macroblock to be predicted
 * pict_type: I, P or B
 * pict_struct: FRAME_PICTURE, TOP_FIELD, BOTTOM_FIELD
 * mb_type:     MB_FORWARD, MB_BACKWARD, MB_INTRA
 * motion_type: MC_FRAME, MC_FIELD, MC_16X8, MC_DMV
 * secondfield: predict second field of a frame
 * PMV[2][2][2]: motion vectors (in half pel picture coordinates)
 * mv_field_sel[2][2]: motion vertical field selects (for field predictions)
 * dmvector: differential motion vectors (for dual prime)
 *
 * Notes:
 * - when predicting a P type picture which is the second field of
 *   a frame, the same parity reference field is in oldref, while the
 *   opposite parity reference field is assumed to be in newref!
 * - intra macroblocks are modelled to have a constant prediction of 128
 *   for all pels; this results in a DC DCT coefficient symmetric to 0
 * - vectors for field prediction in frame pictures are in half pel frame
 *   coordinates (vertical component is twice the field value and always
 *   even)
 *
 * already covers dual prime (not yet used)
 */

static void predict_mb(oldref,newref,cur,lx,bx,by,pict_type,pict_struct,
  mb_type,motion_type,secondfield,PMV,mv_field_sel,dmvector)
unsigned char *oldref[],*newref[],*cur[];
int lx;
int bx,by;
int pict_type;
int pict_struct;
int mb_type;
int motion_type;
int secondfield;
int PMV[2][2][2], mv_field_sel[2][2], dmvector[2];
{
  int addflag, currentfield;
  unsigned char **predframe;
  int DMV[2][2];

  if (mb_type&MB_INTRA)
  {
    clearblock(cur,bx,by);
    return;
  }

  addflag = 0; /* first prediction is stored, second is added and averaged */

  if ((mb_type & MB_FORWARD) || (pict_type==P_TYPE))
  {
    /* forward prediction, including zero MV in P pictures */

    if (pict_struct==FRAME_PICTURE)
    {
      /* frame picture */

      if ((motion_type==MC_FRAME) || !(mb_type & MB_FORWARD))
      {
        /* frame-based prediction in frame picture */
        pred(oldref,0,cur,0,
          lx,16,16,bx,by,PMV[0][0][0],PMV[0][0][1],0);
      }
      else if (motion_type==MC_FIELD)
      {
        /* field-based prediction in frame picture
         *
         * note scaling of the vertical coordinates (by, PMV[][0][1])
         * from frame to field!
         */

        /* top field prediction */
        pred(oldref,mv_field_sel[0][0],cur,0,
          lx<<1,16,8,bx,by>>1,PMV[0][0][0],PMV[0][0][1]>>1,0);

        /* bottom field prediction */
        pred(oldref,mv_field_sel[1][0],cur,1,
          lx<<1,16,8,bx,by>>1,PMV[1][0][0],PMV[1][0][1]>>1,0);
      }
      else if (motion_type==MC_DMV)
      {
        /* dual prime prediction */

        /* calculate derived motion vectors */
        calc_DMV(DMV,dmvector,PMV[0][0][0],PMV[0][0][1]>>1);

        /* predict top field from top field */
        pred(oldref,0,cur,0,
          lx<<1,16,8,bx,by>>1,PMV[0][0][0],PMV[0][0][1]>>1,0);

        /* predict bottom field from bottom field */
        pred(oldref,1,cur,1,
          lx<<1,16,8,bx,by>>1,PMV[0][0][0],PMV[0][0][1]>>1,0);

        /* predict and add to top field from bottom field */
        pred(oldref,1,cur,0,
          lx<<1,16,8,bx,by>>1,DMV[0][0],DMV[0][1],1);

        /* predict and add to bottom field from top field */
        pred(oldref,0,cur,1,
          lx<<1,16,8,bx,by>>1,DMV[1][0],DMV[1][1],1);
      }
      else
      {
        /* invalid motion_type in frame picture */
        if (!quiet)
          fprintf(stderr,"invalid motion_type\n");
      }
    }
    else /* TOP_FIELD or BOTTOM_FIELD */
    {
      /* field picture */

      currentfield = (pict_struct==BOTTOM_FIELD);

      /* determine which frame to use for prediction */
      if ((pict_type==P_TYPE) && secondfield
          && (currentfield!=mv_field_sel[0][0]))
        predframe = newref; /* same frame */
      else
        predframe = oldref; /* previous frame */

      if ((motion_type==MC_FIELD) || !(mb_type & MB_FORWARD))
      {
        /* field-based prediction in field picture */
        pred(predframe,mv_field_sel[0][0],cur,currentfield,
          lx<<1,16,16,bx,by,PMV[0][0][0],PMV[0][0][1],0);
      }
      else if (motion_type==MC_16X8)
      {
        /* 16 x 8 motion compensation in field picture */

        /* upper half */
        pred(predframe,mv_field_sel[0][0],cur,currentfield,
          lx<<1,16,8,bx,by,PMV[0][0][0],PMV[0][0][1],0);

        /* determine which frame to use for lower half prediction */
        if ((pict_type==P_TYPE) && secondfield
            && (currentfield!=mv_field_sel[1][0]))
          predframe = newref; /* same frame */
        else
          predframe = oldref; /* previous frame */

        /* lower half */
        pred(predframe,mv_field_sel[1][0],cur,currentfield,
          lx<<1,16,8,bx,by+8,PMV[1][0][0],PMV[1][0][1],0);
      }
      else if (motion_type==MC_DMV)
      {
        /* dual prime prediction */

        /* determine which frame to use for prediction */
        if (secondfield)
          predframe = newref; /* same frame */
        else
          predframe = oldref; /* previous frame */

        /* calculate derived motion vectors */
        calc_DMV(DMV,dmvector,PMV[0][0][0],PMV[0][0][1]);

        /* predict from field of same parity */
        pred(oldref,currentfield,cur,currentfield,
          lx<<1,16,16,bx,by,PMV[0][0][0],PMV[0][0][1],0);

        /* predict from field of opposite parity */
        pred(predframe,!currentfield,cur,currentfield,
          lx<<1,16,16,bx,by,DMV[0][0],DMV[0][1],1);
      }
      else
      {
        /* invalid motion_type in field picture */
        if (!quiet)
          fprintf(stderr,"invalid motion_type\n");
      }
    }
    addflag = 1; /* next prediction (if any) will be averaged with this one */
  }

  if (mb_type & MB_BACKWARD)
  {
    /* backward prediction */

    if (pict_struct==FRAME_PICTURE)
    {
      /* frame picture */

      if (motion_type==MC_FRAME)
      {
        /* frame-based prediction in frame picture */
        pred(newref,0,cur,0,
          lx,16,16,bx,by,PMV[0][1][0],PMV[0][1][1],addflag);
      }
      else
      {
        /* field-based prediction in frame picture
         *
         * note scaling of the vertical coordinates (by, PMV[][1][1])
         * from frame to field!
         */

        /* top field prediction */
        pred(newref,mv_field_sel[0][1],cur,0,
          lx<<1,16,8,bx,by>>1,PMV[0][1][0],PMV[0][1][1]>>1,addflag);

        /* bottom field prediction */
        pred(newref,mv_field_sel[1][1],cur,1,
          lx<<1,16,8,bx,by>>1,PMV[1][1][0],PMV[1][1][1]>>1,addflag);
      }
    }
    else /* TOP_FIELD or BOTTOM_FIELD */
    {
      /* field picture */

      currentfield = (pict_struct==BOTTOM_FIELD);

      if (motion_type==MC_FIELD)
      {
        /* field-based prediction in field picture */
        pred(newref,mv_field_sel[0][1],cur,currentfield,
          lx<<1,16,16,bx,by,PMV[0][1][0],PMV[0][1][1],addflag);
      }
      else if (motion_type==MC_16X8)
      {
        /* 16 x 8 motion compensation in field picture */

        /* upper half */
        pred(newref,mv_field_sel[0][1],cur,currentfield,
          lx<<1,16,8,bx,by,PMV[0][1][0],PMV[0][1][1],addflag);

        /* lower half */
        pred(newref,mv_field_sel[1][1],cur,currentfield,
          lx<<1,16,8,bx,by+8,PMV[1][1][0],PMV[1][1][1],addflag);
      }
      else
      {
        /* invalid motion_type in field picture */
        if (!quiet)
          fprintf(stderr,"invalid motion_type\n");
      }
    }
  }
}

/* predict a rectangular block (all three components)
 *
 * src:     source frame (Y,U,V)
 * sfield:  source field select (0: frame or top field, 1: bottom field)
 * dst:     destination frame (Y,U,V)
 * dfield:  destination field select (0: frame or top field, 1: bottom field)
 *
 * the following values are in luminance picture (frame or field) dimensions
 * lx:      distance of vertically adjacent pels (selects frame or field pred.)
 * w,h:     width and height of block (only 16x16 or 16x8 are used)
 * x,y:     coordinates of destination block
 * dx,dy:   half pel motion vector
 * addflag: store or add (= average) prediction
 */
static void pred(src,sfield,dst,dfield,lx,w,h,x,y,dx,dy,addflag)
unsigned char *src[];
int sfield;
unsigned char *dst[];
int dfield;
int lx;
int w, h;
int x, y;
int dx, dy;
int addflag;
{
  int cc;

  for (cc=0; cc<3; cc++)
  {
    if (cc==1)
    {
      /* scale for color components */
      if (chroma_format==CHROMA420)
      {
        /* vertical */
        h >>= 1; y >>= 1; dy /= 2;
      }
      if (chroma_format!=CHROMA444)
      {
        /* horizontal */
        w >>= 1; x >>= 1; dx /= 2;
        lx >>= 1;
      }
    }

    pred_comp(src[cc]+(sfield?lx>>1:0),dst[cc]+(dfield?lx>>1:0),
      lx,w,h,x,y,dx,dy,addflag);
  }
}

/* low level prediction routine
 *
 * src:     prediction source
 * dst:     prediction destination
 * lx:      line width (for both src and dst)
 * x,y:     destination coordinates
 * dx,dy:   half pel motion vector
 * w,h:     size of prediction block
 * addflag: store or add prediction
 */

static void pred_comp(src,dst,lx,w,h,x,y,dx,dy,addflag)
unsigned char *src;
unsigned char *dst;
int lx;
int w, h;
int x, y;
int dx, dy;
int addflag;
{
  int xint, xh, yint, yh;
  int i, j;
  unsigned char *s, *d;

  /* half pel scaling */
  xint = dx>>1; /* integer part */
  xh = dx & 1;  /* half pel flag */
  yint = dy>>1;
  yh = dy & 1;

  /* origins */
  s = src + lx*(y+yint) + (x+xint); /* motion vector */
  d = dst + lx*y + x;

  if (!xh && !yh)
    if (addflag)
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (unsigned int)(d[i]+s[i]+1)>>1;
        s+= lx;
        d+= lx;
      }
    else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = s[i];
        s+= lx;
        d+= lx;
      }
  else if (!xh && yh)
    if (addflag)
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (d[i] + ((unsigned int)(s[i]+s[i+lx]+1)>>1)+1)>>1;
        s+= lx;
        d+= lx;
      }
    else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (unsigned int)(s[i]+s[i+lx]+1)>>1;
        s+= lx;
        d+= lx;
      }
  else if (xh && !yh)
    if (addflag)
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (d[i] + ((unsigned int)(s[i]+s[i+1]+1)>>1)+1)>>1;
        s+= lx;
        d+= lx;
      }
    else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (unsigned int)(s[i]+s[i+1]+1)>>1;
        s+= lx;
        d+= lx;
      }
  else /* if (xh && yh) */
    if (addflag)
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (d[i] + ((unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2)+1)>>1;
        s+= lx;
        d+= lx;
      }
    else
      for (j=0; j<h; j++)
      {
        for (i=0; i<w; i++)
          d[i] = (unsigned int)(s[i]+s[i+1]+s[i+lx]+s[i+lx+1]+2)>>2;
        s+= lx;
        d+= lx;
      }
}


/* calculate derived motion vectors (DMV) for dual prime prediction
 * dmvector[2]: differential motion vectors (-1,0,+1)
 * mvx,mvy: motion vector (for same parity)
 *
 * DMV[2][2]: derived motion vectors (for opposite parity)
 *
 * uses global variables pict_struct and topfirst
 *
 * Notes:
 *  - all vectors are in field coordinates (even for frame pictures)
 */

static void calc_DMV(DMV,dmvector,mvx,mvy)
int DMV[][2];
int *dmvector;
int mvx, mvy;
{
  if (pict_struct==FRAME_PICTURE)
  {
    if (topfirst)
    {
      /* vector for prediction of top field from bottom field */
      DMV[0][0] = ((mvx  +(mvx>0))>>1) + dmvector[0];
      DMV[0][1] = ((mvy  +(mvy>0))>>1) + dmvector[1] - 1;

      /* vector for prediction of bottom field from top field */
      DMV[1][0] = ((3*mvx+(mvx>0))>>1) + dmvector[0];
      DMV[1][1] = ((3*mvy+(mvy>0))>>1) + dmvector[1] + 1;
    }
    else
    {
      /* vector for prediction of top field from bottom field */
      DMV[0][0] = ((3*mvx+(mvx>0))>>1) + dmvector[0];
      DMV[0][1] = ((3*mvy+(mvy>0))>>1) + dmvector[1] - 1;

      /* vector for prediction of bottom field from top field */
      DMV[1][0] = ((mvx  +(mvx>0))>>1) + dmvector[0];
      DMV[1][1] = ((mvy  +(mvy>0))>>1) + dmvector[1] + 1;
    }
  }
  else
  {
    /* vector for prediction from field of opposite 'parity' */
    DMV[0][0] = ((mvx+(mvx>0))>>1) + dmvector[0];
    DMV[0][1] = ((mvy+(mvy>0))>>1) + dmvector[1];

    /* correct for vertical field shift */
    if (pict_struct==TOP_FIELD)
      DMV[0][1]--;
    else
      DMV[0][1]++;
  }
}

static void clearblock(cur,i0,j0)
unsigned char *cur[];
int i0, j0;
{
  int i, j, w, h;
  unsigned char *p;

  p = cur[0] + ((pict_struct==BOTTOM_FIELD) ? width : 0) + i0 + width2*j0;

  for (j=0; j<16; j++)
  {
    for (i=0; i<16; i++)
      p[i] = 128;
    p+= width2;
  }

  w = h = 16;

  if (chroma_format!=CHROMA444)
  {
    i0>>=1; w>>=1;
  }

  if (chroma_format==CHROMA420)
  {
    j0>>=1; h>>=1;
  }

  p = cur[1] + ((pict_struct==BOTTOM_FIELD) ? chrom_width : 0) + i0
             + chrom_width2*j0;

  for (j=0; j<h; j++)
  {
    for (i=0; i<w; i++)
      p[i] = 128;
    p+= chrom_width2;
  }

  p = cur[2] + ((pict_struct==BOTTOM_FIELD) ? chrom_width : 0) + i0
             + chrom_width2*j0;

  for (j=0; j<h; j++)
  {
    for (i=0; i<w; i++)
      p[i] = 128;
    p+= chrom_width2;
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* putbits.c, bit-level output                                              */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <string.h>
#include "config.h"
#ifdef LTHREAD
#include <malloc.h>
#endif

extern FILE *outfile; /* the only global var we need here */

/* private data */
static unsigned char outbfr;
static int outcnt;
static int bytecnt;

#ifdef LTHREAD
#define OUT_FB_LEN 128
int buf_ptr[NUM_THREADS];  /* pointer to outfrmbuf */
int cur_size[NUM_THREADS]; 
unsigned char *outfrmbuf[NUM_THREADS];

static unsigned char out_bfr[NUM_THREADS];
static int out_cnt[NUM_THREADS];
int byte_cnt[NUM_THREADS];

void write_buf(unsigned char val, int id) {

  if (buf_ptr[id]==cur_size[id]-1) {
    unsigned char* tmp;

    cur_size[id] <<= 1;
    tmp = malloc(cur_size[id] * sizeof(unsigned char));
    memcpy(tmp, outfrmbuf[id], cur_size[id]>>1);
    free(outfrmbuf[id]);
    outfrmbuf[id]=tmp;
    /*    outfrmbuf[id] = (unsigned char *) realloc(outfrmbuf[id], \
	  cur_size[id] * sizeof(unsigned char));*/
  }
    outfrmbuf[id][buf_ptr[id]++] = val;
}

/* write rightmost n (0<=n<=32) bits of val to outfile */
void put_bits(val,n,id)
     int val;
int n;
int id;
{
  int i;
  unsigned int mask;

  mask = 1 << (n-1); /* selects first (leftmost) bit */
  
  for (i=0; i<n; i++)
  {
    out_bfr[id] <<= 1;
    
    if (val & mask)
      out_bfr[id]|= 1;
    
    mask >>= 1; /* select next bit */
    out_cnt[id]--;

    if (out_cnt[id]==0) /* 8 bit buffer full */
      {
	write_buf(out_bfr[id],id);
	out_cnt[id] = 8;
	byte_cnt[id]++;
      }
  }

}

/* zero bit stuffing to next byte boundary (5.2.3, 6.2.1) */
void align_bits(int id)
{
  if (out_cnt[id]!=8)
    put_bits(0,out_cnt[id],id);
}

void flushbits(int id) {
  int i;

  align_bits(id);
  /*  for (i = 0; i<buf_ptr[id]; i++) {
    fputc(outfrmbuf[id][i],outfile);
    }*/
  fwrite(outfrmbuf[id], sizeof(unsigned char), buf_ptr[id], outfile);

  buf_ptr[id] = 0;

}

#endif

/* initialize buffer, call once before first putbits or alignbits */
void initbits()
{
#ifdef LTHREAD
  int id;
#endif
  
  outcnt = 8;
  bytecnt = 0;
#ifdef LTHREAD
  for (id=0; id<NUM_THREADS; id++) {
    out_cnt[id] = 8;
    byte_cnt[id] = 0;
    buf_ptr[id] = 0;
    outfrmbuf[id] = (unsigned char *) malloc(OUT_FB_LEN*sizeof(unsigned char));
    cur_size[id] = OUT_FB_LEN;
  }
#endif
}


/* write rightmost n (0<=n<=32) bits of val to outfile */
void putbits(val,n)
     int val;
     int n;
{
  int i;
  unsigned int mask;

  mask = 1 << (n-1); /* selects first (leftmost) bit */
  
  for (i=0; i<n; i++)
    {
      outbfr <<= 1;
      
      if (val & mask)
	outbfr|= 1;
      
      mask >>= 1; /* select next bit */
      outcnt--;
      
      if (outcnt==0) /* 8 bit buffer full */
	{
	  fputc(outbfr,outfile);
	  outcnt = 8;
	  bytecnt++;
	}
    }
}

/* zero bit stuffing to next byte boundary (5.2.3, 6.2.1) */
void alignbits()
{

  if (outcnt!=8)
    putbits(0,outcnt);
}

/* return total number of generated bits */
int bitcount()
{
  return 8*bytecnt + (8-outcnt);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* puthdr.c, generation of headers                                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <math.h>
#include "config.h"
#include "global.h"

/* private prototypes */
static int frametotc _ANSI_ARGS_((int frame));

/* generate sequence header (6.2.2.1, 6.3.3)
 *
 * matrix download not implemented
 */
void putseqhdr()
{
  int i;

  alignbits();
  putbits(SEQ_START_CODE,32); /* sequence_header_code */
  putbits(horizontal_size,12); /* horizontal_size_value */
  putbits(vertical_size,12); /* vertical_size_value */
  putbits(aspectratio,4); /* aspect_ratio_information */
  putbits(frame_rate_code,4); /* frame_rate_code */
  putbits((int)ceil(bit_rate/400.0),18); /* bit_rate_value */
  putbits(1,1); /* marker_bit */
  putbits(vbv_buffer_size,10); /* vbv_buffer_size_value */
  putbits(constrparms,1); /* constrained_parameters_flag */

  putbits(load_iquant,1); /* load_intra_quantizer_matrix */
  if (load_iquant)
    for (i=0; i<64; i++)  /* matrices are always downloaded in zig-zag order */
      putbits(intra_q[zig_zag_scan[i]],8); /* intra_quantizer_matrix */

  putbits(load_niquant,1); /* load_non_intra_quantizer_matrix */
  if (load_niquant)
    for (i=0; i<64; i++)
      putbits(inter_q[zig_zag_scan[i]],8); /* non_intra_quantizer_matrix */
}

/* generate sequence extension (6.2.2.3, 6.3.5) header (MPEG-2 only) */
void putseqext()
{
  alignbits();
  putbits(EXT_START_CODE,32); /* extension_start_code */
  putbits(SEQ_ID,4); /* extension_start_code_identifier */
  putbits((profile<<4)|level,8); /* profile_and_level_indication */
  putbits(prog_seq,1); /* progressive sequence */
  putbits(chroma_format,2); /* chroma_format */
  putbits(horizontal_size>>12,2); /* horizontal_size_extension */
  putbits(vertical_size>>12,2); /* vertical_size_extension */
  putbits(((int)ceil(bit_rate/400.0))>>18,12); /* bit_rate_extension */
  putbits(1,1); /* marker_bit */
  putbits(vbv_buffer_size>>10,8); /* vbv_buffer_size_extension */
  putbits(0,1); /* low_delay  -- currently not implemented */
  putbits(0,2); /* frame_rate_extension_n */
  putbits(0,5); /* frame_rate_extension_d */
}

/* generate sequence display extension (6.2.2.4, 6.3.6)
 *
 * content not yet user setable
 */
void putseqdispext()
{
  alignbits();
  putbits(EXT_START_CODE,32); /* extension_start_code */
  putbits(DISP_ID,4); /* extension_start_code_identifier */
  putbits(video_format,3); /* video_format */
  putbits(1,1); /* colour_description */
  putbits(color_primaries,8); /* colour_primaries */
  putbits(transfer_characteristics,8); /* transfer_characteristics */
  putbits(matrix_coefficients,8); /* matrix_coefficients */
  putbits(display_horizontal_size,14); /* display_horizontal_size */
  putbits(1,1); /* marker_bit */
  putbits(display_vertical_size,14); /* display_vertical_size */
}

/* output a zero terminated string as user data (6.2.2.2.2, 6.3.4.1)
 *
 * string must not emulate start codes
 */
void putuserdata(userdata)
char *userdata;
{
  alignbits();
  putbits(USER_START_CODE,32); /* user_data_start_code */
  while (*userdata)
    putbits(*userdata++,8);
}

/* generate group of pictures header (6.2.2.6, 6.3.9)
 *
 * uses tc0 (timecode of first frame) and frame0 (number of first frame)
 */
void putgophdr(frame,closed_gop)
int frame,closed_gop;
{
  int tc;

  alignbits();
  putbits(GOP_START_CODE,32); /* group_start_code */
  tc = frametotc(tc0+frame);
  putbits(tc,25); /* time_code */
  putbits(closed_gop,1); /* closed_gop */
  putbits(0,1); /* broken_link */
}

/* convert frame number to time_code
 *
 * drop_frame not implemented
 */
static int frametotc(frame)
int frame;
{
  int fps, pict, sec, minute, hour, tc;

  fps = (int)(frame_rate+0.5);
  pict = frame%fps;
  frame = (frame-pict)/fps;
  sec = frame%60;
  frame = (frame-sec)/60;
  minute = frame%60;
  frame = (frame-minute)/60;
  hour = frame%24;
  tc = (hour<<19) | (minute<<13) | (1<<12) | (sec<<6) | pict;

  return tc;
}

/* generate picture header (6.2.3, 6.3.10) */
void putpicthdr()
{
  alignbits();
  putbits(PICTURE_START_CODE,32); /* picture_start_code */
  calc_vbv_delay();
  putbits(temp_ref,10); /* temporal_reference */
  putbits(pict_type,3); /* picture_coding_type */
  putbits(vbv_delay,16); /* vbv_delay */

  if (pict_type==P_TYPE || pict_type==B_TYPE)
  {
    putbits(0,1); /* full_pel_forward_vector */
    if (mpeg1)
      putbits(forw_hor_f_code,3);
    else
      putbits(7,3); /* forward_f_code */
  }

  if (pict_type==B_TYPE)
  {
    putbits(0,1); /* full_pel_backward_vector */
    if (mpeg1)
      putbits(back_hor_f_code,3);
    else
      putbits(7,3); /* backward_f_code */
  }

  putbits(0,1); /* extra_bit_picture */
}

/* generate picture coding extension (6.2.3.1, 6.3.11)
 *
 * composite display information (v_axis etc.) not implemented
 */
void putpictcodext()
{
  alignbits();
  putbits(EXT_START_CODE,32); /* extension_start_code */
  putbits(CODING_ID,4); /* extension_start_code_identifier */
  putbits(forw_hor_f_code,4); /* forward_horizontal_f_code */
  putbits(forw_vert_f_code,4); /* forward_vertical_f_code */
  putbits(back_hor_f_code,4); /* backward_horizontal_f_code */
  putbits(back_vert_f_code,4); /* backward_vertical_f_code */
  putbits(dc_prec,2); /* intra_dc_precision */
  putbits(pict_struct,2); /* picture_structure */
  putbits((pict_struct==FRAME_PICTURE)?topfirst:0,1); /* top_field_first */
  putbits(frame_pred_dct,1); /* frame_pred_frame_dct */
  putbits(0,1); /* concealment_motion_vectors  -- currently not implemented */
  putbits(q_scale_type,1); /* q_scale_type */
  putbits(intravlc,1); /* intra_vlc_format */
  putbits(altscan,1); /* alternate_scan */
  putbits(repeatfirst,1); /* repeat_first_field */
  putbits(prog_frame,1); /* chroma_420_type */
  putbits(prog_frame,1); /* progressive_frame */
  putbits(0,1); /* composite_display_flag */
}

/* generate sequence_end_code (6.2.2) */
void putseqend()
{
  alignbits();
  putbits(SEQ_END_CODE,32);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* putmpg.c, block and motion vector encoding routines                      */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "config.h"
#include "global.h"

/* generate variable length codes for an intra-coded block (6.2.6, 6.3.17) */
void putintrablk(blk,cc)
short *blk;
int cc;
{
  int n, dct_diff, run, signed_level;

  /* DC coefficient (7.2.1) */
  dct_diff = blk[0] - dc_dct_pred[cc]; /* difference to previous block */
  dc_dct_pred[cc] = blk[0];

  if (cc==0)
    putDClum(dct_diff);
  else
    putDCchrom(dct_diff);

  /* AC coefficients (7.2.2) */
  run = 0;
  for (n=1; n<64; n++)
  {
    /* use appropriate entropy scanning pattern */
    signed_level = blk[(altscan ? alternate_scan : zig_zag_scan)[n]];
    if (signed_level!=0)
    {
      putAC(run,signed_level,intravlc);
      run = 0;
    }
    else
      run++; /* count zero coefficients */
  }

  /* End of Block -- normative block punctuation */
  if (intravlc)
    putbits(6,4); /* 0110 (Table B-15) */
  else
    putbits(2,2); /* 10 (Table B-14) */
}

/* generate variable length codes for a non-intra-coded block (6.2.6, 6.3.17) */
void putnonintrablk(blk)
short *blk;
{
  int n, run, signed_level, first;

  run = 0;
  first = 1;

  for (n=0; n<64; n++)
  {
    /* use appropriate entropy scanning pattern */
    signed_level = blk[(altscan ? alternate_scan : zig_zag_scan)[n]];

    if (signed_level!=0)
    {
      if (first)
      {
        /* first coefficient in non-intra block */
        putACfirst(run,signed_level);
        first = 0;
      }
      else
        putAC(run,signed_level,0);

      run = 0;
    }
    else
      run++; /* count zero coefficients */
  }

  /* End of Block -- normative block punctuation  */
  putbits(2,2);
}

/* generate variable length code for a motion vector component (7.6.3.1) */
void putmv(dmv,f_code)
int dmv,f_code;
{
  int r_size, f, vmin, vmax, dv, temp, motion_code, motion_residual;

  r_size = f_code - 1; /* number of fixed length code ('residual') bits */
  f = 1<<r_size;
  vmin = -16*f; /* lower range limit */
  vmax = 16*f - 1; /* upper range limit */
  dv = 32*f;

  /* fold vector difference into [vmin...vmax] */
  if (dmv>vmax)
    dmv-= dv;
  else if (dmv<vmin)
    dmv+= dv;

  /* check value */
  if (dmv<vmin || dmv>vmax)
    if (!quiet)
      fprintf(stderr,"invalid motion vector\n");

  /* split dmv into motion_code and motion_residual */
  temp = ((dmv<0) ? -dmv : dmv) + f - 1;
  motion_code = temp>>r_size;
  if (dmv<0)
    motion_code = -motion_code;
  motion_residual = temp & (f-1);

  putmotioncode(motion_code); /* variable length code */

  if (r_size!=0 && motion_code!=0)
    putbits(motion_residual,r_size); /* fixed length code */
}

#ifdef LTHREAD
void put_mv(dmv,f_code,id)
int dmv,f_code,id;
{
  int r_size, f, vmin, vmax, dv, temp, motion_code, motion_residual;

  r_size = f_code - 1; /* number of fixed length code ('residual') bits */
  f = 1<<r_size;
  vmin = -16*f; /* lower range limit */
  vmax = 16*f - 1; /* upper range limit */
  dv = 32*f;

  /* fold vector difference into [vmin...vmax] */
  if (dmv>vmax)
    dmv-= dv;
  else if (dmv<vmin)
    dmv+= dv;

  /* check value */
  if (dmv<vmin || dmv>vmax)
    if (!quiet)
      fprintf(stderr,"invalid motion vector\n");

  /* split dmv into motion_code and motion_residual */
  temp = ((dmv<0) ? -dmv : dmv) + f - 1;
  motion_code = temp>>r_size;
  if (dmv<0)
    motion_code = -motion_code;
  motion_residual = temp & (f-1);

  put_motioncode(motion_code,id); /* variable length code */

  if (r_size!=0 && motion_code!=0)
    put_bits(motion_residual,r_size,id); /* fixed length code */
}
void put_intrablk(blk,cc,id)
short *blk;
int cc,id;
{
  int n, dct_diff, run, signed_level;

  /* DC coefficient (7.2.1) */
  dct_diff = blk[0] - pt_dc_dct_pred[id][cc]; /* difference to previous block */
  pt_dc_dct_pred[id][cc] = blk[0];

  if (cc==0)
    put_DClum(dct_diff,id);
  else
    put_DCchrom(dct_diff,id);

  /* AC coefficients (7.2.2) */
  run = 0;
  for (n=1; n<64; n++)
  {
    /* use appropriate entropy scanning pattern */
    signed_level = blk[(altscan ? alternate_scan : zig_zag_scan)[n]];
    if (signed_level!=0)
    {
      put_AC(run,signed_level,intravlc,id);
      run = 0;
    }
    else
      run++; /* count zero coefficients */
  }

  /* End of Block -- normative block punctuation */
  if (intravlc)
    put_bits(6,4,id); /* 0110 (Table B-15) */
  else
    put_bits(2,2,id); /* 10 (Table B-14) */
}

/* generate variable length codes for a non-intra-coded block (6.2.6, 6.3.17) */
void put_nonintrablk(blk,id)
short *blk;
int id;
{
  int n, run, signed_level, first;

  run = 0;
  first = 1;

  for (n=0; n<64; n++)
  {
    /* use appropriate entropy scanning pattern */
    signed_level = blk[(altscan ? alternate_scan : zig_zag_scan)[n]];

    if (signed_level!=0)
    {
      if (first)
      {
        /* first coefficient in non-intra block */
        put_ACfirst(run,signed_level,id);
        first = 0;
      }
      else
        put_AC(run,signed_level,0,id);

      run = 0;
    }
    else
      run++; /* count zero coefficients */
  }

  /* End of Block -- normative block punctuation  */
  put_bits(2,2,id);
}

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* putpic.c, block and motion vector encoding routines                      */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "config.h"
#include "global.h"

#ifdef LTHREAD

static void put_mvs _ANSI_ARGS_((int MV[2][2][2], int PMV[2][2][2],
  int mv_field_sel[2][2], int dmvector[2], int s, int motion_type,
  int hor_f_code, int vert_f_code,int id));

#endif

/* private prototypes */
static void putmvs _ANSI_ARGS_((int MV[2][2][2], int PMV[2][2][2],
  int mv_field_sel[2][2], int dmvector[2], int s, int motion_type,
  int hor_f_code, int vert_f_code));


/* quantization / variable length encoding of a complete picture */
void putpict(frame)
unsigned char *frame;
{
  int i, j, k, comp, cc;
  int mb_type;
  int PMV[2][2][2];
  int prev_mquant;
  int cbp, MBAinc;

  rc_init_pict(frame); /* set up rate control */

  /* picture header and picture coding extension */
  putpicthdr();

  if (!mpeg1)
    putpictcodext();

  prev_mquant = rc_start_mb(); /* initialize quantization parameter */

  k = 0;

  for (j=0; j<mb_height2; j++)
  {
    /* macroblock row loop */

    for (i=0; i<mb_width; i++)
    {
      /* macroblock loop */
      if (i==0)
      {
        /* slice header (6.2.4) */
        alignbits();

        if (mpeg1 || vertical_size<=2800)
          putbits(SLICE_MIN_START+j,32); /* slice_start_code */
        else
        {
          putbits(SLICE_MIN_START+(j&127),32); /* slice_start_code */
          putbits(j>>7,3); /* slice_vertical_position_extension */
        }
  
        /* quantiser_scale_code */
        putbits(q_scale_type ? map_non_linear_mquant[prev_mquant]
                             : prev_mquant >> 1, 5);
  
        putbits(0,1); /* extra_bit_slice */
  
        /* reset predictors */

        for (cc=0; cc<3; cc++)
          dc_dct_pred[cc] = 0;

        PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
        PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  
        MBAinc = i + 1; /* first MBAinc denotes absolute position */
      }

      mb_type = mbinfo[k].mb_type;

      /* determine mquant (rate control) */
      mbinfo[k].mquant = rc_calc_mquant(k);

      /* quantize macroblock */
      if (mb_type & MB_INTRA)
      {
        for (comp=0; comp<block_count; comp++) {
	  int ind = k*block_count+comp;
	  
	  quant_intra(blocks[ind],blocks[ind],
                      dc_prec,intra_q,mbinfo[k].mquant);
	}
        mbinfo[k].cbp = cbp = (1<<block_count) - 1;
      }
      else
      {
        cbp = 0;
	for (comp=0;comp<block_count;comp++) {
	  
	  int ind = k*block_count+comp;


          cbp = (cbp<<1) | quant_non_intra(blocks[ind],blocks[ind],
                                           inter_q, mbinfo[k].mquant);
	}

        mbinfo[k].cbp = cbp;

        if (cbp)
          mb_type|= MB_PATTERN;
      }

      /* output mquant if it has changed */
      if (cbp && prev_mquant!=mbinfo[k].mquant)
        mb_type|= MB_QUANT;

      /* check if macroblock can be skipped */
      if (i!=0 && i!=mb_width-1 && !cbp)
      {
        /* no DCT coefficients and neither first nor last macroblock of slice */

        if (pict_type==P_TYPE && !(mb_type&MB_FORWARD))
        {
          /* P picture, no motion vectors -> skip */

          /* reset predictors */

          for (cc=0; cc<3; cc++)
            dc_dct_pred[cc] = 0;

          PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
          PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }

        if (pict_type==B_TYPE && pict_struct==FRAME_PICTURE
            && mbinfo[k].motion_type==MC_FRAME
            && ((mbinfo[k-1].mb_type^mb_type)&(MB_FORWARD|MB_BACKWARD))==0
            && (!(mb_type&MB_FORWARD) ||
                (PMV[0][0][0]==mbinfo[k].MV[0][0][0] &&
                 PMV[0][0][1]==mbinfo[k].MV[0][0][1]))
            && (!(mb_type&MB_BACKWARD) ||
                (PMV[0][1][0]==mbinfo[k].MV[0][1][0] &&
                 PMV[0][1][1]==mbinfo[k].MV[0][1][1])))
        {
          /* conditions for skipping in B frame pictures:
           * - must be frame predicted
           * - must be the same prediction type (forward/backward/interp.)
           *   as previous macroblock
           * - relevant vectors (forward/backward/both) have to be the same
           *   as in previous macroblock
           */

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }

        if (pict_type==B_TYPE && pict_struct!=FRAME_PICTURE
            && mbinfo[k].motion_type==MC_FIELD
            && ((mbinfo[k-1].mb_type^mb_type)&(MB_FORWARD|MB_BACKWARD))==0
            && (!(mb_type&MB_FORWARD) ||
                (PMV[0][0][0]==mbinfo[k].MV[0][0][0] &&
                 PMV[0][0][1]==mbinfo[k].MV[0][0][1] &&
                 mbinfo[k].mv_field_sel[0][0]==(pict_struct==BOTTOM_FIELD)))
            && (!(mb_type&MB_BACKWARD) ||
                (PMV[0][1][0]==mbinfo[k].MV[0][1][0] &&
                 PMV[0][1][1]==mbinfo[k].MV[0][1][1] &&
                 mbinfo[k].mv_field_sel[0][1]==(pict_struct==BOTTOM_FIELD))))
        {
          /* conditions for skipping in B field pictures:
           * - must be field predicted
           * - must be the same prediction type (forward/backward/interp.)
           *   as previous macroblock
           * - relevant vectors (forward/backward/both) have to be the same
           *   as in previous macroblock
           * - relevant motion_vertical_field_selects have to be of same
           *   parity as current field
           */

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }
      }

      /* macroblock cannot be skipped */
      mbinfo[k].skipped = 0;

      /* there's no VLC for 'No MC, Not Coded':
       * we have to transmit (0,0) motion vectors
       */
      if (pict_type==P_TYPE && !cbp && !(mb_type&MB_FORWARD))
        mb_type|= MB_FORWARD;

      putaddrinc(MBAinc); /* macroblock_address_increment */
      MBAinc = 1;

      putmbtype(pict_type,mb_type); /* macroblock type */

      if (mb_type & (MB_FORWARD|MB_BACKWARD) && !frame_pred_dct)
        putbits(mbinfo[k].motion_type,2);

      if (pict_struct==FRAME_PICTURE && cbp && !frame_pred_dct)
        putbits(mbinfo[k].dct_type,1);

      if (mb_type & MB_QUANT)
      {
        putbits(q_scale_type ? map_non_linear_mquant[mbinfo[k].mquant]
                             : mbinfo[k].mquant>>1,5);
        prev_mquant = mbinfo[k].mquant;
      }

      if (mb_type & MB_FORWARD)
      {
        /* forward motion vectors, update predictors */
        putmvs(mbinfo[k].MV,PMV,mbinfo[k].mv_field_sel,mbinfo[k].dmvector,0,
          mbinfo[k].motion_type,forw_hor_f_code,forw_vert_f_code);
      }

      if (mb_type & MB_BACKWARD)
      {
        /* backward motion vectors, update predictors */
        putmvs(mbinfo[k].MV,PMV,mbinfo[k].mv_field_sel,mbinfo[k].dmvector,1,
          mbinfo[k].motion_type,back_hor_f_code,back_vert_f_code);
      }

      if (mb_type & MB_PATTERN)
      {
        putcbp((cbp >> (block_count-6)) & 63);
        if (chroma_format!=CHROMA420)
          putbits(cbp,block_count-6);
      }

      for (comp=0; comp<block_count; comp++)
      {
        /* block loop */
        if (cbp & (1<<(block_count-1-comp)))
        {
          if (mb_type & MB_INTRA)
          {
            cc = (comp<4) ? 0 : (comp&1)+1;
            putintrablk(blocks[k*block_count+comp],cc);
          }
          else
            putnonintrablk(blocks[k*block_count+comp]);
        }
      }

      /* reset predictors */
      if (!(mb_type & MB_INTRA))
        for (cc=0; cc<3; cc++)
          dc_dct_pred[cc] = 0;

      if (mb_type & MB_INTRA || (pict_type==P_TYPE && !(mb_type & MB_FORWARD)))
      {
        PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
        PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
      }

      mbinfo[k].mb_type = mb_type;
      k++;
    }
  }

  rc_update_pict();
  vbv_end_of_picture();
}

#ifdef LTHREAD
    /***********************************************************************
                       Threaded Version of Putpict
    ************************************************************/

void ptputpict(frame, start_mbh, end_mbh, pmq, id)
unsigned char *frame;
int start_mbh, end_mbh, pmq, id;
{
  int i, j, k, comp, cc;
  int mb_type;
  int PMV[2][2][2];
  int prev_mquant;
  int cbp, MBAinc;

  k = start_mbh*mb_width;
  prev_mquant = pmq;

  for (j=start_mbh; j<end_mbh; j++)
  {
    /* macroblock row loop */

    for (i=0; i<mb_width; i++)
    {
      /* macroblock loop */
      if (i==0)
      {
        /* slice header (6.2.4) */
        align_bits(id);

        if (mpeg1 || vertical_size<=2800)
          put_bits(SLICE_MIN_START+j,32,id); /* slice_start_code */
        else
        {
          put_bits(SLICE_MIN_START+(j&127),32,id); /* slice_start_code */
          put_bits(j>>7,3,id); /* slice_vertical_position_extension */
        }
  
        /* quantiser_scale_code */
        put_bits(q_scale_type ? map_non_linear_mquant[prev_mquant]
                             : prev_mquant >> 1, 5, id);
  
        put_bits(0,1,id); /* extra_bit_slice */
  
        /* reset predictors */

        for (cc=0; cc<3; cc++)
          pt_dc_dct_pred[id][cc] = 0;

        PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
        PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
  
        MBAinc = i + 1; /* first MBAinc denotes absolute position */
      }

      mb_type = mbinfo[k].mb_type;

      /* determine mquant (rate control) */
      /*mbinfo[k].mquant = rc_calc_mquant(k);*/
      mbinfo[k].mquant = 20;

      cbp = mbinfo[k].cbp;
      if ((!(mb_type & MB_INTRA)) && cbp)
	mb_type |= MB_PATTERN;
#if 0
      /* quantize macroblock */
      if (mb_type & MB_INTRA)
      {
	for (comp=0; comp<block_count; comp++) {
	  int ind = k*block_count+comp;
	  
	  
	  quant_intra(blocks[ind],blocks[ind],
                      dc_prec,intra_q,mbinfo[k].mquant);
	}
        mbinfo[k].cbp = cbp = (1<<block_count) - 1;
	
      }
      else
      {
        cbp = 0;
        
	for (comp=0;comp<block_count;comp++) {
	  
	  int ind = k*block_count+comp;
	  
          cbp = (cbp<<1) | quant_non_intra(blocks[ind],blocks[ind],
                                           inter_q, mbinfo[k].mquant);
	}

        mbinfo[k].cbp = cbp;

        if (cbp)
          mb_type|= MB_PATTERN;
      }
#endif
      /* output mquant if it has changed */
      if (cbp && prev_mquant!=mbinfo[k].mquant)
        mb_type|= MB_QUANT;

      /* check if macroblock can be skipped */
      if (i!=0 && i!=mb_width-1 && !cbp)
      {
        /* no DCT coefficients and neither first nor last macroblock of slice */

        if (pict_type==P_TYPE && !(mb_type&MB_FORWARD))
        {
          /* P picture, no motion vectors -> skip */

          /* reset predictors */

          for (cc=0; cc<3; cc++)
            pt_dc_dct_pred[id][cc] = 0;

          PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
          PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }

        if (pict_type==B_TYPE && pict_struct==FRAME_PICTURE
            && mbinfo[k].motion_type==MC_FRAME
            && ((mbinfo[k-1].mb_type^mb_type)&(MB_FORWARD|MB_BACKWARD))==0
            && (!(mb_type&MB_FORWARD) ||
                (PMV[0][0][0]==mbinfo[k].MV[0][0][0] &&
                 PMV[0][0][1]==mbinfo[k].MV[0][0][1]))
            && (!(mb_type&MB_BACKWARD) ||
                (PMV[0][1][0]==mbinfo[k].MV[0][1][0] &&
                 PMV[0][1][1]==mbinfo[k].MV[0][1][1])))
        {
          /* conditions for skipping in B frame pictures:
           * - must be frame predicted
           * - must be the same prediction type (forward/backward/interp.)
           *   as previous macroblock
           * - relevant vectors (forward/backward/both) have to be the same
           *   as in previous macroblock
           */

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }

        if (pict_type==B_TYPE && pict_struct!=FRAME_PICTURE
            && mbinfo[k].motion_type==MC_FIELD
            && ((mbinfo[k-1].mb_type^mb_type)&(MB_FORWARD|MB_BACKWARD))==0
            && (!(mb_type&MB_FORWARD) ||
                (PMV[0][0][0]==mbinfo[k].MV[0][0][0] &&
                 PMV[0][0][1]==mbinfo[k].MV[0][0][1] &&
                 mbinfo[k].mv_field_sel[0][0]==(pict_struct==BOTTOM_FIELD)))
            && (!(mb_type&MB_BACKWARD) ||
                (PMV[0][1][0]==mbinfo[k].MV[0][1][0] &&
                 PMV[0][1][1]==mbinfo[k].MV[0][1][1] &&
                 mbinfo[k].mv_field_sel[0][1]==(pict_struct==BOTTOM_FIELD))))
        {
          /* conditions for skipping in B field pictures:
           * - must be field predicted
           * - must be the same prediction type (forward/backward/interp.)
           *   as previous macroblock
           * - relevant vectors (forward/backward/both) have to be the same
           *   as in previous macroblock
           * - relevant motion_vertical_field_selects have to be of same
           *   parity as current field
           */

          mbinfo[k].mb_type = mb_type;
          mbinfo[k].skipped = 1;
          MBAinc++;
          k++;
          continue;
        }
      }

      /* macroblock cannot be skipped */
      mbinfo[k].skipped = 0;

      /* there's no VLC for 'No MC, Not Coded':
       * we have to transmit (0,0) motion vectors
       */
      if (pict_type==P_TYPE && !cbp && !(mb_type&MB_FORWARD))
        mb_type|= MB_FORWARD;

      put_addrinc(MBAinc,id); /* macroblock_address_increment */
      MBAinc = 1;

      put_mbtype(pict_type,mb_type,id); /* macroblock type */

      if (mb_type & (MB_FORWARD|MB_BACKWARD) && !frame_pred_dct)
        put_bits(mbinfo[k].motion_type,2,id);

      if (pict_struct==FRAME_PICTURE && cbp && !frame_pred_dct)
        put_bits(mbinfo[k].dct_type,1,id);

      if (mb_type & MB_QUANT)
      {
        put_bits(q_scale_type ? map_non_linear_mquant[mbinfo[k].mquant]
                             : mbinfo[k].mquant>>1,5,id);
        prev_mquant = mbinfo[k].mquant;
      }

      if (mb_type & MB_FORWARD)
      {
        /* forward motion vectors, update predictors */
        put_mvs(mbinfo[k].MV,PMV,mbinfo[k].mv_field_sel,mbinfo[k].dmvector,0,
          mbinfo[k].motion_type,forw_hor_f_code,forw_vert_f_code,id);
      }

      if (mb_type & MB_BACKWARD)
      {
        /* backward motion vectors, update predictors */
        put_mvs(mbinfo[k].MV,PMV,mbinfo[k].mv_field_sel,mbinfo[k].dmvector,1,
          mbinfo[k].motion_type,back_hor_f_code,back_vert_f_code,id);
      }

      if (mb_type & MB_PATTERN)
      {
        put_cbp((cbp >> (block_count-6)) & 63, id);
        if (chroma_format!=CHROMA420)
          put_bits(cbp,block_count-6,id);
      }

      for (comp=0; comp<block_count; comp++)
      {
        /* block loop */
        if (cbp & (1<<(block_count-1-comp)))
        {
          if (mb_type & MB_INTRA)
          {
            cc = (comp<4) ? 0 : (comp&1)+1;
            put_intrablk(blocks[k*block_count+comp],cc,id);
          }
          else
            put_nonintrablk(blocks[k*block_count+comp],id);
        }
      }

      /* reset predictors */
      if (!(mb_type & MB_INTRA))
        for (cc=0; cc<3; cc++)
          pt_dc_dct_pred[id][cc] = 0;

      if (mb_type & MB_INTRA || (pict_type==P_TYPE && !(mb_type & MB_FORWARD)))
      {
        PMV[0][0][0]=PMV[0][0][1]=PMV[1][0][0]=PMV[1][0][1]=0;
        PMV[0][1][0]=PMV[0][1][1]=PMV[1][1][0]=PMV[1][1][1]=0;
      }

      mbinfo[k].mb_type = mb_type;
      k++;
    }
  }

}

/* output motion vectors (6.2.5.2, 6.3.16.2)
 *
 * this routine also updates the predictions for motion vectors (PMV)
 */

static void put_mvs(MV,PMV,mv_field_sel,dmvector,s,motion_type,
  hor_f_code,vert_f_code,id)
int MV[2][2][2],PMV[2][2][2];
int mv_field_sel[2][2];
int dmvector[2];
int s,motion_type,hor_f_code,vert_f_code,id;
{
  if (pict_struct==FRAME_PICTURE)
  {
    if (motion_type==MC_FRAME)
    {
      /* frame prediction */
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_mv(MV[0][s][1]-PMV[0][s][1],vert_f_code,id);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
    else if (motion_type==MC_FIELD)
    {
      /* field prediction */
      put_bits(mv_field_sel[0][s],1,id);
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_mv((MV[0][s][1]>>1)-(PMV[0][s][1]>>1),vert_f_code,id);
      put_bits(mv_field_sel[1][s],1,id);
      put_mv(MV[1][s][0]-PMV[1][s][0],hor_f_code,id);
      put_mv((MV[1][s][1]>>1)-(PMV[1][s][1]>>1),vert_f_code,id);
      PMV[0][s][0]=MV[0][s][0];
      PMV[0][s][1]=MV[0][s][1];
      PMV[1][s][0]=MV[1][s][0];
      PMV[1][s][1]=MV[1][s][1];
    }
    else
    {
      /* dual prime prediction */
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_dmv(dmvector[0],id);
      put_mv((MV[0][s][1]>>1)-(PMV[0][s][1]>>1),vert_f_code,id);
      put_dmv(dmvector[1],id);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
  }
  else
  {
    /* field picture */
    if (motion_type==MC_FIELD)
    {
      /* field prediction */
      put_bits(mv_field_sel[0][s],1,id);
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_mv(MV[0][s][1]-PMV[0][s][1],vert_f_code,id);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
    else if (motion_type==MC_16X8)
    {
      /* 16x8 prediction */
      put_bits(mv_field_sel[0][s],1,id);
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_mv(MV[0][s][1]-PMV[0][s][1],vert_f_code,id);
      put_bits(mv_field_sel[1][s],1,id);
      put_mv(MV[1][s][0]-PMV[1][s][0],hor_f_code,id);
      put_mv(MV[1][s][1]-PMV[1][s][1],vert_f_code,id);
      PMV[0][s][0]=MV[0][s][0];
      PMV[0][s][1]=MV[0][s][1];
      PMV[1][s][0]=MV[1][s][0];
      PMV[1][s][1]=MV[1][s][1];
    }
    else
    {
      /* dual prime prediction */
      put_mv(MV[0][s][0]-PMV[0][s][0],hor_f_code,id);
      put_dmv(dmvector[0],id);
      put_mv(MV[0][s][1]-PMV[0][s][1],vert_f_code,id);
      put_dmv(dmvector[1],id);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
  }
}
#endif
 
static void putmvs(MV,PMV,mv_field_sel,dmvector,s,motion_type,
  hor_f_code,vert_f_code)
int MV[2][2][2],PMV[2][2][2];
int mv_field_sel[2][2];
int dmvector[2];
int s,motion_type,hor_f_code,vert_f_code;
{
  if (pict_struct==FRAME_PICTURE)
  {
    if (motion_type==MC_FRAME)
    {
      /* frame prediction */
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putmv(MV[0][s][1]-PMV[0][s][1],vert_f_code);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
    else if (motion_type==MC_FIELD)
    {
      /* field prediction */
      putbits(mv_field_sel[0][s],1);
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putmv((MV[0][s][1]>>1)-(PMV[0][s][1]>>1),vert_f_code);
      putbits(mv_field_sel[1][s],1);
      putmv(MV[1][s][0]-PMV[1][s][0],hor_f_code);
      putmv((MV[1][s][1]>>1)-(PMV[1][s][1]>>1),vert_f_code);
      PMV[0][s][0]=MV[0][s][0];
      PMV[0][s][1]=MV[0][s][1];
      PMV[1][s][0]=MV[1][s][0];
      PMV[1][s][1]=MV[1][s][1];
    }
    else
    {
      /* dual prime prediction */
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putdmv(dmvector[0]);
      putmv((MV[0][s][1]>>1)-(PMV[0][s][1]>>1),vert_f_code);
      putdmv(dmvector[1]);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
  }
  else
  {
    /* field picture */
    if (motion_type==MC_FIELD)
    {
      /* field prediction */
      putbits(mv_field_sel[0][s],1);
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putmv(MV[0][s][1]-PMV[0][s][1],vert_f_code);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
    else if (motion_type==MC_16X8)
    {
      /* 16x8 prediction */
      putbits(mv_field_sel[0][s],1);
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putmv(MV[0][s][1]-PMV[0][s][1],vert_f_code);
      putbits(mv_field_sel[1][s],1);
      putmv(MV[1][s][0]-PMV[1][s][0],hor_f_code);
      putmv(MV[1][s][1]-PMV[1][s][1],vert_f_code);
      PMV[0][s][0]=MV[0][s][0];
      PMV[0][s][1]=MV[0][s][1];
      PMV[1][s][0]=MV[1][s][0];
      PMV[1][s][1]=MV[1][s][1];
    }
    else
    {
      /* dual prime prediction */
      putmv(MV[0][s][0]-PMV[0][s][0],hor_f_code);
      putdmv(dmvector[0]);
      putmv(MV[0][s][1]-PMV[0][s][1],vert_f_code);
      putdmv(dmvector[1]);
      PMV[0][s][0]=PMV[1][s][0]=MV[0][s][0];
      PMV[0][s][1]=PMV[1][s][1]=MV[0][s][1];
    }
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* putseq.c, sequence level routines                                        */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "config.h"
#include "global.h"

#ifdef LTHREAD
#if (NUM_THREADS>1)
#include <pthread.h>
#endif


void *thread_work(void* threadargs) {
  struct thread_data *my_data = (struct thread_data*) threadargs;

  /* Arguments for motion estimation*/
  struct Data_Args *mda = my_data->data_ptr; /*mda stands for my data args */
  int start_height = my_data->s_height;
  int end_height = my_data->e_height;
  struct mbinfo *mbi = mda->mbi;
  

  ptmotion_estimation(mda->oldorg, mda->neworg, mda->oldref, mda->newref, mda->cur,
		      mda->curref, mda->sxf, mda->syf, mda->sxb, mda->syb, mbi,
		      mda->secondfield, mda->ipflag, start_height, 
		      end_height);
  
  ptpredict(mda->reff, mda->refb, mda->pd_cur, mda->secondfield, mbi, start_height, 
	    end_height);
  
  ptdct_type_estimation(mda->pred,mda->dte_cur,mbi, start_height, end_height);
  
  pttransform(mda->pd_cur, mda->trfm_cur,mbi,(short (*)[64])mda->blocks,
	       start_height, end_height);
  
  ptquant(my_data->s_mbh, my_data->e_mbh);
  
  ptputpict(mda->dte_cur, my_data->pp_smbh, my_data->pp_embh, 
	    mda->prev_mquant, my_data->id);
  
  ptiquant(my_data->s_mbh, my_data->e_mbh);
  ptitransform(mda->pd_cur, mda->itrfm_cur,mbi,(short (*)[64])mda->blocks,
	       start_height, end_height);

  return NULL;
}

struct thread_data thread_data_array[NUM_THREADS];
struct Data_Args data_args;

void thread_work_dist()
{
  int tmp, tmp1;
  int rc, t, status;

  int excess, chunk;

#if (NUM_THREADS>1)
  pthread_attr_t attr;
  pthread_t thread[NUM_THREADS-1];
  
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
#endif

  chunk = height2/NUM_THREADS;
  excess = (height2/16)%NUM_THREADS;

  for(t=0;t < NUM_THREADS;t++)
  {
    if (t==0) {
      thread_data_array[t].s_height = 0;
      thread_data_array[t].s_mbh = 0;
      thread_data_array[t].pp_smbh = 0;
      tmp = chunk;
    } else {
      thread_data_array[t].s_height = thread_data_array[t-1].e_height;
      thread_data_array[t].s_mbh = thread_data_array[t-1].e_mbh;
      thread_data_array[t].pp_smbh = thread_data_array[t-1].pp_embh;
      tmp = thread_data_array[t-1].e_height + chunk;
    }

    if (excess) {
      tmp = tmp + 16 - (tmp%16);
      excess--;
    } else {
      tmp = tmp - (tmp%16);
    }
    tmp1 = tmp/16;

    thread_data_array[t].e_height = tmp;
    thread_data_array[t].pp_embh = tmp1;
    thread_data_array[t].e_mbh = tmp1*mb_width;
    
    thread_data_array[t].id = t;
    
    thread_data_array[t].data_ptr = &data_args;

#if (NUM_THREADS>1)
     /* create threads */
    if (t<NUM_THREADS-1) {
      rc = pthread_create(&thread[t], &attr, thread_work, 
			  (void*) &thread_data_array[t]); 
      if (rc)
	{
	  printf("ERROR; return code from pthread_create() is %d\n", rc);
	  exit(-1);
	}
    }
#endif
  }

#if (NUM_THREADS>1)
  /* Free attribute and wait for the other threads */
  pthread_attr_destroy(&attr);
#endif

  /* disabled rate control, detail can be found at putpic.c */

  putpicthdr();
  
  if (!mpeg1)
    putpictcodext();
  
  alignbits(); /*align common bitstream buffer */

  thread_work(&thread_data_array[NUM_THREADS-1]);
  
#if (NUM_THREADS>1)
  for(t=0;t < NUM_THREADS-1;t++)
    {
      rc = pthread_join(thread[t], (void **)&status);
      if (rc)
	{
	  printf("ERROR; return code from pthread_join() is %d\n", rc);
	  exit(-1);
	}
      flushbits(t);
      
    }
#endif
  
  flushbits(NUM_THREADS-1);

}

#endif

void putseq()
{
  /* this routine assumes (N % M) == 0 */
  int i, j, k, f, f0, n, np, nb, sxf, syf, sxb, syb;
  int ipflag;
  /*FILE *fd;*/
  char name[256];
  unsigned char *neworg[3], *newref[3];
#ifndef QUIET
  static char ipb[5] = {' ','I','P','B','D'};
#endif

  rc_init_seq(); /* initialize rate control */
  /* sequence header, sequence extension and sequence display extension */
  putseqhdr();
  if (!mpeg1)
  {
    putseqext();
    putseqdispext();
  }

  /* optionally output some text data (description, copyright or whatever) */
  if (strlen(id_string) > 1)
    putuserdata(id_string);

  /* loop through all frames in encoding/decoding order */
  for (i=0; i<nframes; i++)
  {
  
  if (!quiet)
    {
      fprintf(stderr,"Encoding frame %d ",i);
      fflush(stderr);
    }

    /* f0: lowest frame number in current GOP
     *
     * first GOP contains N-(M-1) frames,
     * all other GOPs contain N frames
     */
    f0 = N*((i+(M-1))/N) - (M-1);

    if (f0<0)
      f0=0;

    if (i==0 || (i-1)%M==0)
    {
      /* I or P frame */
      for (j=0; j<3; j++)
      {
        /* shuffle reference frames */
        neworg[j] = oldorgframe[j];
        newref[j] = oldrefframe[j];
        oldorgframe[j] = neworgframe[j];
        oldrefframe[j] = newrefframe[j];
        neworgframe[j] = neworg[j];
        newrefframe[j] = newref[j];
      }

      /* f: frame number in display order */
      f = (i==0) ? 0 : i+M-1;
      if (f>=nframes)
        f = nframes - 1;

      if (i==f0) /* first displayed frame in GOP is I */
      {
        /* I frame */
        pict_type = I_TYPE;
        forw_hor_f_code = forw_vert_f_code = 15;
        back_hor_f_code = back_vert_f_code = 15;

        /* n: number of frames in current GOP
         *
         * first GOP contains (M-1) less (B) frames
         */
        n = (i==0) ? N-(M-1) : N;

        /* last GOP may contain less frames */
        if (n > nframes-f0)
          n = nframes-f0;

        /* number of P frames */
        if (i==0)
          np = (n + 2*(M-1))/M - 1; /* first GOP */
        else
          np = (n + (M-1))/M - 1;

        /* number of B frames */
        nb = n - np - 1;

        rc_init_GOP(np,nb);

        putgophdr(f0,i==0); /* set closed_GOP in first GOP only */
      }
      else
      {
        /* P frame */
        pict_type = P_TYPE;
        forw_hor_f_code = motion_data[0].forw_hor_f_code;
        forw_vert_f_code = motion_data[0].forw_vert_f_code;
        back_hor_f_code = back_vert_f_code = 15;
        sxf = motion_data[0].sxf;
        syf = motion_data[0].syf;
      }
    }
    else
    {
      /* B frame */
      for (j=0; j<3; j++)
      {
        neworg[j] = auxorgframe[j];
        newref[j] = auxframe[j];
      }

      /* f: frame number in display order */
      f = i - 1;
      pict_type = B_TYPE;
      n = (i-2)%M + 1; /* first B: n=1, second B: n=2, ... */
      forw_hor_f_code = motion_data[n].forw_hor_f_code;
      forw_vert_f_code = motion_data[n].forw_vert_f_code;
      back_hor_f_code = motion_data[n].back_hor_f_code;
      back_vert_f_code = motion_data[n].back_vert_f_code;
      sxf = motion_data[n].sxf;
      syf = motion_data[n].syf;
      sxb = motion_data[n].sxb;
      syb = motion_data[n].syb;
    }

    temp_ref = f - f0;
    frame_pred_dct = frame_pred_dct_tab[pict_type-1];
    q_scale_type = qscale_tab[pict_type-1];
    intravlc = intravlc_tab[pict_type-1];
    altscan = altscan_tab[pict_type-1];

#ifndef QUIET
    fprintf(statfile,"\nFrame %d (#%d in display order):\n",i,f);
    fprintf(statfile," picture_type=%c\n",ipb[pict_type]);
    fprintf(statfile," temporal_reference=%d\n",temp_ref);
    fprintf(statfile," frame_pred_frame_dct=%d\n",frame_pred_dct);
    fprintf(statfile," q_scale_type=%d\n",q_scale_type);
    fprintf(statfile," intra_vlc_format=%d\n",intravlc);
    fprintf(statfile," alternate_scan=%d\n",altscan);

    if (pict_type!=I_TYPE)
    {
      fprintf(statfile," forward search window: %d...%d / %d...%d\n",
        -sxf,sxf,-syf,syf);
      fprintf(statfile," forward vector range: %d...%d.5 / %d...%d.5\n",
        -(4<<forw_hor_f_code),(4<<forw_hor_f_code)-1,
        -(4<<forw_vert_f_code),(4<<forw_vert_f_code)-1);
    }

    if (pict_type==B_TYPE)
    {
      fprintf(statfile," backward search window: %d...%d / %d...%d\n",
        -sxb,sxb,-syb,syb);
      fprintf(statfile," backward vector range: %d...%d.5 / %d...%d.5\n",
        -(4<<back_hor_f_code),(4<<back_hor_f_code)-1,
        -(4<<back_vert_f_code),(4<<back_vert_f_code)-1);
    }
#endif
    sprintf(name,tplorg,f+frame0);
    readframe(name,neworg);

    /*** WE DO ONLY FRAME PIC *** Partha */
    if (fieldpic)
    {
      if (!quiet)
      {
        fprintf(stderr,"\nfirst field  (%s) ",topfirst ? "top" : "bot");
        fflush(stderr);
      }

      pict_struct = topfirst ? TOP_FIELD : BOTTOM_FIELD;

      motion_estimation(oldorgframe[0],neworgframe[0],
                        oldrefframe[0],newrefframe[0],
                        neworg[0],newref[0],
                        sxf,syf,sxb,syb,mbinfo,0,0);

      predict(oldrefframe,newrefframe,predframe,0,mbinfo);
      dct_type_estimation(predframe[0],neworg[0],mbinfo);
      transform(predframe,neworg,mbinfo,blocks);

      putpict(neworg[0]);

      for (k=0; k<mb_height2*mb_width; k++)
      {
        if (mbinfo[k].mb_type & MB_INTRA)
          for (j=0; j<block_count; j++)
            iquant_intra(blocks[k*block_count+j],blocks[k*block_count+j],
                         dc_prec,intra_q,mbinfo[k].mquant);
        else
          for (j=0;j<block_count;j++)
            iquant_non_intra(blocks[k*block_count+j],blocks[k*block_count+j],
                             inter_q,mbinfo[k].mquant);
      }

      itransform(predframe,newref,mbinfo,blocks);
      calcSNR(neworg,newref);
      stats();

      if (!quiet)
      {
        fprintf(stderr,"second field (%s) ",topfirst ? "bot" : "top");
        fflush(stderr);
      }

      pict_struct = topfirst ? BOTTOM_FIELD : TOP_FIELD;

      ipflag = (pict_type==I_TYPE);
      if (ipflag)
      {
        /* first field = I, second field = P */
        pict_type = P_TYPE;
        forw_hor_f_code = motion_data[0].forw_hor_f_code;
        forw_vert_f_code = motion_data[0].forw_vert_f_code;
        back_hor_f_code = back_vert_f_code = 15;
        sxf = motion_data[0].sxf;
        syf = motion_data[0].syf;
      }

      motion_estimation(oldorgframe[0],neworgframe[0],
                        oldrefframe[0],newrefframe[0],
                        neworg[0],newref[0],
                        sxf,syf,sxb,syb,mbinfo,1,ipflag);

      predict(oldrefframe,newrefframe,predframe,1,mbinfo);
      dct_type_estimation(predframe[0],neworg[0],mbinfo);
      transform(predframe,neworg,mbinfo,blocks);

      putpict(neworg[0]);

      for (k=0; k<mb_height2*mb_width; k++)
      {
        if (mbinfo[k].mb_type & MB_INTRA)
          for (j=0; j<block_count; j++)
            iquant_intra(blocks[k*block_count+j],blocks[k*block_count+j],
                         dc_prec,intra_q,mbinfo[k].mquant);
        else
          for (j=0;j<block_count;j++)
            iquant_non_intra(blocks[k*block_count+j],blocks[k*block_count+j],
                             inter_q,mbinfo[k].mquant);
      }

      itransform(predframe,newref,mbinfo,blocks);
      calcSNR(neworg,newref);
      stats();
    }
    else
    {
      pict_struct = FRAME_PICTURE;

      /* do motion_estimation
       *
       * uses source frames (...orgframe) for full pel search
       * and reconstructed frames (...refframe) for half pel search
       */
#ifdef LTHREAD

      data_args.oldorg = oldorgframe[0];
      data_args.neworg = neworgframe[0];
      data_args.oldref = oldrefframe[0];
      data_args.newref = newrefframe[0];
      data_args.cur = neworg[0];
      data_args.curref = newref[0];
      data_args.sxf = sxf;
      data_args.syf = syf;
      data_args.sxb = sxb;
      data_args.syb = syb;
      data_args.mbi = mbinfo;
      data_args.secondfield = 0;
      data_args.ipflag = 0;

      data_args.reff = oldrefframe;
      data_args.refb = newrefframe;
      data_args.pd_cur = predframe;

      data_args.pred = predframe[0];
      data_args.dte_cur = neworg[0];

      data_args.trfm_cur = neworg;
      data_args.blocks = (short **)blocks;
      
      data_args.prev_mquant = 20;
      data_args.itrfm_cur = newref;

      thread_work_dist();

#else
      motion_estimation(oldorgframe[0],neworgframe[0],
                        oldrefframe[0],newrefframe[0],
                        neworg[0],newref[0],
                        sxf,syf,sxb,syb,mbinfo,0,0);
      predict(oldrefframe,newrefframe,predframe,0,mbinfo);
      dct_type_estimation(predframe[0],neworg[0],mbinfo);
      transform(predframe,neworg,mbinfo,blocks);

      putpict(neworg[0]); 


      for (k=0; k<mb_height*mb_width; k++)
	{
	  if (mbinfo[k].mb_type & MB_INTRA)
	    for (j=0; j<block_count; j++) {
	      
	      int ind = k*block_count+j;	      
	      iquant_intra(blocks[ind],blocks[ind],
			   dc_prec,intra_q,mbinfo[k].mquant);
	    }
	  else
	    for (j=0;j<block_count;j++) {
	      
	      int ind = k*block_count+j;
	      iquant_non_intra(blocks[ind],blocks[ind],
			       inter_q,mbinfo[k].mquant);
	    }
	}
      
      itransform(predframe,newref,mbinfo,blocks);

#endif	
#ifndef QUIET
      calcSNR(neworg,newref);
      stats();
#endif

    }
    sprintf(name,tplref,f+frame0);
    writeframe(name,newref);
  }

  putseqend();

}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* putvlc.c, generation of variable length codes                            */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>

#include "config.h"
#include "global.h"
#include "vlc.h"

/* private prototypes */
static void putDC _ANSI_ARGS_((sVLCtable *tab, int val));

#ifdef LTHREAD
static void put_DC _ANSI_ARGS_((sVLCtable *tab, int val, int id));


/* generate variable length code for luminance DC coefficient */
void put_DClum(val,id)
int val,id;
{
  put_DC(DClumtab,val,id);
}

/* generate variable length code for chrominance DC coefficient */
void put_DCchrom(val,id)
int val,id;
{
  put_DC(DCchromtab,val,id);
}

/* generate variable length code for DC coefficient (7.2.1) */
static void put_DC(tab,val,id)
sVLCtable *tab;
int val,id;
{
  int absval, size;

  absval = (val<0) ? -val : val; /* abs(val) */

  if (absval>2047 || (mpeg1 && absval>255))
  {
    /* should never happen */
    sprintf(errortext,"DC value out of range (%d)\n",val);
    error(errortext);
  }

  /* compute dct_dc_size */
  size = 0;

  while (absval)
  {
    absval >>= 1;
    size++;
  }

  /* generate VLC for dct_dc_size (Table B-12 or B-13) */
  put_bits(tab[size].code,tab[size].len,id);

  /* append fixed length code (dc_dct_differential) */
  if (size!=0)
  {
    if (val>=0)
      absval = val;
    else
      absval = val + (1<<size) - 1; /* val + (2 ^ size) - 1 */
    put_bits(absval,size,id);
  }
}

/* generate variable length code for first coefficient
 * of a non-intra block (7.2.2.2) */
void put_ACfirst(run,val,id)
int run,val,id;
{
  if (run==0 && (val==1 || val==-1)) /* these are treated differently */
    put_bits(2|(val<0),2,id); /* generate '1s' (s=sign), (Table B-14, line 2) */
  else
    put_AC(run,val,0,id); /* no difference for all others */
}

/* generate variable length code for other DCT coefficients (7.2.2) */
void put_AC(run,signed_level,vlcformat,id)
int run,signed_level,vlcformat,id;
{
  int level, len;
  VLCtable *ptab;

  level = (signed_level<0) ? -signed_level : signed_level; /* abs(signed_level) */

  /* make sure run and level are valid */
  if (run<0 || run>63 || level==0 || level>2047 || (mpeg1 && level>255))
  {
    sprintf(errortext,"AC value out of range (run=%d, signed_level=%d)\n",
      run,signed_level);
    error(errortext);
  }

  len = 0;

  if (run<2 && level<41)
  {
    /* vlcformat selects either of Table B-14 / B-15 */
    if (vlcformat)
      ptab = &dct_code_tab1a[run][level-1];
    else
      ptab = &dct_code_tab1[run][level-1];

    len = ptab->len;
  }
  else if (run<32 && level<6)
  {
    /* vlcformat selects either of Table B-14 / B-15 */
    if (vlcformat)
      ptab = &dct_code_tab2a[run-2][level-1];
    else
      ptab = &dct_code_tab2[run-2][level-1];

    len = ptab->len;
  }

  if (len!=0) /* a VLC code exists */
  {
    put_bits(ptab->code,len,id);
    put_bits(signed_level<0,1,id); /* sign */
  }
  else
  {
    /* no VLC for this (run, level) combination: use escape coding (7.2.2.3) */
    put_bits(1l,6,id); /* Escape */
    put_bits(run,6,id); /* 6 bit code for run */
    if (mpeg1)
    {
      /* ISO/IEC 11172-2 uses a 8 or 16 bit code */
      if (signed_level>127)
        put_bits(0,8,id);
      if (signed_level<-127)
        put_bits(128,8,id);
      put_bits(signed_level,8,id);
    }
    else
    {
      /* ISO/IEC 13818-2 uses a 12 bit code, Table B-16 */
      put_bits(signed_level,12,id);
    }
  }
}

/* generate variable length code for macroblock_address_increment (6.3.16) */
void put_addrinc(addrinc,id)
int addrinc,id;
{
  while (addrinc>33)
  {
    put_bits(0x08,11,id); /* macroblock_escape */
    addrinc-= 33;
  }

  put_bits(addrinctab[addrinc-1].code,addrinctab[addrinc-1].len,id);
}

/* generate variable length code for macroblock_type (6.3.16.1) */
void put_mbtype(pict_type,mb_type,id)
int pict_type,mb_type,id;
{
  put_bits(mbtypetab[pict_type-1][mb_type].code,
          mbtypetab[pict_type-1][mb_type].len,id);
}

/* generate variable length code for motion_code (6.3.16.3) */
void put_motioncode(motion_code,id)
int motion_code,id;
{
  int abscode;

  abscode = (motion_code>=0) ? motion_code : -motion_code; /* abs(motion_code) */

  put_bits(motionvectab[abscode].code,motionvectab[abscode].len,id);
  if (motion_code!=0)
    put_bits(motion_code<0,1,id); /* sign, 0=positive, 1=negative */
}

/* generate variable length code for dmvector[t] (6.3.16.3), Table B-11 */
void put_dmv(dmv,id)
int dmv,id;
{
  if (dmv==0)
    put_bits(0,1,id);
  else if (dmv>0)
    put_bits(2,2,id);
  else
    put_bits(3,2,id);
}

/* generate variable length code for coded_block_pattern (6.3.16.4)
 *
 * 4:2:2, 4:4:4 not implemented
 */
void put_cbp(cbp,id)
int cbp,id;
{
  put_bits(cbptable[cbp].code,cbptable[cbp].len,id);
}

#endif

/* generate variable length code for luminance DC coefficient */
void putDClum(val)
int val;
{
  putDC(DClumtab,val);
}

/* generate variable length code for chrominance DC coefficient */
void putDCchrom(val)
int val;
{
  putDC(DCchromtab,val);
}

/* generate variable length code for DC coefficient (7.2.1) */
static void putDC(tab,val)
sVLCtable *tab;
int val;
{
  int absval, size;

  absval = (val<0) ? -val : val; /* abs(val) */

  if (absval>2047 || (mpeg1 && absval>255))
  {
    /* should never happen */
    sprintf(errortext,"DC value out of range (%d)\n",val);
    error(errortext);
  }

  /* compute dct_dc_size */
  size = 0;

  while (absval)
  {
    absval >>= 1;
    size++;
  }

  /* generate VLC for dct_dc_size (Table B-12 or B-13) */
  putbits(tab[size].code,tab[size].len);

  /* append fixed length code (dc_dct_differential) */
  if (size!=0)
  {
    if (val>=0)
      absval = val;
    else
      absval = val + (1<<size) - 1; /* val + (2 ^ size) - 1 */
    putbits(absval,size);
  }
}

/* generate variable length code for first coefficient
 * of a non-intra block (7.2.2.2) */
void putACfirst(run,val)
int run,val;
{
  if (run==0 && (val==1 || val==-1)) /* these are treated differently */
    putbits(2|(val<0),2); /* generate '1s' (s=sign), (Table B-14, line 2) */
  else
    putAC(run,val,0); /* no difference for all others */
}

/* generate variable length code for other DCT coefficients (7.2.2) */
void putAC(run,signed_level,vlcformat)
int run,signed_level,vlcformat;
{
  int level, len;
  VLCtable *ptab;

  level = (signed_level<0) ? -signed_level : signed_level; /* abs(signed_level) */

  /* make sure run and level are valid */
  if (run<0 || run>63 || level==0 || level>2047 || (mpeg1 && level>255))
  {
    sprintf(errortext,"AC value out of range (run=%d, signed_level=%d)\n",
      run,signed_level);
    error(errortext);
  }

  len = 0;

  if (run<2 && level<41)
  {
    /* vlcformat selects either of Table B-14 / B-15 */
    if (vlcformat)
      ptab = &dct_code_tab1a[run][level-1];
    else
      ptab = &dct_code_tab1[run][level-1];

    len = ptab->len;
  }
  else if (run<32 && level<6)
  {
    /* vlcformat selects either of Table B-14 / B-15 */
    if (vlcformat)
      ptab = &dct_code_tab2a[run-2][level-1];
    else
      ptab = &dct_code_tab2[run-2][level-1];

    len = ptab->len;
  }

  if (len!=0) /* a VLC code exists */
  {
    putbits(ptab->code,len);
    putbits(signed_level<0,1); /* sign */
  }
  else
  {
    /* no VLC for this (run, level) combination: use escape coding (7.2.2.3) */
    putbits(1l,6); /* Escape */
    putbits(run,6); /* 6 bit code for run */
    if (mpeg1)
    {
      /* ISO/IEC 11172-2 uses a 8 or 16 bit code */
      if (signed_level>127)
        putbits(0,8);
      if (signed_level<-127)
        putbits(128,8);
      putbits(signed_level,8);
    }
    else
    {
      /* ISO/IEC 13818-2 uses a 12 bit code, Table B-16 */
      putbits(signed_level,12);
    }
  }
}

/* generate variable length code for macroblock_address_increment (6.3.16) */
void putaddrinc(addrinc)
int addrinc;
{
  while (addrinc>33)
  {
    putbits(0x08,11); /* macroblock_escape */
    addrinc-= 33;
  }

  putbits(addrinctab[addrinc-1].code,addrinctab[addrinc-1].len);
}

/* generate variable length code for macroblock_type (6.3.16.1) */
void putmbtype(pict_type,mb_type)
int pict_type,mb_type;
{
  putbits(mbtypetab[pict_type-1][mb_type].code,
          mbtypetab[pict_type-1][mb_type].len);
}

/* generate variable length code for motion_code (6.3.16.3) */
void putmotioncode(motion_code)
int motion_code;
{
  int abscode;

  abscode = (motion_code>=0) ? motion_code : -motion_code; /* abs(motion_code) */

  putbits(motionvectab[abscode].code,motionvectab[abscode].len);
  if (motion_code!=0)
    putbits(motion_code<0,1); /* sign, 0=positive, 1=negative */
}

/* generate variable length code for dmvector[t] (6.3.16.3), Table B-11 */
void putdmv(dmv)
int dmv;
{
  if (dmv==0)
    putbits(0,1);
  else if (dmv>0)
    putbits(2,2);
  else
    putbits(3,2);
}

/* generate variable length code for coded_block_pattern (6.3.16.4)
 *
 * 4:2:2, 4:4:4 not implemented
 */
void putcbp(cbp)
int cbp;
{
  putbits(cbptable[cbp].code,cbptable[cbp].len);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* quantize.c, quantization / inverse quantization                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include "config.h"
#include "global.h"

extern int QUANT_THRESHOLD;


static void iquant1_intra _ANSI_ARGS_((short *src, short *dst,
  int dc_prec, unsigned char *quant_mat, int mquant));
static void iquant1_non_intra _ANSI_ARGS_((short *src, short *dst,
  unsigned char *quant_mat, int mquant));


#ifdef LTHREAD
void ptquant(start_mbh, end_mbh)
int start_mbh, end_mbh;
{
  int k, mb_type, comp, cbp;

  /* load quantization matirices into v0 and v1, which are used by
     quant_intra, quant_non_intra, iquant_intra, iquant_non_intra.
     At this point, we are loading the matricies for child threads.
  */

  for (k=start_mbh; k<end_mbh; k++) {

      mb_type = mbinfo[k].mb_type;

      /* determine mquant (rate control) */
      /*mbinfo[k].mquant = rc_calc_mquant(k);*/
      mbinfo[k].mquant = 20;

      /* quantize macroblock */
      if (mb_type & MB_INTRA)
      {
	for (comp=0; comp<block_count; comp++) {
	  int ind = k*block_count+comp;
	  
	  quant_intra(blocks[ind],blocks[ind],
                      dc_prec,intra_q,mbinfo[k].mquant);
	}
        mbinfo[k].cbp = cbp = (1<<block_count) - 1;
	
      }
      else
      {
        cbp = 0;
        
	for (comp=0;comp<block_count;comp++) {
	  
	  int ind = k*block_count+comp;
	  
          cbp = (cbp<<1) | quant_non_intra(blocks[ind],blocks[ind],
                                           inter_q, mbinfo[k].mquant);
	}
	
        mbinfo[k].cbp = cbp;
	
      }

  }

}


void ptiquant(start_k, end_k)
int start_k, end_k;
{
  int k, j;


  for (k=start_k; k<end_k; k++) {

      if (mbinfo[k].mb_type & MB_INTRA)
	for (j=0; j<block_count; j++) {

	  int ind = k*block_count+j;

	  iquant_intra(blocks[ind],blocks[ind],
		       dc_prec, intra_q, mbinfo[k].mquant);
	}
      else
	for (j=0;j<block_count;j++) {

	  int ind = k*block_count+j;

	  iquant_non_intra(blocks[ind],blocks[ind],
			   inter_q,mbinfo[k].mquant);
	}

  }

}


#endif

/* Test Model 5 quantization
 *
 * this quantizer has a bias of 1/8 stepsize towards zero
 * (except for the DC coefficient)
 */


int quant_intra(src,dst,dc_prec,quant_mat,mquant)
short *src, *dst;
int dc_prec;
unsigned char *quant_mat;
int mquant;
{
  int i;
  int x, y, d;
  short dst0;

  x = src[0];
  d = 8>>dc_prec; /* intra_dc_mult */
  dst0 = (x>=0) ? (x+(d>>1))/d : -((-x+(d>>1))/d); /* round(x/d) */

#ifdef SSE2
  {
    /* loop invariant variables */
    int mq_3q = (3*mquant+2)>>2; 
    int mq_2 = 2*mquant;

    __asm {
      mov        eax, [src]          ; /*load src addr */
      mov        edx, [quant_mat]    ; /*load quant_mat addr */
      mov        ebx, [dst]          ;
      movd       xmm6, [mq_3q]       ;
      movd       xmm7, [mq_2]        ;
      pshufd     xmm6, xmm6, 0       ;
      pshufd     xmm7, xmm7, 0       ;
      cvtdq2ps   xmm6, xmm6          ;
      cvtdq2ps   xmm7, xmm7          ;
      pxor       xmm0, xmm0          ;
      mov        ecx, eax            ; /* 8 elements per loop, loop 8 times*/
      add        ecx, 128            ;
      
    q_intra:
      movdqu    xmm1, [eax]       ; /*load 8 shorts from src*/
      movq      xmm3, [edx]       ; /*load 8 bytes from quant_mat*/
      punpcklbw xmm3, xmm0        ; /*qm: unpack bytes to shorts */
      movdqa    xmm4, xmm3        ; /*make copy */
      movdqa    xmm5, xmm3        ;
      punpcklwd  xmm3, xmm0       ; /* from 8 bytes to 8 double words*/ 
      punpckhwd  xmm5, xmm0       ; /* xmm3 low, xmm5 high */
      pxor      xmm2, xmm2        ;
      cvtdq2ps   xmm3, xmm3       ;
      cvtdq2ps   xmm5, xmm5       ;

      psraw     xmm4, 1           ; /*d>>1*/
      psubw     xmm2, xmm1        ;
      pmaxsw    xmm2, xmm1        ; /* abs(x) */
      psllw     xmm2, 5           ; /* 32*abs(x) */
      paddw     xmm4, xmm2        ; /* 32*abs(x)+(d>>1)*/
      movdqa    xmm2, xmm4        ;
      punpckhwd xmm4, xmm0        ; /* xmm2 low, xmm4 high */
      punpcklwd xmm2, xmm0        ; /* unpack to 32-bit words */
      
      cvtdq2ps   xmm2, xmm2       ;
      cvtdq2ps   xmm4, xmm4       ;
      
      divps    xmm2, xmm3         ; /* divided by quant_mat[i] */
      divps    xmm4, xmm5         ;
      movd     xmm5, [QUANT_THRESHOLD] ;
      pshuflw  xmm5, xmm5, 0      ;
      pshufd   xmm5, xmm5, 0      ; /* 8 copies of QUANT_THRESHOLD */
      
      addps    xmm2, xmm6         ; /* add mq_3q */
      addps    xmm4, xmm6         ;
      divps    xmm2, xmm7         ; /* divided by mq_2 */
      divps    xmm4, xmm7         ; /* divided by mq_2 */

      pxor      xmm3, xmm3        ;

      cvttps2dq xmm2, xmm2        ; 

      pcmpgtw   xmm3, xmm1        ; /*create masks for neg */

      cvttps2dq xmm4, xmm4        ;

      packssdw  xmm2, xmm4        ; /*in dw, needs to pack back to w*/
      pminsw    xmm2, xmm5        ;

      movdqa    xmm4, xmm3        ; /* copy the mask */

      pxor      xmm5, xmm5        ;
      pandn     xmm3, xmm2        ; /* preserve all pos values */

      psubw     xmm5, xmm2        ; /*xmm5 has -y*/
      pand      xmm4, xmm5        ; /*mask -y with neg mask */
      por      xmm3, xmm4        ; /*(x>=0)?y:-y*/

      movdqu    [ebx], xmm3       ;

      add   eax, 16         ;
      add   edx, 8          ;
      add   ebx, 16         ;
      cmp   ecx, eax        ;
      jne   q_intra        ;
    }
    
  }

#else /* Non-SSE2 code */

  for (i=0; i<64; ) {

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    d = (3*mquant+2)>>2;
    y = (y+d)/(2*mquant); /* (y+0.75*mquant) / (2*mquant) */
    /*if (y > QUANT_THRESHOLD) y = QUANT_THRESHOLD;*/
    y = (y > QUANT_THRESHOLD)? QUANT_THRESHOLD : y;
    dst[i] = (x>=0) ? y : -y;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    d = (3*mquant+2)>>2;
    y = (y+d)/(2*mquant); /* (y+0.75*mquant) / (2*mquant) */
    /*if (y > QUANT_THRESHOLD) y = QUANT_THRESHOLD;*/
    y = (y > QUANT_THRESHOLD)? QUANT_THRESHOLD : y;
    dst[i] = (x>=0) ? y : -y;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    d = (3*mquant+2)>>2;
    y = (y+d)/(2*mquant); /* (y+0.75*mquant) / (2*mquant) */
    y = (y > QUANT_THRESHOLD)? QUANT_THRESHOLD : y;
    /*if (y > QUANT_THRESHOLD) y = QUANT_THRESHOLD;*/
    dst[i] = (x>=0) ? y : -y;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    d = (3*mquant+2)>>2;
    y = (y+d)/(2*mquant); /* (y+0.75*mquant) / (2*mquant) */
    y = (y > QUANT_THRESHOLD)? QUANT_THRESHOLD : y;
    /*if (y > QUANT_THRESHOLD) y = QUANT_THRESHOLD;*/
    dst[i] = (x>=0) ? y : -y;
    i++;
    
  }
#endif
  dst[0] = dst0;

  return 1;
}


int quant_non_intra(src,dst,quant_mat,mquant)
short *src, *dst;
unsigned char *quant_mat;
int mquant;
{
  int i;
  int x, y, d;
  int nzflag;

#ifdef SSE2
  {
    /* loop invariant variables */
    int mq_2 = 2*mquant;

    __asm {
      mov        eax, [src]          ; /*load src addr */
      mov        edx, [quant_mat]    ; /*load quant_mat addr */
      mov        ebx, [dst]          ;
      mov        edi, 0xffff           ;
      movd       xmm7, [mq_2]        ;
      movd       xmm5, [QUANT_THRESHOLD] ;
      pshuflw    xmm7, xmm7, 0       ;
      pshuflw    xmm5, xmm5, 0      ;
      pshufd     xmm7, xmm7, 0       ;
      pshufd     xmm5, xmm5, 0      ; /* 8 copies of QUANT_THRESHOLD */
      
      pxor    xmm0, xmm0          ;
      mov        ecx, eax            ; /* 8 elements per loop, loop 8 times*/
      add        ecx, 128            ;
      
    q_non_intra:
      pxor      xmm2, xmm2        ;
      movdqu    xmm1, [eax]       ; /*load 8 shorts from src*/
      movq      xmm3, [edx]       ; /*load 8 bytes from quant_mat*/
      punpcklbw xmm3, xmm2        ; /*qm: unpack bytes to shorts */

      movdqa    xmm6, xmm7        ;
      movdqa    xmm4, xmm3        ; /*make copy */
      pmullw    xmm6, xmm3        ; /*denom: quant_mat * mq_2 */
      movdqa    xmm3, xmm6        ;

      punpckhwd  xmm6, xmm2       ; /* xmm3 low, xmm6 high */
      punpcklwd  xmm3, xmm2       ; /* from 8 bytes to 8 double words*/ 
      cvtdq2ps   xmm6, xmm6       ;
      cvtdq2ps   xmm3, xmm3       ;

      psraw     xmm4, 1           ; /*d>>1*/
      psubw     xmm2, xmm1        ;
      pmaxsw    xmm2, xmm1        ; /* abs(x) */
      psllw     xmm2, 5           ; /* 32*abs(x) */
      paddw     xmm4, xmm2        ; /* 32*abs(x)+(d>>1)*/
      movdqa    xmm2, xmm4        ;
      punpckhwd xmm4, xmm0        ; /* xmm2 low, xmm4 high */
      punpcklwd xmm2, xmm0        ; /* unpack to 32-bit words */
      
      cvtdq2ps   xmm2, xmm2       ;
      cvtdq2ps   xmm4, xmm4       ;
      
      divps    xmm2, xmm3         ; /* divided by quant_mat[i] */
      divps    xmm4, xmm6         ;

      pxor      xmm3, xmm3        ;

      cvttps2dq xmm2, xmm2        ; 

      pcmpgtw   xmm3, xmm1        ; /*create masks for neg */

      cvttps2dq xmm4, xmm4        ;

      packssdw  xmm2, xmm4        ; /*in dw, needs to pack back to w*/
      pminsw    xmm2, xmm5        ;
      movdqa    xmm4, xmm3        ; /* copy the mask */

      pxor      xmm6, xmm6        ;
      pandn     xmm3, xmm2        ; /* preserve all pos values */
      pxor     xmm1, xmm1        ;

      psubw     xmm6, xmm2        ; /*xmm5 has -y*/
      pand      xmm4, xmm6        ; /*mask -y with neg mask */
      por      xmm3, xmm4        ; /*(x>=0)?y:-y*/

      pcmpeqb  xmm1, xmm3        ; /* compare to zero*/
      pmovmskb esi, xmm1         ;
      and      edi, esi          ;

      movdqu    [ebx], xmm3       ;

      add   eax, 16         ;
      add   edx, 8          ;
      add   ebx, 16         ;
      cmp   ecx, eax        ;
      jne   q_non_intra     ;
      mov   [nzflag], edi   ;
    }
    if (nzflag!=0xffff) 
      nzflag=1;
    else
      nzflag=0;
    
  }

#else /*original code*/
  nzflag = 0;

  for (i=0; i<64; ) {

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    y /= (2*mquant);
    if (y > QUANT_THRESHOLD)  y = QUANT_THRESHOLD;
    if ((dst[i] = (x>=0 ? y : -y)) != 0) nzflag=1;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    y /= (2*mquant);
    if (y > QUANT_THRESHOLD)  y = QUANT_THRESHOLD;
    if ((dst[i] = (x>=0 ? y : -y)) != 0) nzflag=1;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    y /= (2*mquant);
    if (y > QUANT_THRESHOLD)  y = QUANT_THRESHOLD;
    if ((dst[i] = (x>=0 ? y : -y)) != 0) nzflag=1;
    i++;

    x = src[i];
    d = quant_mat[i];
    y = (32*(x>=0 ? x : -x) + (d>>1))/d; /* round(32*x/quant_mat) */
    y /= (2*mquant);
    if (y > QUANT_THRESHOLD)  y = QUANT_THRESHOLD;
    if ((dst[i] = (x>=0 ? y : -y)) != 0) nzflag=1;
    i++;

  }
#endif

  return nzflag;
}

/* MPEG-2 inverse quantization */

void iquant_intra(src,dst,dc_prec,quant_mat,mquant)
short *src, *dst;
int dc_prec;
unsigned char *quant_mat;
int mquant;
{
  int i, val, sum, tmp;

  if (mpeg1)
    iquant1_intra(src,dst,dc_prec,quant_mat,mquant);
  else {
#if 1
    /*Note: Only the LSB of sum matters for mismatch control, thus,
      there's no need for all the accumulations, XORs do just fine and
      save the initial computation of dst[0] */

    tmp = sum = src[0] << (3-dc_prec);

#ifdef SSE2
    {
      const short upper[8] = {2047,2047,2047,2047,
			      2047,2047,2047,2047};
      const short lower[8] = {-2048,-2048,-2048,-2048,
			      -2048,-2048,-2048,-2048};
      __asm {
	movd       xmm5, [mquant]      ;
	movdqu     xmm6, [upper]       ;
	movdqu     xmm7, [lower]       ;
	mov        eax, [src]          ; /*load src addr */
	mov        edx, [quant_mat]    ; /*load quant_mat addr */
	mov        ebx, [dst]          ;
	pshuflw    xmm5, xmm5, 0       ;
	pshufd     xmm5, xmm5, 0       ;
	pxor       xmm0, xmm0          ;
	pxor       xmm4, xmm4          ; /* running sum */
	mov        ecx, eax            ; /* 8 elements per loop, loop 8 times*/
	add        ecx, 128            ;
      
      iq_intra:
	movdqu    xmm1, [eax]       ; /*load 8 shorts from src*/
	movq      xmm2, [edx]       ; /*load 8 bytes from quant_mat*/
	punpcklbw xmm2, xmm0      ; /*qm: unpack bytes to shorts */
	pmullw    xmm2, xmm5      ; /* qm[i] * mquant */

	movdqa  xmm3, xmm2     ; /*make copy*/

	pmulhw xmm2, xmm1      ;
	pmullw xmm3, xmm1      ;

	movdqa xmm1, xmm3      ;
	punpckhwd xmm3,xmm2     ; /*3 : left half, 4 32-bit */
	punpcklwd xmm1,xmm2    ; /*1 : right half, 4 32-bit */

	psrad  xmm3, 4        ;
	psrad  xmm1, 4        ;
	
	packssdw xmm1, xmm3   ;
	pminsw xmm1, xmm6     ;
	pmaxsw xmm1, xmm7     ;
	
	movdqu [ebx], xmm1    ;
	paddw xmm4, xmm1      ;
	add   eax, 16         ;
	add   edx, 8          ;
	add   ebx, 16         ;
	cmp   ecx, eax        ;
	jne   iq_intra        ;

	pshufd xmm0, xmm4, 0xe ; /*reduction: xmm4 has 8 words*/
	paddw xmm4, xmm0       ; /*xmm4 has 4 words */
	pshuflw xmm0, xmm4, 0xe ; 
	paddw xmm4, xmm0        ; /*xmm4 has 2 words */
	pshuflw xmm0, xmm4, 0x1 ; 
	paddw xmm4, xmm0        ;
	movd [sum], xmm4        ;
      }

    }

#else /* NON-SSE2 code */
    for(i=0; i < 64 ; ) {
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum^= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum^= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum^= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum^= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
    }
#endif
    sum^=dst[0]; /* "subtract" dst[0] out from sum*/

    dst[0] = tmp;

    /* mismatch control */
    if ((sum&1)==0)
      dst[63]^= 1;

#else /*original unrolled code */

    tmp = sum = src[0] << (3-dc_prec);
    
    val = (int)(src[0]*quant_mat[0]*mquant)/16;
    sum -= ((val>2047) ? 2047 : ((val<-2048) ? -2048 : val));
    
    for(i=0; i < 64 ; ) {
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
      val = (int)(src[i]*quant_mat[i]*mquant)/16;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;
      
    }

    dst[0] = tmp;
    
    /* mismatch control */
    if ((sum&1)==0)
      dst[63]^= 1;

#endif

  }
  
     
}


void iquant_non_intra(src,dst,quant_mat,mquant)
short *src, *dst;
unsigned char *quant_mat;
int mquant;
{
  int i, val, sum;
 
  if (mpeg1)
    iquant1_non_intra(src,dst,quant_mat,mquant);
  else {
    
#ifdef SSE2
    {
      const short upper[8] = {2047,2047,2047,2047,
			      2047,2047,2047,2047};

      __asm {
	movd       xmm5, [mquant]      ;
	movdqu     xmm6, [upper]       ;
	mov        eax, [src]          ; /*load src addr */
	mov        edx, [quant_mat]    ; /*load quant_mat addr */
	mov        ebx, [dst]          ;
	pshuflw    xmm5, xmm5, 0       ;
	pshufd     xmm5, xmm5, 0       ;
	pcmpeqw    xmm7, xmm7        ; /* contains -1s */
	pxor      xmm0, xmm0        ;
	pxor       xmm4, xmm4          ; /* running sum */
	mov        ecx, eax            ; /* 8 elements per loop, loop 8 times*/
	add        ecx, 128            ;
      
      iq_non_intra:
	movdqu    xmm1, [eax]       ; /*load 8 shorts from src*/

	psllw xmm1, 1       ; /* 2 * src[i] */
	
	movdqa  xmm2, xmm1      ; /* make 2*src[i] copy*/
	movdqa  xmm3, xmm0      ; /* make copy for 0 */
	pcmpgtw xmm3, xmm1     ; /* generate masks for < 0 */
	paddw   xmm2, xmm7       ; /* 2*src-1 */
	pand    xmm2, xmm3       ;
	movdqa  xmm3, xmm1      ;
	pcmpgtw xmm3, xmm0     ; /* generate masks for > 0 */
	psubw   xmm1, xmm7       ;
	pand    xmm1, xmm3        ;
	por    xmm1, xmm2     ; /* 2*src+(src>0)?1:(src<0)?-1:0*/

	movq      xmm2, [edx]       ; /*load 8 bytes from quant_mat*/
	punpcklbw xmm2, xmm0      ; /*qm: unpack bytes to shorts */
	pmullw    xmm2, xmm5      ; /* qm[i] * mquant */

	movdqa  xmm3, xmm2     ; /*make copy*/

	pmulhw xmm2, xmm1      ;
	pmullw xmm3, xmm1      ;

	movdqa xmm1, xmm3      ;
	punpckhwd xmm3,xmm2     ; /*3 : left half, 4 32-bit */
	punpcklwd xmm1,xmm2    ; /*1 : right half, 4 32-bit */

	psrad  xmm3, 5        ; /* divided by 32 */
	psrad  xmm1, 5        ; 
	
	packssdw xmm1, xmm3   ;
	pminsw xmm1, xmm6     ;
	pandn  xmm6, xmm7     ; /* from 2047 to -2048 */
	pmaxsw xmm1, xmm6     ;
	pandn  xmm6, xmm7     ; /* back to -2047 */
	
	movdqu [ebx], xmm1    ;
	paddw xmm4, xmm1      ;
	add   eax, 16         ;
	add   edx, 8          ;
	add   ebx, 16         ;
	cmp   ecx, eax        ;
	jne   iq_non_intra        ;

	pshufd xmm0, xmm4, 0xe ; /*reduction: xmm4 has 8 words*/
	paddw xmm4, xmm0       ; /*xmm4 has 4 words */
	pshuflw xmm0, xmm4, 0xe ; 
	paddw xmm4, xmm0        ; /*xmm4 has 2 words */
	pshuflw xmm0, xmm4, 0x1 ; 
	paddw xmm4, xmm0        ;
	movd [sum], xmm4        ;
      }

    }

#else /* NON-SSE2 code */
    sum = 0;

    for (i=0; i<64; ) {

      val = src[i];
      if (val!=0)
	val = (int)((2*val+(val>0 ? 1 : -1))*quant_mat[i]*mquant)/32;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;

      val = src[i];
      if (val!=0)
	val = (int)((2*val+(val>0 ? 1 : -1))*quant_mat[i]*mquant)/32;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;

      val = src[i];
      if (val!=0)
	val = (int)((2*val+(val>0 ? 1 : -1))*quant_mat[i]*mquant)/32;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;

      val = src[i];
      if (val!=0)
	val = (int)((2*val+(val>0 ? 1 : -1))*quant_mat[i]*mquant)/32;
      sum+= dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
      i++;

    }
#endif
    /* mismatch control */
    if ((sum&1)==0)
      dst[63]^= 1;
  }
}



/******************* Following are Not used anymore -- Ruchira ***********/



/* MPEG-1 inverse quantization */
static void iquant1_intra(src,dst,dc_prec,quant_mat,mquant)
short *src, *dst;
int dc_prec;
unsigned char *quant_mat;
int mquant;
{
  int i, val;

  dst[0] = src[0] << (3-dc_prec);
  for (i=1; i<64; i++)
  {
    val = (int)(src[i]*quant_mat[i]*mquant)/16;

    /* mismatch control */
    if ((val&1)==0 && val!=0)
      val+= (val>0) ? -1 : 1;

    /* saturation */
    dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
  }
}

static void iquant1_non_intra(src,dst,quant_mat,mquant)
short *src, *dst;
unsigned char *quant_mat;
int mquant;
{
  int i, val;

  for (i=0; i<64; i++)
  {
    val = src[i];
    if (val!=0)
    {
      val = (int)((2*val+(val>0 ? 1 : -1))*quant_mat[i]*mquant)/32;

      /* mismatch control */
      if ((val&1)==0 && val!=0)
        val+= (val>0) ? -1 : 1;
    }

    /* saturation */
    dst[i] = (val>2047) ? 2047 : ((val<-2048) ? -2048 : val);
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ratectl.c, bitrate control routines (linear quantization only currently) */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <math.h>

#include "config.h"
#include "global.h"

/* private prototypes */
static void calc_actj _ANSI_ARGS_((unsigned char *frame));
static double var_sblk _ANSI_ARGS_((unsigned char *p, int lx));

/* rate control variables */
int Xi, Xp, Xb, r, d0i, d0p, d0b;
double avg_act;
static int R, T, d;
static double actsum;
static int Np, Nb, S, Q;
static int prev_mquant;

void rc_init_seq()
{
  /* reaction parameter (constant) */
  if (r==0)  r = (int)floor(2.0*bit_rate/frame_rate + 0.5);

  /* average activity */
  if (avg_act==0.0)  avg_act = 400.0;

  /* remaining # of bits in GOP */
  R = 0;

  /* global complexity measure */
  if (Xi==0) Xi = (int)floor(160.0*bit_rate/115.0 + 0.5);
  if (Xp==0) Xp = (int)floor( 60.0*bit_rate/115.0 + 0.5);
  if (Xb==0) Xb = (int)floor( 42.0*bit_rate/115.0 + 0.5);

  /* virtual buffer fullness */
  if (d0i==0) d0i = (int)floor(10.0*r/31.0 + 0.5);
  if (d0p==0) d0p = (int)floor(10.0*r/31.0 + 0.5);
  if (d0b==0) d0b = (int)floor(1.4*10.0*r/31.0 + 0.5);
/*
  if (d0i==0) d0i = (int)floor(10.0*r/(qscale_tab[0] ? 56.0 : 31.0) + 0.5);
  if (d0p==0) d0p = (int)floor(10.0*r/(qscale_tab[1] ? 56.0 : 31.0) + 0.5);
  if (d0b==0) d0b = (int)floor(1.4*10.0*r/(qscale_tab[2] ? 56.0 : 31.0) + 0.5);
*/
#ifndef QUIET
  fprintf(statfile,"\nrate control: sequence initialization\n");
  fprintf(statfile,
    " initial global complexity measures (I,P,B): Xi=%d, Xp=%d, Xb=%d\n",
    Xi, Xp, Xb);
  fprintf(statfile," reaction parameter: r=%d\n", r);
  fprintf(statfile,
    " initial virtual buffer fullness (I,P,B): d0i=%d, d0p=%d, d0b=%d\n",
    d0i, d0p, d0b);
  fprintf(statfile," initial average activity: avg_act=%.1f\n", avg_act);
#endif
}

void rc_init_GOP(np,nb)
int np,nb;
{
  R += (int) floor((1 + np + nb) * bit_rate / frame_rate + 0.5);
  Np = fieldpic ? 2*np+1 : np;
  Nb = fieldpic ? 2*nb : nb;
#ifndef QUIET
  fprintf(statfile,"\nrate control: new group of pictures (GOP)\n");
  fprintf(statfile," target number of bits for GOP: R=%d\n",R);
  fprintf(statfile," number of P pictures in GOP: Np=%d\n",Np);
  fprintf(statfile," number of B pictures in GOP: Nb=%d\n",Nb);
#endif
}

/* Note: we need to substitute K for the 1.4 and 1.0 constants -- this can
   be modified to fit image content */

/* Step 1: compute target bits for current picture being coded */
void rc_init_pict(frame)
unsigned char *frame;
{
  double Tmin;

  switch (pict_type)
  {
  case I_TYPE:
    T = (int) floor(R/(1.0+Np*Xp/(Xi*1.0)+Nb*Xb/(Xi*1.4)) + 0.5);
    d = d0i;
    break;
  case P_TYPE:
    T = (int) floor(R/(Np+Nb*1.0*Xb/(1.4*Xp)) + 0.5);
    d = d0p;
    break;
  case B_TYPE:
    T = (int) floor(R/(Nb+Np*1.4*Xp/(1.0*Xb)) + 0.5);
    d = d0b;
    break;
  }

  Tmin = (int) floor(bit_rate/(8.0*frame_rate) + 0.5);

  if (T<Tmin)
    T = Tmin;

  S = bitcount();
  Q = 0;

  calc_actj(frame);
  actsum = 0.0;
#ifndef QUIET
  fprintf(statfile,"\nrate control: start of picture\n");
  fprintf(statfile," target number of bits: T=%d\n",T);
#endif
}

static void calc_actj(frame)
unsigned char *frame;
{
  int i,j,k;
  unsigned char *p;
  double actj,var;

  k = 0;

  for (j=0; j<height2; j+=16)
    for (i=0; i<width; i+=16)
    {
      p = frame + ((pict_struct==BOTTOM_FIELD)?width:0) + i + width2*j;

      /* take minimum spatial activity measure of luminance blocks */

      actj = var_sblk(p,width2);
      var = var_sblk(p+8,width2);
      if (var<actj) actj = var;
      var = var_sblk(p+8*width2,width2);
      if (var<actj) actj = var;
      var = var_sblk(p+8*width2+8,width2);
      if (var<actj) actj = var;

      if (!fieldpic && !prog_seq)
      {
        /* field */
        var = var_sblk(p,width<<1);
        if (var<actj) actj = var;
        var = var_sblk(p+8,width<<1);
        if (var<actj) actj = var;
        var = var_sblk(p+width,width<<1);
        if (var<actj) actj = var;
        var = var_sblk(p+width+8,width<<1);
        if (var<actj) actj = var;
      }

      actj+= 1.0;

      mbinfo[k++].act = actj;
    }
}

void rc_update_pict()
{
  double X;

  S = bitcount() - S; /* total # of bits in picture */
  R-= S; /* remaining # of bits in GOP */
  X = (int) floor(S*((0.5*(double)Q)/(mb_width*mb_height2)) + 0.5);
  d+= S - T;
  avg_act = actsum/(mb_width*mb_height2);

  switch (pict_type)
  {
  case I_TYPE:
    Xi = X;
    d0i = d;
    break;
  case P_TYPE:
    Xp = X;
    d0p = d;
    Np--;
    break;
  case B_TYPE:
    Xb = X;
    d0b = d;
    Nb--;
    break;
  }
#ifndef QUIET
  fprintf(statfile,"\nrate control: end of picture\n");
  fprintf(statfile," actual number of bits: S=%d\n",S);
  fprintf(statfile," average quantization parameter Q=%.1f\n",
    (double)Q/(mb_width*mb_height2));
  fprintf(statfile," remaining number of bits in GOP: R=%d\n",R);
  fprintf(statfile,
    " global complexity measures (I,P,B): Xi=%d, Xp=%d, Xb=%d\n",
    Xi, Xp, Xb);
  fprintf(statfile,
    " virtual buffer fullness (I,P,B): d0i=%d, d0p=%d, d0b=%d\n",
    d0i, d0p, d0b);
  fprintf(statfile," remaining number of P pictures in GOP: Np=%d\n",Np);
  fprintf(statfile," remaining number of B pictures in GOP: Nb=%d\n",Nb);
  fprintf(statfile," average activity: avg_act=%.1f\n", avg_act);
#endif
}

/* compute initial quantization stepsize (at the beginning of picture) */
int rc_start_mb()
{
  int mquant;

  if (q_scale_type)
  {
    mquant = (int) floor(2.0*d*31.0/r + 0.5);

    /* clip mquant to legal (linear) range */
    if (mquant<1)
      mquant = 1;
    if (mquant>112)
      mquant = 112;

    /* map to legal quantization level */
    mquant = non_linear_mquant_table[map_non_linear_mquant[mquant]];
  }
  else
  {
    mquant = (int) floor(d*31.0/r + 0.5);
    mquant <<= 1;

    /* clip mquant to legal (linear) range */
    if (mquant<2)
      mquant = 2;
    if (mquant>62)
      mquant = 62;

    prev_mquant = mquant;
  }

#ifdef SHOW_MQUANT
  fprintf(statfile,"rc_start_mb:\n");
  fprintf(statfile,"mquant=%d\n",mquant);
#endif

  return mquant;
}

/* Step 2: measure virtual buffer - estimated buffer discrepancy */
int rc_calc_mquant(j)
int j;
{
  int mquant;
  double dj, Qj, actj, N_actj;

  /* measure virtual buffer discrepancy from uniform distribution model */
  dj = d + (bitcount()-S) - j*(T/(mb_width*mb_height2));

  /* scale against dynamic range of mquant and the bits/picture count */
  Qj = dj*31.0/r;
/*Qj = dj*(q_scale_type ? 56.0 : 31.0)/r;  */

  actj = mbinfo[j].act;
  actsum+= actj;

  /* compute normalized activity */
  N_actj = (2.0*actj+avg_act)/(actj+2.0*avg_act);

  if (q_scale_type)
  {
    /* modulate mquant with combined buffer and local activity measures */
    mquant = (int) floor(2.0*Qj*N_actj + 0.5);

    /* clip mquant to legal (linear) range */
    if (mquant<1)
      mquant = 1;
    if (mquant>112)
      mquant = 112;

    /* map to legal quantization level */
    mquant = non_linear_mquant_table[map_non_linear_mquant[mquant]];
  }
  else
  {
    /* modulate mquant with combined buffer and local activity measures */
    mquant = (int) floor(Qj*N_actj + 0.5);
    mquant <<= 1;

    /* clip mquant to legal (linear) range */
    if (mquant<2)
      mquant = 2;
    if (mquant>62)
      mquant = 62;

    /* ignore small changes in mquant */
    if (mquant>=8 && (mquant-prev_mquant)>=-4 && (mquant-prev_mquant)<=4)
      mquant = prev_mquant;

    prev_mquant = mquant;
  }

  Q+= mquant; /* for calculation of average mquant */

#ifdef SHOW_MQUANT
  fprintf(statfile,"rc_calc_mquant(%d): ",j);
  fprintf(statfile,"bitcount=%d, dj=%f, Qj=%f, actj=%f, N_actj=%f, mquant=%d\n",
    bitcount(),dj,Qj,actj,N_actj,mquant);
#endif

  return mquant;
}

/* compute variance of 8x8 block */
static double var_sblk(p,lx)
unsigned char *p;
int lx;
{
  int i, j;
  unsigned int v, s, s2;

  s = s2 = 0;

  for (j=0; j<8; j++)
  {
    for (i=0; i<8; i++)
    {
      v = *p++;
      s+= v;
      s2+= v*v;
    }
    p+= lx - 8;
  }

  return s2/64.0 - (s/64.0)*(s/64.0);
}

/* VBV calculations
 *
 * generates warnings if underflow or overflow occurs
 */

/* vbv_end_of_picture
 *
 * - has to be called directly after writing picture_data()
 * - needed for accurate VBV buffer overflow calculation
 * - assumes there is no byte stuffing prior to the next start code
 */

static int bitcnt_EOP;

void vbv_end_of_picture()
{
  bitcnt_EOP = bitcount();
  bitcnt_EOP = (bitcnt_EOP + 7) & ~7; /* account for bit stuffing */
}

/* calc_vbv_delay
 *
 * has to be called directly after writing the picture start code, the
 * reference point for vbv_delay
 */

void calc_vbv_delay()
{
  double picture_delay;
  static double next_ip_delay; /* due to frame reordering delay */
  static double decoding_time;

  /* number of 1/90000 s ticks until next picture is to be decoded */
  if (pict_type == B_TYPE)
  {
    if (prog_seq)
    {
      if (!repeatfirst)
        picture_delay = 90000.0/frame_rate; /* 1 frame */
      else
      {
        if (!topfirst)
          picture_delay = 90000.0*2.0/frame_rate; /* 2 frames */
        else
          picture_delay = 90000.0*3.0/frame_rate; /* 3 frames */
      }
    }
    else
    {
      /* interlaced */
      if (fieldpic)
        picture_delay = 90000.0/(2.0*frame_rate); /* 1 field */
      else
      {
        if (!repeatfirst)
          picture_delay = 90000.0*2.0/(2.0*frame_rate); /* 2 flds */
        else
          picture_delay = 90000.0*3.0/(2.0*frame_rate); /* 3 flds */
      }
    }
  }
  else
  {
    /* I or P picture */
    if (fieldpic)
    {
      if(topfirst==(pict_struct==TOP_FIELD))
      {
        /* first field */
        picture_delay = 90000.0/(2.0*frame_rate);
      }
      else
      {
        /* second field */
        /* take frame reordering delay into account */
        picture_delay = next_ip_delay - 90000.0/(2.0*frame_rate);
      }
    }
    else
    {
      /* frame picture */
      /* take frame reordering delay into account*/
      picture_delay = next_ip_delay;
    }

    if (!fieldpic || topfirst!=(pict_struct==TOP_FIELD))
    {
      /* frame picture or second field */
      if (prog_seq)
      {
        if (!repeatfirst)
          next_ip_delay = 90000.0/frame_rate;
        else
        {
          if (!topfirst)
            next_ip_delay = 90000.0*2.0/frame_rate;
          else
            next_ip_delay = 90000.0*3.0/frame_rate;
        }
      }
      else
      {
        if (fieldpic)
          next_ip_delay = 90000.0/(2.0*frame_rate);
        else
        {
          if (!repeatfirst)
            next_ip_delay = 90000.0*2.0/(2.0*frame_rate);
          else
            next_ip_delay = 90000.0*3.0/(2.0*frame_rate);
        }
      }
    }
  }

  if (decoding_time==0.0)
  {
    /* first call of calc_vbv_delay */
    /* we start with a 7/8 filled VBV buffer (12.5% back-off) */
    picture_delay = ((vbv_buffer_size*16384*7)/8)*90000.0/bit_rate;
    if (fieldpic)
      next_ip_delay = (int)(90000.0/frame_rate+0.5);
  }

  /* VBV checks */

  /* check for underflow (previous picture) */
  if (!low_delay && (decoding_time < bitcnt_EOP*90000.0/bit_rate))
  {
    /* picture not completely in buffer at intended decoding time */
    if (!quiet)
      fprintf(stderr,"vbv_delay underflow! (decoding_time=%.1f, t_EOP=%.1f\n)",
        decoding_time, bitcnt_EOP*90000.0/bit_rate);
  }

  /* when to decode current frame */
  decoding_time += picture_delay;

  /* warning: bitcount() may overflow (e.g. after 9 min. at 8 Mbit/s */
  vbv_delay = (int)(decoding_time - bitcount()*90000.0/bit_rate);

  /* check for overflow (current picture) */
  if ((decoding_time - bitcnt_EOP*90000.0/bit_rate)
      > (vbv_buffer_size*16384)*90000.0/bit_rate)
  {
    if (!quiet)
      fprintf(stderr,"vbv_delay overflow!\n");
  }

#ifndef QUIET
  fprintf(statfile,
    "\nvbv_delay=%d (bitcount=%d, decoding_time=%.2f, bitcnt_EOP=%d)\n",
    vbv_delay,bitcount(),decoding_time,bitcnt_EOP);
#endif

  if (vbv_delay<0)
  {
    if (!quiet)
      fprintf(stderr,"vbv_delay underflow: %d\n",vbv_delay);
    vbv_delay = 0;
  }

  if (vbv_delay>65535)
  {
    if (!quiet)
      fprintf(stderr,"vbv_delay overflow: %d\n",vbv_delay);
    vbv_delay = 65535;
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* readpic.c, read source pictures                                          */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "global.h"

/* private prototypes */
static void read_y_u_v _ANSI_ARGS_((char *fname, unsigned char *frame[]));
static void read_yuv _ANSI_ARGS_((char *fname, unsigned char *frame[]));
static void read_ppm _ANSI_ARGS_((char *fname, unsigned char *frame[]));
static void border_extend _ANSI_ARGS_((unsigned char *frame, int w1, int h1,
  int w2, int h2));
static void conv444to422 _ANSI_ARGS_((unsigned char *src, unsigned char *dst));
static void conv422to420 _ANSI_ARGS_((unsigned char *src, unsigned char *dst));
static int pbm_getint _ANSI_ARGS_((FILE* file));

void readframe(fname,frame)
char *fname;
unsigned char *frame[];
{
  switch (inputtype)
  {
  case T_Y_U_V:
    read_y_u_v(fname,frame);
    break;
  case T_YUV:
    read_yuv(fname,frame);
    break;
  case T_PPM:
    read_ppm(fname,frame);
    break;
  default:
    break;
  }
}

static void read_y_u_v(fname,frame)
char *fname;
unsigned char *frame[];
{
  int i;
  int chrom_hsize, chrom_vsize;
  char name[128];
  FILE *fd;

  chrom_hsize = (chroma_format==CHROMA444) ? horizontal_size
                                           : horizontal_size>>1;
  chrom_vsize = (chroma_format!=CHROMA420) ? vertical_size
                                           : vertical_size>>1;

  sprintf(name,"%s.Y",fname);
  if (!(fd = fopen(name,"rb")))
  {
    sprintf(errortext,"Couldn't open %s\n",name);
    error(errortext);
  }
  for (i=0; i<vertical_size; i++)
    fread(frame[0]+i*width,1,horizontal_size,fd);
  fclose(fd);
  border_extend(frame[0],horizontal_size,vertical_size,width,height);

  sprintf(name,"%s.U",fname);
  if (!(fd = fopen(name,"rb")))
  {
    sprintf(errortext,"Couldn't open %s\n",name);
    error(errortext);
  }
  for (i=0; i<chrom_vsize; i++)
    fread(frame[1]+i*chrom_width,1,chrom_hsize,fd);
  fclose(fd);
  border_extend(frame[1],chrom_hsize,chrom_vsize,chrom_width,chrom_height);

  sprintf(name,"%s.V",fname);
  if (!(fd = fopen(name,"rb")))
  {
    sprintf(errortext,"Couldn't open %s\n",name);
    error(errortext);
  }
  for (i=0; i<chrom_vsize; i++)
    fread(frame[2]+i*chrom_width,1,chrom_hsize,fd);
  fclose(fd);
  border_extend(frame[2],chrom_hsize,chrom_vsize,chrom_width,chrom_height);
}

static void read_yuv(fname,frame)
char *fname;
unsigned char *frame[];
{
  int i;
  int chrom_hsize, chrom_vsize;
  char name[128];
  FILE *fd;

  chrom_hsize = (chroma_format==CHROMA444) ? horizontal_size
                                           : horizontal_size>>1;
  chrom_vsize = (chroma_format!=CHROMA420) ? vertical_size
                                           : vertical_size>>1;

  sprintf(name,"%s.yuv",fname);
  if (!(fd = fopen(name,"rb")))
  {
    sprintf(errortext,"Couldn't open %s\n",name);
    error(errortext);
  }

  /* Y */
  for (i=0; i<vertical_size; i++)
    fread(frame[0]+i*width,1,horizontal_size,fd);
  border_extend(frame[0],horizontal_size,vertical_size,width,height);

  /* Cb */
  for (i=0; i<chrom_vsize; i++)
    fread(frame[1]+i*chrom_width,1,chrom_hsize,fd);
  border_extend(frame[1],chrom_hsize,chrom_vsize,chrom_width,chrom_height);

  /* Cr */
  for (i=0; i<chrom_vsize; i++)
    fread(frame[2]+i*chrom_width,1,chrom_hsize,fd);
  border_extend(frame[2],chrom_hsize,chrom_vsize,chrom_width,chrom_height);

  fclose(fd);
}

static void read_ppm(fname,frame)
char *fname;
unsigned char *frame[];
{
  int i, j;
  int r, g, b;
  double y, u, v;
  double cr, cg, cb, cu, cv;
  char name[128];
  FILE *fd;
  unsigned char *yp, *up, *vp;
  static unsigned char *u444, *v444, *u422, *v422;
  static double coef[7][3] = {
    {0.2125,0.7154,0.0721}, /* ITU-R Rec. 709 (1990) */
    {0.299, 0.587, 0.114},  /* unspecified */
    {0.299, 0.587, 0.114},  /* reserved */
    {0.30,  0.59,  0.11},   /* FCC */
    {0.299, 0.587, 0.114},  /* ITU-R Rec. 624-4 System B, G */
    {0.299, 0.587, 0.114},  /* SMPTE 170M */
    {0.212, 0.701, 0.087}}; /* SMPTE 240M (1987) */

  i = matrix_coefficients;
  if (i>8)
    i = 3;

  cr = coef[i-1][0];
  cg = coef[i-1][1];
  cb = coef[i-1][2];
  cu = 0.5/(1.0-cb);
  cv = 0.5/(1.0-cr);

  if (chroma_format==CHROMA444)
  {
    u444 = frame[1];
    v444 = frame[2];
  }
  else
  {
    if (!u444)
    {
      if (!(u444 = (unsigned char *)malloc(width*height)))
        error("malloc failed");
      if (!(v444 = (unsigned char *)malloc(width*height)))
        error("malloc failed");
      if (chroma_format==CHROMA420)
      {
        if (!(u422 = (unsigned char *)malloc((width>>1)*height)))
          error("malloc failed");
        if (!(v422 = (unsigned char *)malloc((width>>1)*height)))
          error("malloc failed");
      }
    }
  }

  sprintf(name,"%s.ppm",fname);

  if (!(fd = fopen(name,"rb")))
  {
    sprintf(errortext,"Couldn't open %s\n",name);
    error(errortext);
  }

  /* skip header */
  fgetc(fd); fgetc(fd); /* magic number (P6) */
  pbm_getint(fd); pbm_getint(fd); pbm_getint(fd); /* width height maxcolors */

  for (i=0; i<vertical_size; i++)
  {
    yp = frame[0] + i*width;
    up = u444 + i*width;
    vp = v444 + i*width;

    for (j=0; j<horizontal_size; j++)
    {
      r=fgetc(fd); g=fgetc(fd); b=fgetc(fd);
      /* convert to YUV */
      y = cr*r + cg*g + cb*b;
      u = cu*(b-y);
      v = cv*(r-y);
      yp[j] = (219.0/256.0)*y + 16.5;  /* nominal range: 16..235 */
      up[j] = (224.0/256.0)*u + 128.5; /* 16..240 */
      vp[j] = (224.0/256.0)*v + 128.5; /* 16..240 */
    }
  }
  fclose(fd);

  border_extend(frame[0],horizontal_size,vertical_size,width,height);
  border_extend(u444,horizontal_size,vertical_size,width,height);
  border_extend(v444,horizontal_size,vertical_size,width,height);

  if (chroma_format==CHROMA422)
  {
    conv444to422(u444,frame[1]);
    conv444to422(v444,frame[2]);
  }

  if (chroma_format==CHROMA420)
  {
    conv444to422(u444,u422);
    conv444to422(v444,v422);
    conv422to420(u422,frame[1]);
    conv422to420(v422,frame[2]);
  }
}

static void border_extend(frame,w1,h1,w2,h2)
unsigned char *frame;
int w1,h1,w2,h2;
{
  int i, j;
  unsigned char *fp;

  /* horizontal pixel replication (right border) */

  for (j=0; j<h1; j++)
  {
    fp = frame + j*w2;
    for (i=w1; i<w2; i++)
      fp[i] = fp[i-1];
  }

  /* vertical pixel replication (bottom border) */

  for (j=h1; j<h2; j++)
  {
    fp = frame + j*w2;
    for (i=0; i<w2; i++)
      fp[i] = fp[i-w2];
  }
}

/* horizontal filter and 2:1 subsampling */
static void conv444to422(src,dst)
unsigned char *src, *dst;
{
  int i, j, im5, im4, im3, im2, im1, ip1, ip2, ip3, ip4, ip5, ip6;

  if (mpeg1)
  {
    for (j=0; j<height; j++)
    {
      for (i=0; i<width; i+=2)
      {
        im5 = (i<5) ? 0 : i-5;
        im4 = (i<4) ? 0 : i-4;
        im3 = (i<3) ? 0 : i-3;
        im2 = (i<2) ? 0 : i-2;
        im1 = (i<1) ? 0 : i-1;
        ip1 = (i<width-1) ? i+1 : width-1;
        ip2 = (i<width-2) ? i+2 : width-1;
        ip3 = (i<width-3) ? i+3 : width-1;
        ip4 = (i<width-4) ? i+4 : width-1;
        ip5 = (i<width-5) ? i+5 : width-1;
        ip6 = (i<width-5) ? i+6 : width-1;

        /* FIR filter with 0.5 sample interval phase shift */
        dst[i>>1] = clp[(int)(228*(src[i]+src[ip1])
                         +70*(src[im1]+src[ip2])
                         -37*(src[im2]+src[ip3])
                         -21*(src[im3]+src[ip4])
                         +11*(src[im4]+src[ip5])
                         + 5*(src[im5]+src[ip6])+256)>>9];
      }
      src+= width;
      dst+= width>>1;
    }
  }
  else
  {
    /* MPEG-2 */
    for (j=0; j<height; j++)
    {
      for (i=0; i<width; i+=2)
      {
        im5 = (i<5) ? 0 : i-5;
        im3 = (i<3) ? 0 : i-3;
        im1 = (i<1) ? 0 : i-1;
        ip1 = (i<width-1) ? i+1 : width-1;
        ip3 = (i<width-3) ? i+3 : width-1;
        ip5 = (i<width-5) ? i+5 : width-1;

        /* FIR filter coefficients (*512): 22 0 -52 0 159 256 159 0 -52 0 22 */
        dst[i>>1] = clp[(int)(  22*(src[im5]+src[ip5])-52*(src[im3]+src[ip3])
                         +159*(src[im1]+src[ip1])+256*src[i]+256)>>9];
      }
      src+= width;
      dst+= width>>1;
    }
  }
}

/* vertical filter and 2:1 subsampling */
static void conv422to420(src,dst)
unsigned char *src, *dst;
{
  int w, i, j, jm6, jm5, jm4, jm3, jm2, jm1;
  int jp1, jp2, jp3, jp4, jp5, jp6;

  w = width>>1;

  if (prog_frame)
  {
    /* intra frame */
    for (i=0; i<w; i++)
    {
      for (j=0; j<height; j+=2)
      {
        jm5 = (j<5) ? 0 : j-5;
        jm4 = (j<4) ? 0 : j-4;
        jm3 = (j<3) ? 0 : j-3;
        jm2 = (j<2) ? 0 : j-2;
        jm1 = (j<1) ? 0 : j-1;
        jp1 = (j<height-1) ? j+1 : height-1;
        jp2 = (j<height-2) ? j+2 : height-1;
        jp3 = (j<height-3) ? j+3 : height-1;
        jp4 = (j<height-4) ? j+4 : height-1;
        jp5 = (j<height-5) ? j+5 : height-1;
        jp6 = (j<height-5) ? j+6 : height-1;

        /* FIR filter with 0.5 sample interval phase shift */
        dst[w*(j>>1)] = clp[(int)(228*(src[w*j]+src[w*jp1])
                             +70*(src[w*jm1]+src[w*jp2])
                             -37*(src[w*jm2]+src[w*jp3])
                             -21*(src[w*jm3]+src[w*jp4])
                             +11*(src[w*jm4]+src[w*jp5])
                             + 5*(src[w*jm5]+src[w*jp6])+256)>>9];
      }
      src++;
      dst++;
    }
  }
  else
  {
    /* intra field */
    for (i=0; i<w; i++)
    {
      for (j=0; j<height; j+=4)
      {
        /* top field */
        jm5 = (j<10) ? 0 : j-10;
        jm4 = (j<8) ? 0 : j-8;
        jm3 = (j<6) ? 0 : j-6;
        jm2 = (j<4) ? 0 : j-4;
        jm1 = (j<2) ? 0 : j-2;
        jp1 = (j<height-2) ? j+2 : height-2;
        jp2 = (j<height-4) ? j+4 : height-2;
        jp3 = (j<height-6) ? j+6 : height-2;
        jp4 = (j<height-8) ? j+8 : height-2;
        jp5 = (j<height-10) ? j+10 : height-2;
        jp6 = (j<height-12) ? j+12 : height-2;

        /* FIR filter with 0.25 sample interval phase shift */
        dst[w*(j>>1)] = clp[(int)(8*src[w*jm5]
                            +5*src[w*jm4]
                           -30*src[w*jm3]
                           -18*src[w*jm2]
                          +113*src[w*jm1]
                          +242*src[w*j]
                          +192*src[w*jp1]
                           +35*src[w*jp2]
                           -38*src[w*jp3]
                           -10*src[w*jp4]
                           +11*src[w*jp5]
                            +2*src[w*jp6]+256)>>9];

        /* bottom field */
        jm6 = (j<9) ? 1 : j-9;
        jm5 = (j<7) ? 1 : j-7;
        jm4 = (j<5) ? 1 : j-5;
        jm3 = (j<3) ? 1 : j-3;
        jm2 = (j<1) ? 1 : j-1;
        jm1 = (j<height-1) ? j+1 : height-1;
        jp1 = (j<height-3) ? j+3 : height-1;
        jp2 = (j<height-5) ? j+5 : height-1;
        jp3 = (j<height-7) ? j+7 : height-1;
        jp4 = (j<height-9) ? j+9 : height-1;
        jp5 = (j<height-11) ? j+11 : height-1;
        jp6 = (j<height-13) ? j+13 : height-1;

        /* FIR filter with 0.25 sample interval phase shift */
        dst[w*((j>>1)+1)] = clp[(int)(8*src[w*jp6]
                                +5*src[w*jp5]
                               -30*src[w*jp4]
                               -18*src[w*jp3]
                              +113*src[w*jp2]
                              +242*src[w*jp1]
                              +192*src[w*jm1]
                               +35*src[w*jm2]
                               -38*src[w*jm3]
                               -10*src[w*jm4]
                               +11*src[w*jm5]
                                +2*src[w*jm6]+256)>>9];
      }
      src++;
      dst++;
    }
  }
}

/* pbm_getc() and pbm_getint() are essentially taken from
 * PBMPLUS (C) Jef Poskanzer
 * but without error/EOF checking
 */
char pbm_getc(file)
FILE* file;
{
  char ch;

  ch = fgetc(file);

  if (ch=='#')
  {
    do
    {
      ch = fgetc(file);
    }
    while (ch!='\n' && ch!='\r');
  }

  return ch;
}

int pbm_getint(file)
FILE* file;
{
  char ch;
  int i;

  do
  {
    ch = pbm_getc(file);
  }
  while (ch==' ' || ch=='\t' || ch=='\n' || ch=='\r');

  i = 0;
  do
  {
    i = i*10 + ch-'0';
    ch = pbm_getc(file);
  }
  while (ch>='0' && ch<='9');

  return i;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* stats.c, coding statistics                                               */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <math.h>
#include "config.h"
#include "global.h"

/* private prototypes */
static void calcSNR1 _ANSI_ARGS_((unsigned char *org, unsigned char *rec,
  int lx, int w, int h, double *pv, double *pe));


void calcSNR(org,rec)
unsigned char *org[3];
unsigned char *rec[3];
{
  int w,h,offs;
  double v,e;

  w = horizontal_size;
  h = (pict_struct==FRAME_PICTURE) ? vertical_size : (vertical_size>>1);
  offs = (pict_struct==BOTTOM_FIELD) ? width : 0;

  calcSNR1(org[0]+offs,rec[0]+offs,width2,w,h,&v,&e);
  fprintf(statfile,"Y: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
    v, e, 10.0*log10(255.0*255.0/e), 10.0*log10(v/e));

  if (chroma_format!=CHROMA444)
  {
    w >>= 1;
    offs >>= 1;
  }

  if (chroma_format==CHROMA420)
    h >>= 1;

  calcSNR1(org[1]+offs,rec[1]+offs,chrom_width2,w,h,&v,&e);
  fprintf(statfile,"U: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
    v, e, 10.0*log10(255.0*255.0/e), 10.0*log10(v/e));

  calcSNR1(org[2]+offs,rec[2]+offs,chrom_width2,w,h,&v,&e);
  fprintf(statfile,"V: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
    v, e, 10.0*log10(255.0*255.0/e), 10.0*log10(v/e));
}

static void calcSNR1(org,rec,lx,w,h,pv,pe)
unsigned char *org;
unsigned char *rec;
int lx,w,h;
double *pv,*pe;
{
  int i, j;
  double v1, s1, s2, e2;

  s1 = s2 = e2 = 0.0;

  for (j=0; j<h; j++)
  {
    for (i=0; i<w; i++)
    {
      v1 = org[i];
      s1+= v1;
      s2+= v1*v1;
      v1-= rec[i];
      e2+= v1*v1;
    }
    org += lx;
    rec += lx;
  }

  s1 /= w*h;
  s2 /= w*h;
  e2 /= w*h;

  /* prevent division by zero in calcSNR() */
  if(e2==0.0)
    e2 = 0.00001;

  *pv = s2 - s1*s1; /* variance */
  *pe = e2;         /* MSE */
}

void stats()
{
  int i, j, k, nmb, mb_type;
  int n_skipped, n_intra, n_ncoded, n_blocks, n_interp, n_forward, n_backward;
  struct mbinfo *mbi;

  nmb = mb_width*mb_height2;

  n_skipped=n_intra=n_ncoded=n_blocks=n_interp=n_forward=n_backward=0;

  for (k=0; k<nmb; k++)
  {
    mbi = mbinfo+k;
    if (mbi->skipped)
      n_skipped++;
    else if (mbi->mb_type & MB_INTRA)
      n_intra++;
    else if (!(mbi->mb_type & MB_PATTERN))
      n_ncoded++;

    for (i=0; i<block_count; i++)
      if (mbi->cbp & (1<<i))
        n_blocks++;

    if (mbi->mb_type & MB_FORWARD)
    {
      if (mbi->mb_type & MB_BACKWARD)
        n_interp++;
      else
        n_forward++;
    }
    else if (mbi->mb_type & MB_BACKWARD)
      n_backward++;
  }

  fprintf(statfile,"\npicture statistics:\n");
  fprintf(statfile," # of intra coded macroblocks:  %4d (%.1f%%)\n",
    n_intra,100.0*(double)n_intra/nmb);
  fprintf(statfile," # of coded blocks:             %4d (%.1f%%)\n",
    n_blocks,100.0*(double)n_blocks/(block_count*nmb));
  fprintf(statfile," # of not coded macroblocks:    %4d (%.1f%%)\n",
    n_ncoded,100.0*(double)n_ncoded/nmb);
  fprintf(statfile," # of skipped macroblocks:      %4d (%.1f%%)\n",
    n_skipped,100.0*(double)n_skipped/nmb);
  fprintf(statfile," # of forw. pred. macroblocks:  %4d (%.1f%%)\n",
    n_forward,100.0*(double)n_forward/nmb);
  fprintf(statfile," # of backw. pred. macroblocks: %4d (%.1f%%)\n",
    n_backward,100.0*(double)n_backward/nmb);
  fprintf(statfile," # of interpolated macroblocks: %4d (%.1f%%)\n",
    n_interp,100.0*(double)n_interp/nmb);

  fprintf(statfile,"\nmacroblock_type map:\n");

  k = 0;

  for (j=0; j<mb_height2; j++)
  {
    for (i=0; i<mb_width; i++)
    {
      mbi = mbinfo + k;
      mb_type = mbi->mb_type;
      if (mbi->skipped)
        fputc('S',statfile);
      else if (mb_type & MB_INTRA)
        fputc('I',statfile);
      else switch (mb_type & (MB_FORWARD|MB_BACKWARD))
      {
      case MB_FORWARD:
        fputc(mbi->motion_type==MC_FIELD ? 'f' :
             mbi->motion_type==MC_DMV   ? 'p' :
                                          'F',statfile); break;
      case MB_BACKWARD:
        fputc(mbi->motion_type==MC_FIELD ? 'b' :
                                          'B',statfile); break;
      case MB_FORWARD|MB_BACKWARD:
        fputc(mbi->motion_type==MC_FIELD ? 'd' :
                                          'D',statfile); break;
      default:
        fputc('0',statfile); break;
      }

      if (mb_type & MB_QUANT)
        fputc('Q',statfile);
      else if (mb_type & (MB_PATTERN|MB_INTRA))
        fputc(' ',statfile);
      else
        fputc('N',statfile);

      fputc(' ',statfile);

      k++;
    }
    fputc('\n',statfile);
  }

  fprintf(statfile,"\nmquant map:\n");

  k=0;
  for (j=0; j<mb_height2; j++)
  {
    for (i=0; i<mb_width; i++)
    {
      if (i==0 || mbinfo[k].mquant!=mbinfo[k-1].mquant)
        fprintf(statfile,"%3d",mbinfo[k].mquant);
      else
        fprintf(statfile,"   ");

      k++;
    }
    fputc('\n',statfile);
  }

#if 0
  fprintf(statfile,"\ncbp map:\n");

  k=0;
  for (j=0; j<mb_height2; j++)
  {
    for (i=0; i<mb_width; i++)
    {
      fprintf(statfile,"%02x ",mbinfo[k].cbp);

      k++;
    }
    fputc('\n',statfile);
  }

  if (pict_struct==FRAME_PICTURE && !frame_pred_dct)
  {
    fprintf(statfile,"\ndct_type map:\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & (MB_PATTERN|MB_INTRA))
          fprintf(statfile,"%d  ",mbinfo[k].dct_type);
        else
          fprintf(statfile,"   ");
  
        k++;
      }
      fputc('\n',statfile);
    }
  }

  if (pict_type!=I_TYPE)
  {
    fprintf(statfile,"\nforward motion vectors (first vector, horizontal):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_FORWARD)
          fprintf(statfile,"%4d",mbinfo[k].MV[0][0][0]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nforward motion vectors (first vector, vertical):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_FORWARD)
          fprintf(statfile,"%4d",mbinfo[k].MV[0][0][1]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nforward motion vectors (second vector, horizontal):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_FORWARD
            && ((pict_struct==FRAME_PICTURE && mbinfo[k].motion_type==MC_FIELD) ||
                (pict_struct!=FRAME_PICTURE && mbinfo[k].motion_type==MC_16X8)))
          fprintf(statfile,"%4d",mbinfo[k].MV[1][0][0]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nforward motion vectors (second vector, vertical):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_FORWARD
            && ((pict_struct==FRAME_PICTURE && mbinfo[k].motion_type==MC_FIELD) ||
                (pict_struct!=FRAME_PICTURE && mbinfo[k].motion_type==MC_16X8)))
          fprintf(statfile,"%4d",mbinfo[k].MV[1][0][1]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }


  }
    
  if (pict_type==B_TYPE)
  {
    fprintf(statfile,"\nbackward motion vectors (first vector, horizontal):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_BACKWARD)
          fprintf(statfile,"%4d",mbinfo[k].MV[0][1][0]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nbackward motion vectors (first vector, vertical):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_BACKWARD)
          fprintf(statfile,"%4d",mbinfo[k].MV[0][1][1]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nbackward motion vectors (second vector, horizontal):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_BACKWARD
            && ((pict_struct==FRAME_PICTURE && mbinfo[k].motion_type==MC_FIELD) ||
                (pict_struct!=FRAME_PICTURE && mbinfo[k].motion_type==MC_16X8)))
          fprintf(statfile,"%4d",mbinfo[k].MV[1][1][0]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }

    fprintf(statfile,"\nbackward motion vectors (second vector, vertical):\n");

    k=0;
    for (j=0; j<mb_height2; j++)
    {
      for (i=0; i<mb_width; i++)
      {
        if (mbinfo[k].mb_type & MB_BACKWARD
            && ((pict_struct==FRAME_PICTURE && mbinfo[k].motion_type==MC_FIELD) ||
                (pict_struct!=FRAME_PICTURE && mbinfo[k].motion_type==MC_16X8)))
          fprintf(statfile,"%4d",mbinfo[k].MV[1][1][1]);
        else
          fprintf(statfile,"   .");
  
        k++;
      }
      fputc('\n',statfile);
    }


  }
#endif
    
#if 0
  /* useful for debugging */
  fprintf(statfile,"\nmacroblock info dump:\n");

  k=0;
  for (j=0; j<mb_height2; j++)
  {
    for (i=0; i<mb_width; i++)
    {
      fprintf(statfile,"%d: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
      k,
      mbinfo[k].mb_type,
      mbinfo[k].motion_type,
      mbinfo[k].dct_type,
      mbinfo[k].mquant,
      mbinfo[k].cbp,
      mbinfo[k].skipped,
      mbinfo[k].MV[0][0][0],
      mbinfo[k].MV[0][0][1],
      mbinfo[k].MV[0][1][0],
      mbinfo[k].MV[0][1][1],
      mbinfo[k].MV[1][0][0],
      mbinfo[k].MV[1][0][1],
      mbinfo[k].MV[1][1][0],
      mbinfo[k].MV[1][1][1],
      mbinfo[k].mv_field_sel[0][0],
      mbinfo[k].mv_field_sel[0][1],
      mbinfo[k].mv_field_sel[1][0],
      mbinfo[k].mv_field_sel[1][1]);

      k++;
    }
  }
#endif
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* transfrm.c,  forward / inverse transformation                            */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <math.h>
#include "config.h"
#include "global.h"

/* private prototypes*/
static void add_pred _ANSI_ARGS_((unsigned char *pred, unsigned char *cur,
  int lx, short *blk));
static void sub_pred _ANSI_ARGS_((unsigned char *pred, unsigned char *cur,
  int lx, short *blk));

/* subtract prediction and transform prediction error */
void transform(pred,cur,mbi,blocks)
unsigned char *pred[], *cur[];
struct mbinfo *mbi;
short blocks[][64];
{
  int i, j, i1, j1, k, n, cc, offs, lx;

  k = 0;

  for (j=0; j<height2; j+=16)
    for (i=0; i<width; i+=16)
    {
      for (n=0; n<block_count; n++)
      {
        cc = (n<4) ? 0 : (n&1)+1; /* color component index */
        if (cc==0)
        {
          /* luminance */
          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type)
          {
            /* field DCT */
            offs = i + ((n&1)<<3) + width*(j+((n&2)>>1));
            lx = width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i + ((n&1)<<3) + width2*(j+((n&2)<<2));
            lx = width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += width;
        }
        else
        {
          /* chrominance */

          /* scale coordinates */
          i1 = (chroma_format==CHROMA444) ? i : i>>1;
          j1 = (chroma_format!=CHROMA420) ? j : j>>1;

          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type
              && (chroma_format!=CHROMA420))
          {
            /* field DCT */
            offs = i1 + (n&8) + chrom_width*(j1+((n&2)>>1));
            lx = chrom_width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i1 + (n&8) + chrom_width2*(j1+((n&2)<<2));
            lx = chrom_width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += chrom_width;
        }

	/* Note: sub pred writes into v1 (block) and fdct uses (v1) */

        sub_pred(pred[cc]+offs,cur[cc]+offs,lx,blocks[k*block_count+n]);
        fdct(blocks[k*block_count+n]);
      }

      k++;
    }

}


#ifdef LTHREAD
void pttransform(pred,cur,mbi,blocks,start_height,end_height)
unsigned char *pred[], *cur[];
struct mbinfo *mbi;
short blocks[][64];
int start_height,end_height;
{
  int i, j, i1, j1, k, n, cc, offs, lx;

  k = (start_height>>4)*(width>>4);

  for (j=start_height; j<end_height; j+=16)
    for (i=0; i<width; i+=16)
    {
      for (n=0; n<block_count; n++)
      {
        cc = (n<4) ? 0 : (n&1)+1; /* color component index */
        if (cc==0)
        {
          /* luminance */
          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type)
          {
            /* field DCT */
            offs = i + ((n&1)<<3) + width*(j+((n&2)>>1));
            lx = width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i + ((n&1)<<3) + width2*(j+((n&2)<<2));
            lx = width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += width;
        }
        else
        {
          /* chrominance */

          /* scale coordinates */
          i1 = (chroma_format==CHROMA444) ? i : i>>1;
          j1 = (chroma_format!=CHROMA420) ? j : j>>1;

          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type
              && (chroma_format!=CHROMA420))
          {
            /* field DCT */
            offs = i1 + (n&8) + chrom_width*(j1+((n&2)>>1));
            lx = chrom_width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i1 + (n&8) + chrom_width2*(j1+((n&2)<<2));
            lx = chrom_width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += chrom_width;
        }

	/* Note: sub pred writes into v1 (block) and fdct uses (v1) */

        sub_pred(pred[cc]+offs,cur[cc]+offs,lx,blocks[k*block_count+n]);
        fdct(blocks[k*block_count+n]);
      }

      k++;
    }

}

void ptitransform(pred,cur,mbi,blocks,start_height,end_height)
unsigned char *pred[],*cur[];
struct mbinfo *mbi;
short blocks[][64];
int start_height, end_height;
{
  int i, j, i1, j1, k, n, cc, offs, lx;


  k = (start_height>>4)*(width>>4);

  for (j=start_height; j<end_height; j+=16)
    for (i=0; i<width; i+=16)
    {
      for (n=0; n<block_count; n++)
      {
        cc = (n<4) ? 0 : (n&1)+1; /* color component index */

        if (cc==0)
        {
          /* luminance */
          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type)
          {
            /* field DCT */
            offs = i + ((n&1)<<3) + width*(j+((n&2)>>1));
            lx = width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i + ((n&1)<<3) + width2*(j+((n&2)<<2));
            lx = width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += width;
        }
        else
        {
          /* chrominance */

          /* scale coordinates */
          i1 = (chroma_format==CHROMA444) ? i : i>>1;
          j1 = (chroma_format!=CHROMA420) ? j : j>>1;

          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type
              && (chroma_format!=CHROMA420))
          {
            /* field DCT */
            offs = i1 + (n&8) + chrom_width*(j1+((n&2)>>1));
            lx = chrom_width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i1 + (n&8) + chrom_width2*(j1+((n&2)<<2));
            lx = chrom_width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += chrom_width;
        }

        idct(blocks[k*block_count+n]);
        add_pred(pred[cc]+offs,cur[cc]+offs,lx,blocks[k*block_count+n]);
      }

      k++;
    }

}

#endif

/* inverse transform prediction error and add prediction */
void itransform(pred,cur,mbi,blocks)
unsigned char *pred[],*cur[];
struct mbinfo *mbi;
short blocks[][64];
{
  int i, j, i1, j1, k, n, cc, offs, lx;

  k = 0;

  for (j=0; j<height2; j+=16)
    for (i=0; i<width; i+=16)
    {
      for (n=0; n<block_count; n++)
      {
        cc = (n<4) ? 0 : (n&1)+1; /* color component index */

        if (cc==0)
        {
          /* luminance */
          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type)
          {
            /* field DCT */
            offs = i + ((n&1)<<3) + width*(j+((n&2)>>1));
            lx = width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i + ((n&1)<<3) + width2*(j+((n&2)<<2));
            lx = width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += width;
        }
        else
        {
          /* chrominance */

          /* scale coordinates */
          i1 = (chroma_format==CHROMA444) ? i : i>>1;
          j1 = (chroma_format!=CHROMA420) ? j : j>>1;

          if ((pict_struct==FRAME_PICTURE) && mbi[k].dct_type
              && (chroma_format!=CHROMA420))
          {
            /* field DCT */
            offs = i1 + (n&8) + chrom_width*(j1+((n&2)>>1));
            lx = chrom_width<<1;
          }
          else
          {
            /* frame DCT */
            offs = i1 + (n&8) + chrom_width2*(j1+((n&2)<<2));
            lx = chrom_width2;
          }

          if (pict_struct==BOTTOM_FIELD)
            offs += chrom_width;
        }

        idct(blocks[k*block_count+n]);
        add_pred(pred[cc]+offs,cur[cc]+offs,lx,blocks[k*block_count+n]);
      }

      k++;
    }

}

/* add prediction and prediction error, saturate to 0...255 */
static void add_pred(pred,cur,lx,blk)
unsigned char *pred, *cur;
int lx;
short *blk;
{
  int i, j;
#ifdef SSE2
  const short upper[8]={255,255,255,255,
			255,255,255,255};

  __asm {
    movdqu xmm5, [upper] ;
    mov	  ebx,	[blk]	; /*load the address of blk in ebx*/
    mov	  edx,	[pred]	;/*  load the address of pred in edx */
    mov     eax,  [lx]    ;
    mov     esi, [cur]    ;
    mov     edi, eax      ;
    sal     edi, 1        ;
    mov     ecx,  4       ;
    pxor    xmm4, xmm4    ;
    
  add_pred_loop:
    movdqu  xmm0, [ebx]     ;/* load 8W from blk */
    movdqu  xmm2, [ebx+16]  ;
    movq  xmm1, [edx]      ;/* load 8B from pred */
    movq  xmm3, [edx+eax]  ;/* load another 8B from pred */

    punpcklbw xmm1, xmm4  ; /*unpack bytes to words */
    punpcklbw xmm3, xmm4  ;

    paddsw xmm1, xmm0    ;/*add signed words */
    paddsw xmm3, xmm2    ;

    pminsw xmm1, xmm5    ;
    pminsw xmm3, xmm5    ;
    pmaxsw xmm1, xmm4    ;
    pmaxsw xmm3, xmm4    ;

    packuswb xmm1, xmm1  ; /* pack words to bytes */
    packuswb xmm3, xmm3  ;
    
    movq  [esi], xmm1        ; 
    movq  [esi+eax], xmm3    ;

    add     ebx, 32      ;
    add     edx, edi      ;
    add     esi, edi      ;
    sub     ecx, 1        ;
    cmp     ecx, 0        ;
    jnz     add_pred_loop ;
  }
#else
  for (j=0; j<8; j++)
  {

    for (i=0; i<8; i++)
      cur[i] = clp[blk[i] + pred[i]];
    blk+= 8;
    cur+= lx;
    pred+= lx;
  }
#endif


}

/* subtract prediction from block data */
static void sub_pred(pred,cur,lx,blk)
unsigned char *pred, *cur;
int lx;
short *blk;
{

  int i, j;
#ifdef SSE2
  __asm {
    mov	  ebx,	[blk]	; /*load the address of blk in ebx*/
    mov	  edx,	[pred]	;/*  load the address of pred in edx */
    mov     eax,  [lx]    ;
    mov     esi, [cur]    ;
    mov     edi, eax      ;
    sal     edi, 1        ;
    mov     ecx,  4       ;
    pxor xmm4, xmm4    ;
    
  sub_pred_loop:
    movq  xmm0, [esi]     ;/* load 8B from cur */
    movq  xmm2, [esi+eax]  ;
    movq  xmm1, [edx]      ;/* load 8B from pred */
    movq  xmm3, [edx+eax]  ;/* load another 8B from pred */

    punpcklbw xmm0, xmm4  ;/*unpack bytes to words */
    punpcklbw xmm1, xmm4  ;
    punpcklbw xmm2, xmm4  ;/*unpack bytes to words */
    punpcklbw xmm3, xmm4  ;

    psubw xmm0, xmm1      ;
    psubw xmm2, xmm3      ;

    movdqu  [ebx], xmm0     ; 
    movdqu  [ebx+16], xmm2  ;

    add     ebx, 32      ;
    add     edx, edi      ;
    add     esi, edi      ;
    sub     ecx, 1        ;
    cmp     ecx, 0        ;
    jnz     sub_pred_loop ;
  }
#else
  for (j=0; j<4; j++)  /* unrolled twice - Ruchira */
  {


    for (i=0; i<8; i++)
      blk[i] = cur[i] - pred[i];
    blk+= 8;
    cur+= lx;
    pred+= lx;


    for (i=0; i<8; i++)
      blk[i] = cur[i] - pred[i];
    blk+= 8;
    cur+= lx;
    pred+= lx;

  }
#endif
}

/*
 * select between frame and field DCT
 *
 * preliminary version: based on inter-field correlation
 */
void dct_type_estimation(pred,cur,mbi)
unsigned char *pred,*cur;
struct mbinfo *mbi;
{
  short blk0[128], blk1[128];
  int i, j, i0, j0, k, offs, s0, s1, sq0, sq1, s01;
  double d, r;

  k = 0;

  for (j0=0; j0<height2; j0+=16)
    for (i0=0; i0<width; i0+=16)
    {
      if (frame_pred_dct || pict_struct!=FRAME_PICTURE)
        mbi[k].dct_type = 0;
      else
      {
        /* interlaced frame picture */
        /*
         * calculate prediction error (cur-pred) for top (blk0)
         * and bottom field (blk1)
         */
        for (j=0; j<8; j++)
        {
          offs = width*((j<<1)+j0) + i0;
          for (i=0; i<16; i++)
          {
            blk0[16*j+i] = cur[offs] - pred[offs];
            blk1[16*j+i] = cur[offs+width] - pred[offs+width];
            offs++;
          }
        }
        /* correlate fields */
        s0=s1=sq0=sq1=s01=0;

        for (i=0; i<128; i++)
        {
          s0+= blk0[i];
          sq0+= blk0[i]*blk0[i];
          s1+= blk1[i];
          sq1+= blk1[i]*blk1[i];
          s01+= blk0[i]*blk1[i];
        }

        d = (sq0-(s0*s0)/128.0)*(sq1-(s1*s1)/128.0);

        if (d>0.0)
        {
          r = (s01-(s0*s1)/128.0)/sqrt(d);
          if (r>0.5)
            mbi[k].dct_type = 0; /* frame DCT */
          else
            mbi[k].dct_type = 1; /* field DCT */
        }
        else
          mbi[k].dct_type = 1; /* field DCT */
      }
      k++;
    }
}

#ifdef LTHREAD
void ptdct_type_estimation(pred,cur,mbi,start_height,end_height)
unsigned char *pred,*cur;
struct mbinfo *mbi;
int start_height,end_height;
{
  short blk0[128], blk1[128];
  int i, j, i0, j0, k, offs, s0, s1, sq0, sq1, s01;
  double d, r;

  k = (start_height>>4)*(width>>4);

  for (j0=start_height; j0<end_height; j0+=16)
    for (i0=0; i0<width; i0+=16)
    {
      if (frame_pred_dct || pict_struct!=FRAME_PICTURE)
        mbi[k].dct_type = 0;
      else
      {
        /* interlaced frame picture */
        /*
         * calculate prediction error (cur-pred) for top (blk0)
         * and bottom field (blk1)
         */
        for (j=0; j<8; j++)
        {
          offs = width*((j<<1)+j0) + i0;
          for (i=0; i<16; i++)
          {
            blk0[16*j+i] = cur[offs] - pred[offs];
            blk1[16*j+i] = cur[offs+width] - pred[offs+width];
            offs++;
          }
        }
        /* correlate fields */
        s0=s1=sq0=sq1=s01=0;

        for (i=0; i<128; i++)
        {
          s0+= blk0[i];
          sq0+= blk0[i]*blk0[i];
          s1+= blk1[i];
          sq1+= blk1[i]*blk1[i];
          s01+= blk0[i]*blk1[i];
        }

        d = (sq0-(s0*s0)/128.0)*(sq1-(s1*s1)/128.0);

        if (d>0.0)
        {
          r = (s01-(s0*s1)/128.0)/sqrt(d);
          if (r>0.5)
            mbi[k].dct_type = 0; /* frame DCT */
          else
            mbi[k].dct_type = 1; /* field DCT */
        }
        else
          mbi[k].dct_type = 1; /* field DCT */
      }
      k++;
    }
}

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* vlc.h, variable length code tables (used by routines in putvlc.c)        */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

/* type definitions for variable length code table entries */

typedef struct
{
  unsigned char code; /* right justified */
  char len;
} VLCtable;

/* for codes longer than 8 bits (excluding leading zeroes) */
typedef struct
{
  unsigned short code; /* right justified */
  char len;
} sVLCtable;


/* data from ISO/IEC 13818-2 DIS, Annex B, variable length code tables */

/* Table B-1, variable length codes for macroblock_address_increment
 *
 * indexed by [macroblock_address_increment-1]
 * 'macroblock_escape' is treated elsewhere
 */

static VLCtable addrinctab[33]=
{
  {0x01,1},  {0x03,3},  {0x02,3},  {0x03,4},
  {0x02,4},  {0x03,5},  {0x02,5},  {0x07,7},
  {0x06,7},  {0x0b,8},  {0x0a,8},  {0x09,8},
  {0x08,8},  {0x07,8},  {0x06,8},  {0x17,10},
  {0x16,10}, {0x15,10}, {0x14,10}, {0x13,10},
  {0x12,10}, {0x23,11}, {0x22,11}, {0x21,11},
  {0x20,11}, {0x1f,11}, {0x1e,11}, {0x1d,11},
  {0x1c,11}, {0x1b,11}, {0x1a,11}, {0x19,11},
  {0x18,11}
};


/* Table B-2, B-3, B-4 variable length codes for macroblock_type
 *
 * indexed by [macroblock_type]
 */

static VLCtable mbtypetab[3][32]=
{
 /* I */
 {
  {0,0}, {1,1}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {0,0}, {1,2}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
 },
 /* P */
 {
  {0,0}, {3,5}, {1,2}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {1,3}, {0,0}, {1,1}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {0,0}, {1,6}, {1,5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
  {0,0}, {0,0}, {2,5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
 },
 /* B */
 {
  {0,0}, {3,5}, {0,0}, {0,0}, {2,3}, {0,0}, {3,3}, {0,0},
  {2,4}, {0,0}, {3,4}, {0,0}, {2,2}, {0,0}, {3,2}, {0,0},
  {0,0}, {1,6}, {0,0}, {0,0}, {0,0}, {0,0}, {2,6}, {0,0},
  {0,0}, {0,0}, {3,6}, {0,0}, {0,0}, {0,0}, {2,5}, {0,0}
 }
};


/* Table B-5 ... B-8 variable length codes for macroblock_type in
 *  scalable sequences
 *
 * not implemented
 */

/* Table B-9, variable length codes for coded_block_pattern
 *
 * indexed by [coded_block_pattern]
 */

static VLCtable cbptable[64]=
{
  {0x01,9}, {0x0b,5}, {0x09,5}, {0x0d,6}, 
  {0x0d,4}, {0x17,7}, {0x13,7}, {0x1f,8}, 
  {0x0c,4}, {0x16,7}, {0x12,7}, {0x1e,8}, 
  {0x13,5}, {0x1b,8}, {0x17,8}, {0x13,8}, 
  {0x0b,4}, {0x15,7}, {0x11,7}, {0x1d,8}, 
  {0x11,5}, {0x19,8}, {0x15,8}, {0x11,8}, 
  {0x0f,6}, {0x0f,8}, {0x0d,8}, {0x03,9}, 
  {0x0f,5}, {0x0b,8}, {0x07,8}, {0x07,9}, 
  {0x0a,4}, {0x14,7}, {0x10,7}, {0x1c,8}, 
  {0x0e,6}, {0x0e,8}, {0x0c,8}, {0x02,9}, 
  {0x10,5}, {0x18,8}, {0x14,8}, {0x10,8}, 
  {0x0e,5}, {0x0a,8}, {0x06,8}, {0x06,9}, 
  {0x12,5}, {0x1a,8}, {0x16,8}, {0x12,8}, 
  {0x0d,5}, {0x09,8}, {0x05,8}, {0x05,9}, 
  {0x0c,5}, {0x08,8}, {0x04,8}, {0x04,9},
  {0x07,3}, {0x0a,5}, {0x08,5}, {0x0c,6}
};


/* Table B-10, variable length codes for motion_code
 *
 * indexed by [abs(motion_code)]
 * sign of motion_code is treated elsewhere
 */

static VLCtable motionvectab[17]=
{
  {0x01,1},  {0x01,2},  {0x01,3},  {0x01,4},
  {0x03,6},  {0x05,7},  {0x04,7},  {0x03,7},
  {0x0b,9},  {0x0a,9},  {0x09,9},  {0x11,10},
  {0x10,10}, {0x0f,10}, {0x0e,10}, {0x0d,10},
  {0x0c,10}
};


/* Table B-11, variable length codes for dmvector
 *
 * treated elsewhere
 */

/* Table B-12, variable length codes for dct_dc_size_luminance
 *
 * indexed by [dct_dc_size_luminance]
 */

static sVLCtable DClumtab[12]=
{
  {0x0004,3}, {0x0000,2}, {0x0001,2}, {0x0005,3}, {0x0006,3}, {0x000e,4},
  {0x001e,5}, {0x003e,6}, {0x007e,7}, {0x00fe,8}, {0x01fe,9}, {0x01ff,9}
};


/* Table B-13, variable length codes for dct_dc_size_chrominance
 *
 * indexed by [dct_dc_size_chrominance]
 */

static sVLCtable DCchromtab[12]=
{
  {0x0000,2}, {0x0001,2}, {0x0002,2}, {0x0006,3}, {0x000e,4}, {0x001e,5},
  {0x003e,6}, {0x007e,7}, {0x00fe,8}, {0x01fe,9}, {0x03fe,10},{0x03ff,10}
};


/* Table B-14, DCT coefficients table zero
 *
 * indexed by [run][level-1]
 * split into two tables (dct_code_tab1, dct_code_tab2) to reduce size
 * 'first DCT coefficient' condition and 'End of Block' are treated elsewhere
 * codes do not include s (sign bit)
 */

static VLCtable dct_code_tab1[2][40]=
{
 /* run = 0, level = 1...40 */
 {
  {0x03, 2}, {0x04, 4}, {0x05, 5}, {0x06, 7},
  {0x26, 8}, {0x21, 8}, {0x0a,10}, {0x1d,12},
  {0x18,12}, {0x13,12}, {0x10,12}, {0x1a,13},
  {0x19,13}, {0x18,13}, {0x17,13}, {0x1f,14},
  {0x1e,14}, {0x1d,14}, {0x1c,14}, {0x1b,14},
  {0x1a,14}, {0x19,14}, {0x18,14}, {0x17,14},
  {0x16,14}, {0x15,14}, {0x14,14}, {0x13,14},
  {0x12,14}, {0x11,14}, {0x10,14}, {0x18,15},
  {0x17,15}, {0x16,15}, {0x15,15}, {0x14,15},
  {0x13,15}, {0x12,15}, {0x11,15}, {0x10,15}
 },
 /* run = 1, level = 1...18 */
 {
  {0x03, 3}, {0x06, 6}, {0x25, 8}, {0x0c,10},
  {0x1b,12}, {0x16,13}, {0x15,13}, {0x1f,15},
  {0x1e,15}, {0x1d,15}, {0x1c,15}, {0x1b,15},
  {0x1a,15}, {0x19,15}, {0x13,16}, {0x12,16},
  {0x11,16}, {0x10,16}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}
 }
};

static VLCtable dct_code_tab2[30][5]=
{
  /* run = 2...31, level = 1...5 */
  {{0x05, 4}, {0x04, 7}, {0x0b,10}, {0x14,12}, {0x14,13}},
  {{0x07, 5}, {0x24, 8}, {0x1c,12}, {0x13,13}, {0x00, 0}},
  {{0x06, 5}, {0x0f,10}, {0x12,12}, {0x00, 0}, {0x00, 0}},
  {{0x07, 6}, {0x09,10}, {0x12,13}, {0x00, 0}, {0x00, 0}},
  {{0x05, 6}, {0x1e,12}, {0x14,16}, {0x00, 0}, {0x00, 0}},
  {{0x04, 6}, {0x15,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x07, 7}, {0x11,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x05, 7}, {0x11,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x27, 8}, {0x10,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x23, 8}, {0x1a,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x22, 8}, {0x19,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x20, 8}, {0x18,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x0e,10}, {0x17,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x0d,10}, {0x16,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x08,10}, {0x15,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1a,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x19,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x17,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x16,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1e,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1d,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1c,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1b,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1e,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1d,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1c,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1b,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}}
};


/* Table B-15, DCT coefficients table one
 *
 * indexed by [run][level-1]
 * split into two tables (dct_code_tab1a, dct_code_tab2a) to reduce size
 * 'End of Block' is treated elsewhere
 * codes do not include s (sign bit)
 */

static VLCtable dct_code_tab1a[2][40]=
{
 /* run = 0, level = 1...40 */
 {
  {0x02, 2}, {0x06, 3}, {0x07, 4}, {0x1c, 5},
  {0x1d, 5}, {0x05, 6}, {0x04, 6}, {0x7b, 7},
  {0x7c, 7}, {0x23, 8}, {0x22, 8}, {0xfa, 8},
  {0xfb, 8}, {0xfe, 8}, {0xff, 8}, {0x1f,14},
  {0x1e,14}, {0x1d,14}, {0x1c,14}, {0x1b,14},
  {0x1a,14}, {0x19,14}, {0x18,14}, {0x17,14},
  {0x16,14}, {0x15,14}, {0x14,14}, {0x13,14},
  {0x12,14}, {0x11,14}, {0x10,14}, {0x18,15},
  {0x17,15}, {0x16,15}, {0x15,15}, {0x14,15},
  {0x13,15}, {0x12,15}, {0x11,15}, {0x10,15}
 },
 /* run = 1, level = 1...18 */
 {
  {0x02, 3}, {0x06, 5}, {0x79, 7}, {0x27, 8},
  {0x20, 8}, {0x16,13}, {0x15,13}, {0x1f,15},
  {0x1e,15}, {0x1d,15}, {0x1c,15}, {0x1b,15},
  {0x1a,15}, {0x19,15}, {0x13,16}, {0x12,16},
  {0x11,16}, {0x10,16}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}
 }
};

static VLCtable dct_code_tab2a[30][5]=
{
  /* run = 2...31, level = 1...5 */
  {{0x05, 5}, {0x07, 7}, {0xfc, 8}, {0x0c,10}, {0x14,13}},
  {{0x07, 5}, {0x26, 8}, {0x1c,12}, {0x13,13}, {0x00, 0}},
  {{0x06, 6}, {0xfd, 8}, {0x12,12}, {0x00, 0}, {0x00, 0}},
  {{0x07, 6}, {0x04, 9}, {0x12,13}, {0x00, 0}, {0x00, 0}},
  {{0x06, 7}, {0x1e,12}, {0x14,16}, {0x00, 0}, {0x00, 0}},
  {{0x04, 7}, {0x15,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x05, 7}, {0x11,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x78, 7}, {0x11,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x7a, 7}, {0x10,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x21, 8}, {0x1a,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x25, 8}, {0x19,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x24, 8}, {0x18,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x05, 9}, {0x17,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x07, 9}, {0x16,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x0d,10}, {0x15,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1a,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x19,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x17,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x16,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1e,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1d,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1c,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1b,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1f,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1e,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1d,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1c,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
  {{0x1b,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}}
};
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* writepic.c, write reconstructed pictures                                 */

/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */

/*
 * Disclaimer of Warranty
 *
 * These software programs are available to the user without any license fee or
 * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
 * any and all warranties, whether express, implied, or statuary, including any
 * implied warranties or merchantability or of fitness for a particular
 * purpose.  In no event shall the copyright-holder be liable for any
 * incidental, punitive, or consequential damages of any kind whatsoever
 * arising from the use of these programs.
 *
 * This disclaimer of warranty extends to the user of these programs and user's
 * customers, employees, agents, transferees, successors, and assigns.
 *
 * The MPEG Software Simulation Group does not represent or warrant that the
 * programs furnished hereunder are free of infringement of any third-party
 * patents.
 *
 * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
 * are subject to royalty fees to patent holders.  Many of these patents are
 * general enough such that they are unavoidable regardless of implementation
 * design.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "global.h"

void writeframe(fname,frame)
char *fname;
unsigned char *frame[];
{
  int chrom_hsize, chrom_vsize;
  char name[128];
  FILE *fd;

  chrom_hsize = (chroma_format==CHROMA444) ? horizontal_size
                                           : horizontal_size>>1;

  chrom_vsize = (chroma_format!=CHROMA420) ? vertical_size
                                           : vertical_size>>1;

  if (fname[0]=='-')
    return;

  /* Y */
  sprintf(name,"%s.Y",fname);

  if (!(fd = fopen(name,"wb")))
  {
    sprintf(errortext,"Couldn't create %s\n",name);
    error(errortext);
  }
  fwrite(frame[0],1,horizontal_size*vertical_size,fd);
  fclose(fd);

  /* Cb */
  sprintf(name,"%s.U",fname);
  if (!(fd = fopen(name,"wb")))
  {
    sprintf(errortext,"Couldn't create %s\n",name);
    error(errortext);
  }
  fwrite(frame[1],1,chrom_hsize*chrom_vsize,fd);
  fclose(fd);

  /* Cr */
  sprintf(name,"%s.V",fname);
  if (!(fd = fopen(name,"wb")))
  {
    sprintf(errortext,"Couldn't create %s\n",name);
    error(errortext);
  }
  fwrite(frame[2],1,chrom_hsize*chrom_vsize,fd);
  fclose(fd);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * agc.c -- Various forms of automatic gain control (AGC)
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 04-Nov-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#include "agc.h"


/*
 * Normalize c0 for all frames such that max(c0) = 0.
 */
void agc_max (float **mfc, int32 n_frame)
{
    float32 maxc0;
    int32 i;

    assert (n_frame > 0);

    maxc0 = mfc[0][0];
    for (i = 1; i < n_frame; i++) {
	if (mfc[i][0] > maxc0)
	    maxc0 = mfc[i][0];
    }

    for (i = 0; i < n_frame; i++)
	mfc[i][0] -= maxc0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * agc.h -- Various forms of automatic gain control (AGC)
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Copied from previous version.
 */


#ifndef _S3_AGC_H_
#define _S3_AGC_H_


#include "libutil.h"


/*
 * Apply AGC to the given mfc vectors (normalize all C0 mfc coefficients in the given
 * input such that the max C0 value is 0, by subtracting the input max C0 from all).
 * This function operates on an entire utterance at a time.  Hence, the entire utterance
 * must be available beforehand (batchmode).
 */
void agc_max (float32 **mfc,	/* In/Out: mfc[f] = cepstrum vector in frame f */
	      int32 n_frame);	/* In: #frames of cepstrum vectors supplied */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * ascr.c -- Acoustic (senone) scores
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "ascr.h"


ascr_t *ascr_init (int32 n_sen, int32 n_comsen)
{
    ascr_t *ascr;
    
    ascr = (ascr_t *) ckd_calloc (1, sizeof(ascr_t));
    ascr->sen = (int32 *) ckd_calloc (n_sen + n_comsen, sizeof(int32));
    ascr->comsen = ascr->sen + n_sen;
    
    return ascr;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * ascr.h -- Acoustic (senone) scores
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 19-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_ASCR_H_
#define _S3_ASCR_H_


#include "libutil.h"


/*
 * Structure to hold senone scores (ordinary and composite), in one frame.
 */

typedef struct {
    int32 *sen;		/* Senone scores in current frame */
    int32 *comsen;	/* Composite senone scores in current frame */
} ascr_t;


/*
 * Create an ascr_t structure for the given number of senones (ordinary and composite).
 * Return value: Ptr to created structure if successful, NULL otherwise.
 */
ascr_t *ascr_init (int32 n_sen,		/* In: #Ordinary senones */
		   int32 n_comsen);	/* In: #Composite senones */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#include <stdlib.h>
#include "barrier.h"

barrier_t * thread_barrier_init(int n_clients) {
  barrier_t *barrier = (barrier_t *) malloc(sizeof(barrier_t));

  if (barrier != NULL) {
    barrier->n_clients = n_clients;
    barrier->n_waiting = 0;
    barrier->phase = 0;
    pthread_mutex_init(&barrier->lock, NULL);
    pthread_cond_init(&barrier->wait_cv, NULL);
  }

  return barrier;
}

void thread_barrier_destroy(barrier_t *barrier) {
  pthread_mutex_destroy(&barrier->lock);
  pthread_cond_destroy(&barrier->wait_cv);
  free(barrier);
}

void thread_barrier(int t, barrier_t *barrier) {
#if (NUM_THREADS>1)
  int my_phase;

  pthread_mutex_lock(&barrier->lock);
  my_phase = barrier->phase;
  barrier->n_waiting++;

  if (barrier->n_waiting == barrier->n_clients) {
    barrier->n_waiting = 0;
    barrier->phase = 1 - my_phase;
    pthread_cond_broadcast(&barrier->wait_cv);
  }
#if 0
  printf("thrd %d bp %d mp %d waiting %d\n",t, barrier->phase, my_phase, barrier->n_waiting);
#endif
  while (barrier->phase == my_phase) {
    pthread_cond_wait(&barrier->wait_cv, &barrier->lock);
  }

  pthread_mutex_unlock(&barrier->lock);
#endif
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#include<pthread.h>

typedef struct barrier_struct {
  int padding1[8]; /* Padding bytes to avoid false sharing and cache aliasing */
  pthread_mutex_t lock;   /* Mutex lock for the structure */
  int n_clients;          /* Number of threads to wait for at barrier */
  int n_waiting;          /* Number of currently waiting threads */
  int phase;              /* Flag to separate waiters from fast workers */
  pthread_cond_t wait_cv; /* Clients wait on condition variable to proceed */
  int padding2[8]; /* Padding bytes to avoid false sharing and cache aliasing */
} barrier_t;

barrier_t * thread_barrier_init(int n_clients);
void thread_barrier_destroy(barrier_t *barrier);
void thread_barrier(int t,barrier_t *barrier);
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * beam.c -- Various forms of pruning beam
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "beam.h"
#include "logs3.h"


beam_t *beam_init (float64 svq, float64 hmm, float64 ptr, float64 wd)
{
    beam_t *beam;
    
    beam = (beam_t *) ckd_calloc (1, sizeof(beam_t));
    
    beam->subvq = logs3 (svq);
    beam->hmm = logs3 (hmm);
    beam->ptrans = logs3 (ptr);
    beam->word = logs3 (wd);
    
    return beam;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * beam.h -- Various forms of pruning beam
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 19-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_BEAM_H_
#define _S3_BEAM_H_


#include "libutil.h"


/*
 * Structure containing various beamwidth parameters.  All logs3 values; -infinite is widest,
 * 0 is narrowest.
 */
typedef struct {
    int32 subvq;	/* For selecting active mixture components based on subvq scores */
    int32 hmm;		/* For selecting active HMMs, relative to best */
    int32 ptrans;	/* For determining which HMMs transition to their successors */
    int32 word;		/* For selecting words exited, relative to best HMM score */
} beam_t;


/*
 * Create and initialize a beam_t structure, with the given parameters, converting them
 * from prob space to logs3 space.  Return value: ptr to created structure if successful,
 * NULL otherwise.
 */
beam_t *beam_init (float64 svq, float64 hmm, float64 ptr, float64 wd);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * bio.c -- Sphinx-3 binary file I/O functions.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 02-Jul-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Bugfix: Added byteswapping in bio_verify_chksum().
 * 
 * 18-Dec-1996	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#include "bio.h"


#define BIO_HDRARG_MAX	32
#define END_COMMENT	"*end_comment*\n"


static void bcomment_read (FILE *fp)
{
    char iline[16384];

    while (fgets(iline, sizeof(iline), fp) != NULL) {
	if (strcmp(iline, END_COMMENT) == 0)
	    return;
    }
    E_FATAL("Missing %s marker\n", END_COMMENT);
}


static int32 swap_check(FILE *fp)
{
    uint32 magic;

    if (fread(&magic, sizeof(uint32), 1, fp) != 1) {
	E_ERROR ("Cannot read BYTEORDER MAGIC NO.\n");
	return -1;
    }

    if (magic != BYTE_ORDER_MAGIC) {
	/* either need to swap or got bogus magic number */
	SWAP_INT32(&magic);
	
	if (magic == BYTE_ORDER_MAGIC)
	    return 1;

	SWAP_INT32(&magic);
	E_ERROR("Bad BYTEORDER MAGIC NO: %08x, expecting %08x\n",
		magic, BYTE_ORDER_MAGIC);
	return -1;
    }

    return 0;
}


void bio_hdrarg_free (char **argname, char **argval)
{
    int32 i;
    
    for (i = 0; argname[i]; i++) {
	ckd_free (argname[i]);
	ckd_free (argval[i]);
    }
    ckd_free (argname);
    ckd_free (argval);
}


int32 bio_writehdr_version (FILE *fp, char *version)
{
    uint32 b;
    
    fprintf (fp, "s3\n");
    fprintf (fp, "version %s\n", version);
    fprintf (fp, "endhdr\n");
    fflush (fp);
    
    b = (uint32) BYTE_ORDER_MAGIC;
    fwrite (&b, sizeof(uint32), 1, fp);
    fflush (fp);
    
    return 0;
}


int32 bio_readhdr (FILE *fp, char ***argname, char ***argval, int32 *swap)
{
    char line[16384], word[4096];
    int32 i, l;
    int32 lineno;
    
    *argname = (char **) ckd_calloc (BIO_HDRARG_MAX+1, sizeof(char *));
    *argval = (char **) ckd_calloc (BIO_HDRARG_MAX, sizeof(char *));

    lineno = 0;
    if (fgets (line, sizeof(line), fp) == NULL)
	E_FATAL("Premature EOF, line %d\n", lineno);
    lineno++;
    
    if ((line[0] == 's') && (line[1] == '3') && (line[2] == '\n')) {
	/* New format (post Dec-1996, including checksums); read argument-value pairs */
	for (i = 0;;) {
	    if (fgets (line, sizeof(line), fp) == NULL)
		E_FATAL("Premature EOF, line %d\n", lineno);
	    lineno++;
	    
	    if (sscanf (line, "%s%n", word, &l) != 1)
		E_FATAL("Header format error, line %d\n", lineno);
	    if (strcmp (word, "endhdr") == 0)
		break;
	    if (word[0] == '#')		/* Skip comments */
		continue;

	    if (i >= BIO_HDRARG_MAX)
		E_FATAL("Max arg-value limit(%d) exceeded; increase BIO_HDRARG_MAX\n",
			BIO_HDRARG_MAX);
	    
	    (*argname)[i] = ckd_salloc (word);
	    if (sscanf (line+l, "%s", word) != 1)	/* Multi-word values not allowed */
		E_FATAL("Header format error, line %d\n", lineno);
	    (*argval)[i] = ckd_salloc (word);
	    i++;
	}
    } else {
	/* Old format (without checksums); the first entry must be the version# */
	if (sscanf(line, "%s", word) != 1)
	    E_FATAL("Header format error, line %d\n", lineno);

	(*argname)[0] = ckd_salloc ("version");
	(*argval)[0] = ckd_salloc (word);
	i = 1;
	
	bcomment_read(fp);
    }
    (*argname)[i] = NULL;
    
    if ((*swap = swap_check(fp)) < 0)
	E_FATAL("swap_check failed\n");

    return 0;
}


static uint32 chksum_accum (void *buf, int32 el_sz, int32 n_el, uint32 sum)
{
    int32 i;
    uint8 *i8;
    uint16 *i16;
    uint32 *i32;
    
    switch (el_sz) {
    case 1:
	i8 = (uint8 *)buf;
	for (i = 0; i < n_el; i++)
	    sum = (sum << 5 | sum >> 27) + i8[i];
	break;
    case 2:
	i16 = (uint16 *)buf;
	for (i = 0; i < n_el; i++)
	    sum = (sum << 10 | sum >> 22) + i16[i];
	break;
    case 4:
	i32 = (uint32 *)buf;
	for (i = 0; i < n_el; i++)
	    sum = (sum << 20 | sum >> 12) + i32[i];
	break;
    default:
	E_FATAL("Unsupported elemsize for checksum: %d\n", el_sz);
	break;
    }

    return sum;
}


static void swap_buf (void *buf, int32 el_sz, int32 n_el)
{
    int32 i;
    uint16 *buf16;
    uint32 *buf32;

    switch (el_sz) {
    case 1:
	break;
    case 2:
	buf16 = (uint16 *) buf;
	for (i = 0; i < n_el; i++)
	    SWAP_INT16(buf16+i);
	break;
    case 4:
	buf32 = (uint32 *) buf;
	for (i = 0; i < n_el; i++)
	    SWAP_INT32(buf32+i);
	break;
    default:
	E_FATAL("Unsupported elemsize for byteswapping: %d\n", el_sz);
	break;
    }
}


int32 bio_fread (void *buf, int32 el_sz, int32 n_el, FILE *fp, int32 swap, uint32 *chksum)
{
    if (fread (buf, el_sz, n_el, fp) != (size_t)n_el)
	return -1;
    
    if (swap)
	swap_buf (buf, el_sz, n_el);
    
    if (chksum)
	*chksum = chksum_accum (buf, el_sz, n_el, *chksum);

    return n_el;
}


int32 bio_fread_1d (void **buf, int32 el_sz, int32 *n_el, FILE *fp, int32 sw, uint32 *ck)
{
    if ((el_sz != 1) && (el_sz != 2) && (el_sz != 4))
	E_FATAL("Unsupported elemsize: %d\n", el_sz);
    
    /* Read 1-d array size */
    if (bio_fread (n_el, sizeof(int32), 1, fp, sw, ck) != 1)
	E_FATAL("fread(arraysize) failed\n");
    if (*n_el <= 0)
	E_FATAL("Bad arraysize: %d\n", *n_el);
    
    /* Allocate memory for array data */
    *buf = (void *) ckd_calloc (*n_el, el_sz);

    /* Read array data */
    if (bio_fread (*buf, el_sz, *n_el, fp, sw, ck) != *n_el)
	E_FATAL("fread(arraydata) failed\n");

    return *n_el;
}


void bio_verify_chksum (FILE *fp, int32 byteswap, uint32 chksum)
{
    uint32 file_chksum;
    
    if (fread (&file_chksum, sizeof(uint32), 1, fp) != 1)
	E_FATAL("fread(chksum) failed\n");
    if (byteswap)
	SWAP_INT32(&file_chksum);
    if (file_chksum != chksum)
	E_FATAL("Checksum error; file-checksum %08x, computed %08x\n",
		file_chksum, chksum);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * bio.h -- Sphinx-3 binary file I/O functions.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#ifndef _S3_BIO_H_
#define _S3_BIO_H_


#include "libutil.h"


#define BYTE_ORDER_MAGIC	(0x11223344)

/* Macro to byteswap an int16 variable.  x = ptr to variable */
#define SWAP_INT16(x)	*(x) = ((0x00ff & (*(x))>>8) | (0xff00 & (*(x))<<8))

/* Macro to byteswap an int32 variable.  x = ptr to variable */
#define SWAP_INT32(x)	*(x) = ((0x000000ff & (*(x))>>24) | \
				(0x0000ff00 & (*(x))>>8) | \
				(0x00ff0000 & (*(x))<<8) | \
				(0xff000000 & (*(x))<<24))

/* Macro to byteswap a float32 variable.  x = ptr to variable */
#define SWAP_FLOAT32(x)	SWAP_INT32((int32 *) x)


/*
 * Read binary file format header: has the following format
 *     s3
 *     <argument-name> <argument-value>
 *     <argument-name> <argument-value>
 *     ...
 *     endhdr
 *     4-byte byte-order word used to find file byte ordering relative to host machine.
 * Lines beginning with # are ignored.
 * Memory for name and val allocated by this function; use bio_hdrarg_free to free them.
 * Return value: 0 if successful, -1 otherwise.
 */
int32 bio_readhdr (FILE *fp,		/* In: File to read */
		   char ***name,	/* Out: array of argument name strings read */
		   char ***val,		/* Out: corresponding value strings read */
		   int32 *swap);	/* Out: file needs byteswapping iff (*swap) */

/*
 * Write a simple binary file header, containing only the version string.  Also write
 * the byte order magic word.
 * Return value: 0 if successful, -1 otherwise.
 */
int32 bio_writehdr_version (FILE *fp, char *version);


/*
 * Free name and value strings previously allocated and returned by bio_readhdr.
 */
void bio_hdrarg_free (char **name,	/* In: Array previously returned by bio_readhdr */
		      char **val);	/* In: Array previously returned by bio_readhdr */

/*
 * Like fread but perform byteswapping and accumulate checksum (the 2 extra arguments).
 * But unlike fread, returns -1 if required number of elements (n_el) not read; also,
 * no byteswapping or checksum accumulation is performed in that case.
 */
int32 bio_fread (void *buf,
		 int32 el_sz,
		 int32 n_el,
		 FILE *fp,
		 int32 swap,		/* In: Byteswap iff (swap != 0) */
		 uint32 *chksum);	/* In/Out: Accumulated checksum */

/*
 * Read a 1-d array (fashioned after fread):
 *     4-byte array size (returned in n_el)
 *     memory allocated for the array and read (returned in buf)
 * Byteswapping and checksum accumulation performed as necessary.
 * Fails fatally if expected data not read.
 * Return value: #array elements allocated and read; -1 if error.
 */
int32 bio_fread_1d (void **buf,		/* Out: contains array data; allocated by this
					   function; can be freed using ckd_free */
		    int32 el_sz,	/* In: Array element size */
		    int32 *n_el,	/* Out: #array elements allocated/read */
		    FILE *fp,		/* In: File to read */
		    int32 sw,		/* In: Byteswap iff (swap != 0) */
		    uint32 *ck);	/* In/Out: Accumulated checksum */

/*
 * Read and verify checksum at the end of binary file.  Fails fatally if there is
 * a mismatch.
 */
void bio_verify_chksum (FILE *fp,	/* In: File to read */
			int32 byteswap,	/* In: Byteswap iff (swap != 0) */
			uint32 chksum);	/* In: Value to compare with checksum in file */


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * bitvec.c -- Bit vector type.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 05-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Started.
 */


#include "bitvec.h"


int32 bitvec_count_set (bitvec_t vec, int32 len)
{
    int32 n, i;
    
    for (i = 0, n = 0; i < len; i++)
	if (bitvec_is_set (vec, i))
	    n++;
    
    return n;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * bitvec.h -- Bit vector type.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 13-Sep-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added bitvec_uint32size().
 * 
 * 05-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added bitvec_count_set().
 * 
 * 17-Jul-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#ifndef _LIBUTIL_BITVEC_H_
#define _LIBUTIL_BITVEC_H_


#include "prim_type.h"
#include "ckd_alloc.h"


typedef uint32 *bitvec_t;

/*
 * NOTE: The following definitions haven't been designed for arbitrary usage!!
 */

/* No. of uint32 words allocated to represent a bitvector of the given size n */
#define bitvec_uint32size(n)	(((n)+31)>>5)

#define bitvec_alloc(n)		((bitvec_t) ckd_calloc (((n)+31)>>5, sizeof(uint32)))

#define bitvec_free(v)		ckd_free((char *)(v))

#define bitvec_set(v,b)		(v[(b)>>5] |= (1 << ((b) & 0x001f)))

#define bitvec_clear(v,b)	(v[(b)>>5] &= ~(1 << ((b) & 0x001f)))

#define bitvec_clear_all(v,n)	memset(v, 0, (((n)+31)>>5)*sizeof(uint32))

#define bitvec_is_set(v,b)	(v[(b)>>5] & (1 << ((b) & 0x001f)))

#define bitvec_is_clear(v,b)	(! (bitvec_is_set(v,b)))


/*
 * Return the number of bits set in the given bit-vector.
 */
int32 bitvec_count_set (bitvec_t vec,	/* In: Bit vector to search */
			int32 len);	/* In: Lenght of above bit vector */

#endif
subvq.c:    vq->vqdist = (int32 **) ckd_calloc_2d (vq->n_sv, vq->vqsize, sizeof(int32));
subvq.c:    int32 *vqdist;
subvq.c:    vqdist = vq->vqdist[0];	/* Since map is linearized for efficiency, must also
subvq.c:				   look at vqdist[][] as vqdist[] */
subvq.c:	    v = (int32) vqdist[*map];/* If we are not weighting the cep values, we need to adjust the subvqbeam */
subvq.c:	    v = vqdist[*(map++)];
subvq.c:	      v += 2 * vqdist[*map]; /* RAH Count delta twice, we can keep the same subvqbeam as vq_eval = 3 if we double the delta*/
subvq.c:	      v = vqdist[*(map++)];/* Standard way */
subvq.c:	      v += vqdist[*(map++)]; /*  */
subvq.c:	      v += vqdist[*(map++)]; /*  */
subvq.c:	    v = vqdist[*(map++)];
subvq.c:	    v += vqdist[*(map++)];
subvq.c:	v = vqdist[*(map++)];
subvq.c:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
subvq.c:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
subvq.c:    if (s->vqdist) 
subvq.c:      ckd_free_2d ((void **) s->vqdist);
subvq.c~:    vq->vqdist = (int32 **) ckd_calloc_2d (vq->n_sv, vq->vqsize, sizeof(int32));
subvq.c~:    int32 *vqdist;
subvq.c~:    vqdist = vq->vqdist[0];	/* Since map is linearized for efficiency, must also
subvq.c~:				   look at vqdist[][] as vqdist[] */
subvq.c~:	    v = (int32) vqdist[*map];/* If we are not weighting the cep values, we need to adjust the subvqbeam */
subvq.c~:	    v = vqdist[*(map++)];
subvq.c~:	      v += 2 * vqdist[*map]; /* RAH Count delta twice, we can keep the same subvqbeam as vq_eval = 3 if we double the delta*/
subvq.c~:	      v = vqdist[*(map++)];/* Standard way */
subvq.c~:	      v += vqdist[*(map++)]; /*  */
subvq.c~:	      v += vqdist[*(map++)]; /*  */
subvq.c~:	    v = vqdist[*(map++)];
subvq.c~:	    v += vqdist[*(map++)];
subvq.c~:	v = vqdist[*(map++)];
subvq.c~:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
subvq.c~:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
subvq.c~:    if (s->vqdist) 
subvq.c~:      ckd_free_2d ((void **) s->vqdist);
subvq.h:    int32 **vqdist;		/* vqdist[i][j] = score (distance) for i-th subvector compared
subvq.h: * given subvq codebook.  Save results, as logs3 values, in vq->vqdist[][].
subvq.h: * Save results, as logs3 values, in vq->vqdist[sv][].
subvq.h~:    int32 **vqdist;		/* vqdist[i][j] = score (distance) for i-th subvector compared
subvq.h~: * given subvq codebook.  Save results, as logs3 values, in vq->vqdist[][].
subvq.h~: * Save results, as logs3 values, in vq->vqdist[sv][].
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * case.c -- Upper/lower case conversion routines
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 18-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added strcmp_nocase.  Moved UPPER_CASE and LOWER_CASE definitions to .h.
 * 
 * 16-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#include "case.h"


void lcase(register char *cp)
{
    for (; *cp; cp++)
	*cp = LOWER_CASE(*cp);
}


void ucase(register char *cp)
{
    for (; *cp; cp++)
	*cp = UPPER_CASE(*cp);
}


int32 strcmp_nocase (const char *str1, const char *str2)
{
    char c1, c2;
    
    for (;;) {
	c1 = *(str1++);
	c1 = UPPER_CASE(c1);
	c2 = *(str2++);
	c2 = UPPER_CASE(c2);
	if (c1 != c2)
	    return (c1-c2);
	if (c1 == '\0')
	    return 0;
    }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * case.h -- Upper/lower case conversion routines
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 18-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added strcmp_nocase, UPPER_CASE and LOWER_CASE definitions.
 * 
 * 16-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#ifndef _LIBUTIL_CASE_H_
#define _LIBUTIL_CASE_H_


#include "prim_type.h"


/* Return upper case form for c */
#define UPPER_CASE(c)	((((c) >= 'a') && ((c) <= 'z')) ? (c-32) : c)

/* Return lower case form for c */
#define LOWER_CASE(c)	((((c) >= 'A') && ((c) <= 'Z')) ? (c+32) : c)


/* Convert str to all upper case */
void ucase(char *str);

/* Convert str to all lower case */
void lcase(char *str);

/*
 * Case insensitive string compare.  Return the usual -1, 0, +1, depending on
 * str1 <, =, > str2 (case insensitive, of course).
 */
int32 strcmp_nocase (const char *str1, const char *str2);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * ckd_alloc.c -- Memory allocation package.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 19-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Removed file,line arguments from free functions.
 * 		Removed debugging stuff.
 * 
 * 01-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


/*********************************************************************
 *
 * $Header: /cvsroot/cmusphinx/sphinx3/src/libutil/ckd_alloc.c,v 1.2 2001/12/11 04:40:56 lenzo Exp $
 *
 * Carnegie Mellon ARPA Speech Group
 *
 * Copyright (c) 1994 Carnegie Mellon University.
 * All rights reserved.
 *
 *********************************************************************
 *
 * file: ckd_alloc.c
 * 
 * traceability: 
 * 
 * description: 
 * 
 * author: 
 * 
 *********************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


#include "ckd_alloc.h"
#include "err.h"


void *__ckd_calloc__(size_t n_elem, size_t elem_size,
		     const char *caller_file, int caller_line)
{
    void *mem;

    if ((mem = calloc(n_elem, elem_size)) == NULL) {
	E_FATAL("calloc(%d,%d) failed from %s(%d)\n", n_elem, elem_size,
		caller_file, caller_line);
    }

    return mem;
}


void *__ckd_malloc__(size_t size,
		     const char *caller_file, int caller_line)
{
    void *mem;

    if ((mem = malloc(size)) == NULL)
	E_FATAL("malloc(%d) failed from %s(%d)\n", size, caller_file, caller_line);

    return mem;
}


void *__ckd_realloc__(void *ptr, size_t new_size,
		      const char *caller_file, int caller_line)
{
    void *mem;

    if ((mem = realloc(ptr, new_size)) == NULL) {
	E_FATAL("realloc(%d) failed from %s(%d)\n", new_size,
		caller_file, caller_line);
    }

    return mem;
}


char *__ckd_salloc__ (const char *orig, const char *caller_file, int32 caller_line)
{
    int32 len;
    char *buf;

    len = strlen(orig)+1;
    buf = (char *) __ckd_malloc__(len, caller_file, caller_line);

    strcpy (buf, orig);
    return (buf);
}

void **__ckd_calloc_2d__ (int32 d1, int32 d2, int32 elemsize,
			  const char *caller_file, int32 caller_line)
{
    char **ref, *mem;
    int32 i, offset;

    mem = (char *) __ckd_calloc__(d1*d2, elemsize, caller_file, caller_line);
    ref = (char **) __ckd_malloc__(d1 * sizeof(void *), caller_file, caller_line);

    for (i = 0, offset = 0; i < d1; i++, offset += d2*elemsize)
	ref[i] = mem + offset;

    return ((void **) ref);
}

void **__ckd_calloc_2d__a (int32 d1, int32 d2, int32 elemsize,
			  const char *caller_file, int32 caller_line)
{
    char **ref, *mem;
    int32 i, offset;
#ifdef USE_ICC
    mem = (char *) _mm_malloc(d1*d2*elemsize,16);
#else
    mem = (char *) __ckd_calloc__(d1*d2, elemsize, caller_file, caller_line);
#endif
    ref = (char **) __ckd_malloc__(d1 * sizeof(void *), caller_file, caller_line);

    for (i = 0, offset = 0; i < d1; i++, offset += d2*elemsize)
	ref[i] = mem + offset;

    return ((void **) ref);
}


void ckd_free_2da (void **ptr)
{
#ifdef USE_ICC
  _mm_free(ptr[0]);
#else
  ckd_free(ptr[0]);
#endif
    ckd_free(ptr);
}

void ckd_free_2d (void **ptr)
{
  ckd_free(ptr[0]);
  ckd_free(ptr);
}


void ***__ckd_calloc_3d__ (int32 d1, int32 d2, int32 d3, int32 elemsize,
			   const char *caller_file, int32 caller_line)
{
    char ***ref1, **ref2, *mem;
    int32 i, j, offset;

    mem = (char *) __ckd_calloc__(d1*d2*d3, elemsize, caller_file, caller_line);
    ref1 = (char ***) __ckd_malloc__(d1 * sizeof(void **), caller_file, caller_line);
    ref2 = (char **) __ckd_malloc__(d1*d2 * sizeof(void *), caller_file, caller_line);

    for (i = 0, offset = 0; i < d1; i++, offset += d2)
	ref1[i] = ref2+offset;

    offset = 0;
    for (i = 0; i < d1; i++) {
	for (j = 0; j < d2; j++) {
	    ref1[i][j] = mem + offset;
	    offset += d3*elemsize;
	}
    }

    return ((void ***) ref1);
}


void ckd_free_3d (void ***ptr)
{
    ckd_free(ptr[0][0]);
    ckd_free(ptr[0]);
    ckd_free(ptr);
}


/*
 * Structures for managing linked list elements of various sizes without wasting
 * memory.  A separate linked list for each element-size.  Element-size must be a
 * multiple of pointer-size.
 */
typedef struct mylist_s {
    char **freelist;		/* ptr to first element in freelist */
    struct mylist_s *next;	/* Next linked list */
    int32 elemsize;		/* #(char *) in element */
    int32 blocksize;		/* #elements to alloc if run out of free elments */
    int32 blk_alloc;		/* #Alloc operations before increasing blocksize */
} mylist_t;
static mylist_t *head = NULL;

#define MIN_MYALLOC	50	/* Min #elements to allocate in one block */


char *__mymalloc__ (int32 elemsize, char *caller_file, int32 caller_line)
{
    char *cp;
#if (! __PURIFY__)
    int32 j;
    char **cpp;
    mylist_t *prev, *list;
    
    /* Find list for elemsize, if existing */
    prev = NULL;
    for (list = head; list && (list->elemsize != elemsize); list = list->next)
	prev = list;

    if (! list) {
	/* New list element size encountered, create new list entry */
	if ((elemsize % sizeof(void *)) != 0)
	    E_FATAL("List item size (%d) not multiple of sizeof(void *)\n", elemsize);
	
	list = (mylist_t *) ckd_calloc (1, sizeof(mylist_t));
	list->freelist = NULL;
	list->elemsize = elemsize;
	list->blocksize = MIN_MYALLOC;
	list->blk_alloc = (1<<18) / (list->blocksize * elemsize);

	/* Link entry at head of list */
	list->next = head;
	head = list;
    } else if (prev) {
	/* List found; move entry to head of list */
	prev->next = list->next;
	list->next = head;
	head = list;
    }
    
    /* Allocate a new block if list empty */
    if (list->freelist == NULL) {
	/* Check if block size should be increased (if many requests for this size) */
	if (list->blk_alloc == 0) {
	    list->blocksize <<= 1;
	    list->blk_alloc = (1<<18) / (list->blocksize * elemsize);
	    if (list->blk_alloc <= 0)
		list->blk_alloc = (int32)0x70000000;	/* Limit blocksize to new value */
	}

	/* Allocate block */
	cpp = list->freelist = (char **) __ckd_calloc__ (list->blocksize, elemsize,
							 caller_file, caller_line);
	cp = (char *) cpp;
	for (j = list->blocksize - 1; j > 0; --j) {
	    cp += elemsize;
	    *cpp = cp;
	    cpp = (char **)cp;
	}
	*cpp = NULL;
	--(list->blk_alloc);
    }
    
    /* Unlink and return first element in freelist */
    cp = (char *)(list->freelist);
    list->freelist = (char **)(*(list->freelist));
#else
    if ((cp = (char *) malloc (elemsize)) == NULL) {
	E_FATAL("malloc(%d) failed from %s(%d)\n", elemsize, caller_file, caller_line);
    }
#endif

    return (cp);
}


void __myfree__ (char *elem, int32 elemsize, char *caller_file, int32 caller_line)
{
#if (! __PURIFY__)
    char **cpp;
    mylist_t *prev, *list;
    
    /* Find list for elemsize */
    prev = NULL;
    for (list = head; list && (list->elemsize != elemsize); list = list->next)
	prev = list;

    if (! list) {
	E_FATAL("Unknown list item size: %d; called from %s(%d)\n",
		elemsize, caller_file, caller_line);
    } else if (prev) {
	/* List found; move entry to head of list */
	prev->next = list->next;
	list->next = head;
	head = list;
    }

    /*
     * Insert freed item at head of list.
     * NOTE: skipping check for size being multiple of (void *).
     */
    cpp = (char **) elem;
    *cpp = (char *) list->freelist;
    list->freelist = cpp;
#else
    free (elem);
#endif
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * ckd_alloc.h -- Memory allocation package.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 19-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Removed file,line arguments from free functions.
 * 
 * 01-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


/*********************************************************************
 *
 * $Header: /cvsroot/cmusphinx/sphinx3/src/libutil/ckd_alloc.h,v 1.2 2001/12/11 04:40:56 lenzo Exp $
 *
 * Carnegie Mellon ARPA Speech Group
 *
 * Copyright (c) 1994 Carnegie Mellon University.
 * All rights reserved.
 *
 *********************************************************************
 *
 * file: ckd_alloc.h
 * 
 * traceability: 
 * 
 * description: 
 * 
 * author: 
 * 
 *********************************************************************/


#ifndef _LIBUTIL_CKD_ALLOC_H_
#define _LIBUTIL_CKD_ALLOC_H_


#include <stdlib.h>
#include "prim_type.h"


/*
 * The following functions are similar to the malloc family, except that they have
 * two additional parameters, caller_file and caller_line, for error reporting.
 * All functions print a diagnostic message and exit if any error occurs.
 */

void *__ckd_calloc__(size_t n_elem, size_t elem_size,
		     const char *caller_file, int caller_line);

void *__ckd_malloc__(size_t size,
		     const char *caller_file, int caller_line);

void *__ckd_realloc__(void *ptr, size_t new_size,
		      const char *caller_file, int caller_line);

/*
 * Like strdup, except that if an error occurs it prints a diagnostic message
 * and exits.
 */
char *__ckd_salloc__(const char *origstr,
		     const char *caller_file, int32 caller_line);

/*
 * Allocate a 2-D array and return ptr to it (ie, ptr to vector of ptrs).
 * The data area is allocated in one block so it can also be treated as a 1-D array.
 */
void **__ckd_calloc_2d__(int32 d1, int32 d2,	/* In: #elements in the 2 dimensions */
			 int32 elemsize,	/* In: Size (#bytes) of each element */
			 const char *caller_file, int32 caller_line);	/* In */
#if 1
void **__ckd_calloc_2d__a(int32 d1, int32 d2,	/* In: #elements in the 2 dimensions */
			 int32 elemsize,	/* In: Size (#bytes) of each element */
			 const char *caller_file, int32 caller_line);	/* In */
#endif
/*
 * Allocate a 3-D array and return ptr to it.
 * The data area is allocated in one block so it can also be treated as a 1-D array.
 */
void ***__ckd_calloc_3d__(int32 d1, int32 d2, int32 d3,	/* In: #elems in the dims */
			  int32 elemsize,		/* In: Size (#bytes) per element */
			  const char *caller_file, int32 caller_line);	/* In */

/* Free a 2-D array (ptr) previously allocated by ckd_calloc_2d */
void ckd_free_2d(void **ptr);

#if 1
void ckd_free_2da(void **ptr);
#endif

/* Free a 3-D array (ptr) previously allocated by ckd_calloc_3d */
void ckd_free_3d(void ***ptr);


/*
 * Macros to simplify the use of above functions.
 * One should use these, rather than target functions directly.
 */
#define ckd_calloc(n,sz)	__ckd_calloc__((n),(sz),__FILE__,__LINE__)
#define ckd_malloc(sz)		__ckd_malloc__((sz),__FILE__,__LINE__)
#define ckd_realloc(ptr,sz)	__ckd_realloc__(ptr,(sz),__FILE__,__LINE__)
#define ckd_salloc(ptr)		__ckd_salloc__(ptr,__FILE__,__LINE__)
#define ckd_calloc_2d(d1,d2,sz)	__ckd_calloc_2d__((d1),(d2),(sz),__FILE__,__LINE__)
#define ckd_calloc_2da(d1,d2,sz) __ckd_calloc_2d__a((d1),(d2),(sz),__FILE__,__LINE__)
#define ckd_calloc_3d(d1,d2,d3,sz) __ckd_calloc_3d__((d1),(d2),(d3),(sz),__FILE__,__LINE__)

#define ckd_free(ptr)		free(ptr)


/*
 * Functions for managing graph elements without wasting memory.
 * Allocate and return an element of size elemsize.  elemsize must be a multiple of
 * a pointer size.  The allocated element is not zeroed, unlike calloc.
 * The function internally allocates a block that can accommodate several such elements,
 * anticipating future allocation requests.
 */
char *__mymalloc__ (int32 elemsize, char *file, int32 line);

/*
 * Free a graph element (of given size) that was previously allocated using mymalloc.
 * The element is not really freed; it is returned to an internally maintained
 * freelist pool.
 */
void __myfree__ (char *elem, int32 elemsize, char *file, int32 line);

/*
 * Macros to simplify the use of above functions.  One should use these, rather
 * than target functions directly.
 * For debugging purposes one can redefine the following to malloc() and free().
 */
#define mymalloc(sz)		__mymalloc__((sz),__FILE__,__LINE__)
#define myfree(ptr,sz)		__myfree__(ptr,(sz),__FILE__,__LINE__)


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
#include "libutil.h"

void  parse_args_file(char *live_args);
void  parse_args_free();
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cmd_ln.c -- Command line argument parsing.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 10-Sep-1998	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changed strcasecmp() call in cmp_name() to strcmp_nocase() call.
 * 
 * 15-Jul-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added required arguments handling.
 * 
 * 07-Dec-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created, based on Eric's implementation.  Basically, combined several
 *		functions into one, eliminated validation, and simplified the interface.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "cmd_ln.h"
#include "err.h"
#include "ckd_alloc.h"
#include "hash.h"
#include "case.h"


/* Storage for argument values */
typedef struct argval_s {
    anytype_t val;
    const void *ptr;	/* Needed (with NULL value) in case there is no default */
} argval_t;
static argval_t *argval = NULL;
static hash_table_t *ht;	/* Hash table */


#if 0
static const char *arg_type2str (argtype_t t)
{
    switch (t) {
    case ARG_INT32:
    case REQARG_int32:
	return ("int32");
	break;
    case ARG_FLOAT32:
    case REQARG_FLOAT32:
	return ("float32");
	break;
    case ARG_FLOAT64:
    case REQARG_FLOAT64:
	return ("float64");
	break;
    case ARG_STRING:
    case REQARG_STRING:
	return ("string");
	break;
    default: E_FATAL("Unknown argument type: %d\n", t);
    }
}
#endif


/*
 * Find max length of name and default fields in the given defn array.
 * Return #items in defn array.
 */
static int32 arg_strlen (arg_t *defn, int32 *namelen, int32 *deflen)
{
    int32 i, l;
    
    *namelen = *deflen = 0;
    for (i = 0; defn[i].name; i++) {
	l = strlen (defn[i].name);
	if (*namelen < l)
	    *namelen = l;
	
	if (defn[i].deflt) {
	    l = strlen (defn[i].deflt);
	    if (*deflen < l)
		*deflen = l;
	}
    }

    return i;
}


/* For sorting argument definition list by name */
static arg_t *tmp_defn;

static int32 cmp_name (const void *a, const void *b)
{
    return (strcmp_nocase (tmp_defn[*((int32 *)a)].name, tmp_defn[*((int32 *)b)].name));
}

static int32 *arg_sort (arg_t *defn, int32 n)
{
    int32 *pos;
    int32 i;
    
    pos = (int32 *) ckd_calloc (n, sizeof(int32));
    for (i = 0; i < n; i++)
	pos[i] = i;
    tmp_defn = defn;
    qsort (pos, n, sizeof(int32), cmp_name);
    tmp_defn = NULL;

    return pos;
}


static int32 arg_str2val (argval_t *v, argtype_t t, char *str)
{
    if (! str)
	v->ptr = NULL;
    else {
	switch (t) {
	case ARG_INT32:
	case REQARG_INT32:
	    if (sscanf (str, "%d", &(v->val.int32)) != 1)
		return -1;
	    v->ptr = (void *) &(v->val.int32);
	    break;
	case ARG_FLOAT32:
	case REQARG_FLOAT32:
	    if (sscanf (str, "%f", &(v->val.float32)) != 1)
		return -1;
	    v->ptr = (void *) &(v->val.float32);
	    break;
	case ARG_FLOAT64:
	case REQARG_FLOAT64:
	    if (sscanf (str, "%lf", &(v->val.float64)) != 1)
		return -1;
	    v->ptr = (void *) &(v->val.float64);
	    break;
	case ARG_STRING:
	case REQARG_STRING:
	    v->ptr = (void *) str;
	    break;
	default: E_FATAL("Unknown argument type: %d\n", t);
	}
    }
    
    return 0;
}


static void arg_dump (FILE *fp, arg_t *defn, int32 doc)
{
    int32 *pos;
    int32 i, j, l, n;
    int32 namelen, deflen;
    const void *vp;
    
    /* Find max lengths of name and default value fields, and #entries in defn */
    n = arg_strlen (defn, &namelen, &deflen);
    namelen = namelen & 0xfffffff8;	/* Previous tab position */
    deflen = deflen & 0xfffffff8;	/* Previous tab position */

    fprintf (fp, "[NAME]");
    for (l = 6; l < namelen; l += 8)	/* strlen("[NAME]") */
	fprintf (fp, "\t");
    fprintf (fp, "\t[DEFLT]");
    for (l = 6; l < deflen; l += 8)	/* strlen("[DEFLT]") */
	fprintf (fp, "\t");
    fprintf (fp, "\t[VALUE]\n");
    
    /* Print current configuration, sorted by name */
    pos = arg_sort (defn, n);
    for (i = 0; i < n; i++) {
	j = pos[i];
	
	fprintf (fp, "%s", defn[j].name);
	for (l = strlen(defn[j].name); l < namelen; l += 8)
	    fprintf (fp, "\t");

	fprintf (fp, "\t");
	if (defn[j].deflt) {
	    fprintf (fp, "%s", defn[j].deflt);
	    l = strlen (defn[j].deflt);
	} else
	    l = 0;
	for (; l < deflen; l += 8)
	    fprintf (fp, "\t");
	
	fprintf (fp, "\t");
	if (doc) {
	    if (defn[j].doc)
		fprintf (fp, "%s", defn[j].doc);
	} else {
	    vp = cmd_ln_access (defn[j].name);
	    if (vp) {
		switch (defn[j].type) {
		case ARG_INT32:
		case REQARG_INT32:
		    fprintf (fp, "%d", *((int32 *) vp));
		    break;
		case ARG_FLOAT32:
		case REQARG_FLOAT32:
		    fprintf (fp, "%e", *((float32 *) vp));
		    break;
		case ARG_FLOAT64:
		case REQARG_FLOAT64:
		    fprintf (fp, "%e", *((float64 *) vp));
		    break;
		case ARG_STRING:
		case REQARG_STRING:
		    fprintf (fp, "%s", (char *)vp);
		    break;
		default: E_FATAL("Unknown argument type: %d\n", defn[j].type);
		}
	    }
	}
	
	fprintf (fp, "\n");
    }
    ckd_free (pos);
    
    fprintf (fp, "\n");
    fflush (fp);
}


int32 cmd_ln_parse (arg_t *defn, int32 argc, char *argv[])
{
    int32 i, j, n;
    
    if (argval)
	E_FATAL("Multiple sets of argument definitions not supported\n");
    
    /* Echo command line */
    E_INFO("Parsing command line:\n");
    for (i = 0; i < argc; i++) {
	if (argv[i][0] == '-')
	    fprintf (stderr, "\\\n\t");
	fprintf (stderr, "%s ", argv[i]);
    }
    fprintf (stderr, "\n\n");
    fflush (stderr);
    
    /* Find number of argument names in definition */
    for (n = 0; defn[n].name; n++);
    
    /* Allocate memory for argument values */
    ht = hash_new (n, 0 /* argument names are case-sensitive */);
    argval = (argval_t *) ckd_calloc (n, sizeof(argval_t));
    
    /* Enter argument names into hash table */
    for (i = 0; i < n; i++) {
	/* Associate argument name with index i */
	if (hash_enter (ht, defn[i].name, i) != i)
	    E_FATAL("Duplicate argument name: %s\n", defn[i].name);
    }
    
    /* Parse command line arguments (name-value pairs); skip argv[0] if argc is odd */
    for (j = 1; j < argc; j += 2) {
	if (hash_lookup(ht, argv[j], &i) < 0) {
	    E_ERROR("Unknown argument: %s\n", argv[j]);
	    cmd_ln_print_help (stderr, defn);
	    exit(-1);
	}
	
	/* Check if argument has already been parsed before */
	if (argval[i].ptr)
	    E_FATAL("Multiple occurrences of argument %s\n", argv[j]);
	
	if (j+1 >= argc) {
	    E_ERROR("Argument value for '%s' missing\n", argv[j]);
	    cmd_ln_print_help (stderr, defn);
	    exit(-1);
	}
	
	/* Enter argument value */
	if (arg_str2val (argval+i, defn[i].type, argv[j+1]) < 0) {
	    E_ERROR("Bad argument value for %s: %s\n", argv[j], argv[j+1]);
	    cmd_ln_print_help (stderr, defn);
	    exit(-1);
	}

	assert (argval[i].ptr);
    }
    
    /* Fill in default values, if any, for unspecified arguments */
    for (i = 0; i < n; i++) {
	if (! argval[i].ptr) {
	    if (arg_str2val (argval+i, defn[i].type, defn[i].deflt) < 0)
		E_FATAL("Bad default argument value for %s: %s\n",
			defn[i].name, defn[i].deflt);
	}
    }
    
    /* Check for required arguments; exit if any missing */
    j = 0;
    for (i = 0; i < n; i++) {
	if ((defn[i].type & ARG_REQUIRED) && (! argval[i].ptr)) {
	    E_ERROR("Missing required argument %s\n", defn[i].name);
	    j++;
	}
    }
    if (j > 0) {
	cmd_ln_print_help (stderr, defn);
	exit(-1);
    }
    
    /* Print configuration */
    fprintf (stderr, "Configuration in effect:\n");

    arg_dump (stderr, defn, 0);

    return 0;
}


void cmd_ln_print_help (FILE *fp, arg_t *defn)
{
    fprintf (fp, "Arguments list definition:\n");
    arg_dump (fp, defn, 1);
}


const void *cmd_ln_access (char *name)
{
    int32 i;
    
    if (! argval)
	E_FATAL("cmd_ln_access invoked before cmd_ln_parse\n");
    
    if (hash_lookup (ht, name, &i) < 0)
	E_FATAL("Unknown argument: %s\n", name);
    
    return (argval[i].ptr);
}

/* RAH, 4.17.01, free memory allocated above  */
void cmd_ln_free ()
{
  hash_free (ht);
  ckd_free ((void *) argval);

}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cmd_ln.h -- Command line argument parsing.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 15-Jul-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added required arguments types.
 * 
 * 07-Dec-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created, based on Eric's implementation.  Basically, combined several
 *		functions into one, eliminated validation, and simplified the interface.
 */


#ifndef _LIBUTIL_CMD_LN_H_
#define _LIBUTIL_CMD_LN_H_


#include "prim_type.h"

#define ARG_REQUIRED	1

/* Arguments of these types are OPTIONAL */
#define ARG_INT32	2
#define ARG_FLOAT32	4
#define ARG_FLOAT64	6
#define ARG_STRING	8

/* Arguments of these types are REQUIRED */
#define REQARG_INT32	(ARG_INT32 | ARG_REQUIRED)
#define REQARG_FLOAT32	(ARG_FLOAT32 | ARG_REQUIRED)
#define REQARG_FLOAT64	(ARG_FLOAT64 | ARG_REQUIRED)
#define REQARG_STRING	(ARG_STRING | ARG_REQUIRED)
typedef int32 argtype_t;


typedef struct {
    char *name;		/* Name of the command line switch (case-insensitive) */
    argtype_t type;
    char *deflt;	/* Default value (as a printed string) or NULL if none */
    char *doc;		/* Documentation/description string */
} arg_t;


/*
 * Parse the given list of arguments (name-value pairs) according to the given definitions.
 * Argument values can be retrieved in future using cmd_ln_access().  argv[0] is assumed to be
 * the program name and skipped.  Any unknown argument name causes a fatal error.  The routine
 * also prints the prevailing argument values (to stderr) after parsing.
 * Return value: 0 if successful, -1 if error.
 */
int32 cmd_ln_parse (arg_t *defn,	/* In: Array of argument name definitions */
		    int32 argc,		/* In: #Actual arguments */
		    char *argv[]);	/* In: Actual arguments */


/*
 * Return a pointer to the previously parsed value for the given argument name.
 * The pointer should be cast to the appropriate type before use:
 * e.g., *((float32 *) cmd_ln_access ("-eps") to get the float32 argument named "-eps".
 * And, some convenient wrappers around this function.
 */
const void *cmd_ln_access (char *name);	/* In: Argument name whose value is sought */
#define cmd_ln_str(name)	((char *)cmd_ln_access(name))
#define cmd_ln_int32(name)	(*((int32 *)cmd_ln_access(name)))
#define cmd_ln_float32(name)	(*((float32 *)cmd_ln_access(name)))
#define cmd_ln_float64(name)	(*((float64 *)cmd_ln_access(name)))


/*
 * Print a help message listing the valid argument names, and the associated
 * attributes as given in defn.
 */
void  cmd_ln_print_help (FILE *fp,	/* In: File to which to print */
			 arg_t *defn);	/* In: Array of argument name definitions */

/* RAH, 4.17.01, call this to free memory allocated during cmd_ln_parse() */
void cmd_ln_free ();


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cmn.c -- Various forms of cepstral mean normalization
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added cmn_free() and moved *mean and *var out global space and named them cmn_mean and cmn_var
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changed the name norm_mean() to cmn().
 * 
 * 19-Jun-1996	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changed to compute CMN over ALL dimensions of cep instead of 1..12.
 * 
 * 04-Nov-1995	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#include "cmn.h"

static float32 *cmn_mean = NULL;
static float32 *cmn_var = NULL;


void cmn (float32 **mfc, int32 varnorm, int32 n_frame, int32 veclen)
{
  /*    static float32 *mean = NULL; */ /*  */
  /*    static float32 *var = NULL;	*/ /*  */
    float32 *mfcp;
    float32 t;
    int32 i, f;

    /* assert ((n_frame > 0) && (veclen > 0)); */
    /* Added by PPK to prevent this assert from aborting Sphinx 3 */
    if ((n_frame <= 0) || (veclen <= 0)) {
        return;
    }
    
    if (cmn_mean == NULL)
	cmn_mean = (float32 *) ckd_calloc (veclen, sizeof (float32));

    /* Find mean cep vector for this utterance */
    for (i = 0; i < veclen; i++)
      cmn_mean[i] = 0.0;
    for (f = 0; f < n_frame; f++) {
	mfcp = mfc[f];
	for (i = 0; i < veclen; i++)
	    cmn_mean[i] += mfcp[i];
    }
    for (i = 0; i < veclen; i++)
	cmn_mean[i] /= n_frame;
    
    if (! varnorm) {
	/* Subtract mean from each cep vector */
	for (f = 0; f < n_frame; f++) {
	    mfcp = mfc[f];
	    for (i = 0; i < veclen; i++)
		mfcp[i] -= cmn_mean[i];
	}
    } else {
	/* Scale cep vectors to have unit variance along each dimension, and subtract means */
        if (cmn_var == NULL)
    	    cmn_var = (float32 *) ckd_calloc (veclen, sizeof (float32));
	
        for (i = 0; i < veclen; i++)
	    cmn_var[i] = 0.0;
	
        for (f = 0; f < n_frame; f++) {
    	    mfcp = mfc[f];
	    
	    for (i = 0; i < veclen; i++) {
                t = mfcp[i] - cmn_mean[i];
                cmn_var[i] += t * t;
            }
        }
        for (i = 0; i < veclen; i++) 
	  cmn_var[i] = (float32) sqrt ((float64) n_frame / cmn_var[i]); /* Inverse Std. Dev, RAH added type case from sqrt */

        for (f = 0; f < n_frame; f++) {
	    mfcp = mfc[f];
	    for (i = 0; i < veclen; i++)
	        mfcp[i] = (mfcp[i] - cmn_mean[i]) * cmn_var[i];
        }
    }
}

/* 
 * RAH, free previously allocated memory
 */
void cmn_free ()
{
  ckd_free ((void *) cmn_var);
  ckd_free ((void *) cmn_mean);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cmn.h -- Various forms of cepstral mean normalization
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added cmn_free() and moved *mean and *var out global space and named them cmn_mean and cmn_var
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Copied from previous version.
 */


#ifndef _S3_CMN_H_
#define _S3_CMN_H_


#include "libutil.h"


/*
 * Apply Cepstral Mean Normalization (CMN) to the set of input mfc frames, by subtracting
 * the mean of the input from each frame.  C0 is also included in this process.
 * This function operates on an entire utterance at a time.  Hence, the entire utterance
 * must be available beforehand (batchmode).
 */
void cmn (float32 **mfc,	/* In/Out: mfc[f] = mfc vector in frame f */
	  int32 varnorm,	/* In: if not FALSE, variance normalize the input vectors
				   to have unit variance (along each dimension independently);
				   Irrelevant if no cmn is performed */
	  int32 n_frame,	/* In: #frames of mfc vectors */
	  int32 veclen);	/* In: mfc vector length */


#define CMN_WIN_HWM     800     /* #frames after which window shifted */
#define CMN_WIN         500

void cmn_prior(float32 **incep,  /* In/Out: mfc[f] = mfc vector in frame f*/
	      int32 varnorm,    /* This flag should always be 0 for live */
	      int32 nfr,        /* Number of incoming frames */
              int32 ceplen,     /* Length of the cepstral vector */
	      int32 endutt);    /* Flag indicating end of utterance */


/* RAH, free previously allocated memory */
void cmn_free ();

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*************************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 2000 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 * Created
 */


#include "cmn_prior.h"

void cmn_prior(float32 **incep, int32 varnorm, int32 nfr, int32 ceplen, 
							   int32 endutt)
{
  static float32 *cur_mean = NULL; /* the mean subtracted from input frames */
  static float32 *sum = NULL;	     /* the sum over input frames */
  static int32   nframe;	     /* the total number of input frames */
  static int32   initialize=1;
  float32 sf;
  int32   i, j;
  
  if (varnorm)
    E_FATAL("Variance normalization not implemented in live mode decode\n");
  
  if (initialize){
    cur_mean = (float32 *) ckd_calloc(ceplen, sizeof(float32));
    
    /* A front-end dependent magic number */
    cur_mean[0] = 12.0;
    
    sum      = (float32 *) ckd_calloc(ceplen, sizeof(float32));
    nframe   = 0;
    initialize = 0;
    E_INFO("mean[0]= %.2f, mean[1..%d]= 0.0\n", cur_mean[0], ceplen-1);
  }
  
  if (nfr <= 0)
    return;
  
  for (i = 0; i < nfr; i++){
    for (j = 0; j < ceplen; j++){
      sum[j] += incep[i][j];
      incep[i][j] -= cur_mean[j];
    }
    ++nframe;
  }
  
  /* Shift buffer down if we have more than CMN_WIN_HWM frames */
  if (nframe > CMN_WIN_HWM) {
    sf = (float32) (1.0/nframe);
    for (i = 0; i < ceplen; i++)
      cur_mean[i] = sum[i] * sf;
    
    /* Make the accumulation decay exponentially */
    if (nframe >= CMN_WIN_HWM) {
      sf = CMN_WIN * sf;
      for (i = 0; i < ceplen; i++)
	sum[i] *= sf;
      nframe = CMN_WIN;
    }
  }
  
  if (endutt) {
    /* Update mean buffer */
    
    /* 01.15.01 RAH - removing this printf, it is damn annoying
       printf("Mean norm update: from <"); 
       for (i = 0; i < ceplen; i++) 
       printf("%5.2f ", cur_mean[i]); 
       printf(">\n");
    */
    
    sf = (float32) (1.0/nframe);
    for (i = 0; i < ceplen; i++)
      cur_mean[i] = sum[i] * sf;
    
    /* Make the accumulation decay exponentially */
    if (nframe > CMN_WIN_HWM) {
      sf = CMN_WIN * sf;
      for (i = 0; i < ceplen; i++)
	sum[i] *= sf;
      nframe = CMN_WIN;
    }
    
    /* 01.15.01 RAH - removing this printf, it is damn annoying
       printf("Mean norm update: to   < ");
       for (i = 0; i < ceplen; i++)
       printf("%5.2f ", cur_mean[i]);
       printf(">\n");
    */
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cmn.h -- Various forms of cepstral mean normalization
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Copied from previous version.
 */


#ifndef _S3_CMN_PRIOR_H_
#define _S3_CMN_PRIOR_H_


#include "libutil.h"

/*
 * Apply Cepstral Mean Normalization (CMN) to the set of input mfc frames, 
 * by subtracting the mean of the input from each frame.  C0 is also included 
 * in this process.
 */

#define CMN_WIN_HWM     800     /* #frames after which window shifted */
#define CMN_WIN         500

void cmn_prior(float32 **incep, /* In/Out: mfc[f] = mfc vector in frame f*/
	      int32 varnorm,    /* This flag should always be 0 for live */
	      int32 nfr,        /* Number of incoming frames */
              int32 ceplen,     /* Length of the cepstral vector */
	      int32 endutt);    /* Flag indicating end of utterance */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cont_mgau.c -- Mixture Gaussians for continuous HMM models.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added mgau_free to free memory allocated by mgau_init()
 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added mgau_var_nzvec_floor().
 * 
 * 28-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#include "s3types.h"
#include "bio.h"
#include "vector.h"
#include "logs3.h"
#include "cont_mgau.h"

#if 0/*def SSE2*/
#include <emmintrin.h>
#endif
#define MGAU_PARAM_VERSION	"1.0"	/* Sphinx-3 file format version for mean/var */
#define MGAU_MIXW_VERSION	"1.0"	/* Sphinx-3 file format version for mixw */
#define MGAU_MEAN		1
#define MGAU_VAR		2


/*
 * Sphinx-3 model mean and var files have the same format.  Use this routine for reading
 * either one.
 */
static int32 mgau_file_read(mgau_model_t *g, char *file_name, int32 type)
{
    char tmp;
    FILE *fp;
    int32 i, k, n;
    int32 n_mgau;
    int32 n_feat;
    int32 n_density;
    int32 veclen;
    int32 byteswap, chksum_present;
    float32 *buf, **pbuf;
    char **argname, **argval;
    uint32 chksum;
#ifdef USE_ICC
    int32 a_veclen;
#endif
    
    E_INFO("Reading mixture gaussian file '%s'\n", file_name);
    
    fp = myfopen (file_name, "rb");
    
    /* Read header, including argument-value info and 32-bit byteorder magic */
    if (bio_readhdr (fp, &argname, &argval, &byteswap) < 0)
	E_FATAL("bio_readhdr(%s) failed\n", file_name);
    
    /* Parse argument-value list */
    chksum_present = 0;
    for (i = 0; argname[i]; i++) {
	if (strcmp (argname[i], "version") == 0) {
	    if (strcmp(argval[i], MGAU_PARAM_VERSION) != 0)
		E_WARN("Version mismatch(%s): %s, expecting %s\n",
		       file_name, argval[i], MGAU_PARAM_VERSION);
	} else if (strcmp (argname[i], "chksum0") == 0) {
	    chksum_present = 1;	/* Ignore the associated value */
	}
    }
    bio_hdrarg_free (argname, argval);
    argname = argval = NULL;
    
    chksum = 0;
    
    /* #Codebooks */
    if (bio_fread (&n_mgau, sizeof(int32), 1, fp, byteswap, &chksum) != 1)
	E_FATAL("fread(%s) (#codebooks) failed\n", file_name);
    if (n_mgau >= MAX_S3MGAUID) {
	E_FATAL("%s: #Mixture Gaussians (%d) exceeds limit(%d) enforced by MGAUID type\n",
		file_name, n_mgau, MAX_S3MGAUID);
    }
    
    /* #Features/codebook */
    if (bio_fread (&n_feat, sizeof(int32), 1, fp, byteswap, &chksum) != 1)
	E_FATAL("fread(%s) (#features) failed\n", file_name);
    if (n_feat != 1)
	E_FATAL("#Features streams(%d) != 1\n", n_feat);
    
    /* #Gaussian densities/feature in each codebook */
    if (bio_fread (&n_density, sizeof(int32), 1, fp, byteswap, &chksum) != 1)
	E_FATAL("fread(%s) (#density/codebook) failed\n", file_name);
    
    /* Vector length of feature stream */
    if (bio_fread (&veclen, sizeof(int32), 1, fp, byteswap, &chksum) != 1)
	E_FATAL("fread(%s) (feature vector-length) failed\n", file_name);
    
    /* #Floats to follow; for the ENTIRE SET of CODEBOOKS */
    if (bio_fread (&n, sizeof(int32), 1, fp, byteswap, &chksum) != 1)
	E_FATAL("fread(%s) (total #floats) failed\n", file_name);
    if (n != n_mgau * n_density * veclen) {
	E_FATAL("%s: #float32s(%d) doesn't match dimensions: %d x %d x %d\n",
		file_name, n, n_mgau, n_density, veclen);
    }

    if (type == MGAU_MEAN) {
	/* Allocate memory for mixture gaussian densities */
#ifdef USE_ICC
      a_veclen = (veclen%4)?veclen+4-(veclen%4):veclen;
      n = n_mgau*n_density*a_veclen;
#endif
      g->n_mgau = n_mgau;
	g->max_comp = n_density;
	g->veclen = veclen;
	g->mgau = (mgau_t *) ckd_calloc (n_mgau, sizeof(mgau_t));

#ifdef USE_ICC
	buf = (float32 *) _mm_malloc (n*sizeof(float),16);
#else
	buf = (float32 *) ckd_calloc (n, sizeof(float));
#endif
	pbuf = (float32 **) ckd_calloc (n_mgau * n_density, sizeof(float32 *));
	
	for (i = 0; i < n_mgau; i++) {
	    g->mgau[i].n_comp = n_density;
	    g->mgau[i].mean = pbuf;
	    
	    for (k = 0; k < n_density; k++) {
		g->mgau[i].mean[k] = buf;
#ifdef USE_ICC
		buf += a_veclen; /*veclen;*/
#else
		buf += veclen;
#endif
	    }
	    pbuf += n_density;
	}
	
	buf = g->mgau[0].mean[0];	/* Restore buf to original value */
    } else {
#ifdef USE_ICC
      a_veclen = (veclen%4)?veclen+4-(veclen%4):veclen;
      n = n_mgau*n_density*a_veclen;
#endif
	assert (type == MGAU_VAR);
	
	if (g->n_mgau != n_mgau)
	    E_FATAL("#Mixtures(%d) doesn't match that of means(%d)\n", n_mgau, g->n_mgau);
	if (g->max_comp != n_density)
	    E_FATAL("#Components(%d) doesn't match that of means(%d)\n", n_density, g->max_comp);
	if (g->veclen != veclen)
	    E_FATAL("#Vector length(%d) doesn't match that of means(%d)\n", veclen, g->veclen);
	
#ifdef USE_ICC
	buf = (float32 *) _mm_malloc (n*sizeof(float),16);
#else
	buf = (float32 *) ckd_calloc (n, sizeof(float32));
#endif
	pbuf = (float32 **) ckd_calloc (n_mgau * n_density, sizeof(float32 *));
	
	for (i = 0; i < n_mgau; i++) {
	    if (g->mgau[i].n_comp != n_density)
		E_FATAL("Mixture %d: #Components(%d) doesn't match that of means(%d)\n",
			i, n_density, g->mgau[i].n_comp);
	    
	    g->mgau[i].var = pbuf;
	    
	    for (k = 0; k < n_density; k++) {
		g->mgau[i].var[k] = buf;
#ifdef USE_ICC
		buf += a_veclen; /*veclen;*/
#else
		buf += veclen;
#endif
	    }
	    pbuf += n_density;
	}
	
	buf = (float32 *) ckd_calloc (n_mgau * n_density, sizeof(float32));
	for (i = 0; i < n_mgau; i++) {
	    g->mgau[i].lrd = buf;
	    buf += n_density;
	}
	
	buf = g->mgau[0].var[0];	/* Restore buf to original value */
    }

#ifdef USE_ICC
    if (type == MGAU_MEAN) {
      for (i=0; i < n_mgau; i++) {
	for (k=0; k < n_density; k++) {
	  /*	  printf("g->mgau[%d].mean[%d] %p\n",i,k,g->mgau[i].mean[k]);*/
	  bio_fread(g->mgau[i].mean[k], sizeof(float32), veclen, fp, byteswap, &chksum);
	}
      }
    } else {
      for (i=0; i < n_mgau; i++) {
	for (k=0; k < n_density; k++) {
	  bio_fread(g->mgau[i].var[k], sizeof(float32), veclen, fp, byteswap, &chksum);
	  g->mgau[i].var[k][veclen]=0.0; /* to avoid loop peel in mgau_eval*/
	}
      }
    }
#else   
    /* Read mixture gaussian densities data */
    if (bio_fread (buf, sizeof(float32), n, fp, byteswap, &chksum) != n)
	E_FATAL("fread(%s) (densitydata) failed\n", file_name);
#endif

    if (chksum_present)
	bio_verify_chksum (fp, byteswap, chksum);

    if (fread (&tmp, 1, 1, fp) == 1)
	E_FATAL("%s: More data than expected\n", file_name);
    
    fclose(fp);
    
    E_INFO("%d mixture Gaussians, %d components, veclen %d\n", n_mgau, n_density, veclen);
    
    return 0;
}


static int32 mgau_mixw_read(mgau_model_t *g, char *file_name, float64 mixwfloor)
{
    char **argname, **argval;
    char eofchk;
    FILE *fp;
    int32 byteswap, chksum_present;
    uint32 chksum;
    int32 *buf;
    float32 *pdf;
    int32 i, j, n;
    int32 n_mgau;
    int32 n_feat;
    int32 n_comp;
    int32 n_err;
    
    E_INFO("Reading mixture weights file '%s'\n", file_name);
    
    fp = myfopen (file_name, "rb");
    
    /* Read header, including argument-value info and 32-bit byteorder magic */
    if (bio_readhdr (fp, &argname, &argval, &byteswap) < 0)
	E_FATAL("bio_readhdr(%s) failed\n", file_name);
    
    /* Parse argument-value list */
    chksum_present = 0;
    for (i = 0; argname[i]; i++) {
	if (strcmp (argname[i], "version") == 0) {
	    if (strcmp(argval[i], MGAU_MIXW_VERSION) != 0)
		E_WARN("Version mismatch(%s): %s, expecting %s\n",
			file_name, argval[i], MGAU_MIXW_VERSION);
	} else if (strcmp (argname[i], "chksum0") == 0) {
	    chksum_present = 1;	/* Ignore the associated value */
	}
    }
    bio_hdrarg_free (argname, argval);
    argname = argval = NULL;

    chksum = 0;

    /* Read #senones, #features, #codewords, arraysize */
    if ((bio_fread (&n_mgau, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&n_feat, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&n_comp, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&n, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {
	E_FATAL("bio_fread(%s) (arraysize) failed\n", file_name);
    }
    if (n_feat != 1)
	E_FATAL("#Features streams(%d) != 1\n", n_feat);
    if (n != n_mgau * n_comp) {
	E_FATAL("%s: #float32s(%d) doesn't match header dimensions: %d x %d\n",
		file_name, i, n_mgau, n_comp);
    }
    if (n_mgau != g->n_mgau)
	E_FATAL("%s: #Mixture Gaussians(%d) doesn't match mean/var parameters(%d)\n",
		n_mgau, g->n_mgau);
    
    buf = (int32 *) ckd_calloc (n_mgau * n_comp, sizeof(int32));
    for (i = 0; i < n_mgau; i++) {
	if (n_comp != mgau_n_comp(g,i))
	    E_FATAL("Mixture %d: #Weights(%d) doesn't match #Gaussian components(%d)\n",
		    i, n_comp, mgau_n_comp(g,i));
	
	g->mgau[i].mixw = buf;
	buf += g->mgau[i].n_comp;
    }
    
    /* Temporary structure to read in floats before conversion to (int32) logs3 */
    pdf = (float32 *) ckd_calloc (n_comp, sizeof(float32));
    
    /* Read mixw data, normalize, floor, convert to logs3 */
    n_err = 0;
    for (i = 0; i < n_mgau; i++) {
	if (bio_fread((void *)pdf, sizeof(float32), n_comp, fp, byteswap, &chksum) != n_comp)
	    E_FATAL("bio_fread(%s) (arraydata) failed\n", file_name);
	
	/* Normalize and floor */
	if (vector_is_zero (pdf, n_comp)) {
	    n_err++;
	    for (j = 0; j < n_comp; j++)
		mgau_mixw(g,i,j) = S3_LOGPROB_ZERO;
	} else {
	    vector_nz_floor (pdf, n_comp, mixwfloor);
	    vector_sum_norm (pdf, n_comp);
	    for (j = 0; j < n_comp; j++)
		mgau_mixw(g,i,j) = (pdf[j] != 0.0) ? logs3(pdf[j]) : S3_LOGPROB_ZERO;
	}
    }
    if (n_err > 0)
	E_ERROR("Weight normalization failed for %d senones\n", n_err);

    ckd_free (pdf);

    if (chksum_present)
	bio_verify_chksum (fp, byteswap, chksum);
    
    if (fread (&eofchk, 1, 1, fp) == 1)
	E_FATAL("More data than expected in %s\n", file_name);

    fclose(fp);

    E_INFO("Read %d x %d mixture weights\n", n_mgau, n_comp);
    
    return 0;
}


/*
 * Compact each mixture Gaussian in the given model by removing any uninitialized components.
 * A component is considered to be uninitialized if its variance is the 0 vector.  Compact by
 * copying the data rather than moving pointers.  Otherwise, malloc pointers could get
 * corrupted.
 */
static void mgau_uninit_compact (mgau_model_t *g)
{
    int32 m, c, c2, n, nm;
    
    E_INFO("Removing uninitialized Gaussian densities\n");
    
    n = 0;
    nm = 0;
    for (m = 0; m < mgau_n_mgau(g); m++) {
	for (c = 0, c2 = 0; c < mgau_n_comp(g,m); c++) {
	    if (! vector_is_zero (mgau_var(g,m,c), mgau_veclen(g))) {
		if (c2 != c) {
		    memcpy (mgau_mean(g,m,c2), mgau_mean(g,m,c),
			    mgau_veclen(g) * sizeof(float32));
		    memcpy (mgau_var(g,m,c2), mgau_var(g,m,c),
			    mgau_veclen(g) * sizeof(float32));
		    mgau_mixw(g,m,c2) = mgau_mixw(g,m,c);
		}
		c2++;
	    } else {
		n++;
	    }
	}
	mgau_n_comp(g,m) = c2;
	if (c2 == 0) {
	    fprintf (stderr, " %d", m);
	    fflush (stderr);
	    nm++;
	}
    }
    if (nm > 0)
	fprintf (stderr, "\n");
    
    if ((nm > 0) || (n > 0))
	E_INFO ("%d densities removed (%d mixtures removed entirely)\n", n, nm);
}


static void mgau_var_floor (mgau_model_t *g, float64 floor)
{
  int32 m, c, i, n;
  
  E_INFO("Applying variance floor\n");
  n = 0;
  for (m = 0; m < mgau_n_mgau(g); m++) {
    for (c = 0; c < mgau_n_comp(g,m); c++) {
      for (i = 0; i < mgau_veclen(g); i++) {
	if (g->mgau[m].var[c][i] < floor) {
	  g->mgau[m].var[c][i] = (float32) floor;
	  n++;
	}
      }
    }
  }
  E_INFO("%d variance values floored\n", n);
}


int32 mgau_var_nzvec_floor (mgau_model_t *g, float64 floor)
{
  int32 m, c, i, n, l;
  float32 *var;
  
  E_INFO("Applying variance floor to non-zero variance vectors\n");
  
  l = mgau_veclen(g);
  
  n = 0;
  for (m = 0; m < mgau_n_mgau(g); m++) {
    for (c = 0; c < mgau_n_comp(g,m); c++) {
      var = g->mgau[m].var[c];
      
      if (! vector_is_zero (var, l)) {
	for (i = 0; i < l; i++) {
	  if (var[i] < floor) {
	    var[i] = (float32) floor;
	    n++;
	  }
	}
      }
    }
  }
  
  E_INFO("%d variance values floored\n", n);
  
  return n;
}


/*
 * Some of the Mahalanobis distance computation (between Gaussian density means and given
 * vectors) can be carried out in advance.  (See comment in .h file.)
 */
static int32 mgau_precomp (mgau_model_t *g)
{
    int32 m, c, i;
    float64 lrd;
    
    E_INFO("Precomputing Mahalanobis distance invariants\n");
    
    for (m = 0; m < mgau_n_mgau(g); m++) {
	for (c = 0; c < mgau_n_comp(g,m); c++) {
	    lrd = 0.0;
	    for (i = 0; i < mgau_veclen(g); i++) {
		lrd += log(g->mgau[m].var[c][i]);
		
		/* Precompute this part of the exponential */
		g->mgau[m].var[c][i] = (float32) (1.0 / (g->mgau[m].var[c][i] * 2.0));
	    }
	    
	    lrd += mgau_veclen(g) * log(2.0 * PI);	/* (2pi)^velen */
	    mgau_lrd(g,m,c) = (float32)(-0.5 * lrd);	/* Reciprocal, sqrt */
	}
    }
    
    return 0;
}


/* At the moment, S3 models have the same #means in each codebook and 1 var/mean */
mgau_model_t *mgau_init (char *meanfile, char *varfile, float64 varfloor,
			 char *mixwfile, float64 mixwfloor,
			 int32 precomp)
{
    mgau_model_t *g;
    
    assert (meanfile != NULL);
    assert (varfile != NULL);
    assert (varfloor >= 0.0);
    assert (mixwfile != NULL);
    assert (mixwfloor >= 0.0);
    
    g = (mgau_model_t *) ckd_calloc (1, sizeof(mgau_model_t));
    
    /* Read means and (diagonal) variances for all mixture gaussians */
    mgau_file_read (g, meanfile, MGAU_MEAN);
    mgau_file_read (g, varfile, MGAU_VAR);
    mgau_mixw_read (g, mixwfile, mixwfloor);
    
    mgau_uninit_compact (g);		/* Delete uninitialized components */
    
    if (varfloor > 0.0)
	mgau_var_floor (g, varfloor);	/* Variance floor after above compaction */
    
    if (precomp)
	mgau_precomp (g);		/* Precompute Mahalanobis distance invariants */
    
    g->distfloor = logs3_to_log (S3_LOGPROB_ZERO);	/* Floor for Mahalanobis distance values */
    
    return g;
}


int32 mgau_comp_eval (mgau_model_t *g, int32 s, float32 *x, int32 *score)
{
    mgau_t *mgau;
    int32 veclen;
    float32 *m, *v;
    float64 dval, diff, f;
    int32 bs;
    int32 i, c;



    
    veclen = mgau_veclen(g);
    mgau = &(g->mgau[s]);
    f = log_to_logs3_factor();

    bs = MAX_NEG_INT32;
    for (c = 0; c < mgau->n_comp; c++) {
	m = mgau->mean[c];
	v = mgau->var[c];
	dval = mgau->lrd[c];
	
	for (i = 0; i < veclen; i++) {
	    diff = x[i] - m[i];
	    dval -= diff * diff * v[i];
	}
	
	if (dval < g->distfloor)
	    dval = g->distfloor;
	
	score[c] = (int32) (f * dval);
	if (score[c] > bs)
	    bs = score[c];
    }
    
    return bs;
}


/*******************************************************************/
/* original code */
#if 0
int32 mgau_eval (mgau_model_t *g, int32 m, int32 *active, float32 *x)
{
    mgau_t *mgau;
    int32 veclen, score;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, dval2, diff1, diff2, f;
    int32 i, j, c;
    
    veclen = mgau_veclen(g);
    mgau = &(g->mgau[m]);
    f = log_to_logs3_factor();
    score = S3_LOGPROB_ZERO;
    
    if (! active) {	/* No short list; use all */
	for (c = 0; c < mgau->n_comp-1; c += 2) {	/* Interleave 2 components for speed */
	    m1 = mgau->mean[c];
	    m2 = mgau->mean[c+1];
	    v1 = mgau->var[c];
	    v2 = mgau->var[c+1];
	    dval1 = mgau->lrd[c];
	    dval2 = mgau->lrd[c+1];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
		diff2 = x[i] - m2[i];
		dval2 -= diff2 * diff2 * v2[i];
	    }
	    
	    if (dval1 < g->distfloor)	/* Floor */
		dval1 = g->distfloor;
	    if (dval2 < g->distfloor)
		dval2 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	    score = logs3_add (score, (int32)(f * dval2) + mgau->mixw[c+1]);
	}
	
	/* Remaining iteration if n_mean odd */
	if (c < mgau->n_comp) {
	    m1 = mgau->mean[c];
	    v1 = mgau->var[c];
	    dval1 = mgau->lrd[c];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
	    }
	    
	    if (dval1 < g->distfloor)
		dval1 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	}
    } else {
	for (j = 0; active[j] >= 0; j++) {
	    c = active[j];
	    
	    m1 = mgau->mean[c];
	    v1 = mgau->var[c];
	    dval1 = mgau->lrd[c];
	    
	    for (i = 0; i < veclen; i++) {
		diff1 = x[i] - m1[i];
		dval1 -= diff1 * diff1 * v1[i];
	    }
	    
	    if (dval1 < g->distfloor)
		dval1 = g->distfloor;
	    
	    score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
	}
    }
    
    return score;
}
#else /* unrolled or SIMD code */

#ifdef SSE2 /* SIMD code */


/* 
   inner loop of mgau_eval (simd version)
   returns dval1 
*/

float64 mgau_eval_inner(const mgau_t* mgau, const int32 veclen, const int32 c, 
			const float32 *x) {

  __declspec(align(16)) static const float32 zero[4] = {0.0, 0.0, 0.0, 0.0};
  __declspec(align(16)) static const float32 mask[4] = {1.0, 1.0, 1.0, 0.0};
  float32 *m1, *v1, tmp;
  float64 dval1, diff1;
  int32 i;

  m1 = mgau->mean[c];
  v1 = mgau->var[c];
  dval1 = mgau->lrd[c];
  i = (veclen+1)>>2;
  /*assert(veclen==39);*/
#if 0
  float32 *x_ptr, *m1_ptr, *v1_ptr;
  __m128 xmm_psum = _mm_load_ps(zero);

  x_ptr = x;
  m1_ptr = m1;
  v1_ptr = v1;
  
  __m128 xmm_mask = _mm_load_ps(mask);
  __m128d x_dval1 = _mm_load_sd(&dval1);
  
  for (i=0;i<=veclen;i+=4,v1_ptr+=4,m1_ptr+=4,x_ptr+=4) {
    __m128 xmm_v1 = _mm_load_ps(v1_ptr);
    __m128 xmm_diff = _mm_sub_ps(_mm_load_ps(x_ptr),_mm_load_ps (m1_ptr));
    xmm_psum = _mm_add_ps(xmm_psum,_mm_mul_ps(xmm_v1,_mm_mul_ps(xmm_diff, xmm_diff)));
  }

#if 0
  __m128 xmm_v1 = _mm_load_ps(v1_ptr);
  __m128 xmm_diff = _mm_sub_ps(_mm_load_ps(x_ptr),_mm_load_ps (m1_ptr));
  
  xmm_psum = _mm_add_ps(xmm_psum,_mm_mul_ps(xmm_mask,_mm_mul_ps(xmm_v1,_mm_mul_ps(xmm_diff, xmm_diff))));
#endif
  __m128 xmm_shuf = _mm_shuffle_ps(xmm_psum, xmm_psum,14);
  xmm_psum = _mm_add_ps(xmm_shuf,xmm_psum);

  __m128d xmm_tmp;
  xmm_tmp = _mm_cvtss_sd(xmm_tmp,_mm_add_ss(xmm_psum,_mm_shuffle_ps(xmm_psum, xmm_psum,1)));
  _mm_store_sd(&dval1, _mm_sub_sd(x_dval1,xmm_tmp));
    
#else /*end of intrinsics*/
  __asm
    {
      mov    ecx, [i]       ;
      movaps xmm7, [zero]        ;
      movaps xmm6, xmm7        ;
      mov    eax, [x]          ;
      mov    edx, [m1]         ;
      mov    ebx, [v1]         ;

    mgau_eloop:
#ifdef PREFETCH
      prefetchnta [ebx+320]        ;
      prefetchnta [edx+320]        ;
#endif
      movaps xmm0, [eax]        ; /*load 4 floats from x */
      movaps xmm1, [edx]        ; /*load 4 floats from m1*/
      movaps xmm2, [ebx]        ; /*load 4 floats from v1 */

      movaps xmm3, [eax+16]        ; /*load 4 floats from x */
      movaps xmm4, [edx+16]        ; /*load 4 floats from m1*/
      movaps xmm5, [ebx+16]        ; /*load 4 floats from v1 */

      add    eax, 32       ;
      add    ebx, 32       ;
      add    edx, 32       ;

      subps  xmm0, xmm1        ; /*xmm0 has x-m  */
      subps  xmm3, xmm4        ;

      mulps  xmm0, xmm0        ; /*xmm0 has (x-m)^2  */
      mulps  xmm3, xmm3        ; /*xmm0 has (x-m)^2  */

      mulps  xmm0, xmm2        ; /*xmm0 has (x-m)^2*v1 */
      mulps  xmm3, xmm5        ; /*xmm0 has (x-m)^2*v1 */

      addps  xmm7, xmm0        ; /*partial sum at xmm2*/
      addps  xmm6, xmm3        ; /*partial sum at xmm2*/

      sub     ecx, 2        ;
      cmp     ecx, 0        ;
      jnz     mgau_eloop    ;
    }
#if 0
#ifdef MGAU_NO_LOOP  /*39 elements assumed, undef to unassume */     

      movaps xmm0, [eax]        ; /*load 4 floats from x */
      movaps xmm1, [edx]        ; /*load 4 floats from m1*/
      subps  xmm0, xmm1        ; /*xmm0 has x-m  */
      movaps xmm1, [ebx]        ; /*load 4 floats from v1 */
      mulps  xmm0, xmm0        ; /*xmm0 has (x-m)^2  */
      mulps  xmm0, xmm1        ; /*xmm0 has (x-m)^2*v1 */
      mulps  xmm0, xmm3         ;
      addps  xmm2, xmm0        ; /*partial sum at xmm2*/
    }
#else
    }
  i <<= 2;

  for (;i<veclen; i++) {
    diff1 = x[i] - m1[i];
    dval1 -= diff1 * diff1 * v1[i];
  };
#endif
#endif
 /* reducing partial sum to tmp*/
  __asm
    {
      movsd  xmm4, [dval1]     ;, xmm4     ;
      addps  xmm7, xmm6        ;
      pshufd xmm1, xmm7, 14    ; /* move higher 2 floats to xmm1 */
      addps  xmm7, xmm1        ;
      pshufd xmm1, xmm7, 1     ; /* move 2nd lowest float to xmm1 */
      addss  xmm7, xmm1        ;
      cvtss2sd xmm7, xmm7      ;
      subsd  xmm4, xmm7        ;
      movsd  [dval1],xmm4      ;
      ;movss  [tmp], xmm7        ;
    };

/*dval1 -= tmp;*/
#endif

  return dval1;

}


#else /* unrolled code */

float64 mgau_eval_inner(const mgau_t* mgau, const int32 veclen, const int32 c, const float32 *x) {

  float32 *m1, *v1;
  float64 vdiff[4],vdval[4];
  float64 dval1, diff1;
  int32 i;

  m1 = mgau->mean[c];
  v1 = mgau->var[c];
  dval1 = mgau->lrd[c];

  /* clears vdval, reset v0 and start from the next record of m1 and v1 */
  vdval[0] = vdval[1] = vdval[2] = vdval[3] = 0.0;

  
#pragma novector
  for (i = 0; i < veclen-3; i+=4) {

    /*_mm_prefetch(&m1[i]+40,_MM_HINT_NTA);
      _mm_prefetch(&v1[i]+40,_MM_HINT_NTA);*/

    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
    
    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];
    
    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
    
    vdiff[3] = x[i+3] - m1[i+3];
    vdval[3] += vdiff[3] * vdiff[3] * v1[i+3];

  }

#ifndef MGAU_NO_LOOP

  for (;i<veclen; i++) {
    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
  };
#else
    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];

    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];

    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
#endif

  /* do the reduction */
  dval1 -= (vdval[0] + vdval[1] + vdval[2] +vdval[3] );

  return dval1;

}


#endif /* end of unrolled code */

int32 mgau_eval (mgau_model_t *g, int32 m, int32 *active, float32 *x)
{
    mgau_t *mgau;
    int32 veclen, score;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, /*dval2, diff1, diff2,*/ f;
    int32 i, j, c;
    /*  float64 vdiff[4],vdval[4]; */
    

    veclen = mgau_veclen(g);
    mgau = &(g->mgau[m]);
    f = log_to_logs3_factor();
    score = S3_LOGPROB_ZERO;
        
    if (! active) {	/* No short list; use all */



      for (c = 0; c < mgau->n_comp; c++) {

	dval1 = mgau_eval_inner(mgau, veclen, c, x);
	if (dval1 < g->distfloor)  dval1 = g->distfloor;

	score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
      }
    } else {

      for (j = 0; active[j] >= 0; j++) {  /* start from j=1*/
	c = active[j];
	
	dval1 = mgau_eval_inner(mgau, veclen, c, x);
	if (dval1 < g->distfloor)  dval1 = g->distfloor;
	
	score = logs3_add (score, (int32)(f * dval1) + mgau->mixw[c]);
      }
    }

    return score;
}


#endif









/* RAH, free memory allocated in mgau_init
   I've not verified that this function catches all of the leaks, just most of them.
 */
void mgau_free (mgau_model_t *g)
{
  if (g) {
    if (g->mgau[0].mean) 
      ckd_free ((void *) g->mgau[0].mean);

    /* Free memory allocated for the var structure*/

    if (g->mgau[0].var) 
      ckd_free ((void *) g->mgau[0].var);
    if (g->mgau[0].lrd) 
      ckd_free ((void *) g->mgau[0].lrd);

    /* Free memory allocated for the mixture weights*/

    if (g->mgau[0].mixw) 
      ckd_free ((void *) g->mgau[0].mixw);
    
    if (g->mgau)
      ckd_free ((void *) g->mgau);
    ckd_free ((void *) g);
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * cont_mgau.h -- Mixture Gaussians for continuous HMM models.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added mgau_free to free memory allocated by mgau_init()
 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added mgau_model_t.{frm_sen_eval,frm_gau_eval}.
 * 		Added mgau_var_nzvec_floor().

 * 
 * 28-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#ifndef _S3_CONT_MGAU_H_
#define _S3_CONT_MGAU_H_

#ifdef __cplusplus
extern "C" {
#endif



#include "libutil.h"


/*
 * Mixture Gaussians: Weighted set of Gaussian densities, each with its own mean vector and
 * diagonal covariance matrix.  Specialized for continuous HMMs to improve speed performance.
 * So, a separate mixture Gaussian, with its own mixture weights, for each HMM state.  Also,
 * a single feature stream assumed.  (In other words, the mgau_t structure below represents
 * a senone in a fully continuous HMM model.)
 * 
 * Given a Gaussian density with mean vector m and diagonal variance vector v, and some
 * input vector x, all of length n, the Mahalanobis distance of x from the Gaussian mean m
 * is given by:
 *     {1/sqrt((2pi)^n * det(v))} * exp{-Sum((x[i] - m[i])^2 / (2v[i]))}
 * To speed up this evaluation, the first sub-expression ({1/sqrt...}) can be precomputed at
 * initialization, and so can 1/2v[i] in the second sub-expression.  Secondly, recognition
 * systems work with log-likelihood values, so these distances or likelihood values are
 * computed in log-domain.  Finally, float32 operations are costlier than int32 ones, so
 * the log-values are converted to logs3 domain (see libmisc/logs3.h) (but before the mixing
 * weights are applied).  Thus, to reiterate, the final scores are (int32) logs3 values.
 */


/*
 * A single mixture-Gaussian model for one senone (see above comment).
 */
typedef struct {
    int32 n_comp;	/* #Component Gaussians in this mixture.  NOTE: May be 0 (for the
			   untrained states). */
    float32 **mean;	/* The n_comp means of the Gaussians. */
    float32 **var;	/* The n_comp (diagonal) variances of the Gaussians.  Could be
			   converted to 1/(2*var) for faster computation (see above comment). */
    int32 *mixw;	/* Mixture weights for the n_comp components (int32 instead of float32
			   because these values are in logs3 domain) */
    float32 *lrd;	/* Log(Reciprocal(Determinant (variance))).  (Then there is also a
			   (2pi)^(veclen) involved...) */
} mgau_t;


/*
 * The set of mixture-Gaussians in an acoustic model.
 */
typedef struct {
    int32 n_mgau;	/* #Mixture Gaussians in this model (i.e., #senones) */
    int32 max_comp;	/* Max components in any mixture */
    int32 veclen;	/* Vector length of the Gaussian density means (and diagonal vars) */
    mgau_t *mgau;	/* The n_mgau mixture Gaussians */
    float64 distfloor;	/* Mahalanobis distances can underflow when finally converted to
			   logs3 values.  To prevent this, floor the log values first. */
    /* Statistics */
    int32 frm_sen_eval;		/* #Senones evaluated in the most recent frame */
    int32 frm_gau_eval;		/* #Gaussian densities evaluated in the most recent frame */
} mgau_model_t;


/* Access macros */
#define mgau_n_mgau(g)		((g)->n_mgau)
#define mgau_max_comp(g)	((g)->max_comp)
#define mgau_veclen(g)		((g)->veclen)
#define mgau_n_comp(g,m)	((g)->mgau[m].n_comp)
#define mgau_mean(g,m,c)	((g)->mgau[m].mean[c])
#define mgau_var(g,m,c)		((g)->mgau[m].var[c])
#define mgau_mixw(g,m,c)	((g)->mgau[m].mixw[c])
#define mgau_lrd(g,m,c)		((g)->mgau[m].lrd[c])
#define mgau_frm_sen_eval(g)	((g)->frm_sen_eval)
#define mgau_frm_gau_eval(g)	((g)->frm_gau_eval)


/*
 * Create a new mixture Gaussian model from the given files (Sphinx3 format).  Optionally,
 * apply the precomputations mentioned in the main comment above.
 * Return value: pointer to the model created if successful; NULL if error.
 */
mgau_model_t *
mgau_init (char *meanfile,	/* In: File containing means of mixture gaussians */
	   char *varfile,	/* In: File containing variances of mixture gaussians */
	   float64 varfloor,	/* In: Floor value applied to variances; e.g., 0.0001 */
	   char *mixwfile,	/* In: File containing mixture weights */
	   float64 mixwfloor,	/* In: Floor value for mixture weights; e.g., 0.0000001 */
	   int32 precomp);	/* In: If TRUE, create and precompute mgau_t.lrd and also
				   transform each var value to 1/(2*var).  (If FALSE, one
				   cannot use the evaluation routines provided here.) */

/*
 * Floor any variance vector that is non-zero (vector).
 * Return value: No. of variance VALUES floored.
 */
int32 mgau_var_nzvec_floor (mgau_model_t *g, float64 floor);


/*
 * Evaluate a single mixture Gaussian at the given vector x; i.e., compute the Mahalanobis
 * distance of x from each mean in the mixture, and combine them using the mixture weights.
 * Return value: The final score from this evaluation (a logs3 domain value).  NOTE: if the
 * specified mixture is empty, S3_LOGPROB_ZERO is returned (see libmisc/libmisc.h).
 */
int32
mgau_eval (mgau_model_t *g,	/* In: The entire mixture Gaussian model */
	   int32 m,		/* In: The chosen mixture in the model (i.e., g->mgau[m]) */
	   int32 *active_comp,	/* In: An optional, -1 terminated list of active component
				   indices; if non-NULL, only the specified components are
				   used in the evaluation. */
	   float32 *x);		/* In: Input observation vector (of length g->veclen). */

/*
 * Like mgau_eval, but return the scores of the individual components, instead of combining
 * them into a senone score.  Return value: Best component score.
 */
int32 mgau_comp_eval (mgau_model_t *g,	/* In: Set of mixture Gaussians */
		      int32 m,		/* In: Mixture being considered */
		      float32 *x,	/* In: Input vector being compared to the components */
		      int32 *score);	/* Out: Array of scores for each component */


/* RAH
 * Free memory allocated by mgau_init
 */
void mgau_free (mgau_model_t *g);


#ifdef __cplusplus
}
#endif


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * corpus.c -- Corpus-file related misc functions.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added ctl_process_utt ().
 * 
 * 01-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added check for already existing file extension in ctl_infile().
 * 
 * 23-Mar-1998	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added a general purpose data argument to ctl_process() and its function
 * 		argument func.
 * 
 * 22-Nov-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added an optional validation function argument and an optional
 *		duplicate-resolution function argument to both corpus_load_headid() and
 * 		corpus_load_tailid().
 * 
 * 25-Oct-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "corpus.h"


corpus_t *corpus_load_headid (char *file,
			      int32 (*validate)(char *str),
			      int32 (*dup_resolve)(char *s1, char *s2))
{
    FILE *fp;
    char line[16384], wd[4096], *id;
    int32 j, k, m, n;
    corpus_t *corp;
    
    E_INFO("Loading corpus (%s)\n", file);
    
    if ((fp = fopen(file, "r")) == NULL)
	E_FATAL_SYSTEM("fopen(%s,r) failed\n", file);

    corp = (corpus_t *) ckd_calloc (1, sizeof(corpus_t));
    
    n = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
	/* Skip empty lines */
	if (sscanf (line, "%s", wd) == 1)
	    n++;
    }
    rewind (fp);
    
    corp->ht = hash_new (n, HASH_CASE_YES);
    corp->n = 0;
    corp->str = (char **) ckd_calloc (n, sizeof(char *));
    
    n = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
	/* Skip blank lines */
	if (sscanf (line, "%s%n", wd, &k) != 1)
	    continue;
	
	/* Eliminate the line-terminating newline */
	j = strlen(line);
	if ((j > 0) && (line[j-1] == '\n'))
	    line[j-1] = '\0';

	/* Validate if a validation function is given */
	if (validate && (! (*validate)(line+k))) {
	    E_INFO("Corpus validation %s failed; skipping\n", wd);
	    continue;
	}
	
	id = ckd_salloc (wd);
	if ((m = hash_enter (corp->ht, id, n)) != n) {
	    /* Duplicate entry */
	    if (! dup_resolve)
		E_FATAL("corpus_load_headid(%s) failed; duplicate ID: %s\n", file, id);
	    else {
		/* Invoke the application provided duplicate resolver function */
		if ((j = (*dup_resolve)(corp->str[m], line+k)) < 0)
		    E_FATAL("corpus_load_headid(%s) failed; duplicate ID: %s\n", file, id);
		ckd_free (id);
		if (j > 0) {
		    /* Overwrite the original with the new entry */
		    ckd_free (corp->str[m]);
		    corp->str[m] = ckd_salloc (line+k);
		} else {
		    /* Retain the original entry, discard the new one */
		}
	    }
	} else {
	    /* Fill in new entry */
	    corp->str[n] = ckd_salloc (line+k);
	    n++;
	}
    }
    corp->n = n;
    
    fclose (fp);
    
    E_INFO("%s: %d entries\n", file, n);
    
    return corp;
}


static int32 sep_tailid (char *line, char *uttid)
{
    int32 i, k, l;
    
    l = strlen(line);
    uttid[0] = '\0';
    
    /* Find last close-paren */
    for (i = l-1;
	 (i >= 0) && ((line[i] == '\n') || (line[i] == ' ') || (line[i] == '\t'));
	 --i);
    if ((i < 0)	|| (line[i] != ')'))		/* Missing uttid */
	return -1;
    k = i;
    
    /* Find closest open-paren; no spaces allowed in uttid */
    for (--i; (i >= 0) && (line[i] != ' ') && (line[i] != '\t') && (line[i] != '('); --i);
    if ((i < 0) || (k-i < 2) || (line[i] != '('))	/* Empty or missing uttid */
	return -1;
    
    /* Remove parentheses and copy uttid */
    line[k] = '\0';
    strcpy (uttid, line+i+1);

    /* Strip uttid from line */
    line[i] = '\0';

    return 0;
}


corpus_t *corpus_load_tailid (char *file,
			      int32 (*validate)(char *str),
			      int32 (*dup_resolve)(char *s1, char *s2))
{
    FILE *fp;
    char line[16384], uttid[4096], *id;
    int32 j, m, n;
    corpus_t *corp;
    
    E_INFO("Loading corpus (%s)\n", file);
    
    if ((fp = fopen(file, "r")) == NULL)
	E_FATAL_SYSTEM("fopen(%s,r) failed\n", file);

    corp = (corpus_t *) ckd_calloc (1, sizeof(corpus_t));
    
    n = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
	/* Skip empty lines */
	if (sscanf (line, "%s", uttid) == 1)
	    n++;
    }
    rewind (fp);
    
    corp->ht = hash_new (n, 0 /* Not no-case */);
    corp->n = 0;
    corp->str = (char **) ckd_calloc (n, sizeof(char *));
    
    n = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
	/* Skip blank lines */
	if (sscanf (line, "%s", uttid) < 1)
	    continue;
	
	/* Look for a (uttid) at the end */
	if (sep_tailid (line, uttid) < 0)
	    E_FATAL("corpus_load_tailid(%s) failed; bad line: %s\n", file, line);
	
	/* Validate if a validation function is given */
	if (validate && (! (*validate)(line))) {
	    E_INFO("Corpus validation %s failed; skipping\n", uttid);
	    continue;
	}
	
	id = ckd_salloc (uttid);
	if ((m = hash_enter (corp->ht, id, n)) != n) {
	    /* Duplicate entry */
	    if (! dup_resolve)
		E_FATAL("corpus_load_tailid(%s) failed; duplicate ID: %s\n", file, id);
	    else {
		/* Invoke the application provided duplicate resolver function */
		if ((j = (*dup_resolve)(corp->str[m], line)) < 0)
		    E_FATAL("corpus_load(tailid(%s) failed; duplicate ID: %s\n", file, id);
		ckd_free (id);
		if (j > 0) {
		    /* Overwrite the original with the new entry */
		    ckd_free (corp->str[m]);
		    corp->str[m] = ckd_salloc (line);
		} else {
		    /* Retain the original entry, discard the new one */
		}
	    }
	} else {
	    /* Fill in new entry */
	    corp->str[n] = ckd_salloc (line);
	    n++;
	}
    }
    corp->n = n;
    
    fclose (fp);
    
    E_INFO("%s: %d entries\n", file, n);

    return corp;
}


char *corpus_lookup (corpus_t *corp, char *id)
{
    int32 n;
    
    if (hash_lookup (corp->ht, id, &n) < 0)
	return NULL;

    assert ((n >= 0) && (n < corp->n));
    return (corp->str[n]);
}


#if _CORPUS_TEST_
main (int32 argc, char *argv[])
{
    corpus_t *ch, *ct;
    char id[4096], *str;
    
    if (argc != 3)
	E_FATAL("Usage: %s headid-corpusfile tailid-corpusfile\n", argv[0]);
    
    ch = corpus_load_headid (argv[1], NULL, NULL);
    ct = corpus_load_tailid (argv[2], NULL, NULL);
    for (;;) {
	printf ("> ");
	scanf ("%s", id);
	
	str = corpus_lookup (ch, id);
	if (str == NULL)
	    printf ("%s Not found in 1\n");
	else
	    printf ("%s(1): %s\n", id, str);

	str = corpus_lookup (ct, id);
	if (str == NULL)
	    printf ("%s Not found in 2\n");
	else
	    printf ("%s(2): %s\n", id, str);
    }
}
#endif


int32 ctl_read_entry (FILE *fp, char *uttfile, int32 *sf, int32 *ef, char *uttid)
{
    char line[16384];
    char base[16384];
    int32 k;
    
    do {
	if (fgets (line, sizeof(line), fp) == NULL)
	    return -1;
	if (line[0] == '#')
	    k = 0;
	else
	    k = sscanf (line, "%s %d %d %s", uttfile, sf, ef, uttid);
    } while (k <= 0);
    
    if ((k == 2) || ( (k >= 3) && ((*sf >= *ef) || (*sf < 0))) )
	E_FATAL("Error in ctlfile: %s\n", line);
    
    if (k < 4) {
	/* Create utt-id from mfc-filename (and sf/ef if specified) */
	path2basename (uttfile, base);
	strip_fileext (base, uttid);
	
	if (k == 3) {
	    k = strlen(uttid);
	    sprintf (uttid+k, "_%d_%d", *sf, *ef);
	} else {
	    *sf = 0;
	    *ef = -1;	/* Signifies "until EOF" */
	}
    }
    
    return 0;
}


ptmr_t ctl_process (char *ctlfile, int32 nskip, int32 count,
		    void (*func) (void *kb, char *uttfile, int32 sf, int32 ef, char *uttid),
		    void *kb)
{
  FILE *fp;
  char uttfile[16384], uttid[4096];
  int32 sf, ef;
  ptmr_t tm;
  
  if (ctlfile) {
    if ((fp = fopen(ctlfile, "r")) == NULL)
      E_FATAL_SYSTEM("fopen(%s,r) failed\n", ctlfile);
  } else
    fp = stdin;
  
  ptmr_init (&tm);
  
  if (nskip > 0) {
    E_INFO("Skipping %d entries at the beginning of %s\n", nskip, ctlfile);
    
    for (; nskip > 0; --nskip) {
      if (ctl_read_entry (fp, uttfile, &sf, &ef, uttid) < 0) {
	fclose (fp);
	return tm;
      }
    }
  }
  
  for (; count > 0; --count) {
    if (ctl_read_entry (fp, uttfile, &sf, &ef, uttid) < 0)
      break;
    
    /* Process this utterance */
    ptmr_start (&tm);
    if (func)
      (*func)(kb, uttfile, sf, ef, uttid);
    ptmr_stop (&tm);
    
    E_INFO("%s: %6.1f sec CPU, %6.1f sec Clk;  TOT: %8.1f sec CPU, %8.1f sec Clk\n\n",
	   uttid, tm.t_cpu, tm.t_elapsed, tm.t_tot_cpu, tm.t_tot_elapsed);
    
    ptmr_reset (&tm);
  }
  
  fclose (fp);
  
  return tm;
}


ptmr_t ctl_process_utt (char *uttfile, int32 count,
			void (*func) (void *kb, char *uttfile, int32 sf, int32 ef, char *uttid),
			void *kb)
{
    char uttid[4096];
    char base[16384];
    int32 i, c;
    int32 ts, newts;
    ptmr_t tm;
    
    ptmr_init (&tm);
    path2basename (uttfile, base);
    strip_fileext (base, uttid);
    strcpy (base, uttid);
    
    ts = -1;
    for (c = 0; c < count; c++) {
	/* Wait for uttfile to change from previous iteration */
	for (i = 0;; i++) {
	    newts = stat_mtime (uttfile);
	    if ((newts >= 0) && (newts != ts))
		break;
	    
	    if (i == 0)
		E_INFO("Waiting for %s\n", uttfile);
	    SLEEP_SEC (1);
	}
	ts = newts;
	
	/* Form uttid */
	sprintf (uttid, "%s_%08d", base, c);
	
	/* Process this utterance */
	ptmr_start (&tm);
	if (func)
	    (*func)(kb, uttfile, 0, -1, uttid);
	ptmr_stop (&tm);
	
	E_INFO("%s: %6.1f sec CPU, %6.1f sec Clk;  TOT: %8.1f sec CPU, %8.1f sec Clk\n\n",
	       uttid, tm.t_cpu, tm.t_elapsed, tm.t_tot_cpu, tm.t_tot_elapsed);
	
	ptmr_reset (&tm);
    }
    
    return tm;
}


void ctl_infile (char *file, char *dir, char *ext, char *utt)
{
    int32 l1, l2;
    
    assert (utt);
    
    if (ext && (ext[0] != '\0')) {
	l1 = strlen(ext);
	l2 = strlen(utt);
	if ((l2 > l1) && (utt[l2-l1-1] == '.') && (strcmp (utt+(l2-l1), ext) == 0))
	    ext = NULL;		/* utt already has the desired extension */
    }
    
    if ((utt[0] != '/') && dir) {
	/* Dir specified for relative uttfile pathname */
	if (ext && (ext[0] != '\0'))
	    sprintf (file, "%s/%s.%s", dir, utt, ext);
	else
	    sprintf (file, "%s/%s", dir, utt);
    } else {
	if (ext && (ext[0] != '\0'))
	    sprintf (file, "%s.%s", utt, ext);
	else
	    strcpy (file, utt);
    }
}


void ctl_outfile (char *file, char *dir, char *ext, char *utt, char *uttid)
{
    int32 k;
    
    k = strlen(dir);
    
    if ((k > 4) && (strcmp (dir+k-4, ",CTL") == 0)) {	/* HACK!! Hardwired ,CTL */
	if (utt[0] != '/') {
	    strcpy (file, dir);
	    file[k-4] = '/';
	    strcpy (file+k-3, utt);
	} else
	    strcpy (file, utt);
    } else {
	strcpy (file, dir);
	file[k] = '/';
	strcpy (file+k+1, uttid);
    }
    
    if (ext && (ext[0] != '\0')) {
	strcat (file, ".");
	strcat (file, ext);
    }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * corpus.h -- Corpus-file related misc functions.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added ctl_process_utt ().
 * 
 * 01-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Updated ctl_infile() spec to included check for already existing file extension.
 * 
 * 23-Mar-1998	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added a general purpose data argument to ctl_process() and its function
 * 		argument func.
 * 
 * 22-Nov-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added an optional validation function argument and an optional
 *		duplicate-resolution function argument to both corpus_load_headid() and
 * 		corpus_load_tailid().
 * 
 * 25-Oct-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#ifndef _S3_CORPUS_H_
#define _S3_CORPUS_H_


#include "libutil.h"


/*
 * Structure for a corpus: essentially a set of strings each associated with a
 * unique ID.  (Such as a reference sentence file, hypothesis file, and various
 * control files.)
 * NOTE: IDs are CASE-SENSITIVE.
 */
typedef struct {
    hash_table_t *ht;	/* Hash table for IDs; CASE-SENSITIVE */
    int32 n;		/* #IDs (and corresponding argument strings) in the corpus */
    char **str;		/* The argument strings */
} corpus_t;


/*
 * Load a corpus from the given file and return it.
 * Each line is a separate entry in the corpus.  Blank lines are skipped.
 * The ID is the FIRST word in a line.
 * 
 * Validation:
 * validate is an optional, application-supplied function to determine if each input
 * corpus data entry is eligible (valid) for inclusion in the final corpus.  It should
 * return an integer value signifying the following actions:
 *      0: Not valid, skip the entry;
 *     !0: Valid, include the entry.
 * If validate is NULL, every input entry is included in the corpus.
 * 
 * Duplicate resolution:
 * dup_resolve is an optional, application-supplied function to resolve duplicate keys
 * (IDs).  It may be NULL if none is available.  If present, and a duplicate key is
 * encountered, the function is invoked with the original and the duplicate corpus
 * strings as arguments (s1 and s2, respectively).  It should return an integer value
 * signifying the following actions:
 *      0: Retain the original string, discard the new one;
 *     >0: Replace the original string with the new one;
 *     <0: Error (causes a FATAL_ERROR).
 * If dup_resolve is NULL, any duplicate ID causes a FATAL_ERROR.
 * 
 * Return value: Ptr to corpus if successful.
 */
corpus_t *corpus_load_headid (char *file,	/* Must be seekable and rewindable */
			      int32 (*validate)(char *str),
			      int32 (*dup_resolve)(char *s1, char *s2));

/*
 * Similar to corpus_load_headid, but the ID is at the END of each line, in parentheses.
 */
corpus_t *corpus_load_tailid (char *file,	/* Must be seekable and rewindable */
			      int32 (*validate)(char *str),
			      int32 (*dup_resolve)(char *s1, char *s2));

/*
 * Lookup the given corpus for the given ID and return the associated string.
 * Return NULL if ID not found.
 */
char *corpus_lookup (corpus_t *corp, char *id);

/*
 * Read another entry from a S3 format "control file" and parse its various fields.
 * Blank lines and lines beginning with a hash-character (#) are omitted.
 * Control file entry format:
 *     uttfile(usually cepstrum file) [startframe endframe [uttid]]
 * Any error in control file entry format is FATAL.
 * Return value: 0 if successful, -1 if no more entries left.
 */
int32 ctl_read_entry (FILE *fp,
		      char *uttfile,	/* Out: (Cep)file containing utterance data */
		      int32 *sf,	/* Out: Start frame in uttfile; 0 if omitted */
		      int32 *ef,	/* Out: End frame in uttfile; -1 (signifying
					   until EOF) if omitted */
		      char *uttid);	/* Out: Utterance ID (generated from uttfile/sf/ef
					   if omitted) */

/*
 * Process the given control file (or stdin if NULL):  Skip the first nskip entries, and
 * process the next count entries by calling the given function (*func) for each entry.
 * Any error in reading the control file is FATAL.
 * Return value: ptmr_t structure containing cpu/elapsed time stats for the run.
 */
ptmr_t ctl_process (char *ctlfile,	/* In: Control file to read; use stdin if NULL */
		    int32 nskip,	/* In: No. of entries to skip at the head */
		    int32 count,	/* In: No. of entries to process after nskip */
		    void (*func) (void *kb, char *uttfile, int32 sf, int32 ef, char *uttid),
		    			/* In: Function to be invoked for each of the
					   count entries processed. */
		    void *kb);		/* In: A catch-all data pointer to be passed as
					   the first argument to func above */

/*
 * Like ctl_process, but process the single filename given (uttfile), count times.  After each
 * processing, wait for the time of modification on the given file to change.  In this mode,
 * the decoder can be used to process a dynamically generated sequence of utterances.  To avoid
 * race conditions, each new instance of the file should be created "in an instant": by creating
 * it under a temporary name and finally renaming it to the given filename atomically.
 * Return value: ptmr_t structure containing cpu/elapsed time stats for the run.
 */
ptmr_t ctl_process_utt (char *uttfile,	/* In: Filename to be process (in its entirety) */
			int32 count,	/* In: No. of iterations to process uttfile */
			void (*func) (void *kb, char *uttfile, int32 sf, int32 ef, char *uttid),
			void *kb);

/*
 * Build a complete input filename from the given uttname, directory and file-extension:
 *   If utt begins with a / ignore dir, otherwise prefix dir/ to utt;
 *   If a non-empty file extension is provided, and utt doesn't already have that extension,
 * 	append .ext to filename.
 */
void ctl_infile (char *file,	/* Out: Generated filename (allocated by caller) */
		 char *dir,	/* In: Optional directory spec if relative utt specified */
		 char *ext,	/* In: File extension to be appended to utt to generate
				   complete filename */
		 char *utt);	/* In: Utterance file pathname, absolute or relative,
				   with or without file extension.  This is usually the
				   first field in a control file */

/*
 * Build a complete output filename from the given components as follows:
 *     if dir ends with ,CTL and utt does not begin with /, use dir/utt
 *     if dir ends with ,CTL and utt DOES begin with /, filename is utt
 *     if dir does not end with ,CTL, filename is dir/uttid.
 * If a non-empty ext specified append .ext to generated filename.
 */
void ctl_outfile (char *file,	/* Out: Generated filename (allocated by caller) */
		  char *dir,	/* In: Directory for the generated filename; see comment
				   for special handling of ,CTL suffix */
		  char *ext,	/* In: File-extension applied to the generated filename */
		  char *utt,	/* In: Utterance file pathname, absolute or relative,
				   with or without extension.  This is usually the first
				   field in a control file. */
		  char *uttid);	/* In: Utterance ID (derived from the control file */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * dict2pid.c -- Triphones for dictionary
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 14-Sep-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added dict2pid_comsseq2sen_active().
 * 
 * 04-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "dict2pid.h"
#include "logs3.h"


/*
 * Build a glist of triphone senone-sequence IDs (ssids) derivable from [b][r] at the word
 * begin position.  If no triphone found in mdef, include the ssid for basephone b.
 * Return the generated glist.
 */
static glist_t ldiph_comsseq (mdef_t *mdef, int32 b, int32 r)
{
    int32 l, p, ssid;
    glist_t g;
    
    g = NULL;
    for (l = 0; l < mdef_n_ciphone(mdef); l++) {
	p = mdef_phone_id (mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_BEGIN);
	
	if (IS_S3PID(p)) {
	    ssid = mdef_pid2ssid(mdef, p);
	    if (! glist_chkdup_int32 (g, ssid))
		g = glist_add_int32 (g, ssid);
	}
    }
    if (! g)
	g = glist_add_int32 (g, mdef_pid2ssid(mdef, b));
    
    return g;
}


/*
 * Build a glist of triphone senone-sequence IDs (ssids) derivable from [r][b] at the word
 * end position.  If no triphone found in mdef, include the ssid for basephone b.
 * Return the generated glist.
 */
static glist_t rdiph_comsseq (mdef_t *mdef, int32 b, int32 l)
{
    int32 r, p, ssid;
    glist_t g;
    
    g = NULL;
    for (r = 0; r < mdef_n_ciphone(mdef); r++) {
	p = mdef_phone_id (mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_END);
	
	if (IS_S3PID(p)) {
	    ssid = mdef_pid2ssid(mdef, p);
	    if (! glist_chkdup_int32 (g, ssid))
		g = glist_add_int32 (g, ssid);
	}
    }
    if (! g)
	g = glist_add_int32 (g, mdef_pid2ssid(mdef, b));
    
    return g;
}


/*
 * Build a glist of triphone senone-sequence IDs (ssids) derivable from [b] as a single
 * phone word.  If no triphone found in mdef, include the ssid for basephone b.
 * Return the generated glist.
 */
static glist_t single_comsseq (mdef_t *mdef, int32 b)
{
    int32 l, r, p, ssid;
    glist_t g;
    
    g = NULL;
    for (l = 0; l < mdef_n_ciphone(mdef); l++) {
	for (r = 0; r < mdef_n_ciphone(mdef); r++) {
	    p = mdef_phone_id (mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_SINGLE);
	    
	    if (IS_S3PID(p)) {
		ssid = mdef_pid2ssid(mdef, p);
		if (! glist_chkdup_int32 (g, ssid))
		    g = glist_add_int32 (g, ssid);
	    }
	}
    }
    if (! g)
	g = glist_add_int32 (g, mdef_pid2ssid(mdef, b));
    
    return g;
}


/*
 * Build a glist of triphone senone-sequence IDs (ssids) derivable from [b] as a single
 * phone word, with a given left context l.  If no triphone found in mdef, include the ssid
 * for basephone b.  Return the generated glist.
 */
static glist_t single_lc_comsseq (mdef_t *mdef, int32 b, int32 l)
{
    int32 r, p, ssid;
    glist_t g;
    
    g = NULL;
    for (r = 0; r < mdef_n_ciphone(mdef); r++) {
	p = mdef_phone_id (mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_SINGLE);
	
	if (IS_S3PID(p)) {
	    ssid = mdef_pid2ssid(mdef, p);
	    if (! glist_chkdup_int32 (g, ssid))
		g = glist_add_int32 (g, ssid);
	}
    }
    if (! g)
	g = glist_add_int32 (g, mdef_pid2ssid(mdef, b));
    
    return g;
}


/*
 * Convert the glist of ssids to a composite sseq id.  Return the composite ID.
 */
static s3ssid_t ssidlist2comsseq (glist_t g, mdef_t *mdef, dict2pid_t *dict2pid,
				  hash_table_t *hs,	/* For composite states */
				  hash_table_t *hp)	/* For composite senone seq */
{
    int32 i, j, n, s, ssid;
    s3senid_t **sen;
    s3senid_t *comsenid;
    gnode_t *gn;
    
    n = glist_count (g);
    if (n <= 0)
	E_FATAL("Panic: length(ssidlist)= %d\n", n);
    
    /* Space for list of senones for each state, derived from the given glist */
    sen = (s3senid_t **) ckd_calloc (mdef_n_emit_state (mdef), sizeof(s3senid_t *));
    for (i = 0; i < mdef_n_emit_state (mdef); i++) {
	sen[i] = (s3senid_t *) ckd_calloc (n+1, sizeof(s3senid_t));
	sen[i][0] = BAD_S3SENID;	/* Sentinel */
    }
    /* Space for composite senone ID for each state position */
    comsenid = (s3senid_t *) ckd_calloc (mdef_n_emit_state (mdef), sizeof(s3senid_t));
    
    for (gn = g; gn; gn = gnode_next(gn)) {
	ssid = gnode_int32 (gn);
	
	/* Expand ssid into individual states (senones); insert in sen[][] if not present */
	for (i = 0; i < mdef_n_emit_state (mdef); i++) {
	    s = mdef->sseq[ssid][i];
	    
	    for (j = 0; (IS_S3SENID(sen[i][j])) && (sen[i][j] != s); j++);
	    if (NOT_S3SENID(sen[i][j])) {
		sen[i][j] = s;
		sen[i][j+1] = BAD_S3SENID;
	    }
	}
    }
    
    /* Convert senones list for each state position into composite state */
    for (i = 0; i < mdef_n_emit_state (mdef); i++) {
	for (j = 0; IS_S3SENID(sen[i][j]); j++);
	assert (j > 0);
	
	j = hash_enter_bkey (hs, (char *)(sen[i]), j*sizeof(s3senid_t), dict2pid->n_comstate);
	if (j == dict2pid->n_comstate)
	    dict2pid->n_comstate++;	/* New composite state */
	else
	    ckd_free ((void *) sen[i]);
	
	comsenid[i] = j;
    }
    ckd_free (sen);
    
    /* Convert sequence of composite senids to composite sseq ID */
    j = hash_enter_bkey (hp, (char *)comsenid, mdef->n_emit_state * sizeof(s3senid_t),
			 dict2pid->n_comsseq);
    if (j == dict2pid->n_comsseq) {
	dict2pid->n_comsseq++;
	if (dict2pid->n_comsseq >= MAX_S3SENID)
	    E_FATAL("#Composite sseq limit(%d) reached; increase MAX_S3SENID\n",
		    dict2pid->n_comsseq);
    } else
	ckd_free ((void *) comsenid);
    
    return ((s3ssid_t)j);
}


/* RAH 4.16.01 This code has several leaks that must be fixed */
dict2pid_t *dict2pid_build (mdef_t *mdef, dict_t *dict)
{
    dict2pid_t *dict2pid;
    s3ssid_t *internal, **ldiph, **rdiph, *single;
    int32 pronlen;
    hash_table_t *hs, *hp;
    glist_t g;
    gnode_t *gn;
    s3senid_t *sen;
    hash_entry_t *he;
    int32 *cslen;
    int32 i, j, b, l, r, w, n, p;
    
    E_INFO("Building PID tables for dictionary\n");

    dict2pid = (dict2pid_t *) ckd_calloc (1, sizeof(dict2pid_t));
    dict2pid->internal = (s3ssid_t **) ckd_calloc (dict_size(dict), sizeof(s3ssid_t *));
    dict2pid->ldiph_lc = (s3ssid_t ***) ckd_calloc_3d (mdef->n_ciphone,
						       mdef->n_ciphone,
						       mdef->n_ciphone,
						       sizeof(s3ssid_t));
    dict2pid->single_lc = (s3ssid_t **) ckd_calloc_2d (mdef->n_ciphone,
						       mdef->n_ciphone,
						       sizeof(s3ssid_t));
    dict2pid->n_comstate = 0;
    dict2pid->n_comsseq = 0;
    
    hs = hash_new (mdef->n_ciphone * mdef->n_ciphone * mdef->n_emit_state, HASH_CASE_YES);
    hp = hash_new (mdef->n_ciphone * mdef->n_ciphone, HASH_CASE_YES);
    
    for (w = 0, n = 0; w < dict_size(dict); w++) {
	pronlen = dict_pronlen(dict, w);
	if (pronlen < 0)
	    E_FATAL("Pronunciation-length(%s)= %d\n", dict_wordstr(dict, w), pronlen);
	n += pronlen;
    }

    internal = (s3ssid_t *) ckd_calloc (n, sizeof(s3ssid_t));
    
    /* Temporary */
    ldiph = (s3ssid_t **) ckd_calloc_2d (mdef->n_ciphone, mdef->n_ciphone, sizeof(s3ssid_t));
    rdiph = (s3ssid_t **) ckd_calloc_2d (mdef->n_ciphone, mdef->n_ciphone, sizeof(s3ssid_t));
    single = (s3ssid_t *) ckd_calloc (mdef->n_ciphone, sizeof(s3ssid_t));
    for (b = 0; b < mdef->n_ciphone; b++) {
	for (l = 0; l < mdef->n_ciphone; l++) {
	    for (r = 0; r < mdef->n_ciphone; r++)
		dict2pid->ldiph_lc[b][r][l] = BAD_S3SSID;
	    
	    dict2pid->single_lc[b][l] = BAD_S3SSID;
	    
	    ldiph[b][l] = BAD_S3SSID;
	    rdiph[b][l] = BAD_S3SSID;
	}
	single[b] = BAD_S3SSID;
    }
    
    for (w = 0; w < dict_size(dict); w++) {
	dict2pid->internal[w] = internal;
	pronlen = dict_pronlen(dict,w);
	
	if (pronlen >= 2) {
	    b = dict_pron(dict, w, 0);
	    r = dict_pron(dict, w, 1);
	    if (NOT_S3SSID(ldiph[b][r])) {
		g = ldiph_comsseq(mdef, b, r);
		ldiph[b][r] = ssidlist2comsseq (g, mdef, dict2pid, hs, hp);
		glist_free (g);
		
		for (l = 0; l < mdef_n_ciphone(mdef); l++) {
		    p = mdef_phone_id_nearest (mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_BEGIN);
		    dict2pid->ldiph_lc[b][r][l] = mdef_pid2ssid(mdef, p);
		}
	    }
	    internal[0] = ldiph[b][r];
	    
	    for (i = 1; i < pronlen-1; i++) {
		l = b;
		b = r;
		r = dict_pron(dict, w, i+1);
		
		p = mdef_phone_id_nearest(mdef, (s3cipid_t)b, (s3cipid_t)l, (s3cipid_t)r, WORD_POSN_INTERNAL);
		internal[i] = mdef_pid2ssid(mdef, p);
	    }
	    
	    l = b;
	    b = r;
	    if (NOT_S3SSID(rdiph[b][l])) {
		g = rdiph_comsseq(mdef, b, l);
		rdiph[b][l] = ssidlist2comsseq (g, mdef, dict2pid, hs, hp);
		glist_free (g);
	    }
	    internal[pronlen-1] = rdiph[b][l];
	} else if (pronlen == 1) {
	    b = dict_pron(dict, w, 0);
	    if (NOT_S3SSID(single[b])) {
		g = single_comsseq(mdef, b);
		single[b] = ssidlist2comsseq (g, mdef, dict2pid, hs, hp);
		glist_free (g);
		
		for (l = 0; l < mdef_n_ciphone(mdef); l++) {
		    g = single_lc_comsseq(mdef, b, l);
		    dict2pid->single_lc[b][l] = ssidlist2comsseq (g, mdef, dict2pid, hs, hp);
		    glist_free (g);
		}
	    }
	    internal[0] = single[b];
	}
	
	internal += pronlen;
    }
    
    ckd_free_2d ((void **) ldiph);
    ckd_free_2d ((void **) rdiph);
    ckd_free ((void *) single);
    
    /* Allocate space for composite state table */
    cslen = (int32 *) ckd_calloc (dict2pid->n_comstate, sizeof(int32));
    g = hash_tolist(hs, &n);
    assert (n == dict2pid->n_comstate);
    n = 0;
    for (gn = g; gn; gn = gnode_next(gn)) {
	he = (hash_entry_t *) gnode_ptr (gn);
	sen = (s3senid_t *) hash_entry_key(he);
	for (i = 0; IS_S3SENID(sen[i]); i++);
	
	cslen[hash_entry_val(he)] = i+1;	/* +1 for terminating sentinel */
	
	n += (i+1);
    }
    dict2pid->comstate = (s3senid_t **) ckd_calloc (dict2pid->n_comstate, sizeof(s3senid_t *));
    sen = (s3senid_t *) ckd_calloc (n, sizeof(s3senid_t));
    for (i = 0; i < dict2pid->n_comstate; i++) {
	dict2pid->comstate[i] = sen;
	sen += cslen[i];
    }
    
    /* Build composite state table from hash table hs */
    for (gn = g; gn; gn = gnode_next(gn)) {
	he = (hash_entry_t *) gnode_ptr (gn);
	sen = (s3senid_t *) hash_entry_key(he);
	i = hash_entry_val(he);
	
	for (j = 0; j < cslen[i]; j++)
	    dict2pid->comstate[i][j] = sen[j];
	assert (sen[j-1] == BAD_S3SENID);

	ckd_free ((void *)sen);
    }
    ckd_free (cslen);
    glist_free (g);
    hash_free (hs);
    
    /* Allocate space for composite sseq table */
    dict2pid->comsseq = (s3senid_t **) ckd_calloc (dict2pid->n_comsseq, sizeof(s3senid_t *));
    g = hash_tolist (hp, &n);
    assert (n == dict2pid->n_comsseq);
    
    /* Build composite sseq table */
    for (gn = g; gn; gn = gnode_next(gn)) {
	he = (hash_entry_t *) gnode_ptr (gn);
	i = hash_entry_val(he);
	dict2pid->comsseq[i] = (s3senid_t *) hash_entry_key(he);
    }
    glist_free (g);
    hash_free (hp);
    
    /* Weight for each composite state */
    dict2pid->comwt = (int32 *) ckd_calloc (dict2pid->n_comstate, sizeof(int32));
    for (i = 0; i < dict2pid->n_comstate; i++) {
	sen = dict2pid->comstate[i];
	
	for (j = 0; IS_S3SENID(sen[j]); j++);
#if 0
	/* if comstate i has N states, its weight= (1/N^2) (Major Hack!!) */
	dict2pid->comwt[i] = - (logs3 ((float64)j) << 1);
#else
	/* if comstate i has N states, its weight= 1/N */
	dict2pid->comwt[i] = - logs3 ((float64)j);
#endif
    }
    
    E_INFO("%d composite states; %d composite sseq\n",
	   dict2pid->n_comstate, dict2pid->n_comsseq);
    
    return dict2pid;
}


void dict2pid_comsenscr (dict2pid_t *d2p, int32 *senscr, int32 *comsenscr)
{
    int32 i, j;
    int32 best;
    s3senid_t *comstate, k;
    
    for (i = 0; i < d2p->n_comstate; i++) {
	comstate = d2p->comstate[i];
	
	best = senscr[comstate[0]];
	for (j = 1;; j++) {
	    k = comstate[j];
	    if (NOT_S3SENID(k))
		break;
	    if (best < senscr[k])
		best = senscr[k];
	}
	
	comsenscr[i] = best + d2p->comwt[i];
    }
}


void dict2pid_comsseq2sen_active (dict2pid_t *d2p, mdef_t *mdef, int32 *comssid, int32 *sen)
{
    int32 ss, cs, i, j;
    s3senid_t *csp, *sp;	/* Composite state pointer */
    
    for (ss = 0; ss < d2p->n_comsseq; ss++) {
	if (comssid[ss]) {
	    csp = d2p->comsseq[ss];

	    for (i = 0; i < mdef_n_emit_state(mdef); i++) {
		cs = csp[i];
		sp = d2p->comstate[cs];
		
		for (j = 0; IS_S3SENID(sp[j]); j++)
		    sen[sp[j]] = 1;
	    }
	}
    }
}


void dict2pid_dump (FILE *fp, dict2pid_t *d2p, mdef_t *mdef, dict_t *dict)
{
    int32 w, p, pronlen;
    int32 i, j, b, l, r;
    
    fprintf (fp, "# INTERNAL (wd comssid ssid ssid ... ssid comssid)\n");
    for (w = 0; w < dict_size(dict); w++) {
	fprintf (fp, "%30s ", dict_wordstr(dict, w));
	
	pronlen = dict_pronlen(dict, w);
	for (p = 0; p < pronlen; p++)
	    fprintf (fp, " %5d", d2p->internal[w][p]);
	fprintf (fp, "\n");
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "# LDIPH_LC (b r l ssid)\n");
    for (b = 0; b < mdef_n_ciphone(mdef); b++) {
	for (r = 0; r < mdef_n_ciphone(mdef); r++) {
	    for (l = 0; l < mdef_n_ciphone(mdef); l++) {
		if (IS_S3SSID(d2p->ldiph_lc[b][r][l]))
		    fprintf (fp, "%6s %6s %6s %5d\n",
			     mdef_ciphone_str (mdef, (s3cipid_t)b),
			     mdef_ciphone_str (mdef, (s3cipid_t)r),
			     mdef_ciphone_str (mdef, (s3cipid_t)l),
			     d2p->ldiph_lc[b][r][l]); /* RAH, ldiph_lc is returning an int32, %d expects an int16 */
	    }
	}
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "# SINGLE_LC (b l comssid)\n");
    for (b = 0; b < mdef_n_ciphone(mdef); b++) {
	for (l = 0; l < mdef_n_ciphone(mdef); l++) {
	    if (IS_S3SSID(d2p->single_lc[b][l]))
		fprintf (fp, "%6s %6s %5d\n",
			 mdef_ciphone_str (mdef, (s3cipid_t)b),
			 mdef_ciphone_str (mdef, (s3cipid_t)l),
			 d2p->single_lc[b][l]);	/* RAH, single_lc is returning an int32, %d expects an int16 */
	}
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "# SSEQ %d (senid senid ...)\n", mdef->n_sseq);
    for (i = 0; i < mdef->n_sseq; i++) {
	fprintf (fp, "%5d ", i);
	for (j = 0; j < mdef_n_emit_state(mdef); j++)
	    fprintf (fp, " %5d", mdef->sseq[i][j]);
	fprintf (fp, "\n");
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "# COMSSEQ %d (comstate comstate ...)\n", d2p->n_comsseq);
    for (i = 0; i < d2p->n_comsseq; i++) {
	fprintf (fp, "%5d ", i);
	for (j = 0; j < mdef_n_emit_state(mdef); j++)
	    fprintf (fp, " %5d", d2p->comsseq[i][j]);
	fprintf (fp, "\n");
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "# COMSTATE %d (senid senid ...)\n", d2p->n_comstate);
    for (i = 0; i < d2p->n_comstate; i++) {
	fprintf (fp, "%5d ", i);
	for (j = 0; IS_S3SENID(d2p->comstate[i][j]); j++)
	    fprintf (fp, " %5d", d2p->comstate[i][j]);
	fprintf (fp, "\n");
    }
    fprintf (fp, "#\n");
    fprintf (fp, "# END\n");
    
    fflush (fp);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * dict2pid.h -- Triphones for dictionary
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 14-Sep-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added dict2pid_comsseq2sen_active().
 * 
 * 04-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_DICT2PID_H_
#define _S3_DICT2PID_H_


#include "libutil.h"
#include "dict.h"


/*
 * This is one of the more complicated parts of a cross-word triphone model decoder.  The first
 * and last phones of each word get their left and right contexts, respectively, from other
 * words.  For single-phone words, both its contexts are from other words, simultaneously.  As
 * these words are not known beforehand, life gets complicated.  In this implementation, when
 * we do not wish to distinguish between distinct contexts, we use a COMPOSITE triphone (a bit
 * like BBN's fast-match implementation), by clubbing together all possible contexts.
 * 
 * There are 3 cases:
 *   1. Internal phones, and boundary phones without any specific context, in each word.  The
 * 	boundary phones are modelled using composite phones, internal ones using ordinary phones.
 *   2. The first phone of a multi-phone word, for a specific history (i.e., in a 2g/3g/4g...
 *	tree) has known left and right contexts.  The possible left contexts are limited to the
 *	possible last phones of the history.  So it can be modelled separately, efficiently, as
 *	an ordinary triphone.
 *   3. The one phone in a single-phone word, for a specific history (i.e., in a 2g/3g/4g...
 * 	tree) has a known left context, but unknown right context.  It is modelled using a
 * 	composite triphone.
 * (Note that right contexts are always composite, left contexts are composite only in the
 * unigram tree.)
 * 
 * A composite triphone is formed as follows.  (NOTE: this assumes that all CIphones/triphones
 * have the same HMM topology, specifically, no. of states.)  A composite triphone represents a
 * situation where either the left or the right context (or both) for a given base phone is
 * unknown.  That is, it represents the set of all possible ordinary triphones derivable from
 * the unkown context(s).  Let us call this set S.  It is modelled using the same HMM topology
 * as the ordinary triphones, but with COMPOSITE states.  A composite state (in a given position
 * in the HMM state topology) is the set of states (senones) at that position derived from S.
 * 
 * Actually, we generally deal with COMPOSITE SENONE-SEQUENCES rather than COMPOSITE PHONES.
 * The former are compressed forms of the latter, by virtue of state sharing among phones.
 * (See libmain/mdef.h.)
 */


typedef struct {
    s3ssid_t **internal;	/* For internal phone positions (not first, not last), the
				   ssid; for first and last positions, the composite ssid.
				   ([word][phone-position]) */
    s3ssid_t ***ldiph_lc;	/* For multi-phone words, [base][rc][lc] -> ssid; filled out for
				   word-initial base x rc combinations in current vocabulary */
    s3ssid_t **single_lc;	/* For single phone words, [base][lc] -> composite ssid; filled
				   out for single phone words in current vocabulary */
    
    s3senid_t **comstate;	/* comstate[i] = BAD_S3SENID terminated set of senone IDs in
				   the i-th composite state */
    s3senid_t **comsseq;	/* comsseq[i] = sequence of composite state IDs in i-th
				   composite phone (composite sseq). */
    int32 *comwt;		/* Weight associated with each composite state (logs3 value).
				   Final composite state score weighted by this amount */
    int32 n_comstate;		/* #Composite states */
    int32 n_comsseq;		/* #Composite senone sequences */
} dict2pid_t;

/* Access macros; not designed for arbitrary use */
#define dict2pid_internal(d,w,p)	((d)->internal[w][p])
#define dict2pid_n_comstate(d)		((d)->n_comstate)
#define dict2pid_n_comsseq(d)		((d)->n_comsseq)


/* Build the dict2pid structure for the given model/dictionary */
dict2pid_t *dict2pid_build (mdef_t *mdef, dict_t *dict);


/*
 * Compute composite senone scores from ordinary senone scores (max of component senones)
 */
void dict2pid_comsenscr (dict2pid_t *d2p,
			 int32 *senscr,		/* In: Ordinary senone scores */
			 int32 *comsenscr);	/* Out: Composite senone scores */

/* 
 * Mark active senones as indicated by the input array of composite senone-sequence active flags.
 * Caller responsible for allocating and clearing sen[] before calling this function.
 */
void dict2pid_comsseq2sen_active (dict2pid_t *d2p,
				  mdef_t *mdef,
				  int32 *comssid,	/* In: Active flag for each comssid */
				  int32 *sen);		/* In/Out: Active flags set for senones
							   indicated by the active comssid */

/* For debugging */
void dict2pid_dump (FILE *fp, dict2pid_t *d2p, mdef_t *mdef, dict_t *dict);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * dict.c -- Pronunciation dictionary.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 19-Apr-01    Ricky Houghton, added code for freeing memory that is allocated internally.
 * 
 * 23-Apr-98	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Made usage of mdef optional.  If no mdef is specified while loading
 *		a dictionary, it maintains the needed CI phone information internally.
 * 		Added dict_ciphone_str().
 * 
 * 02-Jul-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added startwid, finishwid, silwid to dict_t.  Modified dict_filler_word
 * 		to check for start and finishwid.
 * 
 * 07-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created from previous Sphinx-3 version.
 */


#include "dict.h"


#define DELIM	" \t\n"		/* Set of field separator characters */
#define DEFAULT_NUM_PHONE	(MAX_S3CIPID+1)


static s3cipid_t dict_ciphone_id (dict_t *d, char *str)
{
    int32 id;
    
    if (d->mdef)
	return mdef_ciphone_id (d->mdef, str);
    else {
	if (hash_lookup (d->pht, str, &id) < 0) {
	    id = (d->n_ciphone)++;
	    
	    if (id >= MAX_S3CIPID)
		E_FATAL("Too many CIphones in dictionary; increase MAX_S3CIPID\n");
	    d->ciphone_str[id] = (char *) ckd_salloc(str); /* Freed in dict_free()*/
	    
	    if (hash_enter (d->pht, d->ciphone_str[id], id) != id)
		E_FATAL("hash_enter(local-phonetable, %s) failed\n", str);
	}
	return id;
    }
}


const char *dict_ciphone_str (dict_t *d, s3wid_t wid, int32 pos)
{
    assert (d != NULL);
    assert ((wid >= 0) && (wid < d->n_word));
    assert ((pos >= 0) && (pos < d->word[wid].pronlen));
    
    if (d->mdef)
	return mdef_ciphone_str (d->mdef, d->word[wid].ciphone[pos]);
    else
	return (d->ciphone_str[(int)d->word[wid].ciphone[pos]]);
}


s3wid_t dict_add_word (dict_t *d, char *word, s3cipid_t *p, int32 np)
{
    int32 w, len;
    dictword_t *wordp;
    s3wid_t newwid;
    
    if (d->n_word >= d->max_words) {
	E_ERROR("Dictionary full; add(%s) failed\n", word);
	return (BAD_S3WID);
    }
    
    wordp = d->word + d->n_word;
    wordp->word = (char *) ckd_salloc (word); /* Freed in dict_free */
    
    /* Associate word string with d->n_word in hash table */
    if (hash_enter (d->ht, wordp->word, d->n_word) != d->n_word) {
	ckd_free (wordp->word);
	return (BAD_S3WID);
    }

    /* Fill in word entry, and set defaults */
    if (p && (np > 0)) {
	wordp->ciphone = (s3cipid_t *) ckd_malloc (np * sizeof(s3cipid_t)); /* Freed in dict_free */
	memcpy (wordp->ciphone, p, np*sizeof(s3cipid_t));
	wordp->pronlen = np;
    } else {
	wordp->ciphone = NULL;
	wordp->pronlen = 0;
    }
    wordp->alt = BAD_S3WID;
    wordp->basewid = d->n_word;
    wordp->n_comp = 0;
    wordp->comp = NULL;
    
    /* Determine base/alt wids */
    if ((len = dict_word2basestr (word)) > 0) {
	/* Truncated to a baseword string; find its ID */
	if (hash_lookup (d->ht, word, &w) < 0) {
	    word[len] = '(';	/* Get back the original word */
	    E_FATAL("Missing base word for: %s\n", word);
	} else
	    word[len] = '(';	/* Get back the original word */
	
	/* Link into alt list */
	wordp->basewid = w;
	wordp->alt = d->word[w].alt;
	d->word[w].alt = d->n_word;
    }
    
    newwid = d->n_word++;
    
    return (newwid);
}


static int32 dict_read (FILE *fp, dict_t *d)
{
    char line[16384], **wptr;
    s3cipid_t p[4096];
    int32 lineno, nwd;
    s3wid_t w;
    int32 i, maxwd;
    
    maxwd = 4092;
    wptr = (char **) ckd_calloc (maxwd, sizeof(char *)); /* Freed below */
    
    lineno = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
        lineno++;
	if (line[0] == '#')	/* Comment line */
	    continue;
	
	if ((nwd = str2words (line, wptr, maxwd)) < 0)
	    E_FATAL("str2words(%s) failed; Increase maxwd from %d\n", line, maxwd);

	if (nwd == 0)	    /* Empty line */
	    continue;
	/* wptr[0] is the word-string and wptr[1..nwd-1] the pronunciation sequence */
	if (nwd == 1) {
	    E_ERROR("Line %d: No pronunciation for word %s; ignored\n", lineno, wptr[0]);
	    continue;
	}
	
	/* Convert pronunciation string to CI-phone-ids */
	for (i = 1; i < nwd; i++) {
	    p[i-1] = dict_ciphone_id (d, wptr[i]);
	    if (NOT_S3CIPID(p[i-1])) {
		E_ERROR("Line %d: Bad ciphone: %s; word %s ignored\n",
			lineno, wptr[i], wptr[0]);
		break;
	    }
	}
	
	if (i == nwd) {	/* All CI-phones successfully converted to IDs */
	    w = dict_add_word (d, wptr[0], p, nwd-1);
	    if (NOT_S3WID(w))
		E_ERROR("Line %d: dict_add_word (%s) failed (duplicate?); ignored\n",
			lineno, wptr[0]);
	}
    }

    ckd_free (wptr);
    
    return 0;
}


static s3wid_t *dict_comp_head (dict_t *d)
{
    int32 w;
    s3wid_t *comp_head;
    
    comp_head = (s3wid_t *) ckd_calloc (d->n_word, sizeof(s3wid_t)); /* freed in dict_free */
    
    for (w = 0; w < d->n_word; w++)
	comp_head[w] = BAD_S3WID;
    for (w = 0; w < d->n_word; w++) {
	if (d->word[w].n_comp > 0) {
	    comp_head[w] = comp_head[d->word[w].comp[0]];
	    comp_head[d->word[w].comp[0]] = w;
	}
    }

    return comp_head;
}


/*
 * Scan the dictionary for compound words.  This function should be called just after
 * loading the dictionary.  For the moment, compound words in a compound word are
 * assumed to be separated by the given sep character, (underscore in the CMU dict).
 * Return value: #compound words found in dictionary.
 */
static int32 dict_build_comp (dict_t *d,
			      char sep)		/* Separator character */
{
    char wd[4096];
    int32 w, cwid;
    dictword_t *wordp;
    int32 nc;		/* # compound words in dictionary */
    int32 i, j, l, n;
    
    nc = 0;
    for (w = 0; w < d->n_word; w++) {
	wordp = d->word + dict_basewid(d, w);
	strcpy (wd, wordp->word);
	l = strlen(wd);
	if ((wd[0] == sep) || (wd[l-1] == sep))
	    E_FATAL("Bad compound word %s: leading or trailing separator\n", wordp->word);
	
	/* Count no. of components in this word */
	n = 1;
	for (i = 1; i < l-1; i++)	/* 0 and l-1 already checked above */
	    if (wd[i] == sep)
		n++;
	if (n == 1)
	    continue;		/* Not a compound word */
	nc++;
	
	if ((w == d->startwid) || (w == d->finishwid) || dict_filler_word (d, w))
	    E_FATAL("Compound special/filler word (%s) not allowed\n", wordp->word);
	
	/* Allocate and fill in component word info */
	wordp->n_comp = n;
	wordp->comp = (s3wid_t *) ckd_calloc (n, sizeof(s3wid_t)); /* freed in dict_free */
	
	/* Parse word string into components */
	n = 0;
	for (i = 0; i < l; i++) {
	    for (j = i; (i < l) && (wd[i] != sep); i++);
	    if (j == i)
		E_FATAL("Bad compound word %s: successive separators\n", wordp->word);
	    
	    wd[i] = '\0';
	    cwid = dict_wordid (d, wd+j);
	    if (NOT_S3WID(cwid))
		E_FATAL("Component word %s of %s not in dictionary\n", wd+j, wordp->word);
	    wordp->comp[n] = cwid;
	    n++;
	}
    }
    
    if (nc > 0)
	d->comp_head = dict_comp_head (d);
    
    return nc;
}


dict_t *dict_init (mdef_t *mdef, char *dictfile, char *fillerfile, char comp_sep)
{
    FILE *fp, *fp2;
    int32 n ;
    char line[1024];
    dict_t *d;
    
    if (! dictfile)
	E_FATAL("No dictionary file\n");

    /*
     * First obtain #words in dictionary (for hash table allocation).
     * Reason: The PC NT system doesn't like to grow memory gradually.  Better to allocate
     * all the required memory in one go.
     */
    if ((fp = fopen(dictfile, "r")) == NULL)
	E_FATAL_SYSTEM("fopen(%s,r) failed\n", dictfile);
    n = 0;
    while (fgets (line, sizeof(line), fp) != NULL) {
	if (line[0] != '#')
	    n++;
    }
    rewind (fp);

    fp2 = NULL;
    if (fillerfile) {
	if ((fp2 = fopen(fillerfile, "r")) == NULL)
	    E_FATAL_SYSTEM("fopen(%s,r) failed\n", fillerfile);

	while (fgets (line, sizeof(line), fp2) != NULL) {
	    if (line[0] != '#')
		n++;
	}
	rewind (fp2);
    }
    
    /*
     * Allocate dict entries.  HACK!!  Allow some extra entries for words not in file.
     * Also check for type size restrictions.
     */
    d = (dict_t *) ckd_calloc (1, sizeof(dict_t)); /* freed in dict_free() */
    d->max_words = (n+1024 < MAX_S3WID) ? n+1024 : MAX_S3WID;
    if (n >= MAX_S3WID)
	E_FATAL("#Words in dictionaries (%d) exceeds limit (%d)\n", n, MAX_S3WID);
    
    d->word = (dictword_t *) ckd_calloc (d->max_words, sizeof(dictword_t)); /* freed in dict_free() */
    d->n_word = 0;
    d->mdef = mdef;
    if (mdef) {
	d->pht = NULL;
	d->ciphone_str = NULL;
    } else {
	d->pht = hash_new (DEFAULT_NUM_PHONE, 1 /* No case */);
	d->ciphone_str = (char **) ckd_calloc (DEFAULT_NUM_PHONE, sizeof(char *)); /* freed in dict_free() */
    }
    d->n_ciphone = 0;
    
    /* Create new hash table for word strings; case-insensitive word strings */
    d->ht = hash_new (d->max_words, 1 /* no-case */);

    /* Initialize with no compound words */
    d->comp_head = NULL;
    
    /* Digest main dictionary file */
    E_INFO("Reading main dictionary: %s\n", dictfile);
    dict_read (fp, d);
    fclose (fp);
    E_INFO("%d words read\n", d->n_word);

    /* Now the filler dictionary file, if it exists */
    d->filler_start = d->n_word;
    if (fillerfile) {
        E_INFO("Reading filler dictionary: %s\n", fillerfile);
	dict_read (fp2, d);
	fclose (fp2);
	E_INFO("%d words read\n", d->n_word - d->filler_start);
    }
    d->filler_end = d->n_word-1;

    /* Initialize distinguished word-ids */
    d->startwid = dict_wordid (d, S3_START_WORD);
    d->finishwid = dict_wordid (d, S3_FINISH_WORD);
    d->silwid = dict_wordid (d, S3_SILENCE_WORD);
#if 0
    if (NOT_S3WID(d->startwid))
	E_WARN("%s not in dictionary\n", S3_START_WORD);
    if (NOT_S3WID(d->finishwid))
	E_WARN("%s not in dictionary\n", S3_FINISH_WORD);
    if (NOT_S3WID(d->silwid))
	E_WARN("%s not in dictionary\n", S3_SILENCE_WORD);
#endif

    /* Identify compound words if indicated */
    if (comp_sep) {
	E_INFO("Building compound words (separator = '%c')\n", comp_sep);
	n = dict_build_comp (d, comp_sep);
	E_INFO("%d compound words\n", n);
    }
    
    return d;
}


s3wid_t dict_wordid (dict_t *d, char *word)
{
    int32 w;
    
    assert (d);
    assert (word);
    
    if (hash_lookup (d->ht, word, &w) < 0)
	return (BAD_S3WID);
    return ((s3wid_t) w);
}


s3wid_t _dict_basewid (dict_t *d, s3wid_t w)
{
    assert (d);
    assert ((w >= 0) && (w < d->n_word));
    
    return (d->word[w].basewid);
}


char *_dict_wordstr (dict_t *d, s3wid_t wid)
{
    assert (d);
    assert (IS_S3WID(wid) && (wid < d->n_word));
    
    return (d->word[wid].word);
}


s3wid_t _dict_nextalt (dict_t *d, s3wid_t wid)
{
    assert (d);
    assert (IS_S3WID(wid) && (wid < d->n_word));
    
    return (d->word[wid].alt);
}


int32 dict_filler_word (dict_t *d, s3wid_t w)
{
    assert (d);
    assert ((w >= 0) && (w < d->n_word));
    
    w = dict_basewid(d, w);
    if ((w == d->startwid) || (w == d->finishwid))
	return 0;
    if ((w >= d->filler_start) && (w <= d->filler_end))
	return 1;
    return 0;
}


s3wid_t dict_wids2compwid (dict_t *d, s3wid_t *wid, int32 len)
{
    s3wid_t w;
    int32 i;
    
    if (! d->comp_head)
	return BAD_S3WID;
    
    assert (len > 1);
    
    for (w = d->comp_head[wid[0]]; IS_S3WID(w); w = d->comp_head[w]) {
	/* w is a compound word beginning with wid[0]; check if rest matches */
	assert (d->word[w].n_comp > 1);
	assert (d->word[w].comp[0] == wid[0]);
	
	if (d->word[w].n_comp == len) {
	    for (i = 0; (i < len) && (d->word[w].comp[i] == wid[i]); i++);
	    if (i == len)
		return (dict_basewid(d, w));
	}
    }

    return BAD_S3WID;
}


int32 dict_word2basestr (char *word)
{
    int32 i, len;
    
    len = strlen(word);
    if (word[len-1] == ')') {
	for (i = len-2; (i > 0) && (word[i] != '('); --i);
	
	if (i > 0) {
	    /* The word is of the form <baseword>(...); strip from left-paren */
	    word[i] = '\0';
	    return i;
	}
    }

    return -1;
}

/* RAH 4.19.01, try to free memory allocated by the calls above.
   All testing I've done shows that this gets all the memory, however I've 
   likely not tested all cases. 
 */
void dict_free (dict_t *d)
{
  int i;
  dictword_t *word;

  if (d) { /* Clean up the dictionary stuff*/
    /* First Step, free all memory allocated for each word */
    for (i=0;i<d->n_word;i++) {
      word = (dictword_t *) &(d->word[i]);
      if (word->word) 
	ckd_free ((void *)word->word);
      if (word->ciphone) 
      ckd_free ((void *)word->ciphone);
      if (word->comp) 
	ckd_free ((void *)word->comp);
    }
    
    if (d->word) 
      ckd_free ((void *)d->word);
    for (i=0;i<d->n_ciphone;i++) {
      if (d->ciphone_str[i]) 
	ckd_free ((void *)d->ciphone_str[i]);
    }
    if (d->comp_head) 
      ckd_free ((void *)d->comp_head);
    if (d->ciphone_str)
      ckd_free ((void *)d->ciphone_str);
    if (d->pht)
      hash_free (d->pht);
    if (d->ht)
      hash_free (d->ht);
    ckd_free ((void *)d);
  }
}


#if (_DICT_TEST_)
main (int32 argc, char *argv[])
{
    mdef_t *m;
    dict_t *d;
    char wd[1024];
    s3wid_t wid;
    int32 p;
    
    if (argc < 3)
	E_FATAL("Usage: %s {mdeffile | NULL} dict [fillerdict]\n", argv[0]);
    
    m = (strcmp (argv[1], "NULL") != 0) ? mdef_init (argv[1]) : NULL;
    /*  d = dict_init (m, argv[2], ((argc > 3) ? argv[3] : NULL), '_'); */ /*  */
  d = dict_init (m, argv[2], ((argc > 3) ? argv[3] : NULL), ' '); */ /* RAH, remove compound word separator */
    
#define _DICT_MEM_LEAK_TEST_ 0

#if (_DICT_MEM_LEAK_TEST_)

  if (0) { /* RAH For now, just exit so we can check for memory leaks */
    strcpy (wd,"empty");
    while ((strcmp(wd,"q") !=  0)) {	/* RAH, changed this from: for (;;) */
#else
    for (;;) {
#endif
	printf ("word> ");
	scanf ("%s", wd);
	
	wid = dict_wordid (d, wd);
	if (NOT_S3WID(wid))
	    E_ERROR("Unknown word\n");
	else {
	    for (wid = dict_basewid(d, wid); IS_S3WID(wid); wid = d->word[wid].alt) {
		printf ("%s\t", dict_wordstr(d, wid));
		for (p = 0; p < d->word[wid].pronlen; p++)
		    printf (" %s", dict_ciphone_str (d, wid, p));
		printf ("\n");
	    }
	}
    }
}
#if (_DICT_MEM_LEAK_TEST_)
  mdef_free (m);		/* RAH, added freeing of memory */
  dict_free (d);		/* RAH, added freeing of the memory*/
  exit (0);
#endif
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * dict.h -- Pronunciation dictionary structures
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 19-Apr-01    Ricky Houghton, added code for freeing memory that is allocated internally.
 * 
 * 23-Apr-98	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Made usage of mdef optional.  If no mdef is specified while loading
 *		a dictionary, it maintains the needed CI phone information internally.
 * 		Added dict_ciphone_str().
 * 
 * 02-Jul-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added startwid, finishwid, silwid to dict_t structure.
 * 
 * 07-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created from previous Sphinx-3 version.
 */


#ifndef _S3_DICT_H_
#define _S3_DICT_H_


#include "libutil.h"
#include "s3types.h"
#include "mdef.h"	/* This is still a sore point; dict should be independent of mdef */


typedef struct {
    char *word;		/* Ascii word string */
    s3cipid_t *ciphone;	/* Pronunciation */
    int32 pronlen;	/* Pronunciation length */
    s3wid_t alt;	/* Next alternative pronunciation id, NOT_S3WID if none */
    s3wid_t basewid;	/* Base pronunciation id */
    int32 n_comp;	/* If this is a compound word, no. of component words; else 0.
			   (Compound words are concatenations of other words, such as
			   GOING_TO, whose pronunciation is quite different from the
			   mere concatenation of their components.) */
    s3wid_t *comp;	/* If n_comp > 0, its components */
} dictword_t;

typedef struct {
    mdef_t *mdef;	/* Model definition used for phone IDs; NULL if none used */
    hash_table_t *pht;	/* Used only if CI phones handled internally (mdef == NULL) */
    char **ciphone_str;	/* Used only if CI phones handled internally (mdef == NULL) */
    int32 n_ciphone;	/* Used only if CI phones handled internally (mdef == NULL) */
    dictword_t *word;	/* Array of entries in dictionary */
    hash_table_t *ht;	/* Hash table for mapping word strings to word ids */
    int32 max_words;	/* #Entries allocated in dict, including empty slots */
    int32 n_word;	/* #Occupied entries in dict; ie, excluding empty slots */
    int32 filler_start;	/* First filler word id (read from filler dict) */
    int32 filler_end;	/* Last filler word id (read from filler dict) */
    s3wid_t *comp_head;	/* comp_head[w] = wid of a compound word with 1st component = w;
			   comp_head[comp_head[w]] = next such compound word, and so on,
			   until we hit BAD_S3WID.  NULL if no compound word in dict. */
    s3wid_t startwid;	/* FOR INTERNAL-USE ONLY */
    s3wid_t finishwid;	/* FOR INTERNAL-USE ONLY */
    s3wid_t silwid;	/* FOR INTERNAL-USE ONLY */
} dict_t;


/*
 * Initialize with given main and filler dictionary files.  fillerfile can be NULL
 * (but external modules might impose their own requirements).
 * Return ptr to dict_t if successful, NULL otherwise.
 */
dict_t *dict_init (mdef_t *mdef,	/* For looking up CI phone IDs; NULL if none,
					   in which case CI phones kept internally */
		   char *dictfile,	/* Main dictionary file */
		   char *fillerfile,	/* Filler dictionary file */
		   char comp_sep);	/* Compound word separator character, or 0 if
					   no compound words */

/* Return word id for given word string if present.  Otherwise return BAD_S3WID */
s3wid_t dict_wordid (dict_t *d, char *word);

/*
 * Return 1 if w is a filler word, 0 if not.  A filler word is one that was read in from the
 * filler dictionary; however, sentence START and FINISH words are not filler words.
 */
int32 dict_filler_word (dict_t *d, s3wid_t w);

/*
 * Add a word with the given ciphone pronunciation list to the dictionary.
 * Return value: Result word id if successful, BAD_S3WID otherwise
 */
s3wid_t dict_add_word (dict_t *d, char *word, s3cipid_t *p, int32 np);

/*
 * Look for a compound word that matches the given word-id sequence.
 * Return value: Base ID of compound word if found, else BAD_S3WID.
 */
s3wid_t dict_wids2compwid (dict_t *d,		/* In: Dictionary to look up */
			   s3wid_t *wid,	/* In: Component words to look for */
			   int32 len);		/* In: No. of component words */

/*
 * Return value: CI phone string for the given word, phone position.
 */
const char *dict_ciphone_str (dict_t *d,	/* In: Dictionary to look up */
			      s3wid_t wid,	/* In: Component word being looked up */
			      int32 pos);	/* In: Pronunciation phone position */

/* Packaged macro access to dictionary members */
#define dict_size(d)		((d)->n_word)
#define dict_basewid(d,w)	((d)->word[w].basewid)
#define dict_wordstr(d,w)	((d)->word[w].word)
#define dict_nextalt(d,w)	((d)->word[w].alt)
#define dict_pronlen(d,w)	((d)->word[w].pronlen)
#define dict_pron(d,w,p)	((d)->word[w].ciphone[p])
#define dict_filler_start(d)	((d)->filler_start)
#define dict_filler_end(d)	((d)->filler_end)
#define dict_startwid(d)	((d)->startwid)
#define dict_finishwid(d)	((d)->finishwid)
#define dict_silwid(d)		((d)->silwid)
#define dict_first_phone(d,w)	((d)->word[w].ciphone[0])
#define dict_last_phone(d,w)	((d)->word[w].ciphone[(d)->word[w].pronlen - 1])


/* Function versions of some of the above macros; note the leading underscore. */

/*
 * Return base word id for given word id w (which may be itself).  w must be valid.
 */
s3wid_t _dict_basewid (dict_t *d, s3wid_t w);

/*
 * Return word string for given word id, which must be valid.
 */
char *_dict_wordstr (dict_t *d, s3wid_t wid);

/*
 * Return the next alternative word id for the given word id, which must be valid.
 * The returned id may be BAD_S3WID if there is none.
 */
s3wid_t _dict_nextalt (dict_t *d, s3wid_t wid);

/*
 * If the given word contains a trailing "(....)" (i.e., a Sphinx-II style alternative
 * pronunciation specification), strip that trailing portion from it.  Note that the given
 * string is modified.
 * Return value: If string was modified, the character position at which the original string
 * was truncated; otherwise -1.
 */
int32 dict_word2basestr (char *word);

/* RAH, free memory allocated for the dictionary */
void dict_free (dict_t *d);

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * err.c -- Package for checking and catching common errors, printing out
 *		errors nicely, etc.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * 6/01/95  Paul Placeway  CMU speech group
 *
 * 6/02/95  Eric Thayer
 *	- Removed non-ANSI expresssions.  I don't know of any non-ANSI
 *		holdouts left anymore. (DEC using -std1, HP using -Aa,
 *		Sun using gcc or acc.)
 *      - Removed the automatic newline at the end of the error message
 *	  as that all S3 error messages have one in them now.
 *	- Added an error message option that does a perror() call.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if ((! WIN32) && (! _SGI_SOURCE))
#include <sys/errno.h>
#else
#include <errno.h>
#endif

#include "err.h"


void
_E__pr_header(char const *f, long ln, char const *msg)
{
    (void) fflush(stderr);
    (void) fprintf(stderr, "%s: \"%s\", line %ld: ", msg, f, ln);
}

void
_E__pr_info_header(char const *f, long ln, char const *msg)
{
    (void) fflush(stderr);

    /* make different format so as not to be parsed by emacs compile */
    (void) fprintf(stderr, "%s: %s(%ld): ", msg, f, ln);
}

void
_E__pr_warn( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);
    (void) vfprintf(stderr, fmt, pvar);
    va_end(pvar);

    (void) fflush(stderr);
}

void
_E__pr_info( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);
    (void) vfprintf(stderr, fmt, pvar);
    va_end(pvar);

    (void) fflush(stderr);
}

void _E__die_error( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);

    (void) vfprintf(stderr, fmt, pvar);
    (void) fflush(stderr);

    va_end(pvar);

    (void) fflush(stderr);
    
    exit (-1);
}

void _E__fatal_sys_error( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);
    (void) vfprintf(stderr, fmt, pvar);
    va_end(pvar);

    fputc(';', stderr);
    fputc(' ', stderr);

    perror("");
    
    (void) fflush(stderr);

    exit(errno);
}

void _E__sys_error( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);
    (void) vfprintf(stderr, fmt, pvar);
    va_end(pvar);

    fputc(';', stderr);
    fputc(' ', stderr);

    perror("");

    (void) fflush(stderr);
}

void _E__abort_error( char const *fmt, ... ) 
{
    va_list pvar;

    va_start(pvar, fmt);
    (void) vfprintf(stderr, fmt, pvar);
    va_end(pvar);

    (void) fflush(stderr);

    abort ();
}

#ifdef TEST
main()
{
    char const *two = "two";
    char const *three = "three";
    FILE *fp;

    E_WARN("this is a simple test\n");

    E_WARN("this is a test with \"%s\" \"%s\".\n", "two", "arguments");

    E_WARN("foo %d is bar\n", 5);

    E_WARN("bar is foo\n");

    E_WARN("one\n", two, three);

    E_INFO("Just some information you might find interesting\n");

    fp = fopen("gondwanaland", "r");
    if (fp == NULL) {
	E_SYSTEM("Can't open gondwanaland for reading");
    }
}
#endif /* TEST */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * err.h -- Package for checking and catching common errors, printing out
 *		errors nicely, etc.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * 6/01/95  Paul Placeway  CMU speech group
 */


#ifndef _LIBUTIL_ERR_H_
#define _LIBUTIL_ERR_H_

/* 01.18.01 RAH, allow for C++ compiles */
#ifdef __cplusplus
extern "C" {
#endif



#include <stdarg.h>
#include <errno.h>

void _E__pr_header( char const *file, long line, char const *msg );
void _E__pr_info_header( char const *file, long line, char const *tag );
void _E__pr_warn( char const *fmt, ... );
void _E__pr_info( char const *fmt, ... );
void _E__die_error( char const *fmt, ... );
void _E__abort_error( char const *fmt, ... );
void _E__sys_error( char const *fmt, ... );
void _E__fatal_sys_error( char const *fmt, ... );

/* These three all abort */

/* core dump after error message */
#ifndef E_ABORT
#define E_ABORT  _E__pr_header(__FILE__, __LINE__, "ERROR"),_E__abort_error
#endif

/* exit with non-zero status after error message */
#define E_FATAL  _E__pr_header(__FILE__, __LINE__, "FATAL_ERROR"),_E__die_error

/* Print error text; Call perror(""); exit(errno); */
#define E_FATAL_SYSTEM	_E__pr_header(__FILE__, __LINE__, "SYSTEM_ERROR"),_E__fatal_sys_error

/* Print error text; Call perror(""); */
#define E_WARN_SYSTEM	_E__pr_header(__FILE__, __LINE__, "SYSTEM_ERROR"),_E__sys_error

/* Print error text; Call perror(""); */
#define E_ERROR_SYSTEM	_E__pr_header(__FILE__, __LINE__, "SYSTEM_ERROR"),_E__sys_error


/* Print logging information, warnings, or error messages; all to stderr */
#define E_INFO	  _E__pr_info_header(__FILE__, __LINE__, "INFO"),_E__pr_info

#define E_WARN	  _E__pr_header(__FILE__, __LINE__, "WARNING"),_E__pr_warn

#define E_ERROR	  _E__pr_header(__FILE__, __LINE__, "ERROR"),_E__pr_warn


#ifdef __cplusplus
}
#endif


#endif /* !_ERR_H */


/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * feat.c -- Feature vector description and cepstra->feature computation.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Adding feat_free() to free allocated memory
 *
 * 02-Jan-2001	Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Modified feat_s2mfc2feat_block() to handle empty buffers at
 *		the end of an utterance
 *
 * 30-Dec-2000	Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Added feat_s2mfc2feat_block() to allow feature computation
 *		from sequences of blocks of cepstral vectors
 *
 * 12-Jun-98	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Major changes to accommodate arbitrary feature input types.  Added
 * 		feat_read(), moved various cep2feat functions from other files into
 *		this one.  Also, made this module object-oriented with the feat_t type.
 * 		Changed definition of s2mfc_read to let the caller manage MFC buffers.
 * 
 * 03-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added unistd.h include.
 * 
 * 02-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added check for sf argument to s2mfc_read being within file size.
 * 
 * 18-Sep-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added sf, ef parameters to s2mfc_read().
 * 
 * 10-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added feat_cepsize().
 * 		Added different feature-handling (s2_4x, s3_1x39 at this point).
 * 		Moved feature-dependent functions to feature-dependent files.
 * 
 * 09-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Moved constant declarations from feat.h into here.
 * 
 * 04-Nov-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


/*
 * This module encapsulates different feature streams used by the Sphinx group.  New
 * stream types can be added by augmenting feat_init() and providing an accompanying
 * compute_feat function.  It also provides a "generic" feature vector definition for
 * handling "arbitrary" speech input feature types (see the last section in feat_init()).
 * In this case the speech input data should already be feature vectors; no computation,
 * such as MFC->feature conversion, is available or needed.
 */


#include "libutil.h"
#include "feat.h"
#include "bio.h"
#include "cmn.h"
#include "agc.h"
#include "s3types.h"

#if (! WIN32)
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/param.h>
#else
#include <fcntl.h>
#endif


#define FEAT_VERSION	"1.0"

#define N_FEAT			1

#define FEAT_DCEP_WIN		2

int32 feat_readfile (feat_t *fcb, char *file, int32 sf, int32 ef, float32 ***feat, int32 maxfr)
{
    FILE *fp;
    int32 i, l, k, nfr;
    int32 byteswap, chksum_present;
    uint32 chksum;
    char **argname, **argval;
    
    E_INFO("Reading feature file: '%s'[%d..%d]\n", file, sf, ef);
    assert (fcb);

    if (ef <= sf) {
	E_ERROR("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
	return -1;
    }
    
    if ((fp = fopen(file, "rb")) == NULL) {
	E_ERROR("fopen(%s,rb) failed\n", file);
	return -1;
    }
    
    /* Read header */
    if (bio_readhdr (fp, &argname, &argval, &byteswap) < 0) {
	E_ERROR("bio_readhdr(%s) failed\n", file);
	fclose (fp);
	return -1;
    }
    
    /* Parse header info (although nothing much is done with it) */
    chksum_present = 0;
    for (i = 0; argname[i]; i++) {
	if (strcmp (argname[i], "version") == 0) {
	    if (strcmp(argval[i], FEAT_VERSION) != 0)
		E_WARN("%s: Version mismatch: %s, expecting %s\n",
		       file, argval[i], FEAT_VERSION);
	} else if (strcmp (argname[i], "chksum0") == 0) {
	    chksum_present = 1;	/* Ignore the associated value */
	}
    }

    bio_hdrarg_free (argname, argval);
    argname = argval = NULL;
    
    chksum = 0;
    
    /* #Frames */
    if (bio_fread (&nfr, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {
	E_ERROR("%s: fread(#frames) failed\n", file);
	fclose (fp);
	return -1;
    }
    
    /* #Feature streams */
    if ((bio_fread (&l, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(l != feat_n_stream(fcb))) {
	E_ERROR("%s: Missing or bad #feature streams\n", file);
	fclose (fp);
	return -1;
    }
    
    /* Feature stream lengths */
    k = 0;
    for (i = 0; i < feat_n_stream(fcb); i++) {
	if ((bio_fread (&l, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	    (l != feat_stream_len (fcb, i))) {
	    E_ERROR("%s: Missing or bad feature stream size\n", file);
	    fclose (fp);
	    return -1;
	}
	k += l;
    }
    
    /* Check sf/ef specified */
    if (sf > 0) {
	if (sf >= nfr) {
	    E_ERROR("%s: Start frame (%d) beyond file size (%d)\n", file, sf, nfr);
	    fclose (fp);
	    return -1;
	}
	nfr -= sf;
    }
    
    /* Limit nfr as indicated by [sf..ef] */
    if ((ef-sf+1) < nfr)
	nfr = (ef-sf+1);
    if (nfr > maxfr) {
	E_ERROR("%s: Feature buffer size(%d frames) < actual #frames(%d)\n",
		file, maxfr, nfr);
	fclose (fp);
	return -1;
    }
    
    /* Position at desired start frame and read feature data */
    if (sf > 0)
	fseek (fp, sf * k * sizeof(float32), SEEK_CUR);
    if (bio_fread (feat[0][0], sizeof(float32), nfr*k, fp, byteswap, &chksum) != nfr*k) {
	E_ERROR("%s: fread(%dx%d) (feature data) failed\n", file, nfr, k);
	fclose (fp);
	return -1;
    }
    
    fclose (fp);	/* NOTE: checksum NOT verified; we might read only part of file */
    
    return nfr;
}


int32 feat_writefile (feat_t *fcb, char *file, float32 ***feat, int32 nfr)
{
    FILE *fp;
    int32 i, k;
    
    E_INFO ("Writing feature file: '%s'\n", file);
    assert (fcb);
    
    if ((fp = fopen (file, "wb")) == NULL) {
	E_ERROR("fopen(%s,wb) failed\n", file);
	return -1;
    }
    
    /* Write header */
    bio_writehdr_version (fp, FEAT_VERSION);
    
    fwrite (&nfr, sizeof(int32), 1, fp);
    fwrite (&(fcb->n_stream), sizeof(int32), 1, fp);
    k = 0;
    for (i = 0; i < feat_n_stream(fcb); i++) {
	fwrite (&(fcb->stream_len[i]), sizeof(int32), 1, fp);
	k += feat_stream_len(fcb, i);
    }
    
    /* Feature data is assumed to be in a single block, starting at feat[0][0][0] */
    if ((int32) fwrite (feat[0][0], sizeof(float32), nfr*k, fp) != nfr*k) {
	E_ERROR("%s: fwrite(%dx%d feature data) failed\n", file, nfr, k);
	fclose (fp);
	return -1;
    }
    
    fclose (fp);
    
    return 0;
}


/*
 * Read specified segment [sf..ef] of Sphinx-II format mfc file read and return
 * #frames read.  Return -1 if error.
 */
int32 feat_s2mfc_read (char *file, int32 sf, int32 ef, float32 **mfc, int32 maxfr)
{
    FILE *fp;
    int32 n_float32;
    struct stat statbuf;
    int32 i, n, byterev, cepsize;
    
    if (ef < 0)
	ef = (int32)0x7fff0000;		/* Hack!! hardwired constant */
    
    E_INFO("Reading mfc file: '%s'[%d..%d]\n", file, sf, ef);
    if (ef <= sf) {
	E_ERROR("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
	return -1;
    }
    
    cepsize = 13;	/* Hack!! hardwired constant */
    
    /* Find filesize; HACK!! To get around intermittent NFS failures, use stat_retry */
    if ((stat_retry (file, &statbuf) < 0) || ((fp = fopen(file, "rb")) == NULL)) {
	E_ERROR("stat_retry/fopen(%s) failed\n", file);
	return -1;
    }
    
    /* Read #floats in header */
    if (fread_retry (&n_float32, sizeof(int32), 1, fp) != 1) {
	E_ERROR("%s: fread(#floats) failed\n", file);
	fclose (fp);
	return -1;
    }
    
    /* Check if n_float32 matches file size */
    byterev = FALSE;
    if ((int32) (n_float32*sizeof(float32) + 4) !=  (int32) statbuf.st_size) { /* RAH, typecast both sides to remove compile warning */
	n = n_float32;
	SWAP_INT32(&n);

	if ((int32) (n*sizeof(float32) + 4) != (int32) (statbuf.st_size)) { /* RAH, typecast both sides to remove compile warning */
	    E_ERROR("%s: Header size field: %d(%08x); filesize: %d(%08x)\n",
		    file, n_float32, n_float32, statbuf.st_size, statbuf.st_size);
	    fclose (fp);
	    return -1;
	}
	
	n_float32 = n;
	byterev = TRUE;
    }
    if (n_float32 <= 0) {
	E_ERROR("%s: Header size field (#floats) = %d\n", file, n_float32);
	fclose (fp);
	return -1;
    }
    
    /* Convert n to #frames of input */
    n = n_float32/cepsize;
    if (n * cepsize != n_float32) {
	E_ERROR("Header size field: %d; not multiple of %d\n", n_float32, cepsize);
	fclose (fp);
	return -1;
    }

    /* Check sf/ef specified */
    if (sf > 0) {
	if (sf >= n) {
	    E_ERROR("%s: Start frame (%d) beyond file size (%d)\n", file, sf, n);
	    fclose (fp);
	    return -1;
	}
	n -= sf;
    }

    /* Limit n if indicated by [sf..ef] */
    if ((ef-sf+1) < n)
	n = (ef-sf+1);
    if (n > maxfr) {
	E_ERROR("%s: MFC buffer size(%d frames) < actual #frames(%d)\n", file, maxfr, n);
	fclose (fp);
	return -1;
    }
    
    /* Position at desired start frame and read MFC data */
    if (sf > 0)
	fseek (fp, sf * cepsize * sizeof(float32), SEEK_CUR);
    n_float32 = n * cepsize;
    if (fread_retry (mfc[0], sizeof(float32), n_float32, fp) != n_float32) {
	E_ERROR("%s: fread(%dx%d) (MFC data) failed\n", file, n, cepsize);
	fclose (fp);
	return -1;
    }
    if (byterev) {
	for (i = 0; i < n_float32; i++)
	    SWAP_FLOAT32(&(mfc[0][i]));
    }

    fclose (fp);
    
    return n;
}


static int32 feat_stream_len_sum (feat_t *fcb)
{
    int32 i, k;
    
    k = 0;
    for (i = 0; i < feat_n_stream(fcb); i++)
	k += feat_stream_len (fcb, i);
    return k;
}


float32 **feat_vector_alloc (feat_t *fcb)
{
    int32 i, k;
    float32 *data, **feat;
    
    assert (fcb);
    
    if ((k = feat_stream_len_sum(fcb)) <= 0) {
	E_ERROR("Sum(feature stream lengths) = %d\n", k);
	return NULL;
    }
    
    /* Allocate feature data array so that data is in one block from feat[0][0] */
    feat = (float32 **) ckd_calloc (feat_n_stream(fcb), sizeof(float32 *));
    data = (float32 *) ckd_calloc (k, sizeof(float32));
    
    for (i = 0; i < feat_n_stream(fcb); i++) {
	feat[i] = data;
	data += feat_stream_len (fcb, i);
    }
    
    return feat;
}


float32 ***feat_array_alloc (feat_t *fcb, int32 nfr)
{
    int32 i, j, k;
    float32 *data, ***feat;
    
    assert (fcb);
    assert (nfr > 0);
    
    if ((k = feat_stream_len_sum(fcb)) <= 0) {
	E_ERROR("Sum(feature stream lengths) = %d\n", k);
	return NULL;
    }
    
    /* Allocate feature data array so that data is in one block from feat[0][0][0] */
    feat = (float32 ***) ckd_calloc_2d (nfr, feat_n_stream(fcb), sizeof(float32 *));
    data = (float32 *) ckd_calloc (nfr*k, sizeof(float32));
    
    for (i = 0; i < nfr; i++) {
	for (j = 0; j < feat_n_stream(fcb); j++) {
	    feat[i][j] = data;
	    data += feat_stream_len (fcb, j);
	}
    }
    
    return feat;
}


static void feat_s2_4x_cep2feat (feat_t *fcb, float32 **mfc, float32 **feat)
{
    float32 *f;
    float32 *w, *_w;
    float32 *w1, *w_1, *_w1, *_w_1;
    float32 d1, d2;
    int32 i, j;
    
    assert (fcb);
    assert (feat_cepsize (fcb) == 13);
    assert (feat_cepsize_used (fcb) == 13);
    assert (feat_n_stream (fcb) == 4);
    assert (feat_stream_len (fcb, 0) == 12);
    assert (feat_stream_len (fcb, 1) == 24);
    assert (feat_stream_len (fcb, 2) == 3);
    assert (feat_stream_len (fcb, 3) == 12);
    assert (feat_window_size (fcb) == 4);
    
    /* CEP; skip C0 */
    memcpy (feat[0], mfc[0]+1, (feat_cepsize(fcb)-1) * sizeof(float32));
    
    /*
     * DCEP(SHORT): mfc[2] - mfc[-2]
     * DCEP(LONG):  mfc[4] - mfc[-4]
     */
    w  = mfc[2] + 1;	/* +1 to skip C0 */
    _w = mfc[-2] + 1;

    f = feat[1];
    for (i = 0; i < feat_cepsize(fcb)-1; i++)	/* Short-term */
	f[i] = w[i] - _w[i];

    w  = mfc[4] + 1;	/* +1 to skip C0 */
    _w = mfc[-4] + 1;

    for (j = 0; j < feat_cepsize(fcb)-1; i++, j++)	/* Long-term */
	f[i] = w[j] - _w[j];

    /* D2CEP: (mfc[3] - mfc[-1]) - (mfc[1] - mfc[-3]) */
    w1   = mfc[3] + 1;	/* Final +1 to skip C0 */
    _w1  = mfc[-1] + 1;
    w_1  = mfc[1] + 1;
    _w_1 = mfc[-3] + 1;

    f = feat[3];
    for (i = 0; i < feat_cepsize(fcb)-1; i++) {
	d1 =  w1[i] -  _w1[i];
	d2 = w_1[i] - _w_1[i];

	f[i] = d1 - d2;
    }
    
    /* POW: C0, DC0, D2C0; differences computed as above for rest of cep */
    f = feat[2];
    f[0] = mfc[0][0];
    f[1] = mfc[2][0] - mfc[-2][0];

    d1 = mfc[3][0] - mfc[-1][0];
    d2 = mfc[1][0] - mfc[-3][0];
    f[2] = d1 - d2;
}


static void feat_s3_1x39_cep2feat (feat_t *fcb, float32 **mfc, float32 **feat)
{
    float32 *f;
    float32 *w, *_w;
    float32 *w1, *w_1, *_w1, *_w_1;
    float32 d1, d2;
    int32 i;
    
    assert (fcb);
    assert (feat_cepsize (fcb) == 13);
    assert (feat_cepsize_used (fcb) == 13);
    assert (feat_n_stream (fcb) == 1);
    assert (feat_stream_len (fcb, 0) == 39);
    assert (feat_window_size (fcb) == 3);
    
    /* CEP; skip C0 */
    memcpy (feat[0], mfc[0]+1, (feat_cepsize(fcb)-1) * sizeof(float32));
    
    /*
     * DCEP: mfc[2] - mfc[-2];
     */
    f = feat[0] + feat_cepsize(fcb)-1;
    w  = mfc[2] + 1;	/* +1 to skip C0 */
    _w = mfc[-2] + 1;

    for (i = 0; i < feat_cepsize(fcb)-1; i++)
	f[i] = w[i] - _w[i];
    
    /* POW: C0, DC0, D2C0 */
    f += feat_cepsize(fcb)-1;

    f[0] = mfc[0][0];
    f[1] = mfc[2][0] - mfc[-2][0];

    d1 = mfc[3][0] - mfc[-1][0];
    d2 = mfc[1][0] - mfc[-3][0];
    f[2] = d1 - d2;

    /* D2CEP: (mfc[3] - mfc[-1]) - (mfc[1] - mfc[-3]) */
    f += 3;
    
    w1   = mfc[3] + 1;	/* Final +1 to skip C0 */
    _w1  = mfc[-1] + 1;
    w_1  = mfc[1] + 1;
    _w_1 = mfc[-3] + 1;

    for (i = 0; i < feat_cepsize(fcb)-1; i++) {
	d1 =  w1[i] -  _w1[i];
	d2 = w_1[i] - _w_1[i];

	f[i] = d1 - d2;
    }
}


static void feat_s3_cep (feat_t *fcb, float32 **mfc, float32 **feat)
{
    assert (fcb);
    assert (feat_cepsize (fcb) == 13);
    assert ((feat_cepsize_used (fcb) <= 13) && (feat_cepsize_used(fcb) > 0));
    assert (feat_n_stream (fcb) == 1);
    assert (feat_stream_len (fcb, 0) == feat_cepsize_used(fcb));
    assert (feat_window_size (fcb) == 0);
    
    /* CEP */
    memcpy (feat[0], mfc[0], feat_cepsize_used(fcb) * sizeof(float32));
}


static void feat_s3_cep_dcep (feat_t *fcb, float32 **mfc, float32 **feat)
{
    float32 *f;
    float32 *w, *_w;
    int32 i;
    
    assert (fcb);
    assert (feat_cepsize (fcb) == 13);
    assert ((feat_cepsize_used (fcb) <= 13) && (feat_cepsize_used(fcb) > 0));
    assert (feat_n_stream (fcb) == 1);
    assert (feat_stream_len (fcb, 0) == (feat_cepsize_used(fcb) * 2));
    assert (feat_window_size (fcb) == 2);
    
    /* CEP */
    memcpy (feat[0], mfc[0], feat_cepsize_used(fcb) * sizeof(float32));
    
    /*
     * DCEP: mfc[2] - mfc[-2];
     */
    f = feat[0] + feat_cepsize_used(fcb);
    w  = mfc[2];
    _w = mfc[-2];

    for (i = 0; i < feat_cepsize_used(fcb); i++)
	f[i] = w[i] - _w[i];
}

void feat_1s_c_d_dd_cep2feat (feat_t *fcb, float32 **mfc, float32 **feat)
{
    float32 *f;
    float32 *w, *_w;
    float32 *w1, *w_1, *_w1, *_w_1;
    float32 d1, d2;
    int32 i;
    
    assert (fcb);
    assert (feat_cepsize (fcb) == 13);
    assert (feat_cepsize_used (fcb) == 13);
    assert (feat_n_stream (fcb) == 1);
    assert (feat_stream_len (fcb, 0) == 39);
    assert (feat_window_size (fcb) == 3);

    /* CEP */
    memcpy (feat[0], mfc[0], feat_cepsize(fcb) * sizeof(float32));
    
    /*
     * DCEP: mfc[w] - mfc[-w], where w = FEAT_DCEP_WIN;
     */
    f = feat[0] + feat_cepsize(fcb);
    w  = mfc[ FEAT_DCEP_WIN];
    _w = mfc[-FEAT_DCEP_WIN];

    for (i = 0; i < feat_cepsize(fcb); i++)
	f[i] = w[i] - _w[i];
    
    /* 
     * D2CEP: (mfc[w+1] - mfc[-w+1]) - (mfc[w-1] - mfc[-w-1]), 
     * where w = FEAT_DCEP_WIN 
     */
    f += feat_cepsize(fcb);

    w1   = mfc[ FEAT_DCEP_WIN+1];
    _w1  = mfc[-FEAT_DCEP_WIN+1];
    w_1  = mfc[ FEAT_DCEP_WIN-1];
    _w_1 = mfc[-FEAT_DCEP_WIN-1];

    for (i = 0; i < feat_cepsize(fcb); i++) {
	d1 =  w1[i] -  _w1[i];
	d2 = w_1[i] - _w_1[i];

	f[i] = d1 - d2;
    }
}

feat_t *feat_init (char *type, char *cmn, char *varnorm, char *agc)
{
    feat_t *fcb;
    int32 i, l, k;
    char wd[16384], *strp;
    
    E_INFO("Initializing feature stream to type: '%s', CMN='%s', VARNORM='%s', AGC='%s'\n",
	   type, cmn, varnorm, agc);
    
    fcb = (feat_t *) ckd_calloc (1, sizeof(feat_t));
    
    fcb->name = (char *) ckd_salloc (type);
    if (strcmp (type, "s2_4x") == 0) {
	/* Sphinx-II format 4-stream feature (Hack!! hardwired constants below) */
	fcb->cepsize = 13;
	fcb->cepsize_used = 13;
	fcb->n_stream = 4;
	fcb->stream_len = (int32 *) ckd_calloc (4, sizeof(int32));
	fcb->stream_len[0] = 12;
	fcb->stream_len[1] = 24;
	fcb->stream_len[2] = 3;
	fcb->stream_len[3] = 12;
	fcb->window_size = 4;
	fcb->compute_feat = feat_s2_4x_cep2feat;
    } else if (strcmp (type, "s3_1x39") == 0) {
	/* 1-stream cep/dcep/pow/ddcep (Hack!! hardwired constants below) */
	fcb->cepsize = 13;
	fcb->cepsize_used = 13;
	fcb->n_stream = 1;
	fcb->stream_len = (int32 *) ckd_calloc (1, sizeof(int32));
	fcb->stream_len[0] = 39;
	fcb->window_size = 3;
	fcb->compute_feat = feat_s3_1x39_cep2feat;
    } else if (strcmp (type, "1s_c_d_dd") == 0) {
        fcb->cepsize = 13;
        fcb->cepsize_used = 13;
	fcb->n_stream = 1;
	fcb->stream_len = (int32 *) ckd_calloc (1, sizeof(int32));
	fcb->stream_len[0] = 39;
	fcb->window_size = 3; /* FEAT_DCEP_WIN + 1 */
	fcb->compute_feat = feat_1s_c_d_dd_cep2feat;
    } else if (strncmp (type, "cep_dcep", 8) == 0) {
	/* 1-stream cep/dcep (Hack!! hardwired constants below) */
	fcb->cepsize = 13;
	/* Check if using only a portion of cep dimensions */
	if (type[8] == ',') {
	    if ((sscanf (type+9, "%d%n", &(fcb->cepsize_used), &l) != 1) ||
		(type[l+9] != '\0') ||
		(feat_cepsize_used(fcb) <= 0) ||
		(feat_cepsize_used(fcb) > feat_cepsize(fcb)))
		E_FATAL("Bad feature type argument: '%s'\n", type);
	} else
	    fcb->cepsize_used = 13;
	fcb->n_stream = 1;
	fcb->stream_len = (int32 *) ckd_calloc (1, sizeof(int32));
	fcb->stream_len[0] = feat_cepsize_used(fcb) * 2;
	fcb->window_size = 2;
	fcb->compute_feat = feat_s3_cep_dcep;
    } else if (strncmp (type, "cep", 3) == 0) {
	/* 1-stream cep (Hack!! hardwired constants below) */
	fcb->cepsize = 13;
	/* Check if using only a portion of cep dimensions */
	if (type[3] == ',') {
	    if ((sscanf (type+4, "%d%n", &(fcb->cepsize_used), &l) != 1) ||
		(type[l+4] != '\0') ||
		(feat_cepsize_used(fcb) <= 0) ||
		(feat_cepsize_used(fcb) > feat_cepsize(fcb)))
		E_FATAL("Bad feature type argument: '%s'\n", type);
	} else
	    fcb->cepsize_used = 13;
	fcb->n_stream = 1;
	fcb->stream_len = (int32 *) ckd_calloc (1, sizeof(int32));
	fcb->stream_len[0] = feat_cepsize_used(fcb);
	fcb->window_size = 0;
	fcb->compute_feat = feat_s3_cep;
    } else {
	/*
	 * Generic definition: Format should be %d,%d,%d,...,%d (i.e., comma separated
	 * list of feature stream widths; #items = #streams).
	 */
	l = strlen(type);
	k = 0;
	for (i = 1; i < l-1; i++)
	    if (type[i] == ',') {
		type[i] = ' ';
		k++;
	    }
	k++;	/* Presumably there are (#commas+1) streams */
	fcb->n_stream = k;
	fcb->stream_len = (int32 *) ckd_calloc (k, sizeof(int32));

	/* Scan individual feature stream lengths */
	strp = type;
	i = 0;
	while (sscanf (strp, "%s%n", wd, &l) == 1) {
	    strp += l;
	    if ((i >= fcb->n_stream) || (sscanf (wd, "%d", &(fcb->stream_len[i])) != 1) ||
		(fcb->stream_len[i] <= 0))
		E_FATAL("Bad feature type argument\n");
	    i++;
	}
	if (i != fcb->n_stream)
	    E_FATAL("Bad feature type argument\n");
	
	/* Input is already the feature stream */
	fcb->cepsize = -1;
	fcb->cepsize_used = -1;
	fcb->window_size = 0;
	fcb->compute_feat = NULL;
    }
    
    if (strcmp (cmn, "current") == 0)
	fcb->cmn = 1;
    else if (strcmp (cmn, "none") == 0)
	fcb->cmn = 0;
    else
	E_FATAL("Unsupported CMN type '%s'\n", cmn);
    
    if (strcmp (varnorm, "yes") == 0)
	fcb->varnorm = 1;
    else if (strcmp (varnorm, "no") == 0)
	fcb->varnorm = 0;
    else
	E_FATAL("Unsupported VARNORM type '%s'\n", varnorm);
    
    if (strcmp (agc, "max") == 0)
	fcb->agc = 1;
    else if (strcmp (agc, "none") == 0)
	fcb->agc = 0;
    else
	E_FATAL("Unsupported AGC type '%s'\n", agc);
    
    return fcb;
}


void feat_print (feat_t *fcb, float32 ***feat, int32 nfr, FILE *fp)
{
    int32 i, j, k;
    
    for (i = 0; i < nfr; i++) {
	fprintf (fp, "%8d:", i);

	for (j = 0; j < feat_n_stream(fcb); j++) {
	    fprintf (fp, "\t%2d:", j);

	    for (k = 0; k < feat_stream_len(fcb, j); k++)
		fprintf (fp, " %8.4f", feat[i][j][k]);
	    fprintf (fp, "\n");
	}
    }
    
    fflush (fp);
}


int32 feat_s2mfc2feat (feat_t *fcb, char *file, char *dir, int32 sf, int32 ef, float32 ***feat,
		       int32 maxfr)
{
    char path[16384];
    int32 win, nfr;
    int32 i, k;
    float32 **mfc;
    
    if (fcb->cepsize <= 0) {
	E_ERROR("Bad cepsize: %d\n", fcb->cepsize);
	return -1;
    }
    
    /* Create mfc filename, combining file, dir and extension (.mfc) if necessary */
    k = strlen(file);
    if ((k > 4) && (strcmp (file+k-4, ".mfc") == 0)) {	/* Hack!! Hardwired .mfc extension */
	if (dir && (file[0] != '/'))
	    sprintf (path, "%s/%s", dir, file);
	else
	    strcpy (path, file);
    } else {
	if (dir && (file[0] != '/'))
	    sprintf (path, "%s/%s.mfc", dir, file);
	else
	    sprintf (path, "%s.mfc", file);
    }
    
    win = feat_window_size(fcb);
    
    /* Adjust boundaries to include padding for feature computation */
    if (ef < 0)
	ef = (int32)0x7fff0000 - win;	/* Hack!! Hardwired constant */
    sf -= win;
    ef += win;
    
    /* Read mfc file */
    mfc = (float32 **) ckd_calloc_2d (S3_MAX_FRAMES, fcb->cepsize, sizeof(float32));
    if (sf < 0)
	nfr = feat_s2mfc_read (path, 0, ef, mfc-sf, S3_MAX_FRAMES+sf-win);
    else
	nfr = feat_s2mfc_read (path, sf, ef, mfc, S3_MAX_FRAMES-win);
    if (nfr < 0) {
	ckd_free_2d((void **) mfc);
	return -1;
    }
    
    if (nfr < 2*win+1) {
	E_ERROR("%s: MFC file/segment too short to compute features: %d frames\n", file, nfr);
	ckd_free_2d((void **) mfc);
	return -1;
    }

    /* Add padding at the beginning by replicating input data, if necessary */
    if (sf < 0) {
	for (i = 0; i < -sf; i++)
	    memcpy (mfc[i], mfc[i-sf+1], fcb->cepsize * sizeof(float32));
	nfr -= sf;
    }
    
    /* Add padding at the end by replicating input data, if necessary */
    k = ef - sf + 1;
    if (nfr < k) {
	k -= nfr;	/* Extra frames padding needed at the end */
	if (k > win)
	    k = win;	/* Limit feature frames to extent of file, not to unbounded ef */
	
	for (i = 0; i < k; i++)
	    memcpy (mfc[nfr+i], mfc[nfr+i-1-k], fcb->cepsize * sizeof(float32));
	nfr += k;
    }
    /* At this point, nfr includes complete padded cepstrum frames */
    
    if (nfr - win*2 > maxfr) {
	E_ERROR("%s: Feature buffer size(%d frames) < required(%d)\n", maxfr, nfr - win*2);
	ckd_free_2d((void **) mfc);
	return -1;
    }
    
    if (fcb->cmn)
	cmn (mfc, fcb->varnorm, nfr, fcb->cepsize);
    if (fcb->agc)
	agc_max (mfc, nfr);
    
    /* Create feature vectors */
    for (i = win; i < nfr-win; i++)
	fcb->compute_feat (fcb, mfc+i, feat[i-win]);
    
    ckd_free_2d((void **) mfc);
    
    return (nfr - win*2);
}


/* Feature computation module for live mode decoder. Computes featuers
 * for incoming blocks of data. Maintains a cyclic buffer of size 256
 * for computing cross-block deltas etc. Needs explicit begin-utterance
 * and end-of-utterance flags to be set to indicate the beginning of
 * a new utterance or the end of an utterance in order to function
 * properly
 *
 * The cyclic buffer of size 256 was controlled by using an unsigned
 * char. Replaced it so that the pointers into the buffer have a cycle
 * of LIVEBUFBLOCKSIZE. This was done so that if one day we decide to
 * change this variable from 256 to something else, the cyclic buffer
 * will still work.  (ebg)
 *
 * Feature type is hardwired in this routine!!! Currently it's
 * hardwired to follow the more intuitive order of cepstra followed by
 * delta cepstra followed by delta delta cepstra, as opposed to the
 * traditional Sphinx-3 order of c1-12,d1-12,c0,d0,dd,dd1-12.
 */
int32	feat_s2mfc2feat_block(feat_t *fcb, float32 **uttcep, int32 nfr,
			      int32 beginutt, int32 endutt, float32 ***ofeat)
{
    static float32 **feat=NULL;
    static float32 **cepbuf=NULL;
    /*    static int32 nfr_allocated = 0; */ /* Variable never used. - EBG */
    /*    static unsigned char   bufpos, curpos;   */
    /*    static unsigned char  jp1, jp2, jp3, jf1, jf2, jf3;	   */
    static int32   bufpos; /*  RAH 4.15.01 upgraded unsigned char variables to int32*/
    static int32   curpos; /*  RAH 4.15.01 upgraded unsigned char variables to int32*/
    static int32  jp1, jp2, jp3, jf1, jf2, jf3; /* RAH 4.15.01 upgraded unsigned char variables to int32 */
    int32  win, cepsize; 
    int32  i, j, nfeatvec, residualvecs;

    float32 *w, *_w, *f;
    float32 *w1, *w_1, *_w1, *_w_1;
    float32 d1, d2;

    /* If this assert fails, you're risking overwriting elements
     * in the buffer. -EBG */
    assert(nfr < LIVEBUFBLOCKSIZE);
    win = feat_window_size(fcb);

    if (fcb->cepsize <= 0) 
	E_FATAL("Bad cepsize: %d\n", fcb->cepsize);
    cepsize = feat_cepsize(fcb);
    if (feat == NULL)
#if 1 
      {
	int32 tmp = feat_stream_len(fcb,0);
	tmp = (tmp%4)?(tmp+(4-tmp%4)):tmp;
	feat = (float32 **)ckd_calloc_2d(LIVEBUFBLOCKSIZE,
					  tmp,
					  sizeof(float32));
      }
#else
	feat = (float32 **)ckd_calloc_2d(LIVEBUFBLOCKSIZE,
					 feat_stream_len(fcb,0),
					 sizeof(float32));
#endif
    if (cepbuf == NULL){
	cepbuf = (float32 **)ckd_calloc_2d(LIVEBUFBLOCKSIZE,
					 cepsize,
					 sizeof(float32));
	beginutt = 1; /* If no buffer was present we are beginning an utt */
    if (! feat)
      E_FATAL("Unable to allocate feat ckd_calloc_2d(%ld,%d,%d)\n",LIVEBUFBLOCKSIZE,feat_stream_len(fcb,0),sizeof(float32));
    if (! cepbuf)
      E_FATAL("Unable to allocate cepbuf ckd_calloc_2d(%ld,%d,%d)\n",LIVEBUFBLOCKSIZE,cepsize,sizeof(float32));
	E_INFO("Feature buffers initialized to %d vectors\n",LIVEBUFBLOCKSIZE);
    }


    if (fcb->cmn) /* Only cmn_prior in block computation mode */
	cmn_prior (uttcep, fcb->varnorm, nfr, fcb->cepsize, endutt);

    residualvecs = 0;
    if (beginutt){
	/* Replicate first frame into the first win frames */
	for (i=0;i<win;i++) 
	   memcpy(cepbuf[i],uttcep[0],cepsize*sizeof(float32));
	/* beginutt = 0; */  /* Removed by Rita Singh around 02-Jan-2001 */
                             /* See History at the top of this file */
	bufpos = win;
	bufpos %= LIVEBUFBLOCKSIZE;
        curpos = bufpos;
        jp1 = curpos - 1;
	jp1 %= LIVEBUFBLOCKSIZE;
        jp2 = curpos - 2;
	jp2 %= LIVEBUFBLOCKSIZE;
        jp3 = curpos - 3;
	jp3 %= LIVEBUFBLOCKSIZE;
        jf1 = curpos + 1;
	jf1 %= LIVEBUFBLOCKSIZE;
        jf2 = curpos + 2;
	jf2 %= LIVEBUFBLOCKSIZE;
        jf3 = curpos + 3;
	jf3 %= LIVEBUFBLOCKSIZE;
	residualvecs -= win;
    }

    for (i=0;i<nfr;i++){
      assert(bufpos < LIVEBUFBLOCKSIZE);
      memcpy(cepbuf[bufpos++],uttcep[i],cepsize*sizeof(float32));
      bufpos %= LIVEBUFBLOCKSIZE;
    }

    if (endutt){
	/* Replicate last frame into the last win frames */
	if (nfr > 0) {
	  for (i=0;i<win;i++) {
	    assert(bufpos < LIVEBUFBLOCKSIZE);
	   memcpy(cepbuf[bufpos++],uttcep[nfr-1],cepsize*sizeof(float32));
	   bufpos %= LIVEBUFBLOCKSIZE;
	  }
        }
	else {
	    int16 tpos = bufpos-1;
	    tpos %= LIVEBUFBLOCKSIZE;
	    for (i=0;i<win;i++) {
	      assert(bufpos < LIVEBUFBLOCKSIZE);
	        memcpy(cepbuf[bufpos++],cepbuf[tpos],cepsize*sizeof(float32));
		bufpos %= LIVEBUFBLOCKSIZE;
	    }
	}
        residualvecs += win;
    }

    /* Create feature vectors */
    nfeatvec = 0;
    nfr += residualvecs;

    for (i = 0; i < nfr; i++,nfeatvec++){
        /* CEP */
        memcpy (feat[i], cepbuf[curpos], (cepsize) * sizeof(float32));
    
        /*
         * DCEP: mfc[2] - mfc[-2];
         */
        f = feat[i] + cepsize;
        w  = cepbuf[jf2];	/* +1 to skip C0 */
        _w = cepbuf[jp2];

        for (j = 0; j < cepsize; j++)
	    f[j] = w[j] - _w[j];
    
        /* D2CEP: (mfc[3] - mfc[-1]) - (mfc[1] - mfc[-3]) */
        f += cepsize;
    
        w1   = cepbuf[jf3];	/* Final +1 to skip C0 */
        _w1  = cepbuf[jp1];
        w_1  = cepbuf[jf1];
        _w_1 = cepbuf[jp3];

        for (j = 0; j < cepsize; j++) {
	    d1 =  w1[j] -  _w1[j];
	    d2 = w_1[j] - _w_1[j];

	    f[j] = d1 - d2;
        }
	jf1++; jf2++; jf3++;
	jp1++; jp2++; jp3++;
	curpos++;
	jf1 %= LIVEBUFBLOCKSIZE;
	jf2 %= LIVEBUFBLOCKSIZE;
	jf3 %= LIVEBUFBLOCKSIZE;
	jp1 %= LIVEBUFBLOCKSIZE;
	jp2 %= LIVEBUFBLOCKSIZE;
	jp3 %= LIVEBUFBLOCKSIZE;
	curpos %= LIVEBUFBLOCKSIZE;
    }
    *ofeat = feat;

    return(nfeatvec);
}

/*
 * RAH, remove memory allocated by feat_init
 * What is going on? feat_vector_alloc doesn't appear to be called
 */
void feat_free (feat_t *f)
{
  if (f) {
    /*   if (f->stream_len)
      //      ckd_free ((void *) f->stream_len);

      //    ckd_free ((void *) f); */
  }

}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * feat.h -- Cepstral features computation.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Adding feat_free() to free allocated memory
 * 
 * 04-Jan-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_FEAT_H_
#define _S3_FEAT_H_


#include "libutil.h"


#define LIVEBUFBLOCKSIZE        256    /* Blocks of 256 vectors allocated 
					  for livemode decoder */


/*
 * Structure for describing a speech feature type (no. of streams and stream widths),
 * as well as the computation for converting the input speech (e.g., Sphinx-II format
 * MFC cepstra) into this type of feature vectors.
 */
typedef struct feat_s {
    char *name;		/* Printable name for this feature type */
    int32 cepsize;	/* Size of input speech vector (typically, a cepstrum vector) */
    int32 cepsize_used;	/* No. of cepstrum vector dimensions actually used (0 onwards) */
    int32 n_stream;	/* #Feature streams; e.g., 4 in Sphinx-II */
    int32 *stream_len;	/* Vector length of each feature stream */
    int32 window_size;	/* #Extra frames around given input frame needed to compute
			   corresponding output feature (so total = window_size*2 + 1) */
    int32 cmn;		/* Whether CMN is to be performed on each utterance */
    int32 varnorm;	/* Whether variance normalization is to be performed on each utt;
			   Irrelevant if no CMN is performed */
    int32 agc;		/* Whether AGC-Max is to be performed on each utterance */
    void (*compute_feat)(struct feat_s *fcb, float32 **input, float32 **feat);
			/* Function for converting window of input speech vector
			   (input[-window_size..window_size]) to output feature vector
			   (feat[stream][]).  If NULL, no conversion available, the
			   speech input must be feature vector itself.
			   Return value: 0 if successful, -ve otherwise. */
} feat_t;

/* Access macros */
#define feat_name(f)		((f)->name)
#define feat_cepsize(f)		((f)->cepsize)
#define feat_cepsize_used(f)	((f)->cepsize_used)
#define feat_n_stream(f)	((f)->n_stream)
#define feat_stream_len(f,i)	((f)->stream_len[i])
#define feat_window_size(f)	((f)->window_size)


/*
 * Read feature vectors from the given file.  Feature file format:
 *   Line containing the single word: s3
 *   File header including any argument value pairs/line and other text (e.g.,
 * 	'chksum0 yes', 'version 1.0', as in other S3 format binary files)
 *   Header ended by line containing the single word: endhdr
 *   (int32) Byte-order magic number (0x11223344)
 *   (int32) No. of frames in file (N)
 *   (int32) No. of feature streams (S)
 *   (int32 x S) Width or dimensionality of each feature stream (sum = L)
 *   (float32) Feature vector data (NxL float32 items).
 *   (uint32) Checksum (if present).
 * (Note that this routine does NOT verify the checksum.)
 * Return value: # frames read if successful, -1 if error.
 */
int32 feat_readfile (feat_t *fcb,	/* In: Control block from feat_init() */
		     char *file,	/* In: File to read */
		     int32 sf,		/* In: Start/end frames (range) to be read from
					   file; use 0, 0x7ffffff0 to read entire file */
		     int32 ef,
		     float32 ***feat,	/* Out: Data structure to be filled with read
					   data; allocate using feat_array_alloc() */
		     int32 maxfr);	/* In: #Frames allocated for feat above; error if
					   attempt to read more than this amount. */

/*
 * Counterpart to feat_readfile.  Feature data is assumed to be in a contiguous block
 * starting from feat[0][0][0].  (NOTE: No checksum is written.)
 * Return value: # frames read if successful, -1 if error.
 */
int32 feat_writefile (feat_t *fcb,	/* In: Control block from feat_init() */
		     char *file,	/* In: File to write */
		     float32 ***feat,	/* In: Feature data to be written */
		     int32 nfr);	/* In: #Frames to be written */

/*
 * Read Sphinx-II format mfc file (s2mfc = Sphinx-II format MFC data).
 * Return value: #frames read if successful, -1 if error (e.g., mfc array too small).
 */
int32
feat_s2mfc_read (char *file,		/* In: Sphinx-II format MFC file to be read */
		 int32 sf, int32 ef,	/* In: Start/end frames (range) to be read from file;
					   Can use 0,-1 to read entire file */
		 float32 **mfc,		/* Out: 2-D array to be filled with read data;
					   caller must have allocated this array */
		 int32 maxfr);		/* In: #Frames of mfc array allocated; error if
					   attempt to read more than this amount. */

/*
 * Allocate an array to hold several frames worth of feature vectors.  The returned value
 * is the float32 ***data array, organized as follows:
 *   data[0][0] = frame 0 stream 0 vector, data[0][1] = frame 0 stream 1 vector, ...
 *   data[1][0] = frame 1 stream 0 vector, data[0][1] = frame 1 stream 1 vector, ...
 *   data[2][0] = frame 2 stream 0 vector, data[0][1] = frame 2 stream 1 vector, ...
 *   ...
 * NOTE: For I/O convenience, the entire data area is allocated as one contiguous block.
 * Return value: Pointer to the allocated space if successful, NULL if any error.
 */
float32 ***feat_array_alloc (feat_t *fcb,	/* In: Descriptor from feat_init(), used
						   to obtain #streams and stream sizes */
			     int32 nfr);	/* In: #Frames for which to allocate */

/*
 * Like feat_array_alloc except that only a single frame is allocated.  Hence, one
 * dimension less.
 */
float32 **feat_vector_alloc (feat_t *fcb);  /* In: Descriptor from feat_init(),
					       used to obtain #streams and 
					       stream sizes */

/*
 * Initialize feature module to use the selected type of feature stream.  
 * One-time only * initialization at the beginning of the program.  Input type 
 * is a string defining the  kind of input->feature conversion desired:
 *   "s2_4x":   s2mfc->Sphinx-II 4-feature stream,
 *   "s3_1x39": s2mfc->Sphinx-3 single feature stream,
 *   "n1,n2,n3,...": Explicit feature vector layout spec. with comma-separated 
 *   feature stream lengths.  In this case, the input data is already in the 
 *   feature format and there is no conversion necessary.
 * Return value: (feat_t *) descriptor if successful, NULL if error.  Caller 
 * must not directly modify the contents of the returned value.
 */
feat_t *feat_init (char *type,	/* In: Type of feature stream */
		   char *cmn,	/* In: Type of cepstram mean normalization to 
			           be done before feature computation; can be 
		                   NULL (for none) */
		   char *varnorm,  /* In: ("yes" or "no") Whether variance 
				   normalization done on each utt; only 
				   applicable if CMN also done */
		   char *agc);	/* In: Type of automatic gain control to be 
				   done before feature computation; can be 
				   NULL (for none) */

/*
 * Print the given block of feature vectors to the given FILE.
 */
void feat_print (feat_t *fcb,		/* In: Descriptor from feat_init() */
		 float32 ***feat,	/* In: Feature data to be printed */
		 int32 nfr,		/* In: #Frames of feature data above */
		 FILE *fp);		/* In: Output file pointer */

/*
 * Read a specified MFC file (or given segment within it), perform CMN/AGC as 
 * indicated by * fcb, and compute feature vectors.  Feature vectors are 
 * computed for the entire segment specified, by including additional 
 * surrounding or padding frames to accommodate the feature windows.
 * Return value: #Frames of feature vectors computed if successful; -1 if 
 * any error.
 */
int32 feat_s2mfc2feat (feat_t *fcb,	/* In: Descriptor from feat_init() */
		       char *file,	/* In: File to be read */
		       char *dir,	/* In: Directory prefix for file, 
					   if needed; can be NULL */
		       int32 sf, int32 ef,   /* Start/End frames within 
					   file to be read. Use 0,-1 to process 
					   entire file */
		       float32 ***feat,	/* Out: Computed feature vectors; 
					   caller must allocate this space */
		       int32 maxfr);	/* In: Available space (#frames) in 
					   above feat array; it must be 
					   sufficient to hold the result */


/* Feature computation routine for live mode decoder. Computes features
 * for blocks of incoming data. Retains an internal buffer for computing
 * deltas etc */

int32   feat_s2mfc2feat_block(feat_t  *fcb,    /* Descriptor from feat_init() */
			      float32 **uttcep, /* Incoming cepstral buffer */
			      int32   nfr,      /* Size of incoming buffer */
                              int32 beginutt,   /* Begining of utterance flag */
                              int32 endutt,     /* End of utterance flag */
                              float32 ***ofeat  /* Output feature buffer */
			     );


/* Feature computation routine for live mode decoder. Computes features
 * for blocks of incoming data. Retains an internal buffer for computing
 * deltas etc */

/*
 * RAH, remove memory allocated by feat_init
 */
void feat_free (feat_t *f);



#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * filename.c -- File and path name operations.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 30-Oct-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "filename.h"


/* Strip off all leading pathname components */
void path2basename (char *path, char *base)
{
    int32 i, l;
    
    l = strlen(path);
    for (i = l-1; (i >= 0) && (path[i] != '/'); --i);
    strcpy (base, path+i+1);
}


/* Strip off the shortest trailing .xyz suffix */
void strip_fileext (char *path, char *root)
{
    int32 i, l;
    
    l = strlen(path);
    for (i = l-1; (i >= 0) && (path[i] != '.'); --i);
    if (i < 0)
	strcpy (root, path);	/* Didn't find a . */
    else {
	path[i] = '\0';
	strcpy (root, path);
	path[i] = '.';
    }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * filename.h -- File and path name operations.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 30-Oct-1997	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#ifndef _LIBUTIL_FILENAME_H_
#define _LIBUTIL_FILENAME_H_


#include "prim_type.h"


/*
 * Strip off leading path components from the given path and copy the base into base.
 * Caller must have allocated base.
 */
void path2basename (char *path, char *base);


/*
 * Strip off the smallest trailing file-extension suffix and copy the rest into the
 * given root argument.  Caller must have allocated root.
 */
void strip_fileext (char *file, char *root);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * fillpen.c -- Filler penalties (penalties for words that do not show up in
 * the main LM.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 20-Apr-2001  Ricky Houghton (ricky.houghton@cs.cmu.edu or rhoughton@mediasite.com)
 *              Added fillpen_free to free memory allocated by fillpen_init
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Removed language weight application to wip. To maintain
 *		comparability between s3decode and current decoder. Does
 *		not affect decoding performance.
 *
 * 24-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Bugfix: Applied language weight to word insertion penalty.
 * 
 * 11-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#include "fillpen.h"
#include "logs3.h"


fillpen_t *fillpen_init (dict_t *dict, char *file, float64 silprob, float64 fillprob,
			 float64 lw, float64 wip)
{
    s3wid_t w, bw;
    float64 prob;
    FILE *fp;
    char line[1024], wd[1024];
    int32 k;
    fillpen_t *_fillpen;
    
    _fillpen = (fillpen_t *) ckd_calloc (1, sizeof(fillpen_t));
    
    _fillpen->dict = dict;
    _fillpen->lw = lw;
    _fillpen->wip = wip;
    if (dict->filler_end >= dict->filler_start)
	_fillpen->prob = (int32 *) ckd_calloc (dict->filler_end - dict->filler_start + 1,
					       sizeof(int32));
    else
	_fillpen->prob = NULL;
    
    /* Initialize all words with filler penalty (HACK!! backward compatibility) */
    prob = fillprob;
    for (w = dict->filler_start; w <= dict->filler_end; w++)
#if 0 /* Language weight need not apply to wip */
	_fillpen->prob[w - dict->filler_start] = (int32) ((logs3(prob) + logs3(wip)) * lw); 
#endif
	_fillpen->prob[w - dict->filler_start] = (int32) ((logs3(prob)*lw + logs3(wip))); 

    /* Overwrite silence penalty (HACK!! backward compatibility) */
    w = dict_wordid (dict, S3_SILENCE_WORD);
    if (NOT_S3WID(w) || (w < dict->filler_start) || (w > dict->filler_end))
	E_FATAL("%s not a filler word in the given dictionary\n", S3_SILENCE_WORD);
    prob = silprob;
#if 0 /* language weight need not apply to wip */
   _fillpen->prob[w - dict->filler_start] = (int32) ((logs3(prob) + logs3(wip)) * lw); 
#endif
   _fillpen->prob[w - dict->filler_start] = (int32)((logs3(prob)*lw + logs3(wip)));
    
    /* Overwrite with filler prob input file, if specified */
    if (! file)
	return _fillpen;
    
    E_INFO("Reading filler penalty file: %s\n", file);
    if ((fp = fopen (file, "r")) == NULL)
	E_FATAL("fopen(%s,r) failed\n", file);
    while (fgets (line, sizeof(line), fp) != NULL) {
	if (line[0] == '#')	/* Skip comment lines */
	    continue;
	
	k = sscanf (line, "%s %lf", wd, &prob);
	if ((k != 0) && (k != 2))
	    E_FATAL("Bad input line: %s\n", line);
	w = dict_wordid(dict, wd);
	if (NOT_S3WID(w) || (w < dict->filler_start) || (w > dict->filler_end))
	    E_FATAL("%s not a filler word in the given dictionary\n", S3_SILENCE_WORD);
	
#if 0 /* language weight need not apply to wip */
        _fillpen->prob[w - dict->filler_start] = (int32) ((logs3(prob) + logs3(wip)) * lw); 
#endif
        _fillpen->prob[w - dict->filler_start] = (int32) ((logs3(prob)*lw + logs3(wip)));
    }
    fclose (fp);
    
    /* Replicate fillpen values for alternative pronunciations */
    for (w = dict->filler_start; w <= dict->filler_end; w++) {
	bw = dict_basewid (dict, w);
	if (bw != w)
	    _fillpen->prob[w-dict->filler_start] = _fillpen->prob[bw-dict->filler_start];
    }
    
    return _fillpen;
}


int32 fillpen (fillpen_t *f, s3wid_t w)
{
    assert ((w >= f->dict->filler_start) && (w <= f->dict->filler_end));
    return (f->prob[w - f->dict->filler_start]);
}


/* RAH, free memory allocated above */
void fillpen_free (fillpen_t *f)
{
  if (f) {
    if (f->prob) 
      ckd_free ((void *) f->prob);
    ckd_free ((void *) f);
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * fillpen.c -- Filler penalties (penalties for words that do not show up in
 * the main LM.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 11-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#ifndef _S3_FILLPEN_H_
#define _S3_FILLPEN_H_


#include "libutil.h"
#include "dict.h"


typedef struct {
    dict_t *dict;	/* Reference dictionary for which the filler word probabilities
			   are maintained in this structure */
    int32 *prob;	/* Filler word probability (in logs3 space, after
			   langwt and inspen application) */
    float64 lw;		/* Language weight */
    float64 wip;	/* Word insertion penalty */
} fillpen_t;


/*
 * Initialize filler probabilities (penalties, whatever) module and return a pointer to the
 * structure created.  Filler word probabilities are simple unigram probabilities.  Here is an
 * example of such a file (one entry per line; a word and a probability):
 *   <sil>  0.10792
 *   <uh>   0.00866
 *   <um>   0.00147
 * If the first character in a line is a '#', the line is treated as a comment and ignored.
 * If no filler probabilities file is provided, the silence word gets silprob, and all other
 * filler words get fillprob.  As with the trigram LM, the resulting log-probabilities are
 * multiplied by a language weight and finally a word insertion penalty is tacked on.
 */
fillpen_t *fillpen_init (dict_t *dict,		/* In: Dictionary containing filler words */
			 char *file,		/* In: Filler word probabilities file, if any */
			 float64 silprob,	/* In: Default probability for silence word */
			 float64 fillprob,	/* In: Default probability for non-silence filler
						   words */
			 float64 lw,		/* In: Language weight (see lm.h) */
			 float64 wip);		/* In: Word insertion penalty (see lm.h) */

/*
 * Return the filler word probability for the given dictionary word-ID.
 */
int32 fillpen (fillpen_t *f,		/* In: Filler word probabilities structure */
	       s3wid_t w);		/* In: Dictionary word-ID of filler word */

/* RAH 
   free memory allocated by fillpen_init
 */
void fillpen_free (fillpen_t *f);

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * glist.h -- Module for maintaining a generic, linear linked-list structure.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added glist_chkdup_*().
 * 
 * 13-Feb-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created from earlier version.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "glist.h"
#include "ckd_alloc.h"


glist_t glist_add_ptr (glist_t g, void *ptr)
{
    gnode_t *gn;
    
    gn = (gnode_t *) mymalloc (sizeof(gnode_t));
    gn->data.ptr = ptr;
    gn->next = g;
    return ((glist_t) gn);	/* Return the new head of the list */
}


glist_t glist_add_int32 (glist_t g, int32 val)
{
    gnode_t *gn;
    
    gn = (gnode_t *) mymalloc (sizeof(gnode_t));
    gn->data.int32 = val;
    gn->next = g;
    return ((glist_t) gn);	/* Return the new head of the list */
}


glist_t glist_add_uint32 (glist_t g, uint32 val)
{
    gnode_t *gn;
    
    gn = (gnode_t *) mymalloc (sizeof(gnode_t));
    gn->data.uint32 = val;
    gn->next = g;
    return ((glist_t) gn);	/* Return the new head of the list */
}


glist_t glist_add_float32 (glist_t g, float32 val)
{
    gnode_t *gn;
    
    gn = (gnode_t *) mymalloc (sizeof(gnode_t));
    gn->data.float32 = val;
    gn->next = g;
    return ((glist_t) gn);	/* Return the new head of the list */
}


glist_t glist_add_float64 (glist_t g, float64 val)
{
    gnode_t *gn;
    
    gn = (gnode_t *) mymalloc (sizeof(gnode_t));
    gn->data.float64 = val;
    gn->next = g;
    return ((glist_t) gn);	/* Return the new head of the list */
}


int32 glist_chkdup_ptr (glist_t g, void *val)
{
    gnode_t *gn;

    for (gn = g; gn; gn = gnode_next(gn))
	if (gnode_ptr(gn) == val)
	    return 1;
    
    return 0;
}


int32 glist_chkdup_int32 (glist_t g, int32 val)
{
    gnode_t *gn;

    for (gn = g; gn; gn = gnode_next(gn))
	if (gnode_int32(gn) == val)
	    return 1;
    
    return 0;
}


int32 glist_chkdup_uint32 (glist_t g, uint32 val)
{
    gnode_t *gn;

    for (gn = g; gn; gn = gnode_next(gn))
	if (gnode_uint32(gn) == val)
	    return 1;
    
    return 0;
}


int32 glist_chkdup_float32 (glist_t g, float32 val)
{
    gnode_t *gn;

    for (gn = g; gn; gn = gnode_next(gn))
	if (gnode_float32(gn) == val)
	    return 1;
    
    return 0;
}


int32 glist_chkdup_float64 (glist_t g, float64 val)
{
    gnode_t *gn;

    for (gn = g; gn; gn = gnode_next(gn))
	if (gnode_float64(gn) == val)
	    return 1;
    
    return 0;
}


void glist_apply_ptr (glist_t g, void (*func)(void *))
{
    gnode_t *gn;
    
    for (gn = g; gn; gn = gn->next)
	(*func)(gn->data.ptr);
}


void glist_apply_int32 (glist_t g, void (*func)(int32))
{
    gnode_t *gn;
    
    for (gn = g; gn; gn = gn->next)
	(*func)(gn->data.int32);
}


void glist_apply_uint32 (glist_t g, void (*func)(uint32))
{
    gnode_t *gn;
    
    for (gn = g; gn; gn = gn->next)
	(*func)(gn->data.uint32);
}


void glist_apply_float32 (glist_t g, void (*func)(float32))
{
    gnode_t *gn;
    
    for (gn = g; gn; gn = gn->next)
	(*func)(gn->data.float32);
}


void glist_apply_float64 (glist_t g, void (*func)(float64))
{
    gnode_t *gn;
    
    for (gn = g; gn; gn = gn->next)
	(*func)(gn->data.float64);
}


void glist_free (glist_t g)
{
    gnode_t *gn;
    
    while (g) {
	gn = g;
	g = gn->next;
	myfree((char *)gn, sizeof(gnode_t));
    }
}


void glist_myfree (glist_t g, int32 datasize)
{
    gnode_t *gn;
    
    while (g) {
	gn = g;
	g = gn->next;
	myfree((char *)(gn->data.ptr), datasize);
	myfree((char *)gn, sizeof(gnode_t));
    }
}


int32 glist_count (glist_t g)
{
    gnode_t *gn;
    int32 n;
    
    for (gn = g, n = 0; gn; gn = gn->next, n++);
    return n;
}


gnode_t *glist_tail (glist_t g)
{
    gnode_t *gn;
    
    if (! g)
	return NULL;
    
    for (gn = g; gn->next; gn = gn->next);
    return gn;
}


glist_t glist_reverse (glist_t g)
{
    gnode_t *gn, *nextgn;
    gnode_t *rev;
    
    rev = NULL;
    for (gn = g; gn; gn = nextgn) {
	nextgn = gn->next;
	
	gn->next = rev;
	rev = gn;
    }

    return rev;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * glist.h -- Module for maintaining a generic, linear linked-list structure.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 09-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added glist_chkdup_*().
 * 
 * 13-Feb-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created from earlier version.
 */


/*
 * Generic linked-lists maintenance.
 * Only insert at the head of the list.
 * No selective deletions, except to destroy the entire list.
 * A convenient little linked-list package, but a double-edged sword: the user must
 * keep track of the data type within the linked list elements.
 * 
 * (C++ would be good for this, but that's a double-edged sword as well.)
 */


#ifndef _LIBUTIL_GLIST_H_
#define _LIBUTIL_GLIST_H_


#include <stdlib.h>
#include "prim_type.h"


/* A node in a generic list */
typedef struct gnode_s {
    anytype_t data;		/* See prim_type.h */
    struct gnode_s *next;	/* Next node in list */
} gnode_t;
typedef gnode_t *glist_t;	/* Head of a list of gnodes */


/* Access macros, for convenience */
#define gnode_ptr(g)		((g)->data.ptr)
#define gnode_int32(g)		((g)->data.int32)
#define gnode_uint32(g)		((g)->data.uint32)
#define gnode_float32(g)	((g)->data.float32)
#define gnode_float64(g)	((g)->data.float64)
#define gnode_next(g)		((g)->next)


/*
 * Create and insert a new list node, with the given user-defined data, at the HEAD
 * of the given generic list.  Return the new list thus formed.
 * g may be NULL to indicate an initially empty list.
 * (Too bad there's no function overloading.)
 */
glist_t glist_add_ptr (glist_t g, void *ptr);
glist_t glist_add_int32 (glist_t g, int32 val);
glist_t glist_add_uint32 (glist_t g, uint32 val);
glist_t glist_add_float32 (glist_t g, float32 val);
glist_t glist_add_float64 (glist_t g, float64 val);


/*
 * Check the given glist to see if it already contains the given value (of appropriate type).
 * In the case of the ptr, only the pointer values are compared, not the data pointed to by them.
 * Return value: 1 if match found, 0 if not.
 */
int32 glist_chkdup_ptr (glist_t g, void *val);	/* List and value to check for */
int32 glist_chkdup_int32 (glist_t g, int32 val);
int32 glist_chkdup_uint32 (glist_t g, uint32 val);
int32 glist_chkdup_float32 (glist_t g, float32 val);
int32 glist_chkdup_float64 (glist_t g, float64 val);


/*
 * Reverse the order of the given glist.  (glist_add() adds to the head; one might
 * ultimately want the reverse of that.)
 * Return value: The head of the new list.
 * NOTE: The list is reversed "in place"; i.e., no new memory is allocated.
 */
glist_t glist_reverse (glist_t g);


/* Return the number of elements in the given glist_t */
int32 glist_count (glist_t g);


/*
 * Apply the given function to the user-defined data.ptr for each node in the list.
 * (Again, too bad there's no function overloading in C.)
 */
void glist_apply_ptr (glist_t g, void (*func)(void *));
void glist_apply_int32 (glist_t g, void (*func)(int32));
void glist_apply_uint32 (glist_t g, void (*func)(uint32));
void glist_apply_float32 (glist_t g, void (*func)(float32));
void glist_apply_float64 (glist_t g, void (*func)(float64));


/*
 * Free the given generic list; user-defined data contained within is not
 * automatically freed.  The caller must have done that already.
 */
void glist_free (glist_t g);


/*
 * Free the user-defined data (i.e., g->data.ptr) contained at each node of the given
 * glist (using myfree()).  Then free the glist.  "datasize" is the size of the
 * user-defined data at each node, and is needed by myfree().
 */
void glist_myfree (glist_t g, int32 datasize);


/*
 * Return the last node in the given list.
 */
gnode_t *glist_tail (glist_t g);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * hash.c -- Hash table module.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 05-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Removed hash_key2hash().  Added hash_enter_bkey() and hash_lookup_bkey(),
 * 		and len attribute to hash_entry_t.
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added hash_key2hash().
 * 
 * 18-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Included case sensitive/insensitive option.  Removed local, static
 * 		maintenance of all hash tables.
 * 
 * 31-Jul-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "hash.h"
#include "err.h"
#include "ckd_alloc.h"
#include "case.h"


#if 0
static void prime_sieve (int32 max)
{
    char *notprime;
    int32 p, pp;
    
    notprime = (char *) ckd_calloc (max+1, 1);
    p = 2;
    for (;;) {
	printf ("%d\n", p);
	for (pp = p+p; pp <= max; pp += p)
	    notprime[pp] = 1;
	for (++p; (p <= max) && notprime[p]; p++);
	if (p > max)
	    break;
    }
}
#endif


/*
 * HACK!!  Initial hash table size is restricted by this set of primes.  (Of course,
 * collision resolution by chaining will accommodate more entries indefinitely, but
 * efficiency will drop.)
 */
static int32 prime[] = {
    101, 211, 307, 401, 503, 601, 701, 809, 907,
    1009, 1201, 1601, 2003, 2411, 3001, 4001, 5003, 6007, 7001, 8009, 9001,
    10007, 12007, 16001, 20011, 24001, 30011, 40009, 50021, 60013, 70001, 80021, 90001,
    100003, 120011, 160001, 200003, 240007, 300007, 400009, 500009, 600011, 700001, 800011, 900001,
    -1
};


static int32 prime_size (int32 size)
{
    int32 i;
    
    for (i = 0; (prime[i] > 0) && (prime[i] < size); i++);
    if (prime[i] <= 0) {
	E_WARN("Very large hash table requested (%d entries)\n", size);
	--i;
    }
    return (prime[i]);
}


hash_table_t *hash_new (int32 size, int32 casearg)
{
    hash_table_t *h;
    
    h = (hash_table_t *) ckd_calloc (1, sizeof(hash_table_t));
    h->size = prime_size (size+(size>>1));
    h->nocase = (casearg == HASH_CASE_NO);
    h->table = (hash_entry_t *) ckd_calloc (h->size, sizeof(hash_entry_t));
    /* The above calloc clears h->table[*].key and .next to NULL, i.e. an empty table */

    return h;
}


/*
 * Compute hash value for given key string.
 * Somewhat tuned for English text word strings.
 */
static uint32 key2hash (hash_table_t *h, const char *key)
{
    register const char *cp;
    register char c;
    register int32 s;
    register uint32 hash;
    
    hash = 0;
    s = 0;
    
    if (h->nocase) {
	for (cp = key; *cp; cp++) {
	    c = *cp;
	    c = UPPER_CASE(c);
	    hash += c << s;
	    s += 5;
	    if (s >= 25)
		s -= 24;
	}
    } else {
	for (cp = key; *cp; cp++) {
	    hash += (*cp) << s;
	    s += 5;
	    if (s >= 25)
		s -= 24;
	}
    }
    
    return (hash % h->size);
}


static char *makekey (uint8 *data, int32 len, char *key)
{
    int32 i, j;
    
    if (! key)
	key = (char *) ckd_calloc (len*2 + 1, sizeof(char));
    
    for (i = 0, j = 0; i < len; i++, j += 2) {
	key[j] = 'A' + (data[i] & 0x000f);
	key[j+1] = 'J' + ((data[i] >> 4) & 0x000f);
    }
    key[j] = '\0';
    
    return key;
}


static int32 keycmp_nocase (hash_entry_t *entry, const char *key)
{
    char c1, c2;
    int32 i;
    const char *str;
    
    str = entry->key;
    for (i = 0; i < entry->len; i++) {
	c1 = *(str++);
	c1 = UPPER_CASE(c1);
	c2 = *(key++);
	c2 = UPPER_CASE(c2);
	if (c1 != c2)
	    return (c1-c2);
    }
    
    return 0;
}


static int32 keycmp_case (hash_entry_t *entry, const char *key)
{
    char c1, c2;
    int32 i;
    const char *str;
    
    str = entry->key;
    for (i = 0; i < entry->len; i++) {
	c1 = *(str++);
	c2 = *(key++);
	if (c1 != c2)
	    return (c1-c2);
    }
    
    return 0;
}


/*
 * Lookup chained entries with hash-value hash in table h for given key and return
 * associated value in *val.
 * Return value: 0 if key found in hash table, else -1.
 */
static int32 lookup (hash_table_t *h, uint32 hash, const char *key, int32 len, int32 *val)
{
    hash_entry_t *entry;
    
    entry = &(h->table[hash]);
    if (entry->key == NULL)
	return -1;
    
    if (h->nocase) {
	while (entry && ((entry->len != len) || (keycmp_nocase (entry, key) != 0)))
	    entry = entry->next;
    } else {
	while (entry && ((entry->len != len) || (keycmp_case (entry, key) != 0)))
	    entry = entry->next;
    }
    
    if (entry) {
	*val = entry->val;
	return 0;
    } else
	return -1;
}


int32 hash_lookup (hash_table_t *h, const char *key, int32 *val)
{
    uint32 hash;
    int32 len;
    
    hash = key2hash (h, key);
    len = strlen(key);
    
    return (lookup (h, hash, key, len, val));
}


int32 hash_lookup_bkey (hash_table_t *h, const char *key, int32 len, int32 *val)
{
    uint32 hash;
    char *str;
    
    str = makekey ((uint8 *)key, len, NULL);
    hash = key2hash (h, str);
    ckd_free (str);
    
    return (lookup (h, hash, key, len, val));
}


static int32 enter (hash_table_t *h, uint32 hash, const char *key, int32 len, int32 val)
{
    int32 old;
    hash_entry_t *cur, *new;
    
    if (lookup (h, hash, key, len, &old) == 0) {
	/* Key already exists */
	return old;
    }
    
    cur = &(h->table[hash]);
    if (cur->key == NULL) {
	/* Empty slot at hashed location; add this entry */
	cur->key = key;
	cur->len = len;
	cur->val = val;
    } else {
	/* Key collision; create new entry and link to hashed location */
	new = (hash_entry_t *) ckd_calloc (1, sizeof(hash_entry_t));
	new->key = key;
	new->len = len;
	new->val = val;
	new->next = cur->next;
	cur->next = new;
    }

    return val;
}


int32 hash_enter (hash_table_t *h, const char *key, int32 val)
{
    uint32 hash;
    int32 len;
    
    hash = key2hash (h, key);
    len = strlen(key);
    return (enter (h, hash, key, len, val));
}


int32 hash_enter_bkey (hash_table_t *h, const char *key, int32 len, int32 val)
{
    uint32 hash;
    char *str;
    
    str = makekey ((uint8 *)key, len, NULL);
    hash = key2hash (h, str);
    ckd_free (str);
    
    return (enter (h, hash, key, len, val));
}


glist_t hash_tolist (hash_table_t *h, int32 *count)
{
    glist_t g;
    hash_entry_t *e;
    int32 i, j;
    
    g = NULL;
    
    j = 0;
    for (i = 0; i < h->size; i++) {
	e = &(h->table[i]);
	
	if (e->key != NULL) {
	    g = glist_add_ptr (g, (void *)e);
	    j++;
	    
	    for (e = e->next; e; e = e->next) {
		g = glist_add_ptr (g, (void *)e);
		j++;
	    }
	}
    }
    
    *count = j;
    
    return g;
}


void hash_free (hash_table_t *h)
{
    hash_entry_t *e, *e2;
    int32 i;
    
    /* Free additional entries created for key collision cases */
    for (i = 0; i < h->size; i++) {
	for (e = h->table[i].next; e; e = e2) {
	    e2 = e->next;
	    ckd_free ((void *) e);
	}
    }
    
    ckd_free ((void *) h->table);
    ckd_free ((void *) h);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * hash.h -- Hash table module.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 05-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Removed hash_key2hash().  Added hash_enter_bkey() and hash_lookup_bkey(),
 * 		and len attribute to hash_entry_t.
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added hash_key2hash().
 * 
 * 18-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Included case sensitive/insensitive option.
 * 
 * 08-31-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


/*
 * Hash tables are intended for associating an integer "value" with a char string "key",
 * (e.g., an ID with a word string).  Subsequently, one can retrieve the integer value
 * by providing the string key.  (The reverse functionality--obtaining the string given
 * the value--is not provided with the hash table module.)
 */


#ifndef _LIBUTIL_HASH_H_
#define _LIBUTIL_HASH_H_


#include "prim_type.h"
#include "glist.h"


/*
 * The hash table structures.
 * Each hash table is identified by a hash_table_t structure.  hash_table_t.table is
 * pre-allocated for a user-controlled max size, and is initially empty.  As new
 * entries are created (using hash_enter()), the empty entries get filled.  If multiple
 * keys hash to the same entry, new entries are allocated and linked together in a
 * linear list.
 */

typedef struct hash_entry_s {
    const char *key;		/* Key string, NULL if this is an empty slot.
				   NOTE that the key must not be changed once the entry
				   has been made. */
    int32 len;			/* Key-length; the key string does not have to be a C-style NULL
				   terminated string; it can have arbitrary binary bytes */
    int32 val;			/* Value associated with above key */
    struct hash_entry_s *next;	/* For collision resolution */
} hash_entry_t;

typedef struct {
    hash_entry_t *table;	/* Primary hash table, excluding entries that collide */
    int32 size;			/* Primary hash table size, (is a prime#); NOTE: This is the
				   number of primary entries ALLOCATED, NOT the number of valid
				   entries in the table */
    uint8 nocase;		/* Whether case insensitive for key comparisons */
} hash_table_t;


/* Access macros */
#define hash_entry_val(e)	((e)->val)
#define hash_entry_key(e)	((e)->key)
#define hash_entry_len(e)	((e)->len)
#define hash_table_size(h)	((h)->size)


/*
 * Allocate a new hash table for a given expected size.
 * Return value: READ-ONLY handle to allocated hash table.
 */
hash_table_t *
hash_new (int32 size,		/* In: Expected #entries in the table */
	  int32 casearg);	/* In: Whether case insensitive for key comparisons.
				   Use values provided below */
#define HASH_CASE_YES		0
#define HASH_CASE_NO		1


/*
 * Free the specified hash table; the caller is responsible for freeing the key strings
 * pointed to by the table entries.
 */
void hash_free (hash_table_t *h);


/*
 * Try to add a new entry with given key and associated value to hash table h.  If key doesn't
 * already exist in hash table, the addition is successful, and the return value is val.  But
 * if key already exists, return its existing associated value.  (The hash table is unchanged;
 * it is upto the caller to resolve the conflict.)
 */
int32
hash_enter (hash_table_t *h,	/* In: Handle of hash table in which to create entry */
	    const char *key,	/* In: C-style NULL-terminated key string for the new entry */
	    int32 val);		/* In: Value to be associated with above key */

/*
 * Like hash_enter, but with an explicitly specified key length, instead of a NULL-terminated,
 * C-style key string.  So the key string is a binary key (or bkey).  Hash tables containing
 * such keys should be created with the HASH_CASE_YES option.  Otherwise, the results are
 * unpredictable.
 */
int32
hash_enter_bkey (hash_table_t *h,	/* In: Handle of hash table in which to create entry */
		 const char *key,	/* In: Key buffer */
		 int32 len,		/* In: Length of above key buffer */
		 int32 val);		/* In: Value to be associated with above key */

/*
 * Lookup hash table h for given key and return the associated value in *val.
 * Return value: 0 if key found in hash table, else -1.
 */
int32
hash_lookup (hash_table_t *h,	/* In: Handle of hash table being searched */
	     const char *key,	/* In: C-style NULL-terminated string whose value is sought */
	     int32 *val);	/* Out: *val = value associated with key */

/*
 * Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated,
 * C-style key string.  So the key string is a binary key (or bkey).  Hash tables containing
 * such keys should be created with the HASH_CASE_YES option.  Otherwise, the results are
 * unpredictable.
 */
int32
hash_lookup_bkey (hash_table_t *h,	/* In: Handle of hash table being searched */
		  const char *key,	/* In: Key buffer */
		  int32 len,		/* In: Length of above key buffer */
		  int32 *val);		/* Out: *val = value associated with key */

/*
 * Build a glist of valid hash_entry_t pointers from the given hash table.  Return the list.
 */
glist_t hash_tolist (hash_table_t *h,	/* In: Hash table from which list is to be generated */
		     int32 *count);	/* Out: #entries in the list */


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * heap.c -- Generic heap structure for inserting in any and popping in sorted
 * 		order.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 05-Mar-99	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Fixed bug in heap_destroy() (in while loop exit condition).
 * 
 * 23-Dec-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "heap.h"
#include "ckd_alloc.h"


typedef struct heap_s {
    void *data;		/* Application data at this node */
    int32 val;		/* Associated with above application data; according to which
			   heap is sorted (in ascending order) */
    int32 nl, nr;	/* #left/right descendants of this node (for balancing heap) */
    struct heap_s *l;	/* Root of left descendant heap */
    struct heap_s *r;	/* Root of right descendant heap */
} heapnode_t;


#if 0
static void heap_dump (heapnode_t *top, int32 level)
{
    int32 i;
    
    if (! top)
	return;
    
    for (i = 0; i < level; i++)
	printf ("  ");
    /* print top info */
    heap_dump (top->l, level+1);
    heap_dump (top->r, level+1);
}
#endif


heap_t heap_new ( void )
{
    heapnode_t **h;
    
    h = (heapnode_t **) ckd_calloc (1, sizeof(heapnode_t *));
    *h = NULL;

    return ((heap_t) h);
}


static heapnode_t *subheap_insert (heapnode_t *root, void *data, int32 val)
{
    heapnode_t *h;
    void *tmpdata;
    int32 tmpval;
    
    if (! root) {
	h = (heapnode_t *) mymalloc (sizeof(heapnode_t));
	h->data = data;
	h->val = val;
	h->l = h->r = NULL;
	h->nl = h->nr = 0;
	return h;
    }

    /* Root already exists; if new value is less, replace root node */
    if (root->val > val) {
	tmpdata = root->data;
	tmpval = root->val;
	root->data = data;
	root->val = val;
	data = tmpdata;
	val = tmpval;
    }

    /* Insert new or old (replaced) node in right or left subtree; keep them balanced */
    if (root->nl > root->nr) {
	root->r = subheap_insert (root->r, data, val);
	root->nr++;
    } else {
	root->l = subheap_insert (root->l, data, val);
	root->nl++;
    }

    return root;
}


int32 heap_insert (heap_t heap, void *data, int32 val)
{
    heapnode_t **hp;

    hp = (heapnode_t **) heap;
    
    *hp = subheap_insert (*hp, data, val);

    return 0;
}


static heapnode_t *subheap_pop (heapnode_t *root)
{
    heapnode_t *l, *r;

    /* Propagate best value from below into root, if any */
    l = root->l;
    r = root->r;

    if (! l) {
	if (! r) {
	    myfree ((char *) root, sizeof(heapnode_t));
	    return NULL;
	} else {
	    root->data = r->data;
	    root->val = r->val;
	    root->r = subheap_pop (r);
	    root->nr--;
	}
    } else {
	if ((! r) || (l->val < r->val)) {
	    root->data = l->data;
	    root->val = l->val;
	    root->l = subheap_pop (l);
	    root->nl--;
	} else {
	    root->data = r->data;
	    root->val = r->val;
	    root->r = subheap_pop (r);
	    root->nr--;
	}
    }

    return root;
}


int32 heap_pop (heap_t heap, void **data, int32 *val)
{
    heapnode_t **hp, *h;

    hp = (heapnode_t **) heap;
    h = *hp;

    if (! h)
	return 0;
    
    *data = h->data;
    *val = h->val;
    
    *hp = subheap_pop (h);
    
    return 1;
}


int32 heap_top (heap_t heap, void **data, int32 *val)
{
    heapnode_t **hp, *h;

    hp = (heapnode_t **) heap;
    h = *hp;

    if (! h)
	return 0;
    
    *data = h->data;
    *val = h->val;
    
    return 1;
}


int32 heap_destroy (heap_t heap)
{
    void *data;
    int32 val;
    
    /* Empty the heap and free it */
    while (heap_pop (heap, &data, &val) > 0);
    ckd_free ((char *)heap);

    return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * heap.c -- Generic heap structure for inserting in any and popping in sorted
 * 		order.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 23-Dec-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _LIBUTIL_HEAP_H_
#define _LIBUTIL_HEAP_H_


#include "prim_type.h"


typedef void *heap_t;


/*
 * General comments:  Sorted heap structure with three main operations:
 *   1. Insert a data item (with two attributes: an application supplied pointer and an
 *      integer value; the heap is maintained in ascending order of the integer value).
 *   2. Return the currently topmost item (i.e., item with smallest associated value).
 *   3. Return the currently topmost item and pop it off the heap.
 */


/*
 * Allocate a new heap and return handle to it.
 */
heap_t heap_new ( void );


/*
 * Insert a new item into the given heap.
 * Return value: 0 if successful, -1 otherwise.
 */
int32 heap_insert (heap_t heap,	/* In: Heap into which item is to be inserted */
		   void *data,	/* In: Application-determined data pointer */
		   int32 val);	/* In: According to item entered in sorted heap */

/*
 * Return the topmost item in the heap.
 * Return value: 1 if heap is not empty and the topmost value is returned;
 * 0 if heap is empty; -1 if some error occurred.
 */
int32 heap_top (heap_t heap,	/* In: Heap whose topmost item is to be returned */
		void **data,	/* Out: Data pointer associated with the topmost item */
		int32 *val);	/* Out: Value associated with the topmost item */

/*
 * Like heap_top but also pop the top item off the heap.
 */
int32 heap_pop (heap_t heap, void **data, int32 *val);


/*
 * Destroy the given heap; free the heap nodes.  NOTE: Data pointers in the nodes are NOT freed.
 * Return value: 0 if successful, -1 otherwise.
 */
int32 heap_destroy (heap_t heap);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * hmm.c -- HMM Viterbi search.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * HISTORY
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Modified hmm_vit_eval_3st() to include explicit checks for
 *		tr[0][2] and tr[1][3]. Included compiler directive activated
 *		checks for int32 underflow
 *
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified hmm_t.state to be a run-time array instead of a compile-time
 * 		one.  Modified compile-time 3 and 5-state versions of hmm_vit_eval
 * 		into hmm_vit_eval_3st and hmm_vit_eval_5st, to allow run-time selection.
 * 		Removed hmm_init().
 * 
 * 11-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Bugfix in computing HMM exit state score.
 * 
 * 08-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added HMM_SKIPARCS compile-time option and hmm_init().
 * 
 * 20-Sep-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Bugfix in hmm_eval: If state1->state2 transition took place,
 * 		state1 history didn't get propagated to state2.
 * 		Also, included tp[][] in HMM evaluation.
 * 
 * 10-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started, based on an earlier version.
 */


#include "hmm.h"


void hmm_dump (hmm_t *hmm, int32 n_state, s3senid_t *senid, int32 *senscr, FILE *fp)
{
    int32 i;
    
    fprintf (fp, " %11d    ", hmm->in.score);
    for (i = 0; i < n_state; i++)
	fprintf (fp, " %11d", hmm->state[i].score);
    fprintf (fp, "     %11d\n", hmm->out.score);
    
    fprintf (fp, " %11d    ", hmm->in.history);
    for (i = 0; i < n_state; i++)
	fprintf (fp, " %11d", hmm->state[i].history);
    fprintf (fp, "     %11d\n", hmm->out.history);
    
    if (senid) {
	fprintf (fp, " %-11s    ", "senid");
	for (i = 0; i < n_state; i++)
	    fprintf (fp, " %11d", senid[i]);
	fprintf (fp, "\n");
	
	if (senscr) {
	    fprintf (fp, " %-11s    ", "senscr");
	    for (i = 0; i < n_state; i++)
		fprintf (fp, " %11d", senscr[senid[i]]);
	    fprintf (fp, "\n");
	}
    }
    
    fflush (fp);
}


void hmm_clear (hmm_t *h, int32 n_state)
{
    int32 i;

    h->in.score = S3_LOGPROB_ZERO;
    h->in.history = -1;
    for (i = 0; i < n_state; i++) {
	h->state[i].score = S3_LOGPROB_ZERO;
	h->state[i].history = -1;
    }
    h->out.score = S3_LOGPROB_ZERO;
    h->out.history = -1;
    
    h->bestscore = S3_LOGPROB_ZERO;
}


int32 hmm_vit_eval_5st (hmm_t *hmm, s3senid_t *senid, int32 *senscr)
{
    int32 s0, s1, s2, s3, s4, best, *tp;
    
    tp = hmm->tp[0];	/* Hack!!, use the knowledge that the 2-D tp is a contiguous block */
    
    /* 4 = max(2,3,4); */
    s4 = hmm->state[4].score + tp[28];
    s3 = hmm->state[3].score + tp[22];
    s2 = hmm->state[2].score + tp[16];
    if (s4 < s3) {
	if (s3 >= s2) {
	    s4 = s3;
	    hmm->state[4].history = hmm->state[3].history;
	} else {
	    s4 = s2;
	    hmm->state[4].history = hmm->state[2].history;
	}
    } else if (s4 < s2) {
	s4 = s2;
	hmm->state[4].history = hmm->state[2].history;
    }
    s4 += senscr[senid[4]];
    hmm->state[4].score = s4;
    
    /* 3 = max(1,2,3); */
    s3 = hmm->state[3].score + tp[21];
    s2 = hmm->state[2].score + tp[15];
    s1 = hmm->state[1].score + tp[ 9];
    if (s3 < s2) {
	if (s2 >= s1) {
	    s3 = s2;
	    hmm->state[3].history = hmm->state[2].history;
	} else {
	    s3 = s1;
	    hmm->state[3].history = hmm->state[1].history;
	}
    } else if (s3 < s1) {
	s3 = s1;
	hmm->state[3].history = hmm->state[1].history;
    }
    s3 += senscr[senid[3]];
    hmm->state[3].score = s3;
    
    best = (s4 > s3) ? s4 : s3;
    
    /* Exit state score */
    s4 += tp[29];
    s3 += tp[23];
    if (s4 < s3) {
	hmm->out.score = s3;
	hmm->out.history = hmm->state[3].history;
    } else {
	hmm->out.score = s4;
	hmm->out.history = hmm->state[4].history;
    }
    
    /* 2 = max(0,1,2); */
    s2 = hmm->state[2].score + tp[14];
    s1 = hmm->state[1].score + tp[ 8];
    s0 = hmm->state[0].score + tp[ 2];
    if (s2 < s1) {
	if (s1 >= s0) {
	    s2 = s1;
	    hmm->state[2].history = hmm->state[1].history;
	} else {
	    s2 = s0;
	    hmm->state[2].history = hmm->state[0].history;
	}
    } else if (s2 < s0) {
	s2 = s0;
	hmm->state[2].history = hmm->state[0].history;
    }
    s2 += senscr[senid[2]];
    hmm->state[2].score = s2;
    if (best < s2)
	best = s2;
    
    /* 1 = max(0,1); */
    s1 = hmm->state[1].score + tp[ 7];
    s0 = hmm->state[0].score + tp[ 1];
    if (s1 < s0) {
	s1 = s0;
	hmm->state[1].history = hmm->state[0].history;
    }
    s1 += senscr[senid[1]];
    hmm->state[1].score = s1;
    if (best < s1)
	best = s1;
    
    /* 0 = max(0,in); */
    s0 = hmm->state[0].score + tp[ 0];
    if (s0 < hmm->in.score) {
	s0 = hmm->in.score;
	hmm->state[0].history = hmm->in.history;
    }
    s0 += senscr[senid[0]];
    hmm->state[0].score = s0;
    if (best < s0)
	best = s0;
    
    hmm->in.score = S3_LOGPROB_ZERO;	/* Consumed */
    hmm->bestscore = best;
    
    return best;
}


int32 hmm_vit_eval_3st (hmm_t *hmm, s3senid_t *senid, int32 *senscr)
{
    int32 s0, s1, s2, best, *tp;
#ifdef _CHECKUNDERFLOW_
    int32 st0, st1, st2, sen0, sen1, sen2;
#endif
    
    tp = hmm->tp[0];	/* Hack!! We know the 2-D tp is a contiguous block */
    
    /* 2 = max(0,1,2); */
    s2 = hmm->state[2].score + tp[10];
    s1 = hmm->state[1].score + tp[ 6];
    if (tp[2] > S3_LOGPROB_ZERO) { /* Only if skip(0->2) is allowed */
        s0 = hmm->state[0].score + tp[ 2]; 
        if (s2 < s1) {
	    if (s1 >= s0) {
	        s2 = s1;
	        hmm->state[2].history = hmm->state[1].history;
	    } else {
	        s2 = s0;
	        hmm->state[2].history = hmm->state[0].history;
	    }
        } else if (s2 < s0) {
	    s2 = s0;
	    hmm->state[2].history = hmm->state[0].history;
        }
    } else {
        if (s2 < s1) {
	    s2 = s1;
	    hmm->state[2].history = hmm->state[1].history;
        } 
    } 
#ifdef _CHECKUNDERFLOW_
    sen2 = senscr[senid[2]];
    st2 = s2 + sen2;
    /* If adding two negatives gives us a positive we have an underflow */
    s2 = (st2 > 0 && s2 < 0 && sen2 < 0) ? MAX_NEG_INT32 : st2;
#else
    s2 += senscr[senid[2]];
#endif 
    hmm->state[2].score = s2;
    

    /* 1 = max(0,1); */
    s1 = hmm->state[1].score + tp[ 5];
    s0 = hmm->state[0].score + tp[ 1];
    if (s1 < s0) {
	s1 = s0;
	hmm->state[1].history = hmm->state[0].history;
    }
#ifdef _CHECKUNDERFLOW_
    sen1 = senscr[senid[1]];
    st1 = s1 + sen1;
    s1 = (st1 > 0 && s1 < 0 && sen1 < 0) ? MAX_NEG_INT32 : st1;
#else
    s1 += senscr[senid[1]];
#endif 
    hmm->state[1].score = s1;
 
    best = (s2 > s1) ? s2 : s1;
    
    /* Exit state score */
#ifdef _CHECKUNDERFLOW_
    st2 = s2 + tp[11];
    /* tp[] is always negative */
    s2 = (st2 > 0 && s2 < 0) ? MAX_NEG_INT32 : st2;
#else
    s2 += tp[11];
#endif
    if (tp[7] > S3_LOGPROB_ZERO) { /* Only if skip(1->4) is allowed */
        s1 += tp[ 7];
        if (s2 < s1) {
	    hmm->out.score = s1;
	    hmm->out.history = hmm->state[1].history;
        } else {
	    hmm->out.score = s2;
	    hmm->out.history = hmm->state[2].history;
        }
    } else {
        hmm->out.score = s2;
        hmm->out.history = hmm->state[2].history;
    }
    
    /* 0 = max(0,in); */
    s0 = hmm->state[0].score + tp[ 0];
    if (s0 < hmm->in.score) {
	s0 = hmm->in.score;
	hmm->state[0].history = hmm->in.history;
    }
#ifdef _CHECKUNDERFLOW_
    sen0 = senscr[senid[0]];
    st0 = s0 + sen0;
    s0 = (st0 > 0 && s0 < 0 && sen0 < 0) ? MAX_NEG_INT32 : st0;
#else
    s0 += senscr[senid[0]];
#endif 
    hmm->state[0].score = s0;

    if (best < s0)
	best = s0;
    
    hmm->in.score = S3_LOGPROB_ZERO;	/* Consumed */
    hmm->bestscore = best;
    
    return best;
}


int32 hmm_dump_vit_eval (hmm_t *hmm, int32 n_state, s3senid_t *senid, int32 *senscr, FILE *fp)
{
    int32 bs=0;
    
    if (fp)
	hmm_dump (hmm, n_state, senid, senscr, fp);
    
    if (n_state == 5)
	bs = hmm_vit_eval_5st (hmm, senid, senscr);
    else if (n_state == 3)
	bs = hmm_vit_eval_3st (hmm, senid, senscr);
    else
	E_FATAL("#States= %d unsupported\n", n_state);
    
    if (fp)
	hmm_dump (hmm, n_state, senid, senscr, fp);
    
    return bs;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * hmm.h -- HMM data structure.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * HISTORY
 * 
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified hmm_t.state to be a run-time array instead of a compile-time
 * 		one.  Modified compile-time 3 and 5-state versions of hmm_vit_eval
 * 		into hmm_vit_eval_3st and hmm_vit_eval_5st, to allow run-time selection.
 * 		Removed hmm_init().
 * 
 * 08-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added HMM_SKIPARCS compile-time option and hmm_init().
 * 
 * 10-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started, based on an earlier version.
 */


#ifndef _S3_HMM_H_
#define _S3_HMM_H_


#include "libutil.h"
#include "s3types.h"


/*
 * An individual HMM among the HMM search space.  An HMM with N emitting states consists
 * of N+2 internal states including the non-emitting entry (in) and exit (out) states.
 * For compatibility with Sphinx-II, we assume that the initial or entry state can only
 * transition to state 0, and the transition matrix is n_emit_state x (n_emit_state+1),
 * where the extra destination dimension correponds to the final or exit state.
 */

/*
 * NOTE: For efficiency, this version is hardwired for two possible HMM topologies:
 * 
 * 5-state left-to-right HMMs:  (0 is the entry state and E is a non-emitting exit state;
 * the x's indicate allowed transitions between source and destination states):
 * 
 *               0   1   2   3   4   E (destination-states)
 *           0   x   x   x
 *           1       x   x   x
 *           2           x   x   x
 *           3               x   x   x
 *           4                   x   x
 *    (source-states)
 * 5-state topologies that contain a subset of the above transitions should work as well.
 * 
 * 3-state left-to-right HMMs (similar notation as the 5-state topology above):
 * 
 *               0   1   2   E (destination-states)
 *           0   x   x   x
 *           1       x   x   x
 *           2           x   x 
 *    (source-states)
 * 3-state topologies that contain a subset of the above transitions should work as well.
 */


/* A single state in the HMM */
typedef struct {
    int32 score;	/* State score (path log-likelihood) */
    int32 history;	/* History index */
} hmm_state_t;

typedef struct {
    hmm_state_t *state;	/* Per-state data for emitting states */
    hmm_state_t in;	/* Non-emitting entry state */
    hmm_state_t out;	/* Non-emitting exit state */
    int32 **tp;		/* State transition scores tp[from][to] (logs3 values) */
    int32 bestscore;	/* Best [emitting] state score in current frame (for pruning) */
} hmm_t;


/*
 * Reset the states of the HMM to the invalid or inactive condition; i.e., scores to
 * LOGPROB_ZERO and hist to undefined.
 */
void hmm_clear (hmm_t *h, int32 n_emit_state);


/*
 * Viterbi evaluation of given HMM.  (NOTE that if this module were being used for tracking
 * state segmentations, the dummy, non-emitting exit state would have to be updated separately.
 * In the Viterbi DP diagram, transitions to the exit state occur from the current time; they
 * are vertical transitions.  Hence they should be made only after the history has been logged
 * for the emitting states.  But we're not bothered with state segmentations, for now.  So, we
 * update the exit state as well.)
 * Hardwired for 5-state HMMs with topology shown above.
 * Return value: Best state score after evaluation.
 */
int32 hmm_vit_eval_5st (hmm_t *hmm,		/* In/Out: HMM being updated */
			s3senid_t *senid,	/* In: Senone ID for each HMM state */
			int32 *senscore);	/* In: Senone scores, for all senones */

/*
 * Like hmm_vit_eval_5st, but hardwired for 3-state HMMs with topology shown above.
 * Return value: Best state score after evaluation.
 */
int32 hmm_vit_eval_3st (hmm_t *hmm,		/* In/Out: HMM being updated */
			s3senid_t *senid,	/* In: Senone ID for each HMM state */
			int32 *senscore);	/* In: Senone scores, for all senones */

/* Like hmm_vit_eval, but dump HMM state and relevant senscr to fp first, for debugging */
int32 hmm_dump_vit_eval (hmm_t *hmm, int32 n_emit_state,
			 s3senid_t *senid, int32 *senscr, FILE *fp);

/* For debugging */
void hmm_dump (hmm_t *h, int32 n_emit_state, s3senid_t *senid, int32 *senscr, FILE *fp);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * hyp.h -- Hypothesis structures.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 01-Jun-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#ifndef _S3_HYP_H_
#define _S3_HYP_H_


#include "libutil.h"


typedef struct {
    int32 id;		/* Token ID; could be s3wid_t, s3cipid_t...  Interpreted by client. */
    int32 vhid;		/* Viterbi history (lattice) ID from which this entry created */
    int32 sf, ef;	/* Start/end frames, inclusive, for this segment */
    int32 ascr;		/* Segment acoustic score */
    int32 lscr;		/* LM score for transition to this segment (if applicable) */
    int32 type;		/* Uninterpreted data; see vithist_entry_t in vithist.h */
} hyp_t;


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * io.c -- Packaged I/O routines.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 08-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added stat_mtime().
 * 
 * 11-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added _myfopen().
 * 
 * 05-Sep-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if (! WIN32)
#include <unistd.h>
#endif
#include <assert.h>

#include "io.h"
#include "err.h"


FILE *fopen_comp (char *file, char *mode, int32 *ispipe)
{
    char command[16384];
    FILE *fp;
    int32 k, isgz;
    
    k = strlen (file);
    
#if (WIN32)
    *ispipe = (k > 3) &&
	((strcmp (file+k-3, ".gz") == 0) || (strcmp (file+k-3, ".GZ") == 0));
    isgz = *ispipe;
#else
    *ispipe = 0;
    isgz = 0;
    if ((k > 2) && ((strcmp (file+k-2, ".Z") == 0) || (strcmp (file+k-2, ".z") == 0))) {
	*ispipe = 1;
    } else {
	if ((k > 3) &&
	    ((strcmp (file+k-3, ".gz") == 0) || (strcmp (file+k-3, ".GZ") == 0))) {
	    *ispipe = 1;
	    isgz = 1;
	}
    }
#endif

    if (*ispipe) {
#if (WIN32)
	if (strcmp (mode, "r") == 0) {
	    sprintf (command, "gzip.exe -d -c %s", file);
	    if ((fp = _popen (command, mode)) == NULL) {
		E_ERROR_SYSTEM("_popen (%s,%s) failed\n", command, mode);
		return NULL;
	    }
	} else {
	    E_ERROR ("fopen_comp not implemented for mode = %s\n", mode);
	    return NULL;
	}
#else
	if (strcmp (mode, "r") == 0) {
	    if (isgz)
		sprintf (command, "gunzip -c %s", file);
	    else
		sprintf (command, "zcat %s", file);
	    
	    if ((fp = popen (command, mode)) == NULL) {
		E_ERROR_SYSTEM("popen (%s,%s) failed\n", command, mode);
		return NULL;
	    }
	} else if (strcmp (mode, "w") == 0) {
	    if (isgz)
		sprintf (command, "gzip > %s", file);
	    else
		sprintf (command, "compress -c > %s", file);
	    
	    if ((fp = popen (command, mode)) == NULL) {
		E_ERROR_SYSTEM("popen (%s,%s) failed\n", command, mode);
		return NULL;
	    }
	} else {
	    E_ERROR ("fopen_comp not implemented for mode = %s\n", mode);
	    return NULL;
	}
#endif
    } else {
        fp = fopen (file, mode);
    }

    return (fp);
}


void fclose_comp (FILE *fp, int32 ispipe)
{
    if (ispipe) {
#if (WIN32)
	_pclose (fp);
#else
	pclose (fp);
#endif
    } else
	fclose (fp);
}


FILE *fopen_compchk (char *file, int32 *ispipe)
{
    char tmpfile[16384];
    int32 k, isgz;
    struct stat statbuf;
    
    k = strlen (file);
    
#if (WIN32)
    *ispipe = (k > 3) &&
	((strcmp (file+k-3, ".gz") == 0) || (strcmp (file+k-3, ".GZ") == 0));
    isgz = *ispipe;
#else
    *ispipe = 0;
    isgz = 0;
    if ((k > 2) && ((strcmp (file+k-2, ".Z") == 0) || (strcmp (file+k-2, ".z") == 0))) {
	*ispipe = 1;
    } else {
	if ((k > 3) &&
	    ((strcmp (file+k-3, ".gz") == 0) || (strcmp (file+k-3, ".GZ") == 0))) {
	    *ispipe = 1;
	    isgz = 1;
	}
    }
#endif
    
    strcpy (tmpfile, file);
    if (stat (tmpfile, &statbuf) != 0) {
	/* File doesn't exist; try other compressed/uncompressed form, as appropriate */
	E_ERROR_SYSTEM("stat(%s) failed\n", tmpfile);
	
	if (*ispipe) {
	    if (isgz)
		tmpfile[k-3] = '\0';
	    else
		tmpfile[k-2] = '\0';
	    
	    if (stat (tmpfile, &statbuf) != 0)
		return NULL;
	} else {
	    strcpy (tmpfile+k, ".gz");
	    if (stat (tmpfile, &statbuf) != 0) {
#if (! WIN32)
		strcpy (tmpfile+k, ".Z");
		if (stat (tmpfile, &statbuf) != 0)
		    return NULL;
#else
		return NULL;
#endif
	    }
	}
	
	E_WARN("Using %s instead of %s\n", tmpfile, file);
    }
    
    return (fopen_comp (tmpfile, "r", ispipe));
}


#define FREAD_RETRY_COUNT	60

int32 fread_retry(void *pointer, int32 size, int32 num_items, FILE *stream)
{
    char *data;
    uint32 n_items_read;
    uint32 n_items_rem;
    uint32 n_retry_rem;
    int32 loc;

    n_retry_rem = FREAD_RETRY_COUNT;

    data = pointer;
    loc = 0;
    n_items_rem = num_items;
	
    do {
	n_items_read = fread(&data[loc], size, n_items_rem, stream);

	n_items_rem -= n_items_read;

	if (n_items_rem > 0) {
	    /* an incomplete read occurred */

	    if (n_retry_rem == 0)
		return -1;

	    if (n_retry_rem == FREAD_RETRY_COUNT) {
		E_ERROR_SYSTEM("fread() failed; retrying...\n");
	    }

	    --n_retry_rem;
	    
	    loc += n_items_read * size;
#if (! WIN32)
	    /*sleep(1);*/ /*alex changed */
#endif
	}
    } while (n_items_rem > 0);

    return num_items;
}


#define STAT_RETRY_COUNT	10

int32 stat_retry (char *file, struct stat *statbuf)
{
    int32 i;
    
    for (i = 0; i < STAT_RETRY_COUNT; i++) {
	if (stat (file, statbuf) == 0)
	    return 0;
	
	if (i == 0) {
	    E_ERROR_SYSTEM("stat(%s) failed; retrying...\n", file);
	}
#if (! WIN32)
	/*sleep (10);*/ /*alex changed */
#endif
    }
    
    return -1;
}


int32 stat_mtime (char *file)
{
    struct stat statbuf;
    
    if (stat (file, &statbuf) != 0)
	return -1;
    
    return ((int32)statbuf.st_mtime);
}


FILE *_myfopen (char *file, char *mode, char *pgm, int32 line)
{
    FILE *fp;
    
    if ((fp = fopen(file, mode)) == NULL) {
	fflush (stdout);
	fprintf (stderr, "FATAL_ERROR: \"%s\", line %d: fopen(%s,%s) failed; ",
		 pgm, line, file, mode);
	perror("");
	fflush (stderr);
	
	exit(errno);
    }
    
    return fp;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * io.h -- Packaged I/O routines.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 08-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added stat_mtime().
 * 
 * 11-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added _myfopen() and myfopen macro.
 * 
 * 05-Sep-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _LIBUTIL_IO_H_
#define _LIBUTIL_IO_H_


#include <stdio.h>
#include <sys/stat.h>
#include "prim_type.h"


/*
 * Like fopen, but use popen and zcat if it is determined that "file" is compressed
 * (i.e., has a .z, .Z, .gz, or .GZ extension).
 */
FILE *fopen_comp (char *file,		/* In: File to be opened */
		  char *mode,		/* In: "r" or "w", as with normal fopen */
		  int32 *ispipe);	/* Out: On return *ispipe is TRUE iff file
					   was opened via a pipe */

/*
 * Close a file opened using fopen_comp.
 */
void fclose_comp (FILE *fp,		/* In: File pointer to be closed */
		  int32 ispipe);	/* In: ispipe argument that was returned by the
					   corresponding fopen_comp() call */

/*
 * Open a file for reading, but if file not present try to open compressed version (if
 * file is uncompressed, and vice versa).
 */
FILE *fopen_compchk (char *file,	/* In: File to be opened */
		     int32 *ispipe);	/* Out: On return *ispipe is TRUE iff file
					   was opened via a pipe */

/*
 * Wrapper around fopen to check for failure and E_FATAL if failed.
 */
FILE *_myfopen(char *file, char *mode,
	       char *pgm, int32 line);	/* In: __FILE__, __LINE__ from where called */
#define myfopen(file,mode)	_myfopen((file),(mode),__FILE__,__LINE__)


/*
 * NFS file reads seem to fail now and then.  Use the following functions in place of
 * the regular fread.  It retries failed freads several times and quits only if all of
 * them fail.  Be aware, however, that even normal failures such as attempting to read
 * beyond EOF will trigger such retries, wasting about a minute in retries.
 * Arguments identical to regular fread.
 */
int32 fread_retry(void *pointer, int32 size, int32 num_items, FILE *stream);


/*
 * Like fread_retry, but for stat.  Arguments identical to regular stat.
 * Return value: 0 if successful, -1 if stat failed several attempts.
 */
int32 stat_retry (char *file, struct stat *statbuf);

/*
 * Return time of last modification for the given file, or -1 if stat fails.
 */
int32 stat_mtime (char *file);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/************************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 2000 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 ************************************************
 * 
 * HISTORY
 * 
 * 30-Dec-2000	Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Moved kb_*() routines into kb.c to make them independent of
 *		main() during compilation
 *
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified to allow runtime choice between 3-state and 5-state HMM
 * 		topologies (instead of compile-time selection).
 * 
 * 13-Aug-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added -maxwpf.
 * 
 * 10-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "kb.h"
#include "logs3.h"		/* RAH, added to resolve log3_free */

void kb_init (kb_t *kb)
{
    kbcore_t *kbcore;
    mdef_t *mdef;
    dict_t *dict;
    dict2pid_t *d2p;
    lm_t *lm;
    s3cipid_t sil, ci;
    s3wid_t w;
    int32 i, n, n_lc;
    wordprob_t *wp;
    s3cipid_t *lc;
    bitvec_t lc_active;
    char *str;
    
    /* Initialize the kb structure to zero, just in case */
    memset(kb, 0, sizeof(*kb));

    kb->kbcore = kbcore_init (cmd_ln_float32 ("-logbase"),
			      "1s_c_d_dd",    /* Hack!! Hardwired constant 
						for -feat argument */
			      cmd_ln_str("-cmn"),
			      cmd_ln_str("-varnorm"),
			      cmd_ln_str("-agc"),
			      cmd_ln_str("-mdef"),
			      cmd_ln_str("-dict"),
			      cmd_ln_str("-fdict"),
			      "",	/* Hack!! Hardwired constant 
						for -compsep argument */
			      cmd_ln_str("-lm"),
			      cmd_ln_str("-fillpen"),
			      cmd_ln_float32("-silprob"),
			      cmd_ln_float32("-fillprob"),
			      cmd_ln_float32("-lw"),
			      cmd_ln_float32("-wip"),
			      cmd_ln_float32("-uw"),
			      cmd_ln_str("-mean"),
			      cmd_ln_str("-var"),
			      cmd_ln_float32("-varfloor"),
			      cmd_ln_str("-mixw"),
			      cmd_ln_float32("-mixwfloor"),
			      cmd_ln_str("-subvq"),
			      cmd_ln_str("-tmat"),
			      cmd_ln_float32("-tmatfloor"));
    kbcore = kb->kbcore;
    
    mdef = kbcore_mdef(kbcore);
    dict = kbcore_dict(kbcore);
    lm = kbcore_lm(kbcore);
    d2p = kbcore_dict2pid(kbcore);
    
    if (NOT_S3WID(dict_startwid(dict)) || NOT_S3WID(dict_finishwid(dict)))
	E_FATAL("%s or %s not in dictionary\n", S3_START_WORD, S3_FINISH_WORD);
    if (NOT_S3LMWID(lm_startwid(lm)) || NOT_S3LMWID(lm_finishwid(lm)))
	E_FATAL("%s or %s not in LM\n", S3_START_WORD, S3_FINISH_WORD);
    
    /* Check that HMM topology restrictions are not violated */
    if (tmat_chk_1skip (kbcore->tmat) < 0)
	E_FATAL("Tmat contains arcs skipping more than 1 state\n");
    
    /*
     * Unlink <s> and </s> between dictionary and LM, to prevent their 
     * recognition.  They are merely dummy words (anchors) at the beginning 
     * and end of each utterance.
     */
    lm_lmwid2dictwid(lm, lm_startwid(lm)) = BAD_S3WID;
    lm_lmwid2dictwid(lm, lm_finishwid(lm)) = BAD_S3WID;
    for (w = dict_startwid(dict); IS_S3WID(w); w = dict_nextalt(dict, w))
	kbcore->dict2lmwid[w] = BAD_S3LMWID;
    for (w = dict_finishwid(dict); IS_S3WID(w); w = dict_nextalt(dict, w))
	kbcore->dict2lmwid[w] = BAD_S3LMWID;
    
    sil = mdef_silphone (kbcore_mdef (kbcore));
    if (NOT_S3CIPID(sil))
	E_FATAL("Silence phone '%s' not in mdef\n", S3_SILENCE_CIPHONE);
    
    E_INFO("Building lextrees\n");

#ifdef USE_ICC
    
    kb->sen_active = (int32 *) _mm_malloc(mdef_n_sen(mdef)*sizeof(int32),16);
    kb->ssid_active = (int32 *) _mm_malloc(mdef_n_sseq(mdef)*sizeof(int32),16);
    kb->comssid_active = (int32 *) _mm_malloc(dict2pid_n_comsseq(d2p)*sizeof(int32),16);
    
#else
    
    kb->sen_active = (int32 *) ckd_calloc (mdef_n_sen(mdef), sizeof(int32));
    kb->ssid_active = (int32 *) ckd_calloc (mdef_n_sseq(mdef), sizeof(int32));
    kb->comssid_active = (int32 *) ckd_calloc (dict2pid_n_comsseq(d2p), 
							sizeof(int32));
#endif

    E_INFO("ALEX sen_active %d ssid_active %d comssid_active %d\n",
	   mdef_n_sen(mdef), mdef_n_sseq(mdef), dict2pid_n_comsseq(d2p));
    /* Build active word list */
    wp = (wordprob_t *) ckd_calloc (dict_size(dict), sizeof(wordprob_t));
    n = lm_ug_wordprob (lm, MAX_NEG_INT32, wp);
    if (n < 1)
	E_FATAL("%d active words\n", n);
    n = wid_wordprob2alt (dict, wp, n);	   /* Add alternative pronunciations */
    
    /* Retain or remove unigram probs from lextree, depending on option */
    if (cmd_ln_int32("-treeugprob") == 0) {
	for (i = 0; i < n; i++)
	    wp[i].prob = -1;    	/* Flatten all initial probabilities */
    }
    
    /* Build set of all possible left contexts */
    lc = (s3cipid_t *) ckd_calloc (mdef_n_ciphone(mdef) + 1, sizeof(s3cipid_t));
    lc_active = bitvec_alloc (mdef_n_ciphone (mdef));
    for (w = 0; w < dict_size (dict); w++) {
	ci = dict_pron (dict, w, dict_pronlen(dict, w) - 1);
	if (! mdef_is_fillerphone (mdef, (int)ci))
	    bitvec_set (lc_active, ci);
    }
    ci = mdef_silphone(mdef);
    bitvec_set (lc_active, ci);
    for (ci = 0, n_lc = 0; ci < mdef_n_ciphone(mdef); ci++) {
	if (bitvec_is_set (lc_active, ci))
	    lc[n_lc++] = ci;
    }
    lc[n_lc] = BAD_S3CIPID;
    
    /* Create the desired no. of unigram lextrees */
    kb->n_lextree = cmd_ln_int32 ("-Nlextree");
    if (kb->n_lextree < 1) {
	E_ERROR("No. of ugtrees specified: %d; will instantiate 1 ugtree\n", 
								kb->n_lextree);
	kb->n_lextree = 1;
    }
    kb->ugtree = (lextree_t **) ckd_calloc (kb->n_lextree, sizeof(lextree_t *));
    for (i = 0; i < kb->n_lextree; i++) {
	kb->ugtree[i] = lextree_build (kbcore, wp, n, lc);
	lextree_type (kb->ugtree[i]) = 0;
    }
    bitvec_free (lc_active);
    ckd_free ((void *) lc);
    
    /* Create filler lextrees */
    n = 0;
    for (i = dict_filler_start(dict); i <= dict_filler_end(dict); i++) {
	if (dict_filler_word(dict, i)) {
	    wp[n].wid = i;
	    wp[n].prob = fillpen (kbcore->fillpen, i);
	    n++;
	}
    }
    kb->fillertree = (lextree_t **)ckd_calloc(kb->n_lextree,sizeof(lextree_t*));
    for (i = 0; i < kb->n_lextree; i++) {
	kb->fillertree[i] = lextree_build (kbcore, wp, n, NULL);
	lextree_type (kb->fillertree[i]) = -1;
    }
    ckd_free ((void *) wp);
    
    E_INFO("Lextrees(%d), %d nodes(ug), %d nodes(filler)\n",
	   kb->n_lextree, lextree_n_node(kb->ugtree[0]), 
			lextree_n_node(kb->fillertree[0]));
    
    if (cmd_ln_int32("-lextreedump")) {
	for (i = 0; i < kb->n_lextree; i++) {
	    fprintf (stderr, "UGTREE %d\n", i);
	    lextree_dump (kb->ugtree[i], dict, stderr);
	}
	for (i = 0; i < kb->n_lextree; i++) {
	    fprintf (stderr, "FILLERTREE %d\n", i);
	    lextree_dump (kb->fillertree[i], dict, stderr);
	}
	fflush (stderr);
    }
    
    kb->ascr = ascr_init (mgau_n_mgau(kbcore_mgau(kbcore)), 
				kbcore->dict2pid->n_comstate);
    kb->beam = beam_init (cmd_ln_float64("-subvqbeam"),
			  cmd_ln_float64("-beam"),
			  cmd_ln_float64("-pbeam"),
			  cmd_ln_float64("-wbeam"));
    E_INFO("Beam= %d, PBeam= %d, WBeam= %d, SVQBeam= %d\n",
	   kb->beam->hmm, kb->beam->ptrans, kb->beam->word, kb->beam->subvq);
    
    if ((kb->feat = feat_array_alloc(kbcore_fcb(kbcore),S3_MAX_FRAMES)) == NULL)
	E_FATAL("feat_array_alloc() failed\n");
    
    kb->vithist = vithist_init(kbcore, kb->beam->word, cmd_ln_int32("-bghist"));
    
    ptmr_init (&(kb->tm_sen));
    ptmr_init (&(kb->tm_srch));
    kb->tot_fr = 0;
    kb->tot_sen_eval = 0.0;
    kb->tot_gau_eval = 0.0;
    kb->tot_hmm_eval = 0.0;
    kb->tot_wd_exit = 0.0;
    
    kb->hmm_hist_binsize = cmd_ln_int32("-hmmhistbinsize");
    n = ((kb->ugtree[0]->n_node) + (kb->fillertree[0]->n_node)) * kb->n_lextree;
    n /= kb->hmm_hist_binsize;
    kb->hmm_hist_bins = n+1;
    kb->hmm_hist = (int32 *) ckd_calloc (n+1, sizeof(int32));	/* Really no need for +1 */
    
    /* Open hypseg file if specified */
    str = cmd_ln_str("-hypseg");
    kb->matchsegfp = NULL;
    if (str) {
#ifdef WIN32
	if ((kb->matchsegfp = fopen(str, "wt")) == NULL)
#else
	if ((kb->matchsegfp = fopen(str, "w")) == NULL)
#endif
	    E_ERROR("fopen(%s,w) failed; use FWDXCT: from std logfile\n", str);
    }
}


/*
 * Make the next_active information within all lextrees be the current one, after blowing
 * away the latter; in preparation for moving on to the next frame.
 */
void kb_lextree_active_swap (kb_t *kb)
{
    int32 i;
    
    for (i = 0; i < kb->n_lextree; i++) {
	lextree_active_swap (kb->ugtree[i]);
	lextree_active_swap (kb->fillertree[i]);
    }
}

/* RAH 4.15.01 Lots of memory is allocated, but never freed, this function will clean up.
 * First pass will get the low hanging fruit.*/
void kb_free (kb_t *kb)
{
  vithist_t *vithist = kb->vithist;

#ifdef USE_ICC
  if (kb->sen_active)
    _mm_free ((void *)kb->sen_active);
  if (kb->ssid_active) 
    _mm_free ((void *)kb->ssid_active);
  if (kb->comssid_active)
    _mm_free ((void *)kb->comssid_active);
#else
  if (kb->sen_active)
    ckd_free ((void *)kb->sen_active);
  if (kb->ssid_active) 
    ckd_free ((void *)kb->ssid_active);
  if (kb->comssid_active)
    ckd_free ((void *)kb->comssid_active);
#endif
  if (kb->fillertree) 
    ckd_free ((void *)kb->fillertree);
  if (kb->hmm_hist) 
    ckd_free ((void *)kb->hmm_hist);
  

  /* vithist */
  if (vithist) {
    ckd_free ((void *) vithist->entry);
    ckd_free ((void *) vithist->frame_start);
    ckd_free ((void *) vithist->bestscore);
    ckd_free ((void *) vithist->bestvh);
    ckd_free ((void *) vithist->lms2vh_root);    
    ckd_free ((void *) kb->vithist);
  }


  kbcore_free (kb->kbcore);

  if (kb->feat) {
    ckd_free ((void *)kb->feat[0][0]);
    ckd_free_2d ((void **)kb->feat);
  }
    
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * kbcore.c -- Structures for maintain the main models.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 11-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Removed svqpp stuff.  It doesn't work too well anyway.
 * 
 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added kb_t.svqpp_t and related handling.
 * 
 * 10-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "kbcore.h"
#include "logs3.h"


kbcore_t *kbcore_init (float64 logbase,
		       char *feattype,
		       char *cmn,
		       char *varnorm,
		       char *agc,
		       char *mdeffile,
		       char *dictfile,
		       char *fdictfile,
		       char *compsep,
		       char *lmfile,
		       char *fillpenfile,
		       float64 silprob,
		       float64 fillprob,
		       float64 langwt,
		       float64 inspen,
		       float64 uw,
		       char *meanfile,
		       char *varfile,
		       float64 varfloor,
		       char *mixwfile,
		       float64 mixwfloor,
		       char *subvqfile,
		       char *tmatfile,
		       float64 tmatfloor)
{
    kbcore_t *kb;
    
    E_INFO("Initializing core models:\n");
    
    kb = (kbcore_t *) ckd_calloc (1, sizeof(kbcore_t));
    kb->fcb = NULL;
    kb->mdef = NULL;
    kb->dict = NULL;
    kb->dict2pid = NULL;
    kb->lm = NULL;
    kb->fillpen = NULL;
    kb->dict2lmwid = NULL;
    kb->mgau = NULL;
    kb->svq = NULL;
    kb->tmat = NULL;
    
    logs3_init (logbase);
    
    if (feattype) {
	if ((kb->fcb = feat_init (feattype, cmn, varnorm, agc)) == NULL)
	    E_FATAL("feat_init(%s) failed\n", feattype);
	if (feat_n_stream(kb->fcb) != 1)
	    E_FATAL("#Feature streams(%d) != 1\n", feat_n_stream(kb->fcb));
    }
    
    if (mdeffile) {
	if ((kb->mdef = mdef_init (mdeffile)) == NULL)
	    E_FATAL("mdef_init(%s) failed\n", mdeffile);
    }
    
    if (dictfile) {
	if (! compsep)
	    compsep = "";
	else if ((compsep[0] != '\0') && (compsep[1] != '\0')) {
	    E_FATAL("Compound word separator(%s) must be empty or single character string\n",
		    compsep);
	}
	if ((kb->dict = dict_init (kb->mdef, dictfile, fdictfile, compsep[0])) == NULL)
	    E_FATAL("dict_init(%s,%s,%s) failed\n", dictfile,
		    fdictfile ? fdictfile : "", compsep);
    }
    
    if (lmfile) {
	if ((kb->lm = lm_read (lmfile, langwt, inspen, uw)) == NULL)
	    E_FATAL("lm_read(%s, %e, %e, %e) failed\n", lmfile, langwt, inspen, uw);
    }
    
    if (fillpenfile || (lmfile && kb->dict)) {
	if (! kb->dict)		/* Sic */
	    E_FATAL("No dictionary for associating filler penalty file(%s)\n", fillpenfile);
	
	if ((kb->fillpen = fillpen_init (kb->dict, fillpenfile, silprob, fillprob,
					 langwt, inspen)) == NULL)
	    E_FATAL("fillpen_init(%s) failed\n", fillpenfile);
    }
    
    if (meanfile) {
	if ((! varfile) || (! mixwfile))
	    E_FATAL("Varfile or mixwfile not specified along with meanfile(%s)\n", meanfile);
	kb->mgau = mgau_init (meanfile, varfile, varfloor, mixwfile, mixwfloor, TRUE);
	if (kb->mgau == NULL)
	    E_FATAL("gauden_init(%s, %s, %e) failed\n", meanfile, varfile, varfloor);

	if (subvqfile) {
	    if ((kb->svq = subvq_init (subvqfile, varfloor, -1, kb->mgau)) == NULL)
		E_FATAL("subvq_init (%s, %e, -1) failed\n", subvqfile, varfloor);
	}
    }
    
    if (tmatfile) {
	if ((kb->tmat = tmat_init (tmatfile, tmatfloor)) == NULL)
	    E_FATAL("tmat_init (%s, %e) failed\n", tmatfile, tmatfloor);
    }
    
    if (kb->dict && kb->lm) {	/* Initialize dict2lmwid */
	if ((kb->dict2lmwid = wid_dict_lm_map (kb->dict, kb->lm)) == NULL)
	    E_FATAL("Dict/LM word-id mapping failed\n");
    }
    
    if (kb->mdef && kb->dict) {	/* Initialize dict2pid */
	kb->dict2pid = dict2pid_build (kb->mdef, kb->dict);
    }
    
    /* ***************** Verifications ***************** */
    E_INFO("Verifying models consistency:\n");
    
    if (kb->fcb && kb->mgau) {
	/* Verify feature streams against gauden codebooks */
	if (feat_stream_len(kb->fcb, 0) != mgau_veclen(kb->mgau))
	    E_FATAL("Feature streamlen(%d) != mgau streamlen(%d)\n",
		    feat_stream_len(kb->fcb, 0), mgau_veclen(kb->mgau));
    }
    
    if (kb->mdef && kb->mgau) {
	/* Verify senone parameters against model definition parameters */
	if (kb->mdef->n_sen != mgau_n_mgau(kb->mgau))
	    E_FATAL("Mdef #senones(%d) != mgau #senones(%d)\n",
		    kb->mdef->n_sen, mgau_n_mgau(kb->mgau));
    }
    
    if (kb->mdef && kb->tmat) {
	/* Verify transition matrices parameters against model definition parameters */
	if (kb->mdef->n_tmat != kb->tmat->n_tmat)
	    E_FATAL("Mdef #tmat(%d) != tmatfile(%d)\n", kb->mdef->n_tmat, kb->tmat->n_tmat);
	if (kb->mdef->n_emit_state != kb->tmat->n_state)
	    E_FATAL("Mdef #states(%d) != tmat #states(%d)\n",
		    kb->mdef->n_emit_state, kb->tmat->n_state);
    }
    
    return kb;
}

/* RAH 4.19.01 free memory allocated within this module */
void kbcore_free (kbcore_t *kbcore)
{
  feat_t *fcb = kbcore_fcb (kbcore); /*  */
  mdef_t *mdef = kbcore_mdef(kbcore);
  dict_t *dict = kbcore_dict (kbcore);
  dict2pid_t *dict2pid = kbcore_dict2pid (kbcore);		/*  */
  /*   dictword_t *word;   */
  lm_t *lm = kbcore_lm (kbcore); /*  */


  lm_free (lm);
  
  /* Clean up the dictionary stuff*/
  dict_free (dict);


  /* dict2pid */
  ckd_free ((void *) dict2pid->comwt );
  ckd_free ((void *) dict2pid->comsseq );
  ckd_free ((void *) dict2pid->comstate );
  ckd_free_2d ((void *) dict2pid->single_lc );
  ckd_free_3d ((void ***) dict2pid->ldiph_lc );
  
  /* RAH, this bombs    
     for (i=0;i<dict_size(dict);i++) 
     ckd_free ((void *) dict2pid->internal[i]); 
  */
  ckd_free ((void *) dict2pid->internal);

  /* Clean up the mdef stuff */  
  mdef_free (mdef);

  fillpen_free (kbcore->fillpen);

  tmat_free (kbcore->tmat);
  subvq_free (kbcore->svq);
  mgau_free (kbcore->mgau);

  /* memory allocated in kbcore*/
  if (fcb) {
    ckd_free ((void *)fcb->name);
    ckd_free ((void *)fcb->stream_len);
    ckd_free ((void *)fcb);
  }

  /* Free the memory allocated by this module*/
  logs_free();  
  feat_free (kbcore->fcb);

  /* Free the object */
  ckd_free ((void *) kbcore);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * kbcore.h -- Structures for maintain the main models.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 11-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Removed svqpp stuff.  It doesn't work too well anyway.
 * 
 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added kb_t.svqpp_t and related handling.
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#ifndef _S3_KBCORE_H_
#define _S3_KBCORE_H_

#ifdef __cplusplus
extern "C" {
#endif


#include "libutil.h"
#include "feat.h"
#include "cont_mgau.h"
#include "subvq.h"
#include "mdef.h"
#include "dict.h"
#include "dict2pid.h"
#include "fillpen.h"
#include "lm.h"
#include "wid.h"
#include "tmat.h"


typedef struct {
    feat_t *fcb;
    mdef_t *mdef;
    dict_t *dict;
    dict2pid_t *dict2pid;
    lm_t *lm;
    fillpen_t *fillpen;
    s3lmwid_t *dict2lmwid;
    mgau_model_t *mgau;
    subvq_t *svq;
    tmat_t *tmat;
} kbcore_t;


/*
 * Initialize one or more of all the major models:  pronunciation dictionary, acoustic models,
 * language models.  Several arguments are optional (e.g., pointers may be NULL); however, they
 * may not all be independently so.  The logbase argument is required (i.e. must be valid).
 * A number of consistency verifications are carried out.  It's recommended that a reasonable
 * default be provided for any real or integer argument, even if it's unused.
 * Return value: (obvious) pointer to structure encapsulating the individual data bases.
 * NOTE: If any model fails to initialize, the call fails with a FATAL ERROR.
 */
kbcore_t *kbcore_init (float64 logbase,		/* Must be specified */
		       char *feattype,
		       char *cmn,
		       char *varnorm,
		       char *agc,
		       char *mdeffile,
		       char *dictfile,
		       char *fdictfile,
		       char *compsep,		/* Must be valid if dictfile specified */
		       char *lmfile,
		       char *fillpenfile,
		       float64 silprob,		/* Must be valid if lmfile/fillpenfile is
						   specified */
		       float64 fillprob,	/* Must be valid if lmfile/fillpenfile is
						   specified */
		       float64 langwt,		/* Must be valid if lmfile/fillpenfile is
						   specified. */
		       float64 inspen,		/* Must be valid if lmfile/fillpenfile is
						   specified. */
		       float64 uw,		/* Must be valid if lmfile/fillpenfile is
						   specified. */
		       char *meanfile,		/* Acoustic model... */
		       char *varfile,		/* Must be specified if meanfile specified */
		       float64 varfloor,	/* Must be valid if varfile specified */
		       char *mixwfile,		/* Must be specified if meanfile specified */
		       float64 mixwfloor,	/* Must be valid if mixwfile specified */
		       char *subvqfile,		/* Subvector quantized acoustic model
						   (quantized mean/var values), optional */
		       char *tmatfile,
		       float64 tmatfloor);	/* Must be valid if tmatfile specified */

  void kbcore_free (kbcore_t *kbcore);


/* Access macros; not meant for arbitrary use */
#define kbcore_fcb(k)		((k)->fcb)
#define kbcore_mdef(k)		((k)->mdef)
#define kbcore_dict(k)		((k)->dict)
#define kbcore_dict2pid(k)	((k)->dict2pid)
#define kbcore_lm(k)		((k)->lm)
#define kbcore_fillpen(k)	((k)->fillpen)
#define kbcore_dict2lmwid(k,w)	((k)->dict2lmwid[w])
#define kbcore_mgau(k)		((k)->mgau)
#define kbcore_svq(k)		((k)->svq)
#define kbcore_tmat(k)		((k)->tmat)

#ifdef __cplusplus
}
#endif

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * kb.h -- Knowledge bases, search parameters, and auxiliary structures for decoding
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 07-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added kb_t.ci_active.
 * 
 * 02-Jun-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_KB_H_
#define _S3_KB_H_


#include "libutil.h"
#include "kbcore.h"
#include "lextree.h"
#include "vithist.h"
#include "ascr.h"
#include "beam.h"


/*
 * There can be several unigram lextrees.  If we're at the end of frame f, we can only
 * transition into the roots of lextree[(f+1) % n_lextree]; same for fillertree[].  This
 * alleviates the problem of excessive Viterbi pruning in lextrees.
 */

typedef struct {
    kbcore_t *kbcore;		/* Core model structures */
    
    int32 n_lextree;		/* See above comment about n_lextree */
    lextree_t **ugtree;
    lextree_t **fillertree;
    int32 n_lextrans;		/* #Transitions to lextree (root) made so far */
    
    vithist_t *vithist;		/* Viterbi history, built during search */
    
    float32 ***feat;		/* Feature frames */
    int32 nfr;			/* #Frames in feat in current utterance */
    
    int32 *ssid_active;		/* For determining the active senones in any frame */
    int32 *comssid_active;
    int32 *sen_active;
    
    int32 bestscore;		/* Best HMM state score in current frame */
    int32 bestwordscore;	/* Best wordexit HMM state score in current frame */
    
    ascr_t *ascr;		/* Senone and composite senone scores for one frame */
    beam_t *beam;		/* Beamwidth parameters */
    
    char *uttid;
    
    int32 utt_hmm_eval;
    int32 utt_sen_eval;
    int32 utt_gau_eval;
    int32 *hmm_hist;		/* Histogram: #frames in which a given no. of HMMs are active */
    int32 hmm_hist_bins;	/* #Bins in above histogram */
    int32 hmm_hist_binsize;	/* Binsize in above histogram (#HMMs/bin) */
    
    ptmr_t tm_sen;
    ptmr_t tm_srch;
    int32 tot_fr;
    float64 tot_sen_eval;	/* Senones evaluated over the entire session */
    float64 tot_gau_eval;	/* Gaussian densities evaluated over the entire session */
    float64 tot_hmm_eval;	/* HMMs evaluated over the entire session */
    float64 tot_wd_exit;	/* Words hypothesized over the entire session */
    
    FILE *matchsegfp;
} kb_t;

void kb_init (kb_t *kb);
void kb_lextree_active_swap (kb_t *kb);
void kb_free (kb_t *kb);	/* RAH 4.16.01 */


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * lextree.c -- 
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified some functions to be able to deal with HMMs with any number
 * 		of states.  Modified lextree_hmm_eval() to dynamically call the
 * 		appropriate hmm_vit_eval routine.
 * 
 * 07-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lextree_node_t.ci and lextree_ci_active().
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "lextree.h"


/*
 * Lextree nodes, and the HMMs contained within, are cleared upon creation, and whenever
 * they become active during search.  Thus, when activated during search, they are always
 * "ready-to-use".  And, when cleaning up after an utterance, only the active nodes need
 * be cleaned up.
 */


static lextree_node_t *lextree_node_alloc (int32 wid, int32 prob,
					   int32 comp, int32 ssid, int32 n_state, int32 ci)
{
    lextree_node_t *ln;
    
    ln = (lextree_node_t *) mymalloc (sizeof(lextree_node_t));
    ln->children = NULL;
    ln->wid = wid;
    ln->prob = prob;
    ln->ssid = ssid;
    ln->ci = (s3cipid_t) ci;
    ln->composite = comp;
    ln->frame = -1;
    ln->hmm.state = (hmm_state_t *) ckd_calloc (n_state, sizeof(hmm_state_t));
    
    hmm_clear (&(ln->hmm), n_state);
    ln->synch = 0;
    return ln;
}


lextree_t *lextree_build (kbcore_t *kbc, wordprob_t *wordprob, int32 n_word, s3cipid_t *lc)
{
    mdef_t *mdef;
    dict_t *dict;
    tmat_t *tmat;
    dict2pid_t *d2p;
    s3ssid_t *ldiph_lc;
    lextree_t *lextree;
    lextree_lcroot_t *lcroot;
    int32 n_lc, n_node, n_ci, n_sseq, pronlen, ssid, prob, ci, rc, wid, np, n_st;
    lextree_node_t *ln=0, **parent, **ssid2ln;
    gnode_t *gn=0;
    bitvec_t *ssid_lc;
    int32 i, j, k, p;
    
    mdef = kbc->mdef;
    dict = kbc->dict;
    tmat = kbc->tmat;
    d2p = kbc->dict2pid;
    n_ci = mdef_n_ciphone (mdef);
    n_sseq = mdef_n_sseq (mdef);
    n_st = mdef_n_emit_state (mdef);
    
    lextree = (lextree_t *) ckd_calloc (1, sizeof(lextree_t));
    lextree->root = NULL;
    
    /* Table mapping from root level ssid to lexnode (temporary) */
    ssid2ln = (lextree_node_t **) ckd_calloc (n_sseq, sizeof(lextree_node_t *));
    
    /* ssid_lc[ssid] = bitvec indicating which lc's this (root) ssid is entered under */
    ssid_lc = (bitvec_t *) ckd_calloc (n_sseq, sizeof(bitvec_t));
    for (i = 0; i < n_sseq; i++)
	ssid_lc[i] = bitvec_alloc (n_ci);
    
    n_node = 0;
    
    /* Create top-level structures pointing to (shared) lextrees for each left context */
    n_lc = 0;
    lcroot = NULL;
    if (! lc) {
	lextree->n_lc = 0;
	lextree->lcroot = NULL;
	
	parent = (lextree_node_t **) ckd_calloc (1, sizeof(lextree_node_t *));
    } else {
	for (n_lc = 0; IS_S3CIPID(lc[n_lc]); n_lc++);
	assert (n_lc > 0);
	
	lextree->n_lc = n_lc;
	lcroot = (lextree_lcroot_t *) ckd_calloc (n_lc, sizeof(lextree_lcroot_t));
	lextree->lcroot = lcroot;
	
	for (i = 0; i < n_lc; i++) {
	    lcroot[i].lc = lc[i];
	    lcroot[i].root = NULL;
	}
	
	parent = (lextree_node_t **) ckd_calloc (n_lc, sizeof(lextree_node_t *));
    }
    
    /*
     * Build up lextree for each word.  For each word:
     *   for each phone position {
     *     see if node already exists in lextree built so far;
     *     if so, share it, otherwise create one (this becomes the parent whose subtree will be
     *       searched for the next phone position);
     *   }
     * 
     * parent[]: A temporary structure during the addition of one word W to the lextree.
     * Normally, when a phone position p of W is added to the lextree, it has one parent node.
     * But when the parent is at the root level, there can actually be several parents, for the
     * different left contexts.  (Hence, parent[] instead of a scalar parent.  Beyond the root
     * level, only parent[0] is useful.)  Furthermore, root parents may share nodes (with same
     * ssid).  Maintain only the unique set.
     * 
     * Other points worth mentioning:
     * - Leaf nodes are not shared among words
     * - (LM) prob at any node is the max of the probs of words reachable from that node
     */
    for (i = 0; i < n_word; i++) {
	wid = wordprob[i].wid;
	prob = wordprob[i].prob;
	
	pronlen = dict_pronlen(dict, wid);
	
	if (pronlen == 1) {
	    /* Single phone word; node(s) not shared with any other word */
	    ci = dict_pron(dict, wid, 0);
	    if (! lc) {
		ln = lextree_node_alloc (wid, prob, 1, d2p->internal[wid][0], n_st,
					 dict_pron(dict, wid, 0));
		ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];	/* Assuming CI tmat!! */
		
		lextree->root = glist_add_ptr (lextree->root, (void *) ln);
		n_node++;
	    } else {
		np = 0;
		for (j = 0; j < n_lc; j++) {
		    ssid = d2p->single_lc[ci][(int)lc[j]];
		    
		    /* Check if this ssid already allocated for another lc */
		    for (k = 0; (k < np) && (parent[k]->ssid != ssid); k++);
		    if (k >= np) {	/* Not found; allocate new node */
			ln = lextree_node_alloc (wid, prob, 1, ssid, n_st, ci);
			ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];
			
			lextree->root = glist_add_ptr (lextree->root, (void *) ln);
			n_node++;
			
			lcroot[j].root = glist_add_ptr (lcroot[j].root, (void *) ln);
			parent[np++] = ln;
		    } else {	/* Already exists; link to lcroot[j] */
			lcroot[j].root = glist_add_ptr (lcroot[j].root, (void *)parent[k]);
		    }
		}
	    }
	} else {
	    assert (pronlen > 1);
	    
	    /* Multi-phone word; allocate root node(s) first, if not already present */
	    if (! lc) {
		ssid = d2p->internal[wid][0];
		ci = dict_pron(dict, wid, 0);
		
		/* Check if this ssid already allocated for another word */
		for (gn = lextree->root; gn; gn = gnode_next(gn)) {
		    ln = (lextree_node_t *) gnode_ptr (gn);
		    if ((ln->ssid == ssid) && ln->composite && NOT_S3WID(ln->wid))
			break;
		}
		if (! gn) {
		    ln = lextree_node_alloc (BAD_S3WID, prob, 1, ssid, n_st, ci);
		    ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];
		    
		    lextree->root = glist_add_ptr (lextree->root, (void *) ln);
		    n_node++;
		} else {
		    if (ln->prob < prob)
			ln->prob = prob;
		}
		parent[0] = ln;
		np = 1;
	    } else {
		ci = dict_pron(dict, wid, 0);
		rc = dict_pron(dict, wid, 1);
		ldiph_lc = d2p->ldiph_lc[ci][rc];
		
		np = 0;
		for (j = 0; j < n_lc; j++) {
		    ssid = ldiph_lc[(int)lc[j]];
		    
		    /* Check if ssid already allocated */
		    ln = ssid2ln[ssid];
		    if (! ln) {
			ln = lextree_node_alloc (BAD_S3WID, prob, 0, ssid, n_st, ci);
			ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];
			lextree->root = glist_add_ptr (lextree->root, (void *) ln);
			n_node++;
			
			ssid2ln[ssid] = ln;
		    } else if (ln->prob < prob)
			ln->prob = prob;
		    
		    /* Check if lexnode already entered under lcroot[lc] */
		    if (bitvec_is_clear (ssid_lc[ssid], lc[j])) {
			lcroot[j].root = glist_add_ptr (lcroot[j].root, (void *) ln);
			bitvec_set (ssid_lc[ssid], lc[j]);
		    }
		    
		    /* Add to parent_list if not already there */
		    for (k = 0; (k < np) && (parent[k]->ssid != ssid); k++);
		    if (k >= np)
			parent[np++] = ln;
		}
	    }
	    
	    /* Rest of the pronunciation except the final one */
	    for (p = 1; p < pronlen-1; p++) {
		ssid = d2p->internal[wid][p];
		ci = dict_pron(dict, wid, p);
		
		/* Check for ssid under each parent (#parents(np) > 1 only when p==1) */
		for (j = 0; j < np; j++) {
		    for (gn = parent[j]->children; gn; gn = gnode_next(gn)) {
			ln = (lextree_node_t *) gnode_ptr(gn);
			
			if ((ln->ssid == ssid) && (! ln->composite)) {
			    assert (NOT_S3WID(ln->wid));
			    break;
			}
		    }
		    if (gn)
			break;
		}
		
		if (! gn) {	/* Not found under any parent; allocate new node */
		    ln = lextree_node_alloc (BAD_S3WID, prob, 0, ssid, n_st, ci);
		    ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];
		    
		    for (j = 0; j < np; j++)
			parent[j]->children = glist_add_ptr (parent[j]->children, (void *)ln);
		    n_node++;
		} else {	/* Already exists under parent[j] */
		    if (ln->prob < prob)
			ln->prob = prob;
		    
		    k = j;
		    
		    /* Child was not found under parent[0..k-1]; add */
		    for (j = 0; j < k; j++)
			parent[j]->children = glist_add_ptr(parent[j]->children, (void *)ln);
		    
		    /* Parents beyond k have not been checked; add if not present */
		    for (j = k+1; j < np; j++) {
			if (! glist_chkdup_ptr (parent[j]->children, (void *)ln))
			    parent[j]->children = glist_add_ptr(parent[j]->children, (void *)ln);
		    }
		}
		
		parent[0] = ln;
		np = 1;
	    }
	    
	    /* Final (leaf) node, no sharing */
	    ssid = d2p->internal[wid][p];
	    ci = dict_pron(dict, wid, p);
	    ln = lextree_node_alloc (wid, prob, 1, ssid, n_st, ci);
	    ln->hmm.tp = tmat->tp[mdef_pid2tmatid (mdef, ci)];
	    
	    for (j = 0; j < np; j++)
		parent[j]->children = glist_add_ptr (parent[j]->children, (void *)ln);
	    n_node++;
	}
    }
    
    lextree->n_node = n_node;
    
    lextree->active = (lextree_node_t **) ckd_calloc (n_node, sizeof(lextree_node_t *));
    lextree->next_active = (lextree_node_t **) ckd_calloc (n_node, sizeof(lextree_node_t *));
    lextree->n_active = 0;
    lextree->n_next_active = 0;
    
    ckd_free ((void *) ssid2ln);
    for (i = 0; i < n_sseq; i++)
	bitvec_free (ssid_lc[i]);
    ckd_free ((void *) ssid_lc);
    ckd_free (parent);
    
    return lextree;
}


static int32 lextree_subtree_free (lextree_node_t *ln, int32 level)
{
    gnode_t *gn;
    lextree_node_t *ln2;
    int32 k;
    
    k = 0;

    /* Free subtrees below this node */
    for (gn = ln->children; gn; gn = gnode_next(gn)) {
	ln2 = (lextree_node_t *) gnode_ptr (gn);
	k += lextree_subtree_free (ln2, level+1);
    }
    glist_free (ln->children);
    ln->children = NULL;
    
    /* Free this node, but for level-1 nodes only if reference count drops to 0 */
    if ((level != 1) || (--ln->ssid == 0)) {
	myfree ((void *) ln, sizeof(lextree_node_t));
	k++;
    }
    
    return k;
}


/*
 * This is a bit tricky because of the replication of root nodes for different left-contexts.
 * A node just below the root can have more than one parent.  Use reference counts to know how
 * many parents refer to such a node.  Use the lextree_node_t.ssid field for such counts.
 */
void lextree_free (lextree_t *lextree)
{
    gnode_t *gn, *gn2;
    lextree_node_t *ln, *ln2;
    int32 i, k;
    
    if (lextree->n_lc > 0) {
	for (i = 0; i < lextree->n_lc; i++)
	    glist_free (lextree->lcroot[i].root);
	
	ckd_free (lextree->lcroot);
    }
    
    /* Build reference counts for level-1 nodes (nodes just below root) */
    for (gn = lextree->root; gn; gn = gnode_next(gn)) {
	ln = (lextree_node_t *) gnode_ptr (gn);
	for (gn2 = ln->children; gn2; gn2 = gnode_next(gn2)) {
	    ln2 = (lextree_node_t *) gnode_ptr (gn2);
	    if (ln2->composite >= 0) {	/* First visit to this node */
		ln2->composite = -1;
		ln2->ssid = 1;		/* Ref count = 1 */
	    } else
		ln2->ssid++;		/* Increment ref count */
	}
    }
    
    /* Free lextree */
    k = 0;
    for (gn = lextree->root; gn; gn = gnode_next(gn)) {
	ln = (lextree_node_t *) gnode_ptr (gn);
	k += lextree_subtree_free (ln, 0);
    }
    glist_free (lextree->root);
    
    ckd_free ((void *) lextree->active);
    ckd_free ((void *) lextree->next_active);
    
    if (k != lextree->n_node)
	E_ERROR("#Nodes allocated(%d) != #nodes freed(%d)\n", lextree->n_node, k);
    
    ckd_free (lextree);
}


void lextree_ci_active (lextree_t *lextree, bitvec_t ci_active)
{
    lextree_node_t **list, *ln;
    int32 i;
    
    list = lextree->active;
    
    for (i = 0; i < lextree->n_active; i++) {
	ln = list[i];
	bitvec_set (ci_active, ln->ci);
    }
}


void lextree_ssid_active (lextree_t *lextree, int32 *ssid, int32 *comssid)
{
    lextree_node_t **list, *ln;
    int32 i;
    
    list = lextree->active;
    
    for (i = 0; i < lextree->n_active; i++) {
	ln = list[i];
	if (ln->composite) 
	  comssid[ln->ssid] = 1;
	else 
	  ssid[ln->ssid] = 1;
    }
}


void lextree_utt_end (lextree_t *l, kbcore_t *kbc)
{
    mdef_t *mdef;
    lextree_node_t *ln;
    int32 i;
    
    mdef = kbcore_mdef (kbc);
    
    for (i = 0; i < l->n_active; i++) {	/* The inactive ones should already be reset */
	ln = l->active[i];
	
	ln->frame = -1;
	hmm_clear (&(ln->hmm), mdef_n_emit_state(mdef));
    }

    l->n_active = 0;
    l->n_next_active = 0;
}


static void lextree_node_print (lextree_node_t *ln, dict_t *dict, FILE *fp)
{
    fprintf (fp, "wid(%d)pr(%d)com(%d)ss(%d)", ln->wid, ln->prob, ln->composite, ln->ssid);
    if (IS_S3WID(ln->wid))
	fprintf (fp, "%s", dict_wordstr(dict, ln->wid));
    fprintf (fp, "\n");
}


static void lextree_subtree_print (lextree_node_t *ln, int32 level, dict_t *dict, FILE *fp)
{
    int32 i;
    gnode_t *gn;
    
    for (i = 0; i < level; i++)
	fprintf (fp, "    ");
    lextree_node_print (ln, dict, fp);
    
    for (gn = ln->children; gn; gn = gnode_next(gn)) {
	ln = (lextree_node_t *) gnode_ptr (gn);
    	lextree_subtree_print (ln, level+1, dict, fp);
    }
}


void lextree_dump (lextree_t *lextree, dict_t *dict, FILE *fp)
{
    gnode_t *gn;
    lextree_node_t *ln;
    int32 i;
    
    for (gn = lextree->root; gn; gn = gnode_next(gn)) {
	ln = (lextree_node_t *) gnode_ptr (gn);
    	lextree_subtree_print (ln, 0, dict, fp);
    }
    
    if (lextree->n_lc > 0) {
	for (i = 0; i < lextree->n_lc; i++) {
	    fprintf (fp, "lcroot %d\n", lextree->lcroot[i].lc);
	    for (gn = lextree->lcroot[i].root; gn; gn = gnode_next(gn)) {
		ln = (lextree_node_t *) gnode_ptr(gn);
		lextree_node_print (ln, dict, fp);
	    }
	}
    }
}


void lextree_enter (lextree_t *lextree, s3cipid_t lc, int32 cf,
		    int32 inscore, int32 inhist, int32 thresh)
{
    glist_t root;
    gnode_t *gn;
    lextree_node_t *ln;
    int32 nf, scr;
    int32 i, n;
    hmm_t *hmm;
    
    nf = cf+1;
    
    /* Locate root nodes list */
    if (lextree->n_lc == 0) {
	assert (NOT_S3CIPID(lc));
	root = lextree->root;
    } else {
	for (i = 0; (i < lextree->n_lc) && (lextree->lcroot[i].lc != lc); i++);
	assert (i < lextree->n_lc);
	
	root = lextree->lcroot[i].root;
    }
    
    /* Enter root nodes */
    n = lextree->n_next_active;
    for (gn = root; gn; gn = gnode_next(gn)) {
	ln = (lextree_node_t *) gnode_ptr (gn);
	
	hmm = &(ln->hmm);
	
	scr = inscore + ln->prob;
	if ((scr >= thresh) && (hmm->in.score < scr)) {
	    hmm->in.score = scr;
	    hmm->in.history = inhist;
	    
	    if (ln->frame != nf) {
		ln->frame = nf;
		lextree->next_active[n++] = ln;
	    }
	} /* else it is activated separately */
    }
    lextree->n_next_active = n;
}


void lextree_active_swap (lextree_t *lextree)
{
    lextree_node_t **t;
    
    t = lextree->active;
    lextree->active = lextree->next_active;
    lextree->next_active = t;
    lextree->n_active = lextree->n_next_active;
    lextree->n_next_active = 0;
}


int32 lextree_hmm_eval (lextree_t *lextree, kbcore_t *kbc, ascr_t *ascr, int32 frm, FILE *fp)
{
    int32 best, wbest, n_st;
    int32 i, k;
    lextree_node_t **list, *ln;
    mdef_t *mdef;
    dict2pid_t *d2p;
    
    mdef = kbc->mdef;
    d2p = kbc->dict2pid;
    n_st = mdef_n_emit_state (mdef);
    
    list = lextree->active;
    best = MAX_NEG_INT32;
    wbest = MAX_NEG_INT32;
    
    if (DEBUG&0x2) printf("n_active is %d\n",lextree->n_active);

    if (fp) {
	for (i = 0; i < lextree->n_active; i++) {
	    ln = list[i];
	    assert (ln->frame == frm);
	    
	    lextree_node_print (ln, kbc->dict, fp);
	    
	    if (! ln->composite)
		k = hmm_dump_vit_eval (&(ln->hmm), n_st,
				       mdef->sseq[ln->ssid], ascr->sen, fp);
	    else
		k = hmm_dump_vit_eval (&(ln->hmm), n_st,
				       d2p->comsseq[ln->ssid], ascr->comsen, fp);
	    
	    if (best < k)
		best = k;
	    
	    if (IS_S3WID(ln->wid)) {
		if (wbest < k)
		    wbest = k;
	    }
	}
    } else {
	if (n_st == 3) {
	  if (DEBUG&0x2) E_INFO("same tree starts here n_active %d\n\n",lextree->n_active);
	    for (i = 0; i < lextree->n_active; i++) {
		ln = list[i];
		/*printf ("i is %d\n", i);*/
		assert (ln->frame == frm);
		if (DEBUG&0x2) E_INFO("%p\n",ln);
		if (! ln->composite)
		    k = hmm_vit_eval_3st (&(ln->hmm), mdef->sseq[ln->ssid], ascr->sen);
		else
		    k = hmm_vit_eval_3st (&(ln->hmm), d2p->comsseq[ln->ssid], ascr->comsen);
		
		if (best < k)
		    best = k;
		
		if (IS_S3WID(ln->wid)) {
		    if (wbest < k)
			wbest = k;
		}
	    }
	} else if (n_st == 5) {
	    for (i = 0; i < lextree->n_active; i++) {
		ln = list[i];
		assert (ln->frame == frm);
		
		if (! ln->composite)
		    k = hmm_vit_eval_5st (&(ln->hmm), mdef->sseq[ln->ssid], ascr->sen);
		else
		    k = hmm_vit_eval_5st (&(ln->hmm), d2p->comsseq[ln->ssid], ascr->comsen);
		
		if (best < k)
		    best = k;
		
		if (IS_S3WID(ln->wid)) {
		    if (wbest < k)
			wbest = k;
		}
	    }
	} else
	    E_FATAL("#State= %d unsupported\n", n_st);
    }
    
    lextree->best = best;
    lextree->wbest = wbest;
    
    if (fp) {
	fprintf (fp, "Fr %d  #active %d  best %d  wbest %d\n",
		 frm, lextree->n_active, best, wbest);
	fflush (fp);
    }
    
    return best;
}


void lextree_hmm_histbin (lextree_t *lextree, int32 bestscr, int32 *bin, int32 nbin, int32 bw)
{
    lextree_node_t **list, *ln;
    hmm_t *hmm;
    int32 i, k;
    glist_t *binln;
    gnode_t *gn;
    
    binln = (glist_t *) ckd_calloc (nbin, sizeof(glist_t));
    
    list = lextree->active;
    
    for (i = 0; i < lextree->n_active; i++) {
	ln = list[i];
	hmm = &(ln->hmm);
	
	k = (bestscr - hmm->bestscore) / bw;
	if (k >= nbin)
	    k = nbin-1;
	assert (k >= 0);
	
	bin[k]++;
	binln[k] = glist_add_ptr (binln[k], (void *) ln);
    }
    
    /* Reorder the active lexnodes in APPROXIMATELY descending scores */
    k = 0;
    for (i = 0; i < nbin; i++) {
	for (gn = binln[i]; gn; gn = gnode_next(gn)) {
	    ln = (lextree_node_t *) gnode_ptr (gn);
	    list[k++] = ln;
	}
	glist_free (binln[i]);
    }
    assert (k == lextree->n_active);
    
    ckd_free ((void *) binln);
}


void lextree_hmm_propagate (lextree_t *lextree, kbcore_t *kbc, vithist_t *vh,
			    int32 cf, int32 th, int32 pth, int32 wth)
{
    mdef_t *mdef;
    int32 nf, newscore;
    lextree_node_t **list, *ln, *ln2;
    hmm_t *hmm, *hmm2;
    gnode_t *gn;
    int32 i, n;
    
    mdef = kbcore_mdef(kbc);
    
    nf = cf+1;
    
    list = lextree->active;
    
    n = lextree->n_next_active;
    assert (n == 0);
    for (i = 0; i < lextree->n_active; i++) {
	ln = list[i];
	hmm = &(ln->hmm);
	
	if (ln->frame < nf) {
	    if (hmm->bestscore >= th) {		/* Active in next frm */
		ln->frame = nf;
		lextree->next_active[n++] = ln;
	    } else {				/* Deactivate */
		ln->frame = -1;
		hmm_clear (hmm, mdef_n_emit_state(mdef));
	    }
	}
	
	if (NOT_S3WID(ln->wid)) {		/* Not a leaf node */
#if 0
	    if (((cf % 3) == 0) || (hmm->out.score < pth))
		continue;			/* HMM exit score not good enough */
#else 
	    if (hmm->out.score < pth)
		continue;			/* HMM exit score not good enough */
#endif
	    /* Transition to each child */
	    for (gn = ln->children; gn; gn = gnode_next(gn)) {
		ln2 = gnode_ptr(gn);
		hmm2 = &(ln2->hmm);
		
		newscore = hmm->out.score + (ln2->prob - ln->prob);
		if ((newscore >= th) && (hmm2->in.score < newscore)) {
		    hmm2->in.score = newscore;
		    hmm2->in.history = hmm->out.history;
	    
		    if (ln2->frame != nf) {
			ln2->frame = nf;
			lextree->next_active[n++] = ln2;
		    }
		}
	    }
	} else {			/* Leaf node; word exit */
	    if (hmm->out.score < wth)
		continue;		/* Word exit score not good enough */
	    
	    /* Rescore the LM prob for this word wrt all possible predecessors */
	    vithist_rescore (vh, kbc, ln->wid, cf,
			     hmm->out.score - ln->prob, hmm->out.history, lextree->type);
	}
    }
    lextree->n_next_active = n;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * lextree.h -- 
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified some functions to be able to deal with HMMs with any number
 * 		of states.
 * 
 * 07-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lextree_node_t.ci and lextree_ci_active().
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_LEXTREE_H_
#define _S3_LEXTREE_H_


#include "libutil.h"
#include "kbcore.h"
#include "hmm.h"
#include "vithist.h"
#include "ascr.h"


/*
 * A lextree can be built for a specific history (e.g., for all bigram successors of a given
 * word or trigram successors of a word-pair in a given LM).  The history provides a set of left
 * context CIphones (if the final history word has multiple pronunciations; and there is always
 * <sil>).
 * A lextree is usually a set of trees, one for each distinct root model for the given set of
 * words.  Furthermore, the root node of each tree can itself actually be a SET of nodes,
 * required by the different left contexts.  If there is no history (i.e., the unigram lextree),
 * any CIphone is a potential left-context.  But this can explode the number of root nodes.
 * So, the root nodes of the unigram lextree use COMPOSITE models (see dict2pid.h), merging
 * different contexts into one.  Similarly, the right context (at the leaves of any lextree) is
 * always unknown.  So, all leaf nodes also use composite models.
 * Lextrees are formed by sharing as much of the HMM models as possible (based on senone-seq ID),
 * before having to diverge.  But the leaf nodes are always distinct for each word.
 * Finally, each node has a (language model) probability, given its history.  It is the max. of
 * the LM probability of all the words reachable from that node.  (Strictly speaking, it should
 * be their sum instead of max, but practically it makes little difference.)
 */


/*
 * One node in a lextree.
 */
typedef struct {
    hmm_t hmm;		/* HMM states */
    glist_t children;	/* Its data.ptr are children (lextree_node_t *) */
    int32 wid;		/* Dictionary word-ID if a leaf node; BAD_S3WID otherwise */
    int32 prob;		/* LM probability of this node (of all words leading from this node) */
    int32 ssid;		/* Senone-sequence ID (or composite state-seq ID if composite) */
    s3ssid_t *ssid_lc;	/* Array of ssid's (composite or not) for each left context CIphone;
			   READ-ONLY structure */
    s3cipid_t ci;	/* CIphone id for this node */
    int8 composite;	/* Whether it is a composite model (merging many left/right contexts) */
    s3frmid_t frame;	/* Frame in which this node was last active; <0 if inactive */
  int8 synch;
} lextree_node_t;

/* Access macros; not meant for arbitrary use */
#define lextree_node_wid(n)		((n)->wid)
#define lextree_node_prob(n)		((n)->prob)
#define lextree_node_ssid(n)		((n)->ssid)
#define lextree_node_composite(n)	((n)->composite)
#define lextree_node_frame(n)		((n)->frame)


/*
 * Root nodes of the lextree valid for a given left context CIphone.
 */
typedef struct {
    s3cipid_t lc;	/* Left context CIphone */
    glist_t root;	/* Its data.ptr are the root nodes (lextree_node_t *) of interest; subset
			   of the entire lextree roots */
} lextree_lcroot_t;

/*
 * Entire lextree.
 */
typedef struct {
    int32 type;		/* For use by other modules; NOT maintained here.  For example:
			   N-gram type; 0: unigram lextree, 1: 2g, 2: 3g lextree... */
    glist_t root;	/* The entire set of root nodes (lextree_node_t) for this lextree */
    lextree_lcroot_t *lcroot;	/* Lists of subsets of root nodes; a list for each left context;
				   NULL if n_lc == 0 (i.e., no specific left context) */
    int32 n_lc;		/* No. of separate left contexts being maintained, if any */
    int32 n_node;	/* No. of nodes in this lextree */
    lextree_node_t **active;		/* Nodes active in any frame */
    lextree_node_t **next_active;	/* Like active, but temporary space for constructing the
					   active list for the next frame using the current */
    int32 n_active;		/* No. of nodes active in current frame */
    int32 n_next_active;	/* No. of nodes active in current frame */
    
    int32 best;		/* Best HMM state score in current frame (for pruning) */
    int32 wbest;	/* Best wordexit HMM state score in current frame (for pruning) */
} lextree_t;

/* Access macros; not meant for arbitrary usage */
#define lextree_type(l)			((l)->type)
#define lextree_root(l)			((l)->root)
#define lextree_lcroot(l)		((l)->lcroot)
#define lextree_n_lc(l)			((l)->n_lc)
#define lextree_n_node(l)		((l)->n_node)
#define lextree_active(l)		((l)->active)
#define lextree_next_active(l)		((l)->next_active)
#define lextree_n_active(l)		((l)->n_active)
#define lextree_n_next_active(l)	((l)->n_next_active)


/*
 * Build a lexical tree for the set of words specified in wordprob[] (with their
 * associated LM probabilities).  wordprob[] must contain EXACTLY the set of words for
 * which the lextree is to be built, i.e, including alternatives and excluding OOVs.
 * Return value: Pointer to lextree_t structure representing entire lextree.
 */
lextree_t *
lextree_build (kbcore_t *kbc,		/* In: All the necessary knowledge bases */
	       wordprob_t *wordprob,	/* In: Words in the tree and their (LM) probabilities */
	       int32 n_word,		/* In: Size of the wordprob[] array */
	       s3cipid_t *lc);		/* In: BAD_S3CIPID terminated array of left context
					   CIphones, or NULL if no specific left context */

/* Free a lextree that was created by lextree_build */
void lextree_free (lextree_t *lextree);


/*
 * Reset the entire lextree (to the inactive state).  I.e., mark each HMM node as inactive,
 * (with lextree_node_t.frame = -1), and the active list size to 0.
 */
void lextree_utt_end (lextree_t *l, kbcore_t *kbc);


/*
 * Enter root nodes of lextree for given left-context, with given incoming score/history.
 */
void lextree_enter (lextree_t *lextree,	/* In/Out: Lextree being entered */
		    s3cipid_t lc,	/* In: Left-context if any (can be BAD_S3CIPID) */
		    int32 frame,	/* In: Frame from which being activated (for the next) */
		    int32 inscore,	/* In: Incoming score */
		    int32 inhist,	/* In: Incoming history */
		    int32 thresh);	/* In: Pruning threshold; incoming scores below this
					   threshold will not enter successfully */

/*
 * Swap the active and next_active lists of the given lextree.  (Usually done at the end of
 * each frame: from the current active list, we've built the next_active list for the next
 * frame, and finally need to make the latter the current active list.)
 */
void lextree_active_swap (lextree_t *lextree);


/*
 * Marks the active ssid and composite ssids in the given lextree.  Caller must allocate ssid[]
 * and comssid[].  Caller also responsible for clearing them before calling this function.
 */
void lextree_ssid_active (lextree_t *lextree,	/* In: lextree->active is scanned */
			  int32 *ssid,		/* In/Out: ssid[s] is set to non-0 if senone
						   sequence ID s is active */
			  int32 *comssid);	/* In/Out: comssid[s] is set to non-0 if
						   composite senone sequence ID s is active */

/*
 * For each active lextree node, mark the corresponding CI phone as active.
 */
void lextree_ci_active (lextree_t *lextree,	/* In: Lextree being traversed */
			bitvec_t ci_active);	/* In/Out: Active/inactive flag for ciphones */

/*
 * Evaluate the active HMMs in the given lextree, using the current frame senone scores.
 * Return value: The best HMM state score as a result.
 */
int32 lextree_hmm_eval (lextree_t *lextree,	/* In/Out: Lextree with HMMs to be evaluated */
			kbcore_t *kbc,	/* In: */
			ascr_t *ascr,	/* In: Senone scores (primary and composite) */
			int32 f,	/* In: Frame in which being invoked */
			FILE *fp);	/* In: If not-NULL, dump HMM state (for debugging) */

/*
 * Propagate HMMs in the given lextree through to the start of the next frame.  Called after
 * HMM state scores have been updated.  Marks those with "good" scores as active for the next
 * frame, and propagates HMM exit scores through to successor HMM entry states.
 */
void lextree_hmm_propagate (lextree_t *lextree,	/* In/Out: Propagate scores across HMMs in
						   this lextree */
			    kbcore_t *kbc,	/* In: Core knowledge bases */
			    vithist_t *vh,	/* In/Out: Viterbi history structure to be
						   updated with word exits */
			    int32 cf,		/* In: Current frame */
			    int32 th,		/* In: General (HMM survival) pruning thresh */
			    int32 pth,		/* In: Phone transition pruning threshold */
			    int32 wth);		/* In: Word exit pruning threshold */

/*
 * In order to use histogram pruning, get a histogram of the bestscore of each active HMM in
 * the given lextree.  For a given HMM, its bin is determined by:
 * 	(bestscr - hmm->bestscore) / bw.
 * Invoked right after all active HMMs are evaluated.
 */
void lextree_hmm_histbin (lextree_t *lextree,	/* In: Its active HMM bestscores are used */
			  int32 bestscr,	/* In: Overall bestscore in current frame */
			  int32 *bin,		/* In/Out: The histogram bins; caller allocates
						 * this array */
			  int32 nbin,		/* In: Size of bin[] */
			  int32 bw);		/* In: Bin width; i.e., score range per bin */

/* For debugging */
void lextree_dump (lextree_t *lextree, dict_t *dict, FILE *fp);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * libutil.h -- Collection of all other .h files in this directory; for brevity
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1996 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 08-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added SLEEP_SEC macro.
 * 
 * 08-31-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#ifndef _LIBUTIL_LIBUTIL_H_
#define _LIBUTIL_LIBUTIL_H_


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#ifndef WIN32			/* RAH */
#include <unistd.h>
#endif /* RAH */
#include <math.h>

#include "prim_type.h"

#include "bitvec.h"
#include "case.h"
#include "ckd_alloc.h"
#include "cmd_ln.h"
#include "err.h"
#include "filename.h"
#include "glist.h"
#include "hash.h"
#include "heap.h"
#include "io.h"
#include "profile.h"
#include "str2words.h"
#include "unlimit.h"


#if (WIN32)
#define SLEEP_SEC(sec)	(0)			/* Why doesn't Sleep((sec)*1000) work? */
#else
#define SLEEP_SEC(sec)	(0) /*sleep(sec)*/ /*alex changed*/ /* sec must be integer */
#endif

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#endif

#ifndef M_PI
#define M_PI		3.1415926535897932385	/* For the pain-in-the-neck Win32 */
#endif
#define PI		M_PI


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
 /*************************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 2000 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 *************************************************
 *
 * 13-Apr-2001  Ricky Houghton
 *              Added live_free_memory to clean up memory allocated locally.
 *
 * 01-Jan-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Created a separate function live_get_partialhyp() to 
 *		generate partial hypotheses from the kb structure
 *
 * 31-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 * Created
 */

#include "libutil.h"
#include "kb.h"
#include "utt.h"
#include "cmd_ln_args.h"
#include "new_fe.h"		   /* 01.15.01 - RAH, use new_fe.h instead */
#include "live.h"
#if defined(THRD)
#include "barrier.h"
#endif

#define START_BLOCK 0

static fe_t  *fe;

static kb_t  *kb;
static kbcore_t *kbcore;
static FILE  *hmmdumpfp;
static int32 maxwpf;
static int32 maxhistpf;
static int32 maxhmmpf;
static int32 ptranskip;

static partialhyp_t *parthyp = NULL;
static float32 *dummyframe;
/*newly moved from live_initialize_decoder 9/28/04 */
/*static kb_t live_kb;*/
/********************/

#if defined(THRD)
barrier_t *score_barrier;

#endif

/* This routine initializes decoder variables for live mode decoding */
void live_initialize_decoder(char *live_args)
{
    static kb_t live_kb;
    int32   maxcepvecs, maxhyplen, samprate, ceplen;
    param_t *fe_param;
    char const *uttIdNotDefined = "null";

    parse_args_file(live_args);
    unlimit();
    kb_init(&live_kb);
    kb = &live_kb;
    kbcore = kb->kbcore;

    kb->uttid = ckd_salloc(uttIdNotDefined);
    hmmdumpfp = cmd_ln_int32("-hmmdump") ? stderr : NULL;
    maxwpf    = cmd_ln_int32 ("-maxwpf");
    maxhistpf = cmd_ln_int32 ("-maxhistpf");
    maxhmmpf  = cmd_ln_int32 ("-maxhmmpf");
    ptranskip = cmd_ln_int32 ("-ptranskip");

    maxhyplen = cmd_ln_int32 ("-maxhyplen");
    if (!parthyp) 
        parthyp  = (partialhyp_t *) ckd_calloc(maxhyplen, sizeof(partialhyp_t));

    fe_param = (param_t *) ckd_calloc(1, sizeof(param_t));
    samprate = cmd_ln_int32 ("-samprate");
    if (samprate != 8000 && samprate != 16000)
	E_FATAL("Sampling rate %s not supported. Must be 8000 or 16000\n",samprate);

    fe_param->SAMPLING_RATE = (float32) samprate;
    fe_param->LOWER_FILT_FREQ = cmd_ln_float32("-lowerf");
    fe_param->UPPER_FILT_FREQ = cmd_ln_float32("-upperf");
    fe_param->NUM_FILTERS = cmd_ln_int32("-nfilt");
    fe_param->FRAME_RATE = 100; /* HARD CODED TO 100 FRAMES PER SECOND */
    fe_param->PRE_EMPHASIS_ALPHA = (float32) 0.97;
    fe = fe_init(fe_param);
    if (!fe)
	E_FATAL("Front end initialization fe_init() failed\n");

    maxcepvecs = cmd_ln_int32 ("-maxcepvecs");
    ceplen = kbcore->fcb->cepsize;

    dummyframe = (float32*) ckd_calloc(1 * ceplen,sizeof(float32));	/*  */

#if defined(THRD)
    score_barrier = thread_barrier_init(NUM_THREADS);
    if (!score_barrier)
      E_FATAL("Cannot initialize score_barrier\n");
#endif
}


/* RAH Apr.13.2001: Memory was being held, Added Call fe_close to release memory held by fe and then release locally allocated memory */
int32 live_free_memory ()
{
  parse_args_free();		/* Free memory allocated during the argument parseing stage */
  fe_close (fe);		/*  */
  ckd_free(kb->uttid);  /* Free memory allocated in live_initialize_decoder() */
  kb_free (kb);		/*  */
  ckd_free ((void *) dummyframe); /*  */
  ckd_free ((void *) parthyp);  /*  */
#if defined(THRD)
  thread_barrier_destroy(score_barrier);
#endif
  return (0);
}



/*******************************************************************
 * This routine retrieves the part hypothesis from the kb structure
 * at any stage in the decoding. The "endutt" flag is needed to know
 * whether the utterance is to be considered terminated or not
 * The function stores the partial hypothesis in the global array
 * "parthyp" and returns the number of words in the hypothesis
 *******************************************************************/

int32 live_get_partialhyp(int32 endutt)
{
    int32 id, nwds;
    glist_t   hyp;
    gnode_t   *gn;
    hyp_t     *h;
    dict_t    *dict;

    dict = kbcore_dict (kb->kbcore);
    if (endutt)
        id = vithist_utt_end(kb->vithist, kb->kbcore);
    else
        id = vithist_partialutt_end(kb->vithist, kb->kbcore);

    if (id > 0) {
        hyp = vithist_backtrace(kb->vithist,id);

        for (gn = hyp,nwds=0; gn; gn = gnode_next(gn),nwds++) {
            h = (hyp_t *) gnode_ptr (gn);
            if (parthyp[nwds].word != NULL) {
                ckd_free(parthyp[nwds].word);
                parthyp[nwds].word = NULL;
            }
            parthyp[nwds].word = strdup(dict_wordstr(dict, h->id));
            parthyp[nwds].sf = h->sf;
            parthyp[nwds].ef = h->ef;
	    parthyp[nwds].ascr = h->ascr;
	    parthyp[nwds].lscr = h->lscr;
        }
        if (parthyp[nwds].word != NULL){
            ckd_free(parthyp[nwds].word);
            parthyp[nwds].word = NULL;
        }
        /* Free hyplist */
        for (gn = hyp; gn && (gnode_next(gn)); gn = gnode_next(gn)) {
            h = (hyp_t *) gnode_ptr (gn);
            ckd_free ((void *) h);
        }
        glist_free (hyp);
    } else {
        nwds = 0;
        if (parthyp[nwds].word != NULL) {
            ckd_free(parthyp[nwds].word);
            parthyp[nwds].word = NULL;
        }
    }

    return(nwds);
}


/* Routine to decode a block of incoming samples. A partial hypothesis
 * for the utterance upto the current block of samples is returned.
 * The calling routine has to inform the routine if the block of samples
 * being passed is the final block of samples for an utterance by
 * setting live_endutt to 1. On receipt of a live_endutt flag the routine
 * automatically assumes that the next block of samples is the beginning
 * of a new utterance 
 */

#if 1 
int32 sample_blk = 0;
#endif

int32 live_utt_decode_block (int16 *samples, int32 nsamples, 
		      int32 live_endutt, partialhyp_t **ohyp)
{
    static int32 live_begin_new_utt = 1;
    static int32 frmno;
    float32 **live_feat;
    int32   live_nfr, live_nfeatvec;
    int32   nwds;
    /* int32   id;  */  /* unreferenced variable */
    /* glist_t hyp;  */  /* unreferenced variable */
    /* gnode_t *gn;  */  /* unreferenced variable */
    /* hyp_t   *h;  */  /* unreferenced variable */
    /* dict_t  *dict;  */  /* unreferenced variable */
    float32 **mfcbuf;

    if (live_begin_new_utt){
        fe_start_utt(fe);
	utt_begin (kb);
	frmno = 0;
	kb->nfr = 0;
        kb->utt_hmm_eval = 0;
        kb->utt_sen_eval = 0;
        kb->utt_gau_eval = 0;
        live_begin_new_utt = 0;
    }

    sample_blk++;

    /* 10.jan.01 RAH, fe_process_utt now requires ***mfcbuf and it allocates the memory internally) */
    mfcbuf = NULL;

    live_nfr = fe_process_utt(fe, samples, nsamples, &mfcbuf); /*  */
    if (live_endutt) 		/* RAH, It seems that we shouldn't throw out this data */
        fe_end_utt(fe,dummyframe); /* Flush out the fe */

    /* Compute feature vectors */
    live_nfeatvec = feat_s2mfc2feat_block(kbcore_fcb(kbcore), mfcbuf,
                                         live_nfr, live_begin_new_utt,
					 live_endutt, &live_feat);
    E_INFO ("live_nfeatvec: %ld\n",live_nfeatvec);


    /* decode the block */
    if (sample_blk<=START_BLOCK) 
      single_utt_decode_block (live_feat, live_nfeatvec, &frmno, kb, 
			       maxwpf, maxhistpf, maxhmmpf, ptranskip, hmmdumpfp);
    else 
      utt_decode_block (live_feat, live_nfeatvec, &frmno, kb, 
			maxwpf, maxhistpf, maxhmmpf, ptranskip, hmmdumpfp);

    /* Pull out partial hypothesis */
    nwds =  live_get_partialhyp(live_endutt);
    *ohyp = parthyp;

    /* Clean up */
    if (live_endutt) {
	live_begin_new_utt = 1;
	kb->tot_fr += kb->nfr;
	utt_end(kb);
    }
    else {
	live_begin_new_utt = 0;
    }

    /* I'm starting to think that fe_process_utt should not be allocating its memory,
       that or it should allocate some max and just keep on going, this idea of constantly allocating freeing
       memory seems dangerous to me.*/
    ckd_free_2d((void **) mfcbuf); /* RAH, this must be freed since fe_process_utt allocates it */


    return(nwds);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */

/* 01.18.01 - RAH, allow for C++ compiles */
#ifdef __cplusplus
extern "C" {
#endif

#include "libutil.h"
#include "feat.h"


typedef struct {
    int32 ascr;
    int32 lscr;
    char  *word;
    int32 sf;
    int32 ef;
} partialhyp_t;

void live_initialize_decoder (char *argsfile);

int32 live_get_partialhyp(int32 endutt);

/* Routine to decode a block of incoming samples. A partial hypothesis
 * for the utterance upto the current block of samples is returned.
 * The calling routine has to inform the routine if the block of samples
 * being passed is the final block of samples for an utterance by
 * setting live_endutt to 1. On receipt of a live_endutt flag the routine
 * automatically assumes that the next block of samples is the beginning
 * of a new utterance
 */

int32 live_utt_decode_block (int16 *samples,    /* Incoming samples */
			     int32 nsamples,    /* No. of incoming samples */
                      	     int32 live_endutt, /* End of utterance flag */
			     partialhyp_t **ohyp);

int32 live_free_memory ();
  
#ifdef __cplusplus
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * lm.c -- Disk-based backoff word trigram LM module.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Adding lm_free() to free allocated memory
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Removed language weight application to wip. To maintain
 *		comparability between s3decode and current decoder. Does
 *		not affect decoding performance.
 *
 * 23-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Bugfix: Applied language weight to word insertion penalty.
 * 
 * 24-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lm_t.access_type; made lm_wid externally visible.
 * 
 * 24-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lm_t.log_bg_seg_sz and lm_t.bg_seg_sz.
 * 
 * 13-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Creating from original S3 version.
 */


#include "lm.h"
#include "bio.h"
#include "logs3.h"


#define MIN_PROB_F	((float32)-99.0)


static char *darpa_hdr = "Darpa Trigram LM";
static int LM_IN_MEMORY = 0;	/* RAH, 5.8.01 Allow this as an option to sphinx */


#if 0
int32 lm_delete (lm_t *lm)
{
    int32 i;
    tginfo_t *tginfo, *next_tginfo;
    
    if (lm->fp)
	fclose (lm->fp);
    
    free (lm->ug);

    if (lm->n_bg > 0) {
	if (lm->bg)		/* Memory-based; free all bg */
	    free (lm->bg);
	else {		/* Disk-based; free in-memory bg */
	    for (i = 0; i < lm->n_ug; i++)
		if (lm->membg[i].bg)
		    free (lm->membg[i].bg);
	    free (lm->membg);
	}

	free (lm->bgprob);
    }
    
    if (lm->n_tg > 0) {
	if (lm->tg)		/* Memory-based; free all tg */
	    free (lm->tg);
	for (i = 0; i < lm->n_ug; i++) {	/* Free cached tg access info */
	    for (tginfo = lm->tginfo[i]; tginfo; tginfo = next_tginfo) {
		next_tginfo = tginfo->next;
		if ((! lm->tg) && tginfo->tg)	/* Disk-based; free in-memory tg */
		    free (tginfo->tg);
		free (tginfo);
	    }
	}
	free (lm->tginfo);

	free (lm->tgprob);
	free (lm->tgbowt);
	free (lm->tg_segbase);
    }
    
    for (i = 0; i < lm->n_ug; i++)
	free (lm->wordstr[i]);
    free (lm->wordstr);
    
    free (lm);
    free (lmset[i].name);
    
    for (; i < n_lm-1; i++)
	lmset[i] = lmset[i+1];
    --n_lm;
    
    E_INFO("LM(\"%s\") deleted\n", name);
    
    return (0);
}
#endif


/* Apply unigram weight; should be part of LM creation, but... */
static void lm_uw (lm_t *lm, float64 uw)
{
    int32 i, loguw, loguw_, loguniform, p1, p2;

    /* Interpolate unigram probs with uniform PDF, with weight uw */
    loguw = logs3 (uw);
    loguw_ = logs3 (1.0 - uw);
    loguniform = logs3 (1.0/(lm->n_ug-1));	/* Skipping S3_START_WORD */
    
    for (i = 0; i < lm->n_ug; i++) {
	if (strcmp (lm->wordstr[i], S3_START_WORD) != 0) {
	    p1 = lm->ug[i].prob.l + loguw;
	    p2 = loguniform + loguw_;
	    lm->ug[i].prob.l = logs3_add (p1, p2);
	}
    }
}


static void lm2logs3 (lm_t *lm, float64 uw)
{
    int32 i;

    for (i = 0; i < lm->n_ug; i++) {
	lm->ug[i].prob.l = log10_to_logs3 (lm->ug[i].prob.f);
	lm->ug[i].bowt.l = log10_to_logs3 (lm->ug[i].bowt.f);
    }
    
    lm_uw (lm, uw);
    
    for (i = 0; i < lm->n_bgprob; i++)
	lm->bgprob[i].l = log10_to_logs3 (lm->bgprob[i].f);

    if (lm->n_tg > 0) {
	for (i = 0; i < lm->n_tgprob; i++)
	    lm->tgprob[i].l = log10_to_logs3 (lm->tgprob[i].f);
	for (i = 0; i < lm->n_tgbowt; i++)
	    lm->tgbowt[i].l = log10_to_logs3 (lm->tgbowt[i].f);
    }
}


void lm_set_param (lm_t *lm, float64 lw, float64 wip)
{
    int32 i, iwip;
    float64 f;
    
    if (lw <= 0.0)
	E_FATAL("lw = %e\n", lw);
    if (wip <= 0.0)
	E_FATAL("wip = %e\n", wip);
#if 0 /* No lang weight on wip */
    iwip = logs3(wip) * lw; 
#endif
    iwip = logs3(wip);
    
    f = lw / lm->lw;
    
    for (i = 0; i < lm->n_ug; i++) {
	lm->ug[i].prob.l = (int32)((lm->ug[i].prob.l - lm->wip) * f) + iwip;
	lm->ug[i].bowt.l = (int32)(lm->ug[i].bowt.l * f);
    }

    for (i = 0; i < lm->n_bgprob; i++)
	lm->bgprob[i].l = (int32)((lm->bgprob[i].l - lm->wip) * f) + iwip;

    if (lm->n_tg > 0) {
	for (i = 0; i < lm->n_tgprob; i++)
	    lm->tgprob[i].l = (int32)((lm->tgprob[i].l - lm->wip) * f) + iwip;
	for (i = 0; i < lm->n_tgbowt; i++)
	    lm->tgbowt[i].l = (int32)(lm->tgbowt[i].l * f);
    }

    lm->lw = (float32) lw;
    lm->wip = iwip;
}


static int32 lm_fread_int32 (lm_t *lm)
{
    int32 val;
    
    if (fread (&val, sizeof(int32), 1, lm->fp) != 1)
	E_FATAL("fread failed\n");
    if (lm->byteswap)
	SWAP_INT32(&val);
    return (val);
}


/*
 * Read LM dump (<lmname>.DMP) file and make it the current LM.
 * Same interface as lm_read except that the filename refers to a .DMP file.
 */
static lm_t *lm_read_dump (char *file, float64 lw, float64 wip, float64 uw)
{
    lm_t *lm;
    int32 i, j, k, vn;
    char str[1024];
    char *tmp_word_str;
    s3lmwid_t startwid, endwid;
    
    lm = (lm_t *) ckd_calloc (1, sizeof(lm_t));
    
    if ((lm->fp = fopen (file, "rb")) == NULL)
	E_FATAL_SYSTEM("fopen(%s,rb) failed\n", file);
    
    /* Standard header string-size; set byteswap flag based on this */
    if (fread (&k, sizeof(int32), 1, lm->fp) != 1)
	E_FATAL("fread(%s) failed\n", file);
    if ((size_t)k == strlen(darpa_hdr)+1)
	lm->byteswap = 0;
    else {
	SWAP_INT32(&k);
	if ((size_t)k == strlen(darpa_hdr)+1)
	    lm->byteswap = 1;
	else {
	    SWAP_INT32(&k);
	    E_FATAL("Bad magic number: %d(%08x), not an LM dumpfile??\n", k, k);
	}
    }

    /* Read and verify standard header string */
    if (fread (str, sizeof (char), k, lm->fp) != (size_t)k)
	E_FATAL("fread(%s) failed\n", file);
    if (strncmp (str, darpa_hdr, k) != 0)
	E_FATAL("Bad header\n");

    /* Original LM filename string size and string */
    k = lm_fread_int32 (lm);
    if ((k < 1) || (k > 1024))
	E_FATAL("Bad original filename size: %d\n", k);
    if (fread (str, sizeof (char), k, lm->fp) != (size_t)k)
	E_FATAL("fread(%s) failed\n", file);

    /* Version#.  If present (must be <= 0); otherwise it's actually the unigram count */
    vn = lm_fread_int32 (lm);
    if (vn <= 0) {
	/* Read and skip orginal file timestamp; (later compare timestamps) */
	k = lm_fread_int32 (lm);

	/* Read and skip format description */
	for (;;) {
	    if ((k = lm_fread_int32 (lm)) == 0)
		break;
	    if (fread (str, sizeof(char), k, lm->fp) != (size_t)k)
		E_FATAL("fread(%s) failed\n", file);
	}

	/* Read log_bg_seg_sz if present */
	if (vn <= -2) {
	    k = lm_fread_int32 (lm);
	    if ((k < 1) || (k > 15))
		E_FATAL("log2(bg_seg_sz) outside range 1..15\n", k);
	    lm->log_bg_seg_sz = k;
	} else
	    lm->log_bg_seg_sz = LOG2_BG_SEG_SZ;	/* Default */

	/* Read #ug */
	lm->n_ug = lm_fread_int32 (lm);
    } else {
	/* No version number, actually a unigram count */
	lm->n_ug = vn;
	lm->log_bg_seg_sz = LOG2_BG_SEG_SZ;	/* Default */
    }
    if ((lm->n_ug <= 0) || (lm->n_ug >= MAX_S3LMWID))
	E_FATAL("Bad #unigrams: %d (must be >0, <%d\n", lm->n_ug, MAX_S3LMWID);

    lm->bg_seg_sz = 1 << lm->log_bg_seg_sz;

    /* #bigrams */
    lm->n_bg = lm_fread_int32 (lm);
    if (lm->n_bg < 0)
	E_FATAL("Bad #bigrams: %d\n", lm->n_bg);

    /* #trigrams */
    lm->n_tg = lm_fread_int32 (lm);
    if (lm->n_tg < 0)
	E_FATAL("Bad #trigrams: %d\n", lm->n_tg);

    /* Read unigrams; remember sentinel ug at the end! */
    lm->ug = (ug_t *) ckd_calloc (lm->n_ug+1, sizeof(ug_t));
    if (fread (lm->ug, sizeof(ug_t), lm->n_ug+1, lm->fp) != (size_t)(lm->n_ug+1))
	E_FATAL("fread(%s) failed\n", file);
    if (lm->byteswap)
	for (i = 0; i <= lm->n_ug; i++) {
	    SWAP_INT32(&(lm->ug[i].prob.l));
	    SWAP_INT32(&(lm->ug[i].bowt.l));
	    SWAP_INT32(&(lm->ug[i].firstbg));
	}
    E_INFO("%8d unigrams\n", lm->n_ug);

    /* Space for in-memory bigrams/trigrams info; FOR NOW, DISK-BASED LM OPTION ONLY!! */

    /* RAH, 5.1.01 - Let's try reading the whole damn thing in here   */
    if (LM_IN_MEMORY) {
      lm->bg = (bg_t *) ckd_calloc (lm->n_bg+1,sizeof(bg_t));
      lm->tg = (tg_t *) ckd_calloc (lm->n_tg+1,sizeof(tg_t));

      if (lm->n_bg > 0) {       /* Read bigrams; remember sentinel at the end */
	lm->bgoff = ftell (lm->fp);
	fread (lm->bg, lm->n_bg+1,sizeof(bg_t),lm->fp);
	E_INFO("Read %8d bigrams [in memory]\n", lm->n_bg);
	
	lm->membg = (membg_t *) ckd_calloc (lm->n_ug, sizeof(membg_t));
      }
      
      if (lm->n_tg > 0) {       /* Read trigrams */
	lm->tgoff = ftell (lm->fp);
	fread (lm->tg,lm->n_tg,sizeof(tg_t),lm->fp);
	E_INFO("Read %8d trigrams [in memory]\n", lm->n_tg);
	
	lm->tginfo = (tginfo_t **) ckd_calloc (lm->n_ug, sizeof(tginfo_t *));
      }
    } else {
    lm->bg = NULL;
    lm->tg = NULL;

    /* Skip bigrams; remember sentinel at the end */
    if (lm->n_bg > 0) {
	lm->bgoff = ftell (lm->fp);
	fseek (lm->fp, (lm->n_bg+1) * sizeof(bg_t), SEEK_CUR);
	E_INFO("%8d bigrams [on disk]\n", lm->n_bg);
	lm->membg = (membg_t *) ckd_calloc (lm->n_ug, sizeof(membg_t));
    }
    
    /* Skip trigrams */
    if (lm->n_tg > 0) {
	lm->tgoff = ftell (lm->fp);
	fseek (lm->fp, lm->n_tg * sizeof(tg_t), SEEK_CUR);
	E_INFO("%8d trigrams [on disk]\n", lm->n_tg);

	lm->tginfo = (tginfo_t **) ckd_calloc (lm->n_ug, sizeof(tginfo_t *));
    }
    }
    
    if (lm->n_bg > 0) {
	/* Bigram probs table size */
	lm->n_bgprob = lm_fread_int32 (lm);
	if ((lm->n_bgprob <= 0) || (lm->n_bgprob > 65536))
	    E_FATAL("Bad bigram prob table size: %d\n", lm->n_bgprob);
	
	/* Allocate and read bigram probs table */
	lm->bgprob = (lmlog_t *) ckd_calloc (lm->n_bgprob, sizeof (lmlog_t));
	if (fread(lm->bgprob, sizeof(lmlog_t), lm->n_bgprob, lm->fp) !=
	    (size_t)lm->n_bgprob)
	    E_FATAL("fread(%s) failed\n", file);
	if (lm->byteswap) {
	    for (i = 0; i < lm->n_bgprob; i++)
		SWAP_INT32(&(lm->bgprob[i].l));
	}

	E_INFO("%8d bigram prob entries\n", lm->n_bgprob);
    }

    if (lm->n_tg > 0) {
	/* Trigram bowt table size */
	lm->n_tgbowt = lm_fread_int32 (lm);
	if ((lm->n_tgbowt <= 0) || (lm->n_tgbowt > 65536))
	    E_FATAL("Bad trigram bowt table size: %d\n", lm->n_tgbowt);
	
	/* Allocate and read trigram bowt table */
	lm->tgbowt = (lmlog_t *) ckd_calloc (lm->n_tgbowt, sizeof (lmlog_t));
	if (fread (lm->tgbowt, sizeof (lmlog_t), lm->n_tgbowt, lm->fp) !=
	    (size_t)lm->n_tgbowt)
	    E_FATAL("fread(%s) failed\n", file);
	if (lm->byteswap) {
	    for (i = 0; i < lm->n_tgbowt; i++)
		SWAP_INT32(&(lm->tgbowt[i].l));
	}
	E_INFO("%8d trigram bowt entries\n", lm->n_tgbowt);

	/* Trigram prob table size */
	lm->n_tgprob = lm_fread_int32 (lm);
	if ((lm->n_tgprob <= 0) || (lm->n_tgprob > 65536))
	    E_FATAL("Bad trigram bowt table size: %d\n", lm->n_tgprob);
	
	/* Allocate and read trigram bowt table */
	lm->tgprob = (lmlog_t *) ckd_calloc (lm->n_tgprob, sizeof (lmlog_t));
	if (fread (lm->tgprob, sizeof (lmlog_t), lm->n_tgprob, lm->fp) !=
	    (size_t)lm->n_tgprob)
	    E_FATAL("fread(%s) failed\n", file);
	if (lm->byteswap) {
	    for (i = 0; i < lm->n_tgprob; i++)
		SWAP_INT32(&(lm->tgprob[i].l));
	}
	E_INFO("%8d trigram prob entries\n", lm->n_tgprob);

	/* Trigram seg table size */
	k = lm_fread_int32 (lm);
	if (k != (lm->n_bg+1)/lm->bg_seg_sz+1)
	    E_FATAL("Bad trigram seg table size: %d\n", k);
	
	/* Allocate and read trigram seg table */
	lm->tg_segbase = (int32 *) ckd_calloc (k, sizeof(int32));
	if (fread (lm->tg_segbase, sizeof(int32), k, lm->fp) != (size_t)k)
	    E_FATAL("fread(%s) failed\n", file);
	if (lm->byteswap) {
	    for (i = 0; i < k; i++)
		SWAP_INT32(&(lm->tg_segbase[i]));
	}
	E_INFO("%8d trigram segtable entries (%d segsize)\n", k, lm->bg_seg_sz);
    }

    /* Read word string names */
    k = lm_fread_int32 (lm);
    if (k <= 0)
	E_FATAL("Bad wordstrings size: %d\n", k);
    
    tmp_word_str = (char *) ckd_calloc (k, sizeof (char));
    if (fread (tmp_word_str, sizeof(char), k, lm->fp) != (size_t)k)
	E_FATAL("fread(%s) failed\n", file);

    /* First make sure string just read contains ucount words (PARANOIA!!) */
    for (i = 0, j = 0; i < k; i++)
	if (tmp_word_str[i] == '\0')
	    j++;
    if (j != lm->n_ug)
	E_FATAL("Bad #words: %d\n", j);

    /* Break up string just read into words */
    startwid = endwid = BAD_S3LMWID;
    lm->wordstr = (char **) ckd_calloc (lm->n_ug, sizeof(char *));
    j = 0;
    for (i = 0; i < lm->n_ug; i++) {
	if (strcmp (tmp_word_str+j, S3_START_WORD) == 0)
	    startwid = i;
	else if (strcmp (tmp_word_str+j, S3_FINISH_WORD) == 0)
	    endwid = i;

	lm->wordstr[i] = (char *) ckd_salloc (tmp_word_str+j);
	
	j += strlen(tmp_word_str+j) + 1;
    }
    free (tmp_word_str);
    E_INFO("%8d word strings\n", i);
    
    /* Force ugprob(<s>) = MIN_PROB_F */
    if (IS_S3LMWID(startwid)) {
	lm->ug[startwid].prob.f = MIN_PROB_F;
	lm->startlwid = startwid;
    }
    
    /* Force bowt(</s>) = MIN_PROB_F */
    if (IS_S3LMWID(endwid)) {
	lm->ug[endwid].bowt.f = MIN_PROB_F;
	lm->finishlwid = endwid;
    }
    
    lm2logs3 (lm, uw);	/* Applying unigram weight; convert to logs3 values */
    
    /* Apply the new lw and wip values */
    lm->lw = 1.0;	/* The initial settings for lw and wip */
    lm->wip = 0;	/* logs3(1.0) */
    lm_set_param (lm, lw, wip);
    
    return lm;
}


lm_t *lm_read (char *file, float64 lw, float64 wip, float64 uw)
{
    int32 i, u;
    lm_t *lm;
    
    if (! file)
	E_FATAL("No LM file\n");
    if (lw <= 0.0)
	E_FATAL("lw = %e\n", lw);
    if (wip <= 0.0)
	E_FATAL("wip = %e\n", wip);
    if ((uw < 0.0) || (uw > 1.0))
	E_FATAL("uw = %e\n", uw);
    
    E_INFO ("LM read('%s', lw= %.2f, wip= %d, uw= %.2f)\n", file, lw, logs3(wip), uw);
    if (cmd_ln_int32 ("-lminmemory")) 
      LM_IN_MEMORY = 1;    
    else
      LM_IN_MEMORY = 0;
    
    /* For now, only dump files can be read; they are created offline */
    lm = lm_read_dump (file, lw, wip, uw);

    for (u = 0; u < lm->n_ug; u++)
	lm->ug[u].dictwid = BAD_S3WID;
    
    /* Initialize the fast trigram cache, with all entries invalid */
    lm->tgcache = (lm_tgcache_entry_t *) ckd_calloc(LM_TGCACHE_SIZE, sizeof(lm_tgcache_entry_t));
    for (i = 0; i < LM_TGCACHE_SIZE; i++)
	lm->tgcache[i].lwid[0] = BAD_S3LMWID;
    
    return lm;
}


/*
 * Free stale bigram and trigram info, those not used since last reset.
 */
void lm_cache_reset (lm_t *lm)
{
    int32 i, n_bgfree, n_tgfree;
    tginfo_t *tginfo, *next_tginfo, *prev_tginfo;
    
    n_bgfree = n_tgfree = 0;
    
  if (LM_IN_MEMORY)		/* RAH We are going to short circuit this if we are running with the lm in memory */
    return;
  
    if ((lm->n_bg > 0) && (! lm->bg)) {	/* Disk-based; free "stale" bigrams */
	for (i = 0; i < lm->n_ug; i++) {
	    if (lm->membg[i].bg && (! lm->membg[i].used)) {
		lm->n_bg_inmem -= lm->ug[i+1].firstbg - lm->ug[i].firstbg;

		free (lm->membg[i].bg);
		lm->membg[i].bg = NULL;
		n_bgfree++;
	    }

	    lm->membg[i].used = 0;
	}
    }
    
    if (lm->n_tg > 0) {
	for (i = 0; i < lm->n_ug; i++) {
	    prev_tginfo = NULL;
	    for (tginfo = lm->tginfo[i]; tginfo; tginfo = next_tginfo) {
		next_tginfo = tginfo->next;
		
		if (! tginfo->used) {
		    if ((! lm->tg) && tginfo->tg) {
			lm->n_tg_inmem -= tginfo->n_tg;
			free (tginfo->tg);
			n_tgfree++;
		    }
		    
		    free (tginfo);
		    if (prev_tginfo)
			prev_tginfo->next = next_tginfo;
		    else
			lm->tginfo[i] = next_tginfo;
		} else {
		    tginfo->used = 0;
		    prev_tginfo = tginfo;
		}
	    }
	}
    }

    if ((n_tgfree > 0) || (n_bgfree > 0)) {
	E_INFO("%d tg frees, %d in mem; %d bg frees, %d in mem\n",
	       n_tgfree, lm->n_tg_inmem, n_bgfree, lm->n_bg_inmem);
    }
}


void lm_cache_stats_dump (lm_t *lm)
{
    E_INFO("%9d tg(), %9d tgcache, %8d bo; %5d fills, %8d in mem (%.1f%%)\n",
	   lm->n_tg_score, lm->n_tgcache_hit, lm->n_tg_bo, lm->n_tg_fill, lm->n_tg_inmem,
	   (lm->n_tg_inmem*100.0)/(lm->n_tg+1));
    E_INFO("%8d bg(), %8d bo; %5d fills, %8d in mem (%.1f%%)\n",
	   lm->n_bg_score, lm->n_bg_bo, lm->n_bg_fill, lm->n_bg_inmem,
	   (lm->n_bg_inmem*100.0)/(lm->n_bg+1));
    
    lm->n_tgcache_hit = 0;
    lm->n_tg_fill = 0;
    lm->n_tg_score = 0;
    lm->n_tg_bo = 0;
    lm->n_bg_fill = 0;
    lm->n_bg_score = 0;
    lm->n_bg_bo = 0;
}


int32 lm_ug_score (lm_t *lm, s3lmwid_t wid)
{
    if (NOT_S3LMWID(wid) || (wid >= lm->n_ug))
	E_FATAL("Bad argument (%d) to lm_ug_score\n", wid);

    lm->access_type = 1;
    
    return (lm->ug[wid].prob.l);
}


int32 lm_uglist (lm_t *lm, ug_t **ugptr)
{
    *ugptr = lm->ug;
    return (lm->n_ug);
}


int32 lm_ug_wordprob (lm_t *lm, int32 th, wordprob_t *wp)
{
    int32 i, j, n, p;
    s3wid_t w;
    
    n = lm->n_ug;
    
    for (i = 0, j = 0; i < n; i++) {
	w = lm->ug[i].dictwid;
	
	if (IS_S3WID(w)) {
	    if ((p = lm->ug[i].prob.l) >= th) {
		wp[j].wid = w;
		wp[j].prob = p;
		j++;
	    }
	}
    }
    
    return j;
}


/*
 * Load bigrams for the given unigram (LMWID) lw1 from disk into memory
 */
static void load_bg (lm_t *lm, s3lmwid_t lw1)
{
    int32 i, n, b;
    bg_t *bg;
    
    b = lm->ug[lw1].firstbg;		/* Absolute first bg index for ug lw1 */
    n = lm->ug[lw1+1].firstbg - b;	/* Not including guard/sentinel */
    
  if (LM_IN_MEMORY)		/* RAH, if LM_IN_MEMORY, then we don't need to go get it. */
    bg = lm->membg[lw1].bg = &lm->bg[b];
  else {
    bg = lm->membg[lw1].bg = (bg_t *) ckd_calloc (n+1, sizeof(bg_t));
    
    if (fseek (lm->fp, lm->bgoff + b*sizeof(bg_t), SEEK_SET) < 0)
	E_FATAL_SYSTEM ("fseek failed\n");
    
    /* Need to read n+1 because obtaining tg count for one bg also depends on next bg */
    if (fread (bg, sizeof(bg_t), n+1, lm->fp) != (size_t)(n+1))
	E_FATAL("fread failed\n");
    if (lm->byteswap) {
	for (i = 0; i <= n; i++) {
	    SWAP_INT16(&(bg[i].wid));
	    SWAP_INT16(&(bg[i].probid));
	    SWAP_INT16(&(bg[i].bowtid));
	    SWAP_INT16(&(bg[i].firsttg));
	}
    }
  }
    lm->n_bg_fill++;
    lm->n_bg_inmem += n;
}


#define BINARY_SEARCH_THRESH	16

/* Locate a specific bigram within a bigram list */
static int32 find_bg (bg_t *bg, int32 n, s3lmwid_t w)
{
    int32 i, b, e;
    
    /* Binary search until segment size < threshold */
    b = 0;
    e = n;
    while (e-b > BINARY_SEARCH_THRESH) {
	i = (b+e)>>1;
	if (bg[i].wid < w)
	    b = i+1;
	else if (bg[i].wid > w)
	    e = i;
	else
	    return i;
    }

    /* Linear search within narrowed segment */
    for (i = b; (i < e) && (bg[i].wid != w); i++);
    return ((i < e) ? i : -1);
}


int32 lm_bglist (lm_t *lm, s3lmwid_t w1, bg_t **bgptr, int32 *bowt)
{
    int32 n;

    if (NOT_S3LMWID(w1) || (w1 >= lm->n_ug))
	E_FATAL("Bad w1 argument (%d) to lm_bglist\n", w1);

    n = (lm->n_bg > 0) ? lm->ug[w1+1].firstbg - lm->ug[w1].firstbg : 0;
    
    if (n > 0) {
	if (! lm->membg[w1].bg)
	    load_bg (lm, w1);
	lm->membg[w1].used = 1;

	*bgptr = lm->membg[w1].bg;
	*bowt = lm->ug[w1].bowt.l;
    } else {
	*bgptr = NULL;
	*bowt = 0;
    }
    
    return (n);
}


int32 lm_bg_wordprob (lm_t *lm, s3lmwid_t lwid, int32 th, wordprob_t *wp, int32 *bowt)
{
    bg_t *bgptr;
    int32 i, j, n, ugprob, bgprob;
    s3wid_t w;
    
    n = lm_bglist (lm, lwid, &bgptr, bowt);
    ugprob = lm_ug_score (lm, lwid);
    
    /* Convert bglist to wordprob */
    for (i = 0, j = 0; i < n; i++, bgptr++) {
	w = lm->ug[bgptr->wid].dictwid;
	if (IS_S3WID (w)) {
	    bgprob = LM_BGPROB(lm, bgptr);
	    
	    if (ugprob + bgprob >= th) {	/* ABSOLUTE prob (count) >= min thresh */
		wp[j].wid = w;
		wp[j].prob = bgprob;
		j++;
	    }
	}
    }
    
    return j;
}


int32 lm_bg_score (lm_t *lm, s3lmwid_t w1, s3lmwid_t w2)
{
    int32 i, n, score;
    bg_t *bg=0;

    if ((lm->n_bg == 0) || (NOT_S3LMWID(w1)))
	return (lm_ug_score (lm, w2));

    lm->n_bg_score++;

    if (NOT_S3LMWID(w2) || (w2 >= lm->n_ug))
	E_FATAL("Bad w2 argument (%d) to lm_bg_score\n", w2);
    
    n = lm->ug[w1+1].firstbg - lm->ug[w1].firstbg;
    
    if (n > 0) {
	if (! lm->membg[w1].bg)
	    load_bg (lm, w1);
	lm->membg[w1].used = 1;
	bg = lm->membg[w1].bg;

	i = find_bg (bg, n, w2);
    } else
	i = -1;
    
    if (i >= 0) {
	score = lm->bgprob[bg[i].probid].l;
	lm->access_type = 2;
    } else {
	lm->n_bg_bo++;
	lm->access_type = 1;
	score = lm->ug[w1].bowt.l + lm->ug[w2].prob.l;
    }

#if 0
    printf ("      %5d %5d -> %8d\n", lw1, lw2, score);
#endif

    return (score);
}


static void load_tg (lm_t *lm, s3lmwid_t lw1, s3lmwid_t lw2)
{
    int32 i, n, b;
    int32 t = -1; /* Let's make sure that if t isn't initialized after the
					    * "if" statement below, it makes things go bad */
    bg_t *bg;
    tg_t *tg;
    tginfo_t *tginfo;
    
    /* First allocate space for tg information for bg lw1,lw2 */
    tginfo = (tginfo_t *) ckd_malloc (sizeof(tginfo_t));
    tginfo->w1 = lw1;
    tginfo->tg = NULL;
    tginfo->next = lm->tginfo[lw2];
    lm->tginfo[lw2] = tginfo;
    
    /* Locate bigram lw1,lw2 */

    b = lm->ug[lw1].firstbg;
    n = lm->ug[lw1+1].firstbg - b;
    
    /* Make sure bigrams for lw1, if any, loaded into memory */
    if (n > 0) {
	if (! lm->membg[lw1].bg)
	    load_bg (lm, lw1);
	lm->membg[lw1].used = 1;
	bg = lm->membg[lw1].bg;
    }

    /* At this point, n = #bigrams for lw1 */
    if ((n > 0) && ((i = find_bg (bg, n, lw2)) >= 0)) {
	tginfo->bowt = lm->tgbowt[bg[i].bowtid].l;
	
	/* Find t = Absolute first trigram index for bigram lw1,lw2 */
	b += i;			/* b = Absolute index of bigram lw1,lw2 on disk */
	t = lm->tg_segbase[b >> lm->log_bg_seg_sz];
	t += bg[i].firsttg;
	
	/* Find #tg for bigram w1,w2 */
	n = lm->tg_segbase[(b+1) >> lm->log_bg_seg_sz];
	n += bg[i+1].firsttg;
	n -= t;
	tginfo->n_tg = n;
    } else {			/* No bigram w1,w2 */
	tginfo->bowt = 0;
	n = tginfo->n_tg = 0;
    }

    /* "t" has not been assigned any meanigful value, so if you use it
     * beyond this point, make sure it's been properly assigned.
     */   
    /*	assert (t != -1);*/

    /* At this point, n = #trigrams for lw1,lw2.  Read them in */

    if (LM_IN_MEMORY) {
		/* RAH, already have this in memory */
      if (n > 0){
	assert(t != -1);
	tg = tginfo->tg = &lm->tg[t];
      }
    } else {
    if (n > 0) {
	tg = tginfo->tg = (tg_t *) ckd_calloc (n, sizeof(tg_t));
	if (fseek (lm->fp, lm->tgoff + t*sizeof(tg_t), SEEK_SET) < 0)
	    E_FATAL_SYSTEM("fseek failed\n");

	if (fread (tg, sizeof(tg_t), n, lm->fp) != (size_t)n)
	    E_FATAL("fread(tg, %d at %d) failed\n", n, lm->tgoff);
	if (lm->byteswap) {
	    for (i = 0; i < n; i++) {
		SWAP_INT16(&(tg[i].wid));
		SWAP_INT16(&(tg[i].probid));
	    }
	}
    }
    }
    lm->n_tg_fill++;
    lm->n_tg_inmem += n;
}


/* Similar to find_bg */
static int32 find_tg (tg_t *tg, int32 n, s3lmwid_t w)
{
    int32 i, b, e;
    
    b = 0;
    e = n;
    while (e-b > BINARY_SEARCH_THRESH) {
	i = (b+e)>>1;
	if (tg[i].wid < w)
	    b = i+1;
	else if (tg[i].wid > w)
	    e = i;
	else
	    return i;
    }
    
    for (i = b; (i < e) && (tg[i].wid != w); i++);
    return ((i < e) ? i : -1);
}


int32 lm_tglist (lm_t *lm, s3lmwid_t lw1, s3lmwid_t lw2, tg_t **tgptr, int32 *bowt)
{
    tginfo_t *tginfo, *prev_tginfo;

    if (lm->n_tg <= 0) {
	*tgptr = NULL;
	*bowt = 0;
	return 0;
    }
    
    if (NOT_S3LMWID(lw1) || (lw1 >= lm->n_ug))
	E_FATAL("Bad lw1 argument (%d) to lm_tglist\n", lw1);
    if (NOT_S3LMWID(lw2) || (lw2 >= lm->n_ug))
	E_FATAL("Bad lw2 argument (%d) to lm_tglist\n", lw2);

    prev_tginfo = NULL;
    for (tginfo = lm->tginfo[lw2]; tginfo; tginfo = tginfo->next) {
	if (tginfo->w1 == lw1)
	    break;
	prev_tginfo = tginfo;
    }
    
    if (! tginfo) {
    	load_tg (lm, lw1, lw2);
	tginfo = lm->tginfo[lw2];
    } else if (prev_tginfo) {
	prev_tginfo->next = tginfo->next;
	tginfo->next = lm->tginfo[lw2];
	lm->tginfo[lw2] = tginfo;
    }
    tginfo->used = 1;

    *tgptr = tginfo->tg;
    *bowt = tginfo->bowt;

    return (tginfo->n_tg);
}


int32 lm_tg_score (lm_t *lm, s3lmwid_t lw1, s3lmwid_t lw2, s3lmwid_t lw3)
{
    int32 i, h, n, score;
    tg_t *tg;
    tginfo_t *tginfo, *prev_tginfo;
    
    if ((lm->n_tg == 0) || (NOT_S3LMWID(lw1)))
	return (lm_bg_score (lm, lw2, lw3));
    
    lm->n_tg_score++;

    if (NOT_S3LMWID(lw1) || (lw1 >= lm->n_ug))
	E_FATAL("Bad lw1 argument (%d) to lm_tg_score\n", lw1);
    if (NOT_S3LMWID(lw2) || (lw2 >= lm->n_ug))
	E_FATAL("Bad lw2 argument (%d) to lm_tg_score\n", lw2);
    if (NOT_S3LMWID(lw3) || (lw3 >= lm->n_ug))
	E_FATAL("Bad lw3 argument (%d) to lm_tg_score\n", lw3);
    
    /* Lookup tgcache first; compute hash(lw1, lw2, lw3) */
    h = ((lw1 & 0x000003ff) << 21) + ((lw2 & 0x000003ff) << 11) + (lw3 & 0x000007ff);
    h %= LM_TGCACHE_SIZE;
    if ((lm->tgcache[h].lwid[0] == lw1) &&
	(lm->tgcache[h].lwid[1] == lw2) &&
	(lm->tgcache[h].lwid[2] == lw3)) {
	lm->n_tgcache_hit++;
	return lm->tgcache[h].lscr;
    }
    
    prev_tginfo = NULL;
    for (tginfo = lm->tginfo[lw2]; tginfo; tginfo = tginfo->next) {
	if (tginfo->w1 == lw1)
	    break;
	prev_tginfo = tginfo;
    }
    
    if (! tginfo) {
    	load_tg (lm, lw1, lw2);
	tginfo = lm->tginfo[lw2];
    } else if (prev_tginfo) {
	prev_tginfo->next = tginfo->next;
	tginfo->next = lm->tginfo[lw2];
	lm->tginfo[lw2] = tginfo;
    }

    tginfo->used = 1;
    
    /* Trigrams for w1,w2 now in memory; look for w1,w2,w3 */
    n = tginfo->n_tg;
    tg = tginfo->tg;
    if ((i = find_tg (tg, n, lw3)) >= 0) {
	score = lm->tgprob[tg[i].probid].l;
	lm->access_type = 3;
    } else {
	lm->n_tg_bo++;
	score = tginfo->bowt + lm_bg_score(lm, lw2, lw3);
    }

#if 0
    printf ("%5d %5d %5d -> %8d\n", lw1, lw2, lw3, score);
#endif
    
    lm->tgcache[h].lwid[0] = lw1;
    lm->tgcache[h].lwid[1] = lw2;
    lm->tgcache[h].lwid[2] = lw3;
    lm->tgcache[h].lscr = score;
    
    return (score);
}


s3lmwid_t lm_wid (lm_t *lm, char *word)
{
    int32 i;
    
    for (i = 0; i < lm->n_ug; i++)
	if (strcmp (lm->wordstr[i], word) == 0)
	    return ((s3lmwid_t) i);
    
    return BAD_S3LMWID;
}

void lm_free (lm_t *lm)
{
  int i;

  for (i=0;i<lm->n_ug;i++) 
    ckd_free ((void *) lm->wordstr[i]);	/*  */
  ckd_free ((void *) lm->membg);
  ckd_free ((void *) lm->wordstr);
  ckd_free ((void *) lm->tgcache);
  ckd_free ((void *) lm->tg_segbase);
  ckd_free ((void *) lm->tgprob);
  ckd_free ((void *) lm->tgbowt);
  ckd_free ((void *) lm->bgprob);
  ckd_free ((void *) lm->tginfo);
  ckd_free ((void *) lm->ug);  
  ckd_free ((void *) lm);
  
}


#if (_LM_TEST_)
static int32 sentence_lmscore (lm_t *lm, char *line)
{
    char *word[1024];
    s3lmwid_t w[1024];
    int32 nwd, score, tgscr;
    int32 i, j;
    
    if ((nwd = str2words (line, word, 1020)) < 0)
	E_FATAL("Increase word[] and w[] arrays size\n");
    
    w[0] = BAD_S3LMWID;
    w[1] = lm_wid (lm, S3_START_WORD);
    if (NOT_S3LMWID(w[1]))
	E_FATAL("Unknown word: %s\n", S3_START_WORD);
    
    for (i = 0; i < nwd; i++) {
	w[i+2] = lm_wid (lm, word[i]);
	if (NOT_S3LMWID(w[i+2])) {
	    E_ERROR("Unknown word: %s\n", word[i]);
	    return 0;
	}
    }

    w[i+2] = lm_wid (lm, S3_FINISH_WORD);
    if (NOT_S3LMWID(w[i+2]))
	E_FATAL("Unknown word: %s\n", S3_FINISH_WORD);
    
    score = 0;
    for (i = 0, j = 2; i <= nwd; i++, j++) {
	tgscr = lm_tg_score (lm, w[j-2], w[j-1], w[j]);
	score += tgscr;
	printf ("\t%10d %s\n", tgscr, lm->wordstr[w[j]]);
    }
    
    return (score);
}


main (int32 argc, char *argv[])
{
    char line[4096];
    int32 score, k;
    lm_t *lm;
    
    if (argc < 2)
	E_FATAL("Usage: %s <LMdumpfile>\n", argv[0]);

    logs3_init (1.0001);
    lm = lm_read (argv[1], 9.5, 0.2);

    if (1) {			/* Short cut this so we can test for memory leaks */
      for (;;) {
	printf ("> ");
	if (fgets (line, sizeof(line), stdin) == NULL)
	    break;
	
	score = sentence_lmscore (lm, line);

	k = strlen(line);
	if (line[k-1] == '\n')
	    line[k-1] = '\0';
	printf ("LMScr(%s) = %d\n", line, score);
      }
    } /*  */
    lm_free(lm);
    exit (0);
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * lm.h - Disk/memory based word-trigram backoff LM
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 *
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Adding lm_free() to free allocated memory
 * 
 * 24-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lm_t.access_type; made lm_wid externally visible.
 * 
 * 24-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added lm_t.log_bg_seg_sz and lm_t.bg_seg_sz.
 * 
 * 13-Feb-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 *              Created from original S3 version.
 */


#ifndef _S3_LM_H_
#define _S3_LM_H_


#include "libutil.h"
#include "s3types.h"


/* Log quantities represented in either floating or integer format */
typedef union {
    float32 f;
    int32 l;
} lmlog_t;

typedef struct {
    s3wid_t dictwid;	/* Dictionary word id, or BAD_S3WID if unknown.  However, the LM
			   module merely sets this field to BAD_S3WID.  It is upto the
			   application to fill in this field (HACK!!), so that this
			   module can be independent of a dictionary. */
    lmlog_t prob;
    lmlog_t bowt;
    int32 firstbg;	/* 1st bigram entry on disk */
} ug_t;

typedef struct {
    s3lmwid_t wid;	/* LM wid (index into lm_t.ug) */
    uint16 probid;
    uint16 bowtid;
    uint16 firsttg;     /* 1st trigram entry on disk (see tg_segbase below) */
} bg_t;

typedef struct {
    s3lmwid_t wid;	/* LM wid (index into lm_t.ug) */
    uint16 probid;
} tg_t;


/*
 * Management of in-memory bigrams.  Not used if all bigrams in memory.
 */
typedef struct {
    bg_t *bg;		/* Bigrams for a specific unigram; see lm_t.membg */
    int32 used;		/* Whether used since last lm_reset.  If not used, at the next
			   lm_reset bg are freed */
} membg_t;

/*
 * The following trigram information cache eliminates most traversals of 1g->2g->3g
 * tree to locate trigrams for a given bigram (w1,w2).  The organization is optimized
 * for locality of access.  All bigrams (*,w2) for a given w2, for which trigrams have
 * been accessed "recently", form a linear linked list, pointed to by lm_t.tginfo[w2].
 * If disk-based, all trigrams for the given bg loaded upon request.  Cached info (and
 * tg if disk-based) freed at lm_reset if not used since last such reset.
 */
typedef struct tginfo_s {
    s3lmwid_t w1;		/* w1 component of bigram w1,w2.  All bigrams with
				   same w2 linked together. */
    int32 n_tg;			/* #tg for parent bigram w1,w2 */
    tg_t *tg;			/* Trigrams for w1,w2 */
    int32 bowt;			/* tg bowt for w1,w2 */
    int32 used;			/* whether used since last lm_reset */
    struct tginfo_s *next;	/* Next w1 with same parent w2 */
} tginfo_t;


/*
 * Entries in a fast and dirty cache for trigram lookups.  See lm_t.tgcache.
 */
typedef struct {
    s3lmwid_t lwid[3];		/* 0 = oldest, 2 = newest (i.e., P(2|0,1)) */
    int32 lscr;			/* LM score for above trigram */
} lm_tgcache_entry_t;


/*
 * To conserve space, bg/tg probs/ptrs kept in many tables.  Since the number of
 * distinct prob values << #bg/#tg, these table indices can be easily fit into
 * 16 bits.  bgprob and bgbowt are such indices.  The firsttg entry for a bigram
 * is harder.  It is supposed to be the index of the first trigram entry for each
 * bigram.  But #tg can be >> 2^16.  Hence the following segmentation scheme:
 * Partition bigrams into segments of lm_t.bg_seg_sz consecutive entries, such that
 * #trigrams in each segment <= 2**16 (the corresponding trigram segment).  The
 * bigram_t.firsttg value is then a 16-bit relative index within the trigram
 * segment.  A separate table--lm_t.tg_segbase--has the absolute index of the
 * 1st trigram for each segment.
 */

/* Default values for lm_t.log_bg_seg.sz */
#define LOG2_BG_SEG_SZ  9	
#define BG_SEG_SZ       (1 << (LOG2_BG_SEG_SZ))

#define LM_TGCACHE_SIZE		100003	/* A prime no. (hopefully it IS one!) */


/*
 * The language model.
 * All unigrams are read into memory on initialization.
 * Bigrams and trigrams read in on demand.
 */
typedef struct lm_s {
    int32 n_ug;         /* #unigrams in LM */
    int32 n_bg;         /* #bigrams in entire LM */
    int32 n_tg;         /* #trigrams in entire LM */
    int32 max_ug;       /* To which n_ug can grow with dynamic addition of words */
    
    char **wordstr;	/* The LM word list (in unigram order) */
    
    s3lmwid_t startlwid;	/* S3_START_WORD id, if it exists */
    s3lmwid_t finishlwid;	/* S3_FINISH_WORD id, if it exists */
    
    int32 log_bg_seg_sz;/* See big comment above */
    int32 bg_seg_sz;
    
    ug_t *ug;           /* Unigrams */
    bg_t *bg;		/* NULL iff disk-based */
    tg_t *tg;		/* NULL iff disk-based */
    membg_t *membg;	/* membg[w1] = bigrams for lm wid w1 (used iff disk-based) */
    tginfo_t **tginfo;	/* tginfo[w2] = fast trigram access info for bigrams (*,w2) */
    
    lmlog_t *bgprob;    /* Table of actual bigram probs */
    lmlog_t *tgprob;    /* Table of actual trigram probs */
    lmlog_t *tgbowt;    /* Table of actual trigram backoff weights */
    int32 *tg_segbase;  /* tg_segbase[i>>lm_t.log_bg_seg_sz] = index of 1st
			   trigram for bigram segment (i>>lm_t.log_bg_seg_sz) */
    int32 n_bgprob;
    int32 n_tgprob;
    int32 n_tgbowt;

    FILE *fp;
    int32 byteswap;     /* Whether this file is in the WRONG byte order */
    int32 bgoff;        /* BG and TG offsets into DMP file (used iff disk-based) */
    int32 tgoff;

    float32 lw;		/* Language weight currently in effect for this LM */
    int32 wip;          /* logs3(word insertion penalty) in effect for this LM */
    
    /*
     * <w0,w1,w2> hashed to an entry into this array.  Only the last trigram mapping to any
     * given hash entry is kept in that entry.  (The cache doesn't have to be super-efficient.)
     */
    lm_tgcache_entry_t *tgcache;
    
    /* Statistics */
    int32 n_bg_fill;    /* #bg fill operations */
    int32 n_bg_inmem;   /* #bg in memory */
    int32 n_bg_score;   /* #bg_score operations */
    int32 n_bg_bo;	/* #bg_score ops backed off to ug */
    int32 n_tg_fill;	/* Similar stats for trigrams */
    int32 n_tg_inmem;
    int32 n_tg_score;
    int32 n_tg_bo;
    int32 n_tgcache_hit;
    
    int32 access_type;	/* Updated on every lm_{tg,bg,ug}_score call to reflect the kind of
			   n-gram accessed: 3 for 3-gram, 2 for 2-gram and 1 for 1-gram */
} lm_t;

/* Access macros; not meant for arbitrary use */
#define lm_lmwid2dictwid(lm,u)	((lm)->ug[u].dictwid)
#define lm_n_ug(lm)		((lm)->n_ug)
#define lm_n_bg(lm)		((lm)->n_bg)
#define lm_n_tg(lm)		((lm)->n_tg)
#define lm_wordstr(lm,u)	((lm)->wordstr[u])
#define lm_startwid(lm)		((lm)->startlwid)
#define lm_finishwid(lm)	((lm)->finishlwid)
#define lm_access_type(lm)	((lm)->access_type)


/* Generic structure that could be used at any n-gram level */
typedef struct {
    s3wid_t wid;	/* NOTE: dictionary wid; may be BAD_S3WID if not available */
    int32 prob;
} wordprob_t;


/*
 * Read an LM (dump) file; return pointer to LM structure created.
 */
lm_t *lm_read (char *file,	/* In: LM file being read */
	       float64 lw,	/* In: Language weight */
	       float64 wip,	/* In: Word insertion penalty */
	       float64 uw);	/* In: Unigram weight (interpolation with uniform distr.) */

/*
 * Return trigram followers for given two words.  Both w1 and w2 must be valid.
 * Return value: #trigrams in returned list.
 */
int32 lm_tglist (lm_t *lmp,	/* In: LM being queried */
		 s3lmwid_t w1,	/* In: LM word id of the first of a 2-word history */
		 s3lmwid_t w2,	/* In: LM word id of the second of the 2-word history */
		 tg_t **tg,	/* Out: *tg = array of trigrams for <w1,w2> */
		 int32 *bowt);	/* Out: *bowt = backoff-weight for <w1, w2> */

/*
 * Return the bigram followers for the given word w.
 * Return value: #bigrams in returned list.
 */
int32 lm_bglist (lm_t *lmp,	/* In: LM being queried */
		 s3lmwid_t w,	/* In: LM word id of the 1-word history */
		 bg_t **bg,	/* Out: *bg = array of bigrams for w */
		 int32 *bowt);	/* Out: *bowt = backoff-weight for w */

/*
 * Somewhat like lm_bglist, but fill up a wordprob_t array from the bigram list found, instead
 * of simply returning the bglist.  The wordprob array contains dictionary word IDs.  But note
 * that only the base IDs are entered; the caller is responsible for filling out the alternative
 * pronunciations.
 * Return value:  #entries filled in the wordprob array.
 */
int32 lm_bg_wordprob(lm_t *lm,		/* In: LM being queried */
		     s3lmwid_t w,	/* In: LM word ID of the 1-word history */
		     int32 th,		/* In: If a prob (logs3, langwt-ed) < th, ignore it */
		     wordprob_t *wp,	/* In/Out: Array to be filled; caller must have
					   allocated this array */
		     int32 *bowt);	/* Out: *bowt = backoff-weight associated with w */

/*
 * Like lm_bg_wordprob, but for unigrams.
 * Return value:  #entries filled in the wordprob array.
 */
int32 lm_ug_wordprob(lm_t *lm,
		     int32 th,
		     wordprob_t *wp);

/* Return the unigrams in LM.  Return value: #unigrams in returned list. */
int32 lm_uglist (lm_t *lmp,	/* In: LM being queried */
		 ug_t **ug);	/* Out: *ug = unigram array */


/* Return unigram score for the given word */
int32 lm_ug_score (lm_t *lmp, s3lmwid_t w);


/*
 * Return bigram score for the given two word sequence.  If w1 is BAD_S3LMWID, return
 * lm_ug_score (w2).
 */
int32 lm_bg_score (lm_t *lmp, s3lmwid_t w1, s3lmwid_t w2);


/*
 * Return trigram score for the given three word sequence.  If w1 is BAD_S3LMWID, return
 * lm_bg_score (w2, w3).  If both w1 and w2 are BAD_S3LMWID, return lm_ug_score (w3).
 */
int32 lm_tg_score (lm_t *lmp, s3lmwid_t w1, s3lmwid_t w2, s3lmwid_t w3);


/*
 * Set the language-weight and insertion penalty parameters for the LM, after revoking
 * any earlier set of such parameters.
 */
void lm_set_param (lm_t *lm, float64 lw, float64 wip);


/* Return LM word ID for the given string, or BAD_S3LMWID if not available */
s3lmwid_t lm_wid (lm_t *lm, char *wd);


/* LM cache related */
void lm_cache_reset (lm_t *lmp);
void lm_cache_stats_dump (lm_t *lmp);

/* RAH, added code for freeing allocated memory */
void lm_free (lm_t *lm);



/* Macro versions of access functions */
#define LM_TGPROB(lm,tgptr)	((lm)->tgprob[(tgptr)->probid].l)
#define LM_BGPROB(lm,bgptr)	((lm)->bgprob[(bgptr)->probid].l)
#define LM_UGPROB(lm,ugptr)	((ugptr)->prob.l)
#define LM_RAWSCORE(lm,score)	((score - (lm)->wip) / ((lm)->lw))


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * logs3.c -- log(base-S3) module.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added log_to_logs3_factor(), and logs3_to_p().
 * 
 * 05-Nov-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


#include "logs3.h"
#include "s3types.h"

/* RAH, 5.9.2001, Add a means of controlling whether the add table is
   used or the value is simply computed Note, if the add tables are
   not to be used, they are still generated. I'll remove this portion
   later, for now I want to make that there are no problems 
*/
static int USE_LOG3_ADD_TABLE = 1;	
static float64 F = 0;		/* Set this global variable so we don't have to keep computing it in logs3_add() */

/*
 * In evaluating HMM models, probability values are often kept in log domain,
 * to avoid overflow.  Furthermore, to enable these logprob values to be held
 * in int32 variables without significant loss of precision, a logbase of
 * (1+epsilon), epsilon<<1, is used.  This module maintains this logbase (B).
 * 
 * More important, maintaining probabilities in log domain creates a problem when
 * adding two probability values: difficult in the log domain.
 * Suppose P = Q+R (0 <= P,Q,R,Q+R <= 1), and we have to compute:
 *   logB(P), given logB(Q) and logB(R).  Assume Q >= R.
 *   Let z = logB(P), x = logB(Q), y = logB(R).
 *   Therefore, B^z = B^x + B^y = B^x(1 + B^(y-x)).
 *   Therefore, z = x + logB(1+B^(y-x)).
 * Since the latter term only depends on y-x, and log probs are kept in integer
 * variables, it can be precomputed into a table for y-x = 0, -1, -2, -3... until
 * logB(1+B^(y-x)) = (int32) 0.
 */


static float64 B, logB, invlogB, invlog10B;
static uint16 *add_tbl = NULL;	/* See discussion above */
static int32 add_tbl_size;


int32 logs3_init (float64 base)
{
    int32 i, k;
    float64 d, t, f;


    USE_LOG3_ADD_TABLE = cmd_ln_int32 ("-log3table");

    E_INFO("Initializing logbase: %e (add table: %d)\n", base,USE_LOG3_ADD_TABLE);

    if (base <= 1.0)
	E_FATAL("Illegal logbase: %e; must be > 1.0\n", base);

    if (add_tbl) {
	if (B == base)
	    E_WARN("logs3_init() already done\n");
	else
	    E_FATAL("logs3_init() already done with base %e\n", B);
    }
    
    B = base;
    logB = log(base);
    invlogB = 1.0/logB;
    invlog10B = 1.0/log10(base);

    /* Create add-table for adding probs in log domain */

    k = (int32) (log(2.0)*invlogB + 0.5);
    if (k > 65535) {
	E_ERROR("Logbase too small: %e; needs int32 addtable[]\n", base);
	return -1;
    }

    d = 1.0;
    f = 1.0/B;
    F = 1.0/B;			/* RAH 5.9.01, set this global variable so that we don't have to compute it in logs3_add() */

    /* Figure out size of add-table requried */
    for (i = 0;; i++) {
	t = log(1.0+d)*invlogB;
	k = (int32) (t + 0.5);

#if 0
	if (((i%1000) == 0) || (k == 0))
	    printf ("%10d %10d %e\n", i, k, d);
#endif

	if (k == 0)
	    break;

	d *= f;
    }

    add_tbl_size = i+1;
    add_tbl = (uint16 *) ckd_calloc (i+1, sizeof(uint16));
    
    /* Fill add-table */
    d = 1.0;
    for (i = 0;; i++) {
	t = log(1.0+d)*invlogB;
	k = (int32) (t + 0.5);

	add_tbl[i] = k;

	if (k == 0)
	    break;

	d *= f;
    }
    
    E_INFO("Log-Add table size = %d\n", add_tbl_size);

    return 0;
}


int32 logs3_add (int32 logp, int32 logq)
{
    int32 d, r;
    
    assert(add_tbl != NULL);	/* Use assert to allow use of NDEBUG for efficiency */

    if (logp > logq) {
	d = logp - logq;
	r = logp;
    } else {
	d = logq - logp;
	r = logq;
    }
    /* RAH 5.9.01 If we allow the computation of values of d beyond
       the add_tbl_size, speed degrades quickly, for that reason,
       limit the calculations to the same range as the table. This
       seems wrong. Must think more about it */
    if (d < add_tbl_size)
      {
      if (USE_LOG3_ADD_TABLE) 
	r += add_tbl[d];
      else
	/* Do we need to be checking to see if the value is too large? small? */
	r += 0.5 + (float64) (log(1.0 + pow(F,d)) * invlogB); /* RAH, 5.9.01 - compute instead of looking it up */
      }

    return r;
}


int32 logs3 (float64 p)
{
    if (! add_tbl)
	E_FATAL("logs3 module not initialized\n");
    
    if (p <= 0.0) {
	E_WARN("logs3 argument: %e; using S3_LOGPROB_ZERO\n", p);
	return S3_LOGPROB_ZERO;
    }
    
    return ((int32) (log(p) * invlogB));
}


int32 log_to_logs3 (float64 logp)
{
    if (! add_tbl)
	E_FATAL("logs3 module not initialized\n");
    
    return ((int32) (logp * invlogB));
}


float64 log_to_logs3_factor ( void )
{
    return invlogB;
}


float64 logs3_to_log (int32 logs3p)
{
    if (! add_tbl)
	E_FATAL("logs3 module not initialized\n");
    
    return ((float64)logs3p * logB);
}


float64 logs3_to_p (int32 logs3p)
{
    return (exp((float64)logs3p * logB));
}


int32 log10_to_logs3 (float64 log10p)
{
    if (! add_tbl)
	E_FATAL("logs3 module not initialized\n");
    
    return ((int32) (log10p * invlog10B));
}

void logs_free ()
{
  if (add_tbl) 
    ckd_free ((void *) add_tbl);
}


#if _LOGS3_TEST_
main (int argc, char *argv[])
{
    float64 base;
    float64 p, q;
    int32 logp, logq, logpq;

    printf ("base: ");
    scanf ("%lf", &base);
    if (logs3_init (base) < 0)
	exit (-1);

    for (;;) {
	printf ("p,q: ");

	scanf ("%lf %lf", &p, &q);
	logp = logs3 (p);
	logq = logs3 (q);

	logpq = logs3_add (logp, logq);

	printf ("logB(p,q) = %d, %d\n", logp, logq);
	printf ("logB(p+q) = %d, expected %d\n", logpq, logs3 (p+q));
    }
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * logs3.h -- log(base-S3) module.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 28-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added log_to_logs3_factor(), and logs3_to_p().
 * 
 * 05-Nov-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


#ifndef _S3_LOGS3_H_
#define _S3_LOGS3_H_


#include "libutil.h"


/*
 * In evaluating HMM models, probability values are often kept in log domain,
 * to avoid overflow.  Furthermore, to enable these logprob values to be held
 * in int32 variables without significant loss of precision, a logbase of
 * (1+epsilon), epsilon<<1, is used.  This module maintains this logbase, and
 * other functions to support it.
 */


/* Initialize module with a new base (> 1.0).  Returns 0 if successful, -1 otherwise. */
int32 logs3_init (float64 base);

/* Given logs3p, logs3q (ie, log-S3base of p and q), return logs3(p+q) */
int32 logs3_add (int32 logs3p, int32 logs3q);

/* Given p, return logs3(p) */
int32 logs3 (float64 p);

/* Given log(p), return logs3(p) */
int32 log_to_logs3 (float64 logp);

/* Return the multiplication factor used for converting log values to logs3 */
float64 log_to_logs3_factor( void );

/* Given logs3(p), return log(p) */
float64 logs3_to_log (int32 logs3p);

/* Given logs3(p), return p */
float64 logs3_to_p (int32 logs3p);

/* Given log10(p), return logs3(p) */
int32 log10_to_logs3 (float64 log10p);

/* RAH, free the add_tbl if still allocated */
void logs_free();


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/********************************************************************
 * Example program to show usage of the live mode routines
 * The decoder is initialized with live_initialize_decoder()
 * Blocks of samples are decoded by live_utt_decode_block()
 * To compile an excutable compile using
 * $(CC) -I. -Isrc -Llibutil/linux -Lsrc/linux main_live_example.c -lutil -ldecoder -lm
 * from the current directory 
 * Note the include directories (-I*) and the library directories (-L*)
 *
 ********************************************************************/

#include <stdio.h>
#include "libutil.h"
#include "live.h"
#include "cmd_ln_args.h"
#ifdef VTUNE
#include <VtuneApi.h>
#endif

#define MAXSAMPLES 	1000000

int main (int argc, char *argv[])
{
    short *samps;
    int  i, j, buflen, endutt, blksize, nhypwds, nsamp;
    char   *argsfile, *ctlfile, *indir;
    char   filename[512], cepfile[512];
    partialhyp_t *parthyp;
    FILE *fp, *sfp;

    fprintf(stderr,"At the beginning\n");
    if (argc != 4) {
      argsfile = NULL;
      parse_args_file(argsfile);
      E_FATAL("\nUSAGE: %s <ctlfile> <inrawdir> <argsfile>\n",argv[0]);
    }
    ctlfile = argv[1]; indir = argv[2]; argsfile = argv[3];
    fprintf(stderr,"before calloc\n");
    samps = (short *) calloc(MAXSAMPLES,sizeof(short));
    blksize = 2000;
    
    fprintf(stderr,"after calloc\n");
    if ((fp = fopen(ctlfile,"r")) == NULL)
	E_FATAL("Unable to read %s\n",ctlfile);

    live_initialize_decoder(argsfile);
    fprintf(stderr,"after initialize decode\n");

#ifdef VTUNE
    VTResume();
#endif

    while (fscanf(fp,"%s",filename) != EOF){
	sprintf(cepfile,"%s/%s.raw",indir,filename);
	if ((sfp = fopen(cepfile,"rb")) == NULL)
	    E_FATAL("Unable to read %s\n",cepfile);
		nsamp = fread(samps, sizeof(short), MAXSAMPLES, sfp);
        fprintf(stdout,"%d samples in file %s.\nWill be decoded in blocks of %d\n",nsamp,cepfile,blksize);
        fflush(stdout); fclose(sfp);

        for (i=0;i<nsamp;i+=blksize){
	    buflen = i+blksize < nsamp ? blksize : nsamp-i;
	    endutt = i+blksize <= nsamp-1 ? 0 : 1;
	    nhypwds = live_utt_decode_block(samps+i,buflen,endutt,&parthyp);

	    E_INFO("PARTIAL HYP:");
	    if (nhypwds > 0)
                for (j=0; j < nhypwds; j++) fprintf(stderr," %s",parthyp[j].word);
	    fprintf(stderr,"\n");
        }

    }
    return 0;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * mdef.c -- HMM model definition: base (CI) phones and triphones
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 19.Apr-2001  Ricky Houghton, added code for free allocated memory
 *
 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added mdef_sseq2sen_active().
 * 
 * 06-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		In mdef_phone_id(), added backing off to silence phone context from filler
 * 		context if original triphone not found.
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added senone-sequence id (ssid) to phone_t and appropriate functions to
 * 		maintain it.  Instead, moved state sequence info to mdef_t.
 * 
 * 13-Jul-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added mdef_phone_str().
 * 
 * 01-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Allowed mdef_phone_id_nearest to return base phone id if either
 * 		left or right context (or both) is undefined.
 * 
 * 01-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


/*
 * Major assumptions:
 *   All phones have same #states, same topology.
 *   Every phone has exactly one non-emitting, final state--the last one.
 *   CI phones must appear first in model definition file.
 */


#include "mdef.h"


#define MODEL_DEF_VERSION	"0.3"


void mdef_dump (FILE *fp, mdef_t *m)
{
    int32 i, j;
    int32 ssid;
    char buf[1024];
    
    fprintf (fp, "%d ciphone\n", m->n_ciphone);
    fprintf (fp, "%d phone\n", m->n_phone);
    fprintf (fp, "%d emitstate\n", m->n_emit_state);
    fprintf (fp, "%d cisen\n", m->n_ci_sen);
    fprintf (fp, "%d sen\n", m->n_sen);
    fprintf (fp, "%d tmat\n", m->n_tmat);
    
    for (i = 0; i < m->n_phone; i++) {
	mdef_phone_str (m, i, buf);
	ssid = m->phone[i].ssid;
	
	fprintf (fp, "%3d %5d", m->phone[i].tmat, ssid);
	for (j = 0; j < m->n_emit_state; j++)
	    fprintf (fp, " %5d", m->sseq[ssid][j]);
	fprintf (fp, "\t");
	for (j = 0; j < m->n_emit_state; j++)
	    fprintf (fp, " %3d", m->cd2cisen[m->sseq[ssid][j]]);
	fprintf (fp, "\t%s\n", buf);
    }
    
    fflush (fp);
}


#if 0
int32 mdef_hmm_cmp (mdef_t *m, s3pid_t p1, s3pid_t p2)
{
    int32 i;
    
    if (m->phone[p1].tmat != m->phone[p2].tmat)
	return -1;
    
    for (i = 0; i < m->n_emit_state; i++)
	if (m->phone[p1].state[i] != m->phone[p2].state[i])
	    return -1;
    
    return 0;
}
#endif


static void ciphone_add (mdef_t *m, char *ci, s3pid_t p)
{
    assert (p < m->n_ciphone);

    m->ciphone[p].name = (char *) ckd_salloc (ci); /* freed in mdef_free */
    if (hash_enter (m->ciphone_ht, m->ciphone[p].name, p) != p)
	E_FATAL("hash_enter(%s) failed; duplicate CIphone?\n", m->ciphone[p].name);
}


static ph_lc_t *find_ph_lc (ph_lc_t *lclist, s3cipid_t lc)
{
    ph_lc_t *lcptr;

    for (lcptr = lclist; lcptr && (lcptr->lc != lc); lcptr = lcptr->next);
    return lcptr;
}


static ph_rc_t *find_ph_rc (ph_rc_t *rclist, s3cipid_t rc)
{
    ph_rc_t *rcptr;

    for (rcptr = rclist; rcptr && (rcptr->rc != rc); rcptr = rcptr->next);
    return rcptr;
}


static void triphone_add (mdef_t *m,
			  s3cipid_t ci, s3cipid_t lc, s3cipid_t rc, word_posn_t wpos,
			  s3pid_t p)
{
    ph_lc_t *lcptr;
    ph_rc_t *rcptr;
    
    assert (p < m->n_phone);

    /* Fill in phone[p] information (state and tmat mappings added later) */
    m->phone[p].ci = ci;
    m->phone[p].lc = lc;
    m->phone[p].rc = rc;
    m->phone[p].wpos = wpos;

    /* Create <ci,lc,rc,wpos> -> p mapping if not a CI phone */
    if (p >= m->n_ciphone) {
	if ((lcptr = find_ph_lc (m->wpos_ci_lclist[wpos][(int)ci], lc)) 
	    == NULL)
	{
	lcptr = (ph_lc_t *) ckd_calloc (1, sizeof(ph_lc_t)); /* freed at mdef_free, I believe */
	    lcptr->lc = lc;
	    lcptr->next = m->wpos_ci_lclist[wpos][(int)ci];
	    m->wpos_ci_lclist[wpos][(int)ci] = lcptr; /* This is what needs to be freed */
	}
	if ((rcptr = find_ph_rc (lcptr->rclist, rc)) != NULL) {
	    char buf[4096];
	    
	    mdef_phone_str (m, rcptr->pid, buf);
	    E_FATAL("Duplicate triphone: %s\n", buf);
	}
	
      rcptr = (ph_rc_t *) ckd_calloc (1, sizeof(ph_rc_t)); /* freed in mdef_free, I believe */
	rcptr->rc = rc;
	rcptr->pid = p;
	rcptr->next = lcptr->rclist;
	lcptr->rclist = rcptr;
    }
}


s3cipid_t mdef_ciphone_id (mdef_t *m, char *ci)
{
    int32 id;
    
    assert (m);
    assert (ci);
    
    if (hash_lookup (m->ciphone_ht, ci, &id) < 0)
	return (BAD_S3CIPID);
    return ((s3cipid_t) id);
}


const char *mdef_ciphone_str (mdef_t *m, s3cipid_t id)
{
    assert (m);
    assert ((id >= 0) && (id < m->n_ciphone));
    
    return (m->ciphone[(int)id].name);
}


int32 mdef_phone_str (mdef_t *m, s3pid_t pid, char *buf)
{
    char *wpos_name;
    
    assert (m);
    assert ((pid >= 0) && (pid < m->n_phone));
    wpos_name = WPOS_NAME;
    
    buf[0] = '\0';
    if (pid < m->n_ciphone)
	sprintf (buf, "%s", mdef_ciphone_str (m, (s3cipid_t) pid));
    else {
	sprintf (buf, "(%s,%s,%s,%c)",
		 mdef_ciphone_str(m, m->phone[pid].ci),
		 mdef_ciphone_str(m, m->phone[pid].lc),
		 mdef_ciphone_str(m, m->phone[pid].rc),
		 wpos_name[m->phone[pid].wpos]);
    }
    return 0;
}


s3pid_t mdef_phone_id (mdef_t *m, 
		       s3cipid_t ci, s3cipid_t lc, s3cipid_t rc, word_posn_t wpos)
{
    ph_lc_t *lcptr;
    ph_rc_t *rcptr;
    s3cipid_t newl, newr;
    
    assert (m);
    assert ((ci >= 0) && (ci < m->n_ciphone));
    assert ((lc >= 0) && (lc < m->n_ciphone));
    assert ((rc >= 0) && (rc < m->n_ciphone));
    assert ((wpos >= 0) && (wpos < N_WORD_POSN));

    if (((lcptr = find_ph_lc (m->wpos_ci_lclist[wpos][(int)ci], lc)) == NULL) ||
	((rcptr = find_ph_rc (lcptr->rclist, rc)) == NULL)) {
	/* Not found; backoff to silence context if non-silence filler context */
	if (NOT_S3CIPID(m->sil))
	    return BAD_S3PID;
	
	newl = m->ciphone[(int)lc].filler ? m->sil : lc;
	newr = m->ciphone[(int)rc].filler ? m->sil : rc;
	if ((newl == lc) && (newr == rc))
	    return BAD_S3PID;
	
	return (mdef_phone_id (m, ci, newl, newr, wpos));
    }
    
    return (rcptr->pid);
}


s3pid_t mdef_phone_id_nearest (mdef_t *m, 
			       s3cipid_t b, s3cipid_t l, s3cipid_t r, word_posn_t pos)
{
    word_posn_t tmppos;
    s3pid_t p;
    s3cipid_t newl, newr;
    char *wpos_name;
    
    assert (m);
    assert ((b >= 0) && (b < m->n_ciphone));
    assert ((pos >= 0) && (pos < N_WORD_POSN));

    if ((NOT_S3CIPID(l)) || (NOT_S3CIPID(r)))
	return ((s3pid_t) b);
    
    assert ((l >= 0) && (l < m->n_ciphone));
    assert ((r >= 0) && (r < m->n_ciphone));
    
    p = mdef_phone_id (m, b, l, r, pos);
    if (IS_S3PID(p))
	return p;
    
    /* Exact triphone not found; backoff to other word positions */
    for (tmppos = 0; tmppos < N_WORD_POSN; tmppos++) {
	if (tmppos != pos) {
	    p = mdef_phone_id (m, b, l, r, tmppos);
	    if (IS_S3PID(p))
		return p;
	}
    }
    
    /* Nothing yet; backoff to silence phone if non-silence filler context */
    if (IS_S3CIPID(m->sil)) {
	newl = m->ciphone[(int)l].filler ? m->sil : l;
	newr = m->ciphone[(int)r].filler ? m->sil : r;
	if ((newl != l) || (newr != r)) {
	    p = mdef_phone_id (m, b, newl, newr, pos);
	    if (IS_S3PID(p))
		return p;
	    
	    for (tmppos = 0; tmppos < N_WORD_POSN; tmppos++) {
		if (tmppos != pos) {
		    p = mdef_phone_id (m, b, newl, newr, tmppos);
		    if (IS_S3PID(p))
			return p;
		}
	    }
	}
    }
    
    /* Nothing yet; backoff to base phone */
    if ((m->n_phone > m->n_ciphone) && (! m->ciphone[(int)b].filler)) {
	wpos_name = WPOS_NAME;
#if 0
	E_WARN("Triphone(%s,%s,%s,%c) not found; backing off to CIphone\n",
	       mdef_ciphone_str(m, b),
	       mdef_ciphone_str(m, l),
	       mdef_ciphone_str(m, r),
	       wpos_name[pos]);
#endif
    }
    return ((s3pid_t) b);
}


int32 mdef_phone_components (mdef_t *m,
			     s3pid_t p,
			     s3cipid_t *b,
			     s3cipid_t *l,
			     s3cipid_t *r,
			     word_posn_t *pos)
{
    assert (m);
    assert ((p >= 0) && (p < m->n_phone));

    *b = m->phone[p].ci;
    *l = m->phone[p].lc;
    *r = m->phone[p].rc;
    *pos = m->phone[p].wpos;

    return 0;
}


int32 mdef_is_ciphone (mdef_t *m, s3pid_t p)
{
    assert (m);
    assert ((p >= 0) && (p < m->n_phone));
    
    return ((p < m->n_ciphone) ? 1 : 0);
}


/* Parse tmat and state->senone mappings for phone p and fill in structure */
static void parse_tmat_senmap (mdef_t *m, char *line, int32 off, s3pid_t p)
{
    int32 wlen, n, s;
    char word[1024], *lp;

    lp = line + off;
    
    /* Read transition matrix id */
    if ((sscanf (lp, "%d%n", &n, &wlen) != 1) || (n < 0))
        E_FATAL("Missing or bad transition matrix id: %s\n", line);
    m->phone[p].tmat = n;
    if (m->n_tmat <= n)
	E_FATAL("tmat-id(%d) > #tmat in header(%d): %s\n", n, m->n_tmat, line);
    lp += wlen;
    
    /* Read senone mappings for each emitting state */
    for (n = 0; n < m->n_emit_state; n++) {
        if ((sscanf (lp, "%d%n", &s, &wlen) != 1) || (s < 0))
	    E_FATAL("Missing or bad state[%d]->senone mapping: %s\n", n, line);
	if ((p < m->n_ciphone) && (m->n_ci_sen <= s))
	    E_FATAL("CI-senone-id(%d) > #CI-senones(%d): %s\n", s, m->n_ci_sen, line);
	if (m->n_sen <= s)
	    E_FATAL("Senone-id(%d) > #senones(%d): %s\n", s, m->n_sen, line);

	m->sseq[p][n] = s;
	lp += wlen;
    }

    /* Check for the last non-emitting state N */
    if ((sscanf (lp, "%s%n", word, &wlen) != 1) || (strcmp (word, "N") != 0))
        E_FATAL("Missing non-emitting state spec: %s\n", line);
    lp += wlen;

    /* Check for end of line */
    if (sscanf (lp, "%s%n", word, &wlen) == 1)
        E_FATAL("Non-empty beyond non-emitting final state: %s\n", line);
}


static void parse_base_line (mdef_t *m, char *line, s3pid_t p)
{
    int32 wlen, n;
    char word[1024], *lp;
    s3cipid_t ci;

    lp = line;
    
    /* Read base phone name */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing base phone name: %s\n", line);
    lp += wlen;
    
    /* Make sure it's not a duplicate */
    ci = mdef_ciphone_id (m, word);
    if (IS_S3CIPID(ci))
        E_FATAL("Duplicate base phone: %s\n", line);

    /* Add ciphone to ciphone table with id p */
    ciphone_add (m, word, p);
    ci = (s3cipid_t) p;

    /* Read and skip "-" for lc, rc, wpos */
    for (n = 0; n < 3; n++) {
	if ((sscanf (lp, "%s%n", word, &wlen) != 1) || (strcmp (word, "-") != 0))
	    E_FATAL("Bad context info for base phone: %s\n", line);
	lp += wlen;
    }
    
    /* Read filler attribute, if present */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing filler atribute field: %s\n", line);
    lp += wlen;
    if (strcmp (word, "filler") == 0)
        m->ciphone[(int)ci].filler = 1;
    else if (strcmp (word, "n/a") == 0)
        m->ciphone[(int)ci].filler = 0;
    else
        E_FATAL("Bad filler attribute field: %s\n", line);

    triphone_add (m, ci, BAD_S3CIPID, BAD_S3CIPID, WORD_POSN_UNDEFINED, p);

    /* Parse remainder of line: transition matrix and state->senone mappings */
    parse_tmat_senmap (m, line, lp-line, p);
}


static void parse_tri_line (mdef_t *m, char *line, s3pid_t p)
{
    int32 wlen;
    char word[1024], *lp;
    s3cipid_t ci, lc, rc;
    word_posn_t wpos = WORD_POSN_BEGIN;

    lp = line;
    
    /* Read base phone name */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing base phone name: %s\n", line);
    lp += wlen;

    ci = mdef_ciphone_id (m, word);
    if (NOT_S3CIPID(ci))
        E_FATAL("Unknown base phone: %s\n", line);

    /* Read lc */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing left context: %s\n", line);
    lp += wlen;
    lc = mdef_ciphone_id (m, word);
    if (NOT_S3CIPID(lc))
        E_FATAL("Unknown left context: %s\n", line);

    /* Read rc */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing right context: %s\n", line);
    lp += wlen;
    rc = mdef_ciphone_id (m, word);
    if (NOT_S3CIPID(rc))
        E_FATAL("Unknown right  context: %s\n", line);
    
    /* Read tripone word-position within word */
    if ((sscanf (lp, "%s%n", word, &wlen) != 1) || (word[1] != '\0'))
        E_FATAL("Missing or bad word-position spec: %s\n", line);
    lp += wlen;
    switch (word[0]) {
    case 'b': wpos = WORD_POSN_BEGIN; break;
    case 'e': wpos = WORD_POSN_END; break;
    case 's': wpos = WORD_POSN_SINGLE; break;
    case 'i': wpos = WORD_POSN_INTERNAL; break;
    default: E_FATAL("Bad word-position spec: %s\n", line);
    }

    /* Read filler attribute, if present.  Must match base phone attribute */
    if (sscanf (lp, "%s%n", word, &wlen) != 1)
	E_FATAL("Missing filler attribute field: %s\n", line);
    lp += wlen;
    if (((strcmp (word, "filler") == 0) && (m->ciphone[(int)ci].filler)) ||
	((strcmp (word, "n/a") == 0) && (! m->ciphone[(int)ci].filler))) {
	/* Everything is fine */
    } else
        E_FATAL("Bad filler attribute field: %s\n", line);
    
    triphone_add (m, ci, lc, rc, wpos, p);

    /* Parse remainder of line: transition matrix and state->senone mappings */
    parse_tmat_senmap (m, line, lp-line, p);
}


static void sseq_compress (mdef_t *m)
{
    hash_table_t *h;
    s3senid_t **sseq;
    int32 n_sseq;
    int32 p, j, k;
    glist_t g;
    gnode_t *gn;
    hash_entry_t *he;
    
    k = m->n_emit_state * sizeof(s3senid_t);
    
    h = hash_new (m->n_phone, HASH_CASE_YES);
    n_sseq = 0;
    
    /* Identify unique senone-sequence IDs.  BUG: tmat-id not being considered!! */
    for (p = 0; p < m->n_phone; p++) {
	/* Add senone sequence to hash table */
	if ((j = hash_enter_bkey (h, (char *)(m->sseq[p]), k, n_sseq)) == n_sseq)
	    n_sseq++;
	
	m->phone[p].ssid = j;
    }
    
    /* Generate compacted sseq table */
    sseq = (s3senid_t **) ckd_calloc_2d (n_sseq, m->n_emit_state, sizeof(s3senid_t));/* freed in mdef_free() */
    
    g = hash_tolist (h, &j);
    assert (j == n_sseq);
    
    for (gn = g; gn; gn = gnode_next(gn)) {
	he = (hash_entry_t *) gnode_ptr (gn);
	j = hash_entry_val(he);
	memcpy (sseq[j], hash_entry_key(he), k);
    }
    glist_free (g);
    
    /* Free the old, temporary senone sequence table, replace with compacted one */
    ckd_free_2d ((void **) m->sseq);
    m->sseq = sseq;
    m->n_sseq = n_sseq;
    
    hash_free (h);
}


static int32 noncomment_line(char *line, int32 size, FILE *fp)
{
    while (fgets (line, size, fp) != NULL) {
        if (line[0] != '#')
	    return 0;
    }
    return -1;
}


/*
 * Initialize phones (ci and triphones) and state->senone mappings from .mdef file.
 */
mdef_t *mdef_init (char *mdeffile)
{
    FILE *fp;
    int32 n_ci, n_tri, n_map, n;
    char tag[1024], buf[1024];
    s3senid_t **senmap;
    s3pid_t p;
    int32 s, ci, cd;
    mdef_t *m;
    int32 *cdsen_start, *cdsen_end;

    if (! mdeffile)
	E_FATAL("No mdef-file\n");

    E_INFO("Reading model definition: %s\n", mdeffile);

    m = (mdef_t *) ckd_calloc (1, sizeof(mdef_t)); /* freed in mdef_free */
    
    if ((fp = fopen(mdeffile, "r")) == NULL)
        E_FATAL_SYSTEM("fopen(%s,r) failed\n", mdeffile);

    if (noncomment_line(buf, sizeof(buf), fp) < 0)
        E_FATAL("Empty file: %s\n", mdeffile);

    if (strncmp(buf, MODEL_DEF_VERSION, strlen(MODEL_DEF_VERSION)) != 0)
        E_FATAL("Version error: Expecing %s, but read %s\n", MODEL_DEF_VERSION, buf);

    /* Read #base phones, #triphones, #senone mappings defined in header */
    n_ci = -1;
    n_tri = -1;
    n_map = -1;
    m->n_ci_sen = -1;
    m->n_sen = -1;
    m->n_tmat = -1;
    do {
	if (noncomment_line(buf, sizeof(buf), fp) < 0)
	    E_FATAL("Incomplete header\n");

	if ((sscanf(buf, "%d %s", &n, tag) != 2) || (n < 0))
	    E_FATAL("Error in header: %s\n", buf);

	if (strcmp(tag, "n_base") == 0)
	    n_ci = n;
	else if (strcmp(tag, "n_tri") == 0)
	    n_tri = n;
	else if (strcmp(tag, "n_state_map") == 0)
	    n_map = n;
	else if (strcmp(tag, "n_tied_ci_state") == 0)
	    m->n_ci_sen = n;
	else if (strcmp(tag, "n_tied_state") == 0)
	    m->n_sen = n;
	else if (strcmp(tag, "n_tied_tmat") == 0)
	    m->n_tmat = n;
	else
	    E_FATAL("Unknown header line: %s\n", buf);
    } while ((n_ci < 0) || (n_tri < 0) || (n_map < 0) ||
	     (m->n_ci_sen < 0) || (m->n_sen < 0) || (m->n_tmat < 0));

    if ((n_ci == 0) || (m->n_ci_sen == 0) || (m->n_tmat == 0) || (m->n_ci_sen > m->n_sen))
        E_FATAL("%s: Error in header\n", mdeffile);
    
    /* Check typesize limits */
    if (n_ci >= MAX_S3CIPID)
	E_FATAL("%s: #CI phones (%d) exceeds limit (%d)\n", mdeffile, n_ci, MAX_S3CIPID);
    if (n_ci + n_tri >= MAX_S3PID)
	E_FATAL("%s: #Phones (%d) exceeds limit (%d)\n", mdeffile, n_ci+n_tri, MAX_S3PID);
    if (m->n_sen >= MAX_S3SENID)
	E_FATAL("%s: #senones (%d) exceeds limit (%d)\n", mdeffile, m->n_sen, MAX_S3SENID);
    if (m->n_tmat >= MAX_S3TMATID)
	E_FATAL("%s: #tmats (%d) exceeds limit (%d)\n", mdeffile, m->n_tmat, MAX_S3TMATID);
    
    m->n_emit_state = (n_map / (n_ci+n_tri)) - 1;
    if ((m->n_emit_state+1) * (n_ci+n_tri) != n_map)
        E_FATAL("Header error: n_state_map not a multiple of n_ci*n_tri\n");

    /* Initialize ciphone info */
    m->n_ciphone = n_ci;
    m->ciphone_ht = hash_new (n_ci, 1);	/* With case-insensitive string names */ /* freed in mdef_free */
    m->ciphone = (ciphone_t *) ckd_calloc (n_ci, sizeof(ciphone_t)); /* freed in mdef_free */
    /* RAH, let's null the pointers so that we can reliably deallocate them */
    /*    for (i=0;i<m->n_ciphone;i++) { */ /*  */
    /*m->ciphone[i].name = NULL; */ /*  */
    /*} */ /*  */

    /* Initialize phones info (ciphones + triphones) */
    m->n_phone = n_ci + n_tri;
    m->phone = (phone_t *) ckd_calloc (m->n_phone, sizeof(phone_t)); /* freed in mdef_free */

    /* Allocate space for state->senone map for each phone */
    senmap = (s3senid_t **) ckd_calloc_2d (m->n_phone, m->n_emit_state, sizeof(s3senid_t));/* freed in mdef_free */
    m->sseq = senmap;	/* TEMPORARY; until it is compressed into just the unique ones */
    
    /* Allocate initial space for <ci,lc,rc,wpos> -> pid mapping */
    m->wpos_ci_lclist = (ph_lc_t ***) ckd_calloc_2d (N_WORD_POSN, m->n_ciphone, sizeof(ph_lc_t *)); /* freed in mdef_free */

    /*
     * Read base phones and triphones.  They'll simply be assigned a running sequence
     * number as their "phone-id".  If the phone-id < n_ci, it's a ciphone.
     */
    E_INFO("reading base phones\n");
    /* Read base phones */
    for (p = 0; p < n_ci; p++) {
        if (noncomment_line(buf, sizeof(buf), fp) < 0)
	    E_FATAL("Premature EOF reading CIphone %d\n", p);
        parse_base_line (m, buf, p);
    }
    m->sil = mdef_ciphone_id (m, S3_SILENCE_CIPHONE);

    E_INFO("done base phones, reading triphones\n");
    /* Read triphones, if any */
    for (; p < m->n_phone; p++) {
        if (noncomment_line(buf, sizeof(buf), fp) < 0)
	    E_FATAL("Premature EOF reading phone %d\n", p);
        parse_tri_line (m, buf, p);
    }

    if (noncomment_line(buf, sizeof(buf), fp) >= 0)
	E_ERROR("Non-empty file beyond expected #phones (%d)\n", m->n_phone);

    /* Build CD senones to CI senones map */
    if (m->n_ciphone * m->n_emit_state != m->n_ci_sen)
	E_FATAL("#CI-senones(%d) != #CI-phone(%d) x #emitting-states(%d)\n",
		m->n_ci_sen, m->n_ciphone, m->n_emit_state);
    m->cd2cisen = (s3senid_t *) ckd_calloc (m->n_sen, sizeof(s3senid_t)); /* freed in mdef_free */

    m->sen2cimap = (s3cipid_t *) ckd_calloc (m->n_sen, sizeof(s3cipid_t)); /* freed in mdef_free */

    E_INFO("setting BAD_S3CIPID\n");
    for (s = 0; s < m->n_sen; s++)
	m->sen2cimap[s] = BAD_S3CIPID;

    E_INFO("doing CI senones\n");
    for (s = 0; s < m->n_ci_sen; s++) {		/* CI senones */
	m->cd2cisen[s] = (s3senid_t) s;
	m->sen2cimap[s] = s / m->n_emit_state;
    }

    E_INFO("doing CD senones\n");
    for (p = n_ci; p < m->n_phone; p++) {	/* CD senones */
	for (s = 0; s < m->n_emit_state; s++) {
	    cd = m->sseq[p][s];
	    ci = m->sseq[(int)m->phone[p].ci][s];
	    m->cd2cisen[cd] = (s3senid_t) ci;
	    m->sen2cimap[cd] = m->phone[p].ci;
	}
    }
    
    /*
     * Count #senones (CI+CD) for each CI phone.
     * HACK!!  For handling holes in senone-CIphone mappings.  Does not work if holes
     * are present at the beginning or end of senones for a given CIphone.
     */
    cdsen_start = (int32 *) ckd_calloc (m->n_ciphone, sizeof(int32)); /* freed locally */

    cdsen_end = (int32 *) ckd_calloc (m->n_ciphone, sizeof(int32)); /* freed locally */

    E_INFO("doing CD sen\n");
    for (s = m->n_ci_sen; s < m->n_sen; s++) {
	if (NOT_S3CIPID(m->sen2cimap[s]))
	    continue;
	
	if (! cdsen_start[(int)m->sen2cimap[s]])
	    cdsen_start[(int)m->sen2cimap[s]] = s;
	cdsen_end[(int)m->sen2cimap[s]] = s;
    }

    /* Fill up holes */
    E_INFO("fill up holes\n");
    for (s = m->n_ci_sen; s < m->n_sen; s++) {
	if (IS_S3CIPID(m->sen2cimap[s]))
	    continue;

	/* Check if properly inside the observed ranges above */
	for (p = 0; p < m->n_ciphone; p++) {
	    if ((s > cdsen_start[p]) && (s < cdsen_end[p]))
		break;
	}
	if (p >= m->n_ciphone)
	    E_FATAL("Unreferenced senone %d; cannot determine parent CIphone\n", s);
	m->sen2cimap[s] = p;
    }

    /* Build #CD-senones for each CIphone */
    m->ciphone2n_cd_sen = (int32 *) ckd_calloc (m->n_ciphone, sizeof(int32));/* freed mdef_free */
    n = 0;
    E_INFO("build cd senones\n");
    for (p = 0; p < m->n_ciphone; p++) {
	if (cdsen_start[p] > 0) {
	    m->ciphone2n_cd_sen[p] = cdsen_end[p] - cdsen_start[p] + 1;
	    n += m->ciphone2n_cd_sen[p];
	}
    }
    n += m->n_ci_sen;
    assert (n == m->n_sen);

    ckd_free (cdsen_start);
    ckd_free (cdsen_end);

    sseq_compress (m);
    
    E_INFO("%d CI-phone, %d CD-phone, %d emitstate/phone, %d CI-sen, %d Sen, %d Sen-Seq\n",
	   m->n_ciphone, m->n_phone - m->n_ciphone, m->n_emit_state,
	   m->n_ci_sen, m->n_sen, m->n_sseq);
    
    fclose (fp);
    
    return m;
}


void mdef_sseq2sen_active (mdef_t *mdef, int32 *sseq, int32 *sen)
{
    int32 ss, i;
    s3senid_t *sp;
    
    for (ss = 0; ss < mdef_n_sseq(mdef); ss++) {
	if (sseq[ss]) {
	    sp = mdef->sseq[ss];
	    for (i = 0; i < mdef_n_emit_state(mdef); i++)
		sen[sp[i]] = 1;
	}
    }
}

/* RAH 4.23.01, Need to step down the ->next list to see if there are
   any more things to free
 */



/* RAH 4.19.01, Attempt to free memory that was allocated within this module
   I have not verified that all the memory has been freed. I've taken only a 
   reasonable effort for now.
   RAH 4.24.01 - verified that all memory is released.
 */
void mdef_free_recursive_lc (ph_lc_t *lc)
{
  if (lc == NULL) return;

  if (lc->rclist) 
    mdef_free_recursive_rc (lc->rclist);

  if (lc->next) 
    mdef_free_recursive_lc (lc->next);

  ckd_free ((void *) lc);
}

void mdef_free_recursive_rc (ph_rc_t *rc)
{
  if (rc == NULL) return;

    if (rc->next) 
      mdef_free_recursive_rc (rc->next);

    ckd_free ((void *) rc);
}


/* RAH, Free memory that was allocated in mdef_init 
   Rational purify shows that no leaks exist
 */
   
void mdef_free (mdef_t *m)
{
  int i,j;

  if (m) { 
    if (m->ciphone2n_cd_sen)
      ckd_free    ((void *)m->ciphone2n_cd_sen);
    if (m->sen2cimap)
      ckd_free    ((void *)m->sen2cimap);
    if (m->cd2cisen)
      ckd_free    ((void *)m->cd2cisen);

    /* RAH, go down the ->next list and delete all the pieces */
    for (i=0;i<N_WORD_POSN;i++)
      for (j=0;j<m->n_ciphone;j++) 
	if (m->wpos_ci_lclist[i][j]) {
	  mdef_free_recursive_lc (m->wpos_ci_lclist[i][j]->next);
	  mdef_free_recursive_rc (m->wpos_ci_lclist[i][j]->rclist);
	}
    
    for (i=0;i<N_WORD_POSN;i++)
      for (j=0;j<m->n_ciphone;j++) 
	if (m->wpos_ci_lclist[i][j])  
	  ckd_free ((void *) m->wpos_ci_lclist[i][j]);

    
    if (m->wpos_ci_lclist)
      ckd_free_2d ((void *)m->wpos_ci_lclist);
    if (m->sseq) 
      ckd_free_2d ((void *)m->sseq);
    /* Free phone context */
    if (m->phone) 
      ckd_free    ((void *)m->phone);    
    if (m->ciphone_ht)
      hash_free (m->ciphone_ht);

    for (i=0;i<m->n_ciphone;i++) {
      if (m->ciphone[i].name) 
	ckd_free    ((void *)m->ciphone[i].name);
    }
    if (m->ciphone) 
      ckd_free    ((void *)m->ciphone);
    
    ckd_free    ((void *)m);
  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * mdef.h -- HMM model definition: base (CI) phones and triphones
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 19.Apr-2001  Ricky Houghton, added code for free allocated memory
 * 
 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added mdef_sseq2sen_active().
 * 
 * 30-Apr-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added senone-sequence id (ssid) to phone_t and appropriate functions to
 * 		maintain it.  Instead, moved state sequence info to mdef_t.
 * 
 * 13-Jul-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added mdef_phone_str().
 * 
 * 01-Jan-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


#ifndef _S3_MDEF_H_
#define _S3_MDEF_H_


#include "libutil.h"
#include "s3types.h"


typedef enum {
    WORD_POSN_BEGIN = 0,	/* Beginning phone of word */
    WORD_POSN_END = 1,		/* Ending phone of word */
    WORD_POSN_SINGLE = 2,	/* Single phone word (i.e. begin & end) */
    WORD_POSN_INTERNAL = 3,	/* Internal phone of word */
    WORD_POSN_UNDEFINED = 4	/* Undefined value, used for initial conditions, etc */
} word_posn_t;
#define N_WORD_POSN	4	/* total # of word positions (excluding undefined) */
#define WPOS_NAME	"besiu"	/* Printable code for each word position above */


/* CI phone information */
typedef struct {
    char *name;
    int32 filler;		/* Whether a filler phone; if so, can be substituted by
				   silence phone in left or right context position */
} ciphone_t;

/*
 * Triphone information, including base phones as a subset.  For the latter, lc, rc
 * and wpos are non-existent.
 */
typedef struct {
    s3ssid_t ssid;		/* State sequence (or senone sequence) ID, considering the
				   n_emit_state senone-ids are a unit.  The senone sequences
				   themselves are in a separate table */
    s3tmatid_t tmat;		/* Transition matrix id */
    s3cipid_t ci, lc, rc;	/* Base, left, right context ciphones */
    word_posn_t wpos;		/* Word position */
} phone_t;

/*
 * Structures needed for mapping <ci,lc,rc,wpos> into pid.  (See mdef_t.wpos_ci_lclist
 * below.)  (lc = left context; rc = right context.)
 * NOTE: Both ph_rc_t and ph_lc_t FOR INTERNAL USE ONLY.
 */
typedef struct ph_rc_s {
    s3cipid_t rc;		/* Specific rc for a parent <wpos,ci,lc> */
    s3pid_t pid;		/* Triphone id for above rc instance */
    struct ph_rc_s *next;	/* Next rc entry for same parent <wpos,ci,lc> */
} ph_rc_t;

typedef struct ph_lc_s {
    s3cipid_t lc;		/* Specific lc for a parent <wpos,ci> */
    ph_rc_t *rclist;		/* rc list for above lc instance */
    struct ph_lc_s *next;	/* Next lc entry for same parent <wpos,ci> */
} ph_lc_t;


/* The main model definition structure */
typedef struct {
    int32 n_ciphone;		/* #basephones actually present */
    int32 n_phone;		/* #basephones + #triphones actually present */
    int32 n_emit_state;		/* #emitting states per phone */
    int32 n_ci_sen;		/* #CI senones; these are the first */
    int32 n_sen;		/* #senones (CI+CD) */
    int32 n_tmat;		/* #transition matrices */
    
    hash_table_t *ciphone_ht;	/* Hash table for mapping ciphone strings to ids */
    ciphone_t *ciphone;		/* CI-phone information for all ciphones */
    phone_t *phone;		/* Information for all ciphones and triphones */
    s3senid_t **sseq;		/* Unique state (or senone) sequences in this model, shared
				   among all phones/triphones */
    int32 n_sseq;		/* No. of unique senone sequences in this model */
    
    s3senid_t *cd2cisen;	/* Parent CI-senone id for each senone; the first
				   n_ci_sen are identity mappings; the CD-senones are
				   contiguous for each parent CI-phone */
    s3cipid_t *sen2cimap;	/* Parent CI-phone for each senone (CI or CD) */
    int32 *ciphone2n_cd_sen;	/* #CD-senones for each parent CI-phone */
    
    s3cipid_t sil;		/* SILENCE_CIPHONE id */
    
    ph_lc_t ***wpos_ci_lclist;	/* wpos_ci_lclist[wpos][ci] = list of lc for <wpos,ci>.
				   wpos_ci_lclist[wpos][ci][lc].rclist = list of rc for
				   <wpos,ci,lc>.  Only entries for the known triphones
				   are created to conserve space.
				   (NOTE: FOR INTERNAL USE ONLY.) */
} mdef_t;

/* Access macros; not meant for arbitrary use */
#define mdef_is_fillerphone(m,p)	((m)->ciphone[p].filler)
#define mdef_n_ciphone(m)		((m)->n_ciphone)
#define mdef_n_phone(m)			((m)->n_phone)
#define mdef_n_sseq(m)			((m)->n_sseq)
#define mdef_n_emit_state(m)		((m)->n_emit_state)
#define mdef_n_sen(m)			((m)->n_sen)
#define mdef_n_tmat(m)			((m)->n_tmat)
#define mdef_pid2ssid(m,p)		((m)->phone[p].ssid)
#define mdef_pid2tmatid(m,p)		((m)->phone[p].tmat)
#define mdef_silphone(m)		((m)->sil)
#define mdef_sen2cimap(m)		((m)->sen2cimap)


/*
 * Initialize the phone structure from the given model definition file.
 * Return value: pointer to the phone structure created.
 * It should be treated as a READ-ONLY structure.
 */
mdef_t *mdef_init (char *mdeffile);


/* Return value: ciphone id for the given ciphone string name */
s3cipid_t mdef_ciphone_id (mdef_t *m,		/* In: Model structure being queried */
			   char *ciphone);	/* In: ciphone for which id wanted */

/* Return value: READ-ONLY ciphone string name for the given ciphone id */
const char *mdef_ciphone_str (mdef_t *m,	/* In: Model structure being queried */
			      s3cipid_t ci);	/* In: ciphone id for which name wanted */

/* Return 1 if given triphone argument is a ciphone, 0 if not, -1 if error */
int32 mdef_is_ciphone (mdef_t *m,		/* In: Model structure being queried */
		       s3pid_t p);		/* In: triphone id being queried */

/* Return value: phone id for the given constituents if found, else BAD_S3PID */
s3pid_t mdef_phone_id (mdef_t *m,		/* In: Model structure being queried */
		       s3cipid_t b,		/* In: base ciphone id */
		       s3cipid_t l,		/* In: left context ciphone id */
		       s3cipid_t r,		/* In: right context ciphone id */
		       word_posn_t pos);	/* In: Word position */

/*
 * Like phone_id, but backs off to other word positions if exact triphone not found.
 * Also, non-SILENCE_PHONE filler phones back off to SILENCE_PHONE.
 * Ultimately, backs off to base phone id.  Thus, it should never return BAD_S3PID.
 */
s3pid_t mdef_phone_id_nearest (mdef_t *m,	/* In: Model structure being queried */
			       s3cipid_t b,	/* In: base ciphone id */
			       s3cipid_t l,	/* In: left context ciphone id */
			       s3cipid_t r,	/* In: right context ciphone id */
			       word_posn_t pos);	/* In: Word position */

/*
 * Create a phone string for the given phone (base or triphone) id in the given buf.
 * Return value: 0 if successful, -1 if error.
 */
int32 mdef_phone_str (mdef_t *m,		/* In: Model structure being queried */
		      s3pid_t pid,		/* In: phone id being queried */
		      char *buf);		/* Out: On return, buf has the string */

/*
 * Obtain phone components: inverse of mdef_phone_id().
 * Return value: 0 if successful, -1 otherwise.
 */
int32 mdef_phone_components (mdef_t *m,		/* In: Model structure being queried */
			     s3pid_t p,		/* In: triphone id being queried */
			     s3cipid_t *b,	/* Out: base ciphone id */
			     s3cipid_t *l,	/* Out: left context ciphone id */
			     s3cipid_t *r,	/* Out: right context ciphone id */
			     word_posn_t *pos);	/* Out: Word position */

/*
 * Compare the underlying HMMs for two given phones (i.e., compare the two transition
 * matrix IDs and the individual state(senone) IDs).
 * Return value: 0 iff the HMMs are identical, -1 otherwise.
 */
int32 mdef_hmm_cmp (mdef_t *m,			/* In: Model being queried */
		    s3pid_t p1, s3pid_t p2);	/* In: The two triphones being compared */

/*
 * From the given array of active senone-sequence flags, mark the corresponding senones that
 * are active.  Caller responsible for allocating sen[], and for clearing it, if necessary.
 */
void mdef_sseq2sen_active (mdef_t *mdef,
			   int32 *sseq,		/* In: sseq[ss] is != 0 iff senone-sequence ID
						   ss is active */
			   int32 *sen);		/* In/Out: Set sen[s] to non-0 if so indicated
						   by any active senone sequence */

/* For debugging */
void mdef_dump (FILE *fp, mdef_t *m);

/* RAH, For freeing memory */
void mdef_free_recursive_lc (ph_lc_t *lc);
void mdef_free_recursive_rc (ph_rc_t *rc);
void mdef_free (mdef_t *mdef);

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */

#ifdef WIN32			/* RAH, needed for memcpy */
#include <memory.h>
#endif

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <assert.h>
#include "s3types.h"
/*
#include <s2types.h>
*/
#include "new_fe.h"
#include "new_fe_sp.h"

/* 
 *   HISTORY
 *
 *   12-Aug-99 Created by M Seltzer for opensource SPHINX III system
 *             Based in part on past implementations by R Singh, 
 *             M Siegler, M Ravishankar, and others
 *             

      7-Feb-00 M. Seltzer - changed fe_process_utt usage. Function now
      allocated 2d feature array internally and assigns the passed
      pointer to it. This was done to allow for varying numbers of
      frames to be written when block i/o processing
      
      17-Apr-01 RAH, upgraded all floats to float32, it was causing
      some conflicts with external functions that were using float32.
      I know that it doesn't matter for the most part because floats
      are normally float32, however it makes things cleaner.
      
 */  


/*********************************************************************
   FUNCTION:   fe_init
   PARAMETERS: param_t *P
   RETURNS:    pointer to a new front end or NULL if failure.
   DESCRIPTION: builds a front end instance FE according to user
   parameters in P, and completes FE structure accordingly,
   i.e. builds appropriate filters, buffers, etc. If a param in P is
   0 then the FE parameter is set to its default value as defined
   in fe.h 
   Note: if default PRE_EMPHASIS_ALPHA is changed from 0, this will be
   problematic for init of this parameter...
**********************************************************************/

fe_t *fe_init(param_t *P)
{
    fe_t  *FE = (fe_t *) calloc(1,sizeof(fe_t));

    if (FE==NULL){
	fprintf(stderr,"memory alloc failed in fe_init()\n...exiting\n");
	return(NULL);
    }
    
    /* transfer params to front end */
    fe_parse_general_params(P,FE);

    /* compute remaining FE parameters */
    FE->FRAME_SHIFT        = (int32)(FE->SAMPLING_RATE/FE->FRAME_RATE + 0.5);/* why 0.5? */
    FE->FRAME_SIZE         = (int32)(FE->WINDOW_LENGTH*FE->SAMPLING_RATE + 0.5); /* why 0.5? */
    FE->PRIOR              = 0;

    /* establish buffers for overflow samps and hamming window */
    FE->OVERFLOW_SAMPS = (int16 *)calloc(FE->FRAME_SIZE,sizeof(int16));
    FE->HAMMING_WINDOW = (double *) calloc(FE->FRAME_SIZE,sizeof(double));
    
    if (FE->OVERFLOW_SAMPS==NULL || FE->HAMMING_WINDOW==NULL){
	fprintf(stderr,"memory alloc failed in fe_init()\n...exiting\n");
	return(NULL);
    }

    /* create hamming window */    
    fe_create_hamming(FE->HAMMING_WINDOW, FE->FRAME_SIZE);
    
    /* init and fill appropriate filter structure */
    if (FE->FB_TYPE==MEL_SCALE) {   
	if ((FE->MEL_FB = (melfb_t *) calloc(1,sizeof(melfb_t)))==NULL){
	    fprintf(stderr,"memory alloc failed in fe_init()\n...exiting\n");
	    return(NULL);
	}
	/* transfer params to mel fb */
	fe_parse_melfb_params(P, FE->MEL_FB);

	fe_build_melfilters(FE->MEL_FB);
	fe_compute_melcosine(FE->MEL_FB);
    } 
    else {
	fprintf(stderr,"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
	return(NULL);
    }
    return(FE);
}


/*********************************************************************
   FUNCTION: fe_start_utt
   PARAMETERS: fe_t *FE
   RETURNS: 0 if successful
   DESCRIPTION: called at the start of an utterance. resets the
   overflow buffer and activates the start flag of the front end
**********************************************************************/
int32 fe_start_utt(fe_t *FE)
{
    FE->NUM_OVERFLOW_SAMPS = 0;
    memset(FE->OVERFLOW_SAMPS,0,FE->FRAME_SIZE*sizeof(int16));
    FE->START_FLAG=1;
    FE->PRIOR = 0;
    return 0;
}


/*********************************************************************
   FUNCTION: fe_process_utt
   PARAMETERS: fe_t *FE, int16 *spch, int32 nsamps, float **cep
   RETURNS: number of frames of cepstra computed 
   DESCRIPTION: processes the given speech data and returns
   features. will prepend overflow data from last call and store new
   overflow data within the FE
**********************************************************************/
int32 fe_process_utt(fe_t *FE, int16 *spch, int32 nsamps, float32 ***cep_block)	/* RAH, upgraded cep_block to float32 */
{
    int32 frame_start, frame_count=0, whichframe=0;
    int32 i, spbuf_len, offset=0;  
    double *spbuf, *fr_data, *fr_fea;
    int16 *tmp_spch = spch;
    float32 **cep=NULL;
    
    /* are there enough samples to make at least 1 frame? */
    if (nsamps+FE->NUM_OVERFLOW_SAMPS >= FE->FRAME_SIZE){
      
      /* if there are previous samples, pre-pend them to input speech samps */
      if ((FE->NUM_OVERFLOW_SAMPS > 0)) {
	
	if ((tmp_spch = (int16 *) malloc (sizeof(int16)*(FE->NUM_OVERFLOW_SAMPS +nsamps)))==NULL){
	    fprintf(stderr,"memory alloc failed in fe_process_utt()\n...exiting\n");
	    exit(0);
	}
	/* RAH */
	memcpy (tmp_spch,FE->OVERFLOW_SAMPS,FE->NUM_OVERFLOW_SAMPS*(sizeof(int16))); /* RAH */
	memcpy(tmp_spch+FE->NUM_OVERFLOW_SAMPS, spch, nsamps*(sizeof(int16))); /* RAH */
	/* memcpy(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS, spch, nsamps*(sizeof(int16))); */ /*  */
	/* spch = FE->OVERFLOW_SAMPS; */ /*  */
	nsamps += FE->NUM_OVERFLOW_SAMPS;
	FE->NUM_OVERFLOW_SAMPS = 0; /*reset overflow samps count */
      }
      /* compute how many complete frames  can be processed and which samples correspond to those samps */
      frame_count=0;
      for (frame_start=0; frame_start+FE->FRAME_SIZE <= nsamps; frame_start += FE->FRAME_SHIFT)
	frame_count++;


      /*      if (cep!=NULL) fe_free_2d((void**)cep); */ /* It should never not be NULL */
      /* 01.14.01 RAH, added +1 Adding one gives us space to stick the last flushed buffer*/
      if ((cep = (float32 **)fe_create_2d(frame_count+1,FE->NUM_CEPSTRA,sizeof(float32))) == NULL) {
	fprintf(stderr,"memory alloc for cep failed in fe_process_utt()\n\tfe_create_2d(%ld,%d,%d)\n...exiting\n",(long int) (frame_count+1),FE->NUM_CEPSTRA,sizeof(float32));  /* typecast to make the compiler happy - EBG */
	exit(0);
      }


      spbuf_len = (frame_count-1)*FE->FRAME_SHIFT + FE->FRAME_SIZE;    
      /* assert(spbuf_len <= nsamps);*/
      if ((spbuf=(double *)calloc(spbuf_len, sizeof(double)))==NULL){
	  fprintf(stderr,"memory alloc failed in fe_process_utt()\n...exiting\n");
	  exit(0);
      }
      
      /* pre-emphasis if needed,convert from int16 to double */
      if (FE->PRE_EMPHASIS_ALPHA != 0.0){
	fe_pre_emphasis(tmp_spch, spbuf, spbuf_len, FE->PRE_EMPHASIS_ALPHA, FE->PRIOR);
      } else{
	fe_short_to_double(tmp_spch, spbuf, spbuf_len);
      }
      
      /* frame based processing - let's make some cepstra... */    
      fr_data = (double *)calloc(FE->FRAME_SIZE, sizeof(double));
      fr_fea = (double *)calloc(FE->NUM_CEPSTRA, sizeof(double));
      
      if (fr_data==NULL || fr_fea==NULL){
	  fprintf(stderr,"memory alloc failed in fe_process_utt()\n...exiting\n");
	  exit(0);
      }

      for (whichframe=0;whichframe<frame_count;whichframe++){
	for (i=0;i<FE->FRAME_SIZE;i++)
	  fr_data[i] = spbuf[whichframe*FE->FRAME_SHIFT + i];
	
	fe_hamming_window(fr_data, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
	
	fe_frame_to_fea(FE, fr_data, fr_fea);
	
	for (i=0;i<FE->NUM_CEPSTRA;i++)
	  cep[whichframe][i] = (float32)fr_fea[i];
      }
      /* done making cepstra */
      
      
      /* assign samples which don't fill an entire frame to FE overflow buffer for use on next pass */
      if (spbuf_len < nsamps)	{
	offset = ((frame_count)*FE->FRAME_SHIFT);
	memcpy(FE->OVERFLOW_SAMPS,tmp_spch+offset,(nsamps-offset)*sizeof(int16));
	FE->NUM_OVERFLOW_SAMPS = nsamps-offset;
	FE->PRIOR = tmp_spch[offset-1];
	assert(FE->NUM_OVERFLOW_SAMPS<FE->FRAME_SIZE);
      }
      
      if (spch != tmp_spch) 
	free (tmp_spch);
      
      free(spbuf);
      free(fr_data);
      free(fr_fea);
    }
    
    /* if not enough total samps for a single frame, append new samps to
       previously stored overlap samples */
    else { 
      memcpy(FE->OVERFLOW_SAMPS+FE->NUM_OVERFLOW_SAMPS,tmp_spch, nsamps*(sizeof(int16)));
      FE->NUM_OVERFLOW_SAMPS += nsamps;
      assert(FE->NUM_OVERFLOW_SAMPS < FE->FRAME_SIZE);
      frame_count=0;
    }

    *cep_block = cep; /* MLS */
    return frame_count;
}


/*********************************************************************
   FUNCTION: fe_end_utt
   PARAMETERS: fe_t *FE, float *cepvector
   RETURNS: number of frames processed (0 or 1) 
   DESCRIPTION: if there are overflow samples remaining, it will pad
   with zeros to make a complete frame and then process to
   cepstra. also deactivates start flag of FE, and resets overflow
   buffer count. 
**********************************************************************/
int32 fe_end_utt(fe_t *FE, float32 *cepvector)
{
  int32 pad_len=0, frame_count=0;
  int32 i;
  double *spbuf, *fr_fea = NULL;
  
  /* if there are any samples left in overflow buffer, pad zeros to
     make a frame and then process that frame */
  
  if ((FE->NUM_OVERFLOW_SAMPS > 0)) { 
    pad_len = FE->FRAME_SIZE - FE->NUM_OVERFLOW_SAMPS;
    memset(FE->OVERFLOW_SAMPS+(FE->NUM_OVERFLOW_SAMPS),0,pad_len*sizeof(int16));
    FE->NUM_OVERFLOW_SAMPS += pad_len;
    assert(FE->NUM_OVERFLOW_SAMPS==FE->FRAME_SIZE);
    
    if ((spbuf=(double *)calloc(FE->FRAME_SIZE,sizeof(double)))==NULL){
	fprintf(stderr,"memory alloc failed in fe_end_utt()\n...exiting\n");
	exit(0);
    }
 
    if (FE->PRE_EMPHASIS_ALPHA != 0.0){
      fe_pre_emphasis(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE,FE->PRE_EMPHASIS_ALPHA, FE->PRIOR);
    } else {
      fe_short_to_double(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE);
    }
    
    /* again, who should implement cep vector? this can be implemented
       easily from outside or easily from in here */
    if ((fr_fea = (double *)calloc(FE->NUM_CEPSTRA, sizeof(double)))==NULL){
	fprintf(stderr,"memory alloc failed in fe_end_utt()\n...exiting\n");
	exit(0);
    }

    fe_hamming_window(spbuf, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
    fe_frame_to_fea(FE, spbuf, fr_fea);	
    for (i=0;i<FE->NUM_CEPSTRA;i++)
      cepvector[i] = (float32)fr_fea[i];
    frame_count=1;
    free(fr_fea);		/* RAH - moved up */
    free (spbuf);		/* RAH */
  } else {
    frame_count=0;
    cepvector = NULL;
  }
  
  /* reset overflow buffers... */
  FE->NUM_OVERFLOW_SAMPS = 0;
  FE->START_FLAG=0;
  
  return frame_count;
}

/*********************************************************************
   FUNCTION: fe_close
   PARAMETERS: fe_t *FE
   RETURNS: 
   DESCRIPTION: free all allocated memory within FE and destroy FE 
**********************************************************************/

int32 fe_close(fe_t *FE)
{
  /* kill FE instance - free everything... */
  if (FE->FB_TYPE==MEL_SCALE) {
    fe_free_2d((void *)FE->MEL_FB->filter_coeffs);
    fe_free_2d((void *)FE->MEL_FB->mel_cosine);
    free(FE->MEL_FB->left_apex);
    free(FE->MEL_FB->width);
    free(FE->MEL_FB);
  } else {
    fprintf(stderr,"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
  }
    
  free(FE->OVERFLOW_SAMPS);
  free(FE);
  return(0);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
#ifndef _NEW_FE_H_
#define _NEW_FE_H_

#include "s3types.h"

typedef struct{
    float SAMPLING_RATE;
    int32 FRAME_RATE;
    float WINDOW_LENGTH;
    int32 FB_TYPE;
    int32 NUM_CEPSTRA;
    int32 NUM_FILTERS;
    int32 FFT_SIZE;
    float LOWER_FILT_FREQ;
    float UPPER_FILT_FREQ;
    float PRE_EMPHASIS_ALPHA;

    char *wavfile;
    char *cepfile;
    char *ctlfile;
    char *wavdir;
    char *cepdir;
    char *wavext;
    char *cepext;
    int32 input_format;
    int32 is_batch;
    int32 is_single;
    int32 blocksize;
    int32 verbose;
    
    
} param_t;


typedef struct{
    float sampling_rate;
    int32 num_cepstra;
    int32 num_filters;
    int32 fft_size;
    float lower_filt_freq;
    float upper_filt_freq;
    float **filter_coeffs;
    float **mel_cosine;
    float *left_apex;
    int32 *width;
}melfb_t;


typedef struct{
    float SAMPLING_RATE;
    int32 FRAME_RATE;
    int32 FRAME_SHIFT;
    float WINDOW_LENGTH;
    int32 FRAME_SIZE;
    int32 FFT_SIZE;
    int32 FB_TYPE;
    int32 NUM_CEPSTRA;
    float PRE_EMPHASIS_ALPHA;
    int16 *OVERFLOW_SAMPS;
    int32 NUM_OVERFLOW_SAMPS;    
    melfb_t *MEL_FB;
    int32 START_FLAG;
    int16 PRIOR;
    double *HAMMING_WINDOW;
    
} fe_t;



#define MEL_SCALE 1
#define LOG_LINEAR 2

/* Default values */
#define DEFAULT_SAMPLING_RATE 16000.0
#define DEFAULT_FRAME_RATE 100
#define DEFAULT_FRAME_SHIFT 160
#define DEFAULT_WINDOW_LENGTH 0.025625
#define DEFAULT_FFT_SIZE 512
#define DEFAULT_FB_TYPE MEL_SCALE
#define DEFAULT_NUM_CEPSTRA 13
#define DEFAULT_NUM_FILTERS 40
#define DEFAULT_LOWER_FILT_FREQ 133.33334
#define DEFAULT_UPPER_FILT_FREQ 6855.4976
#define DEFAULT_PRE_EMPHASIS_ALPHA 0.97
#define DEFAULT_START_FLAG 0

#define BB_SAMPLING_RATE 16000
#define DEFAULT_BB_FFT_SIZE 512
#define DEFAULT_BB_FRAME_SHIFT 160
#define DEFAULT_BB_NUM_FILTERS 40
#define DEFAULT_BB_LOWER_FILT_FREQ 133.33334
#define DEFAULT_BB_UPPER_FILT_FREQ 6855.4976

#define NB_SAMPLING_RATE 8000
#define DEFAULT_NB_FFT_SIZE 512 /* 256 */
#define DEFAULT_NB_FRAME_SHIFT 80
#define DEFAULT_NB_NUM_FILTERS 31
#define DEFAULT_NB_LOWER_FILT_FREQ 200
#define DEFAULT_NB_UPPER_FILT_FREQ 3500


#define DEFAULT_BLOCKSIZE 200000

/* Functions */

fe_t *fe_init(param_t *P);
int32 fe_start_utt(fe_t *FE);
int32 fe_end_utt(fe_t *FE, float *cepvector);
int32 fe_close(fe_t *FE);
int32 fe_process_utt(fe_t *FE, int16 *spch, int32 nsamps, float32 ***cep_block);
int32 fe_process(fe_t *FE, int16 *spch, int32 nsamps, float ***cep_block);



#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "new_fe.h"
#include "new_fe_sp.h"


/*
  31 Jan 00 mseltzer - changed rounding of filter edges to -not- use 
                        rint() function. 
   3 Dec 99 mseltzer - corrected inverse DCT-2 
                        period is 1/NumFilts not 1/(2*NumFilts)
			added "beta" factor in summation
	  	     - changed mel filter bank construction so that 
                        left,right,center freqs are rounded to DFT 
                        points before filter is constructed
  
*/
                        

int32 fe_build_melfilters(melfb_t *MEL_FB)
{    
    int32 i, whichfilt, start_pt;
    float leftfr, centerfr, rightfr, fwidth, height, *filt_edge;
    float melmax, melmin, dmelbw, freq, dfreq, leftslope,rightslope;

    /*estimate filter coefficients*/
    MEL_FB->filter_coeffs = (float **)fe_create_2d(MEL_FB->num_filters, MEL_FB->fft_size, sizeof(float));
    MEL_FB->left_apex = (float *) calloc(MEL_FB->num_filters,sizeof(float));
    MEL_FB->width = (int32 *) calloc(MEL_FB->num_filters,sizeof(int32));
    
    filt_edge = (float *) calloc(MEL_FB->num_filters+2,sizeof(float));

    if (MEL_FB->filter_coeffs==NULL || MEL_FB->left_apex==NULL || MEL_FB->width==NULL || filt_edge==NULL){
	fprintf(stderr,"memory alloc failed in fe_build_mel_filters()\n...exiting\n");
	exit(0);
    }
    
    dfreq = MEL_FB->sampling_rate/(float)MEL_FB->fft_size;
    
    melmax = fe_mel(MEL_FB->upper_filt_freq);
    melmin = fe_mel(MEL_FB->lower_filt_freq);
    dmelbw = (melmax-melmin)/(MEL_FB->num_filters+1);
    
    for (i=0;i<=MEL_FB->num_filters+1; ++i){
	filt_edge[i] = fe_melinv(i*dmelbw + melmin);
	
    }
    
    

    for (whichfilt=0;whichfilt<MEL_FB->num_filters; ++whichfilt) {
      /*line triangle edges up with nearest dft points... */
      
      /*	
		leftfr = (float)rint((double)(filt_edge[whichfilt]/dfreq))*dfreq;
		centerfr = (float)rint((double)(filt_edge[whichfilt+1]/dfreq))*dfreq;
		rightfr = (float)rint((double)(filt_edge[whichfilt+2]/dfreq))*dfreq;
      */
      
      leftfr   = (float)((int32)((filt_edge[whichfilt]/dfreq)+0.5))*dfreq;
      centerfr = (float)((int32)((filt_edge[whichfilt+1]/dfreq)+0.5))*dfreq;
      rightfr  = (float)((int32)((filt_edge[whichfilt+2]/dfreq)+0.5))*dfreq;
      
      MEL_FB->left_apex[whichfilt] = leftfr;
      
      fwidth = rightfr - leftfr;
      
      /* 2/fwidth for triangles of area 1 */
      height = 2/(float)fwidth;
      leftslope = height/(centerfr-leftfr);
      rightslope = height/(centerfr-rightfr);
      
      start_pt = 1 + (int32)(leftfr/dfreq);
      freq = (float)start_pt*dfreq;
      i=0;
      
      while (freq<=centerfr){
	MEL_FB->filter_coeffs[whichfilt][i] = (freq-leftfr)*leftslope;	    
	freq += dfreq;
	i++;
      }
      while (freq<rightfr){
	MEL_FB->filter_coeffs[whichfilt][i] = (freq-rightfr)*rightslope;
	freq += dfreq;
	i++;
      }
      
      MEL_FB->width[whichfilt] = i;
    }
    
    free(filt_edge);
    return(0);
}

int32 fe_compute_melcosine(melfb_t *MEL_FB)
{

    float period, freq;
    int32 i,j;
    
    period = (float)2*MEL_FB->num_filters;

    if ((MEL_FB->mel_cosine = (float **) fe_create_2d(MEL_FB->num_cepstra,MEL_FB->num_filters,
					      sizeof(float)))==NULL){
	fprintf(stderr,"memory alloc failed in fe_compute_melcosine()\n...exiting\n");
	exit(0);
    }
    
    
    for (i=0; i<MEL_FB->num_cepstra; i++) {
	freq = 2*(float)M_PI*(float)i/period;
	for (j=0;j< MEL_FB->num_filters;j++)
	    MEL_FB->mel_cosine[i][j] = (float)cos((double)(freq*(j+0.5)));	
    }    

    return(0);
	
}


float fe_mel(float x)
{
    return (float)(2595.0*(float)log10(1.0+x/700.0));
}

float fe_melinv(float x)
{
    return(float)(700.0*((float)pow(10.0,x/2595.0) - 1.0));
}


void fe_pre_emphasis(int16 *in, double *out, int32 len, float
		     factor, int16 prior)
{
    int32 i;
  
    out[0] = (double)in[0]-factor*(double)prior;
    for (i=1; i<len;i++) {
	out[i] = (double)in[i] - factor*(double)in[i-1];
    }
 
}

void fe_short_to_double(int16 *in, double *out, int32 len)
{
    int32 i;
    
    for (i=0;i<len;i++)
	out[i] = (double)in[i];
}

    
void fe_create_hamming(double *in, int32 in_len)
{
    int i;
     
    if (in_len>1){
#pragma novector
	for (i=0; i<in_len; i++)
	    in[i] = 0.54 - 0.46*cos(2*M_PI*i/((double)in_len-1.0));
    }
    return;
    
}


void fe_hamming_window(double *in, double *window, int32 in_len)
{
    int i;
    
    if (in_len>1){
	for (i=0; i<in_len; i++)
	    in[i] *= window[i];
    }
    return;
    
}


void fe_frame_to_fea(fe_t *FE, double *in, double *fea)
{
    double *spec, *mfspec;

    /* RAH, typo */
    if (FE->FB_TYPE == MEL_SCALE){
	spec = (double *)calloc(FE->FFT_SIZE, sizeof(double));
	mfspec = (double *)calloc(FE->MEL_FB->num_filters, sizeof(double));

	if (spec==NULL || mfspec==NULL){
	    fprintf(stderr,"memory alloc failed in fe_frame_to_fea()\n...exiting\n");
	    exit(0);
	}
	
 	fe_spec_magnitude(in, FE->FRAME_SIZE, spec, FE->FFT_SIZE);
	fe_mel_spec(FE, spec, mfspec);
	fe_mel_cep(FE, mfspec, fea);
	
	free(spec);
	free(mfspec);	
    }
    else {
	fprintf(stderr,"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
	exit(0);
    }
    
}



void fe_spec_magnitude(double *data, int32 data_len, double *spec, int32 fftsize)
{
    int32  j,wrap;
    complex  *FFT, *IN;
    
    /*fftsize defined at top of file*/
    FFT = (complex *) calloc(fftsize,sizeof(complex));
    IN = (complex *) calloc(fftsize,sizeof(complex));
    
    if (FFT==NULL || IN==NULL){
	fprintf(stderr,"memory alloc failed in fe_spec_magnitude()\n...exiting\n");
	exit(0);
    }
	
    if (data_len > fftsize)  /*aliasing */
    {
	
	for (j=0; j<fftsize;j++) {
	    IN[j].r = data[j];
	    IN[j].i = 0.0;
	}
	for (wrap=0; j<data_len; wrap++,j++) {
	    IN[wrap].r += data[j];
	    IN[wrap].i += 0.0;
	}
    }
    else
    {
	for (j=0; j < data_len; j++){
		IN[j].r = data[j];
		IN[j].i = 0.0;
	}
        for ( ;j<fftsize;j++) {  /*pad zeros if necessary */
		IN[j].r = 0.0;
		IN[j].i = 0.0;
	}
    }
    

    fe_fft(IN,FFT,fftsize,FORWARD_FFT);
    
    for (j=0; j <= fftsize/2; j++)
    {	
	spec[j] = FFT[j].r*FFT[j].r + FFT[j].i*FFT[j].i;
    }

    free(FFT);
    free(IN);
    return;
}

void fe_mel_spec(fe_t *FE, double *spec, double *mfspec)
{
    int32 whichfilt, start, i;
    float dfreq;
    
    dfreq = FE->SAMPLING_RATE/(float)FE->FFT_SIZE;
    
    for (whichfilt = 0; whichfilt<FE->MEL_FB->num_filters; whichfilt++){
	start = (int32)(FE->MEL_FB->left_apex[whichfilt]/dfreq) + 1;
	mfspec[whichfilt] = 0;
	for (i=0; i< FE->MEL_FB->width[whichfilt]; i++)
	    mfspec[whichfilt] +=
		FE->MEL_FB->filter_coeffs[whichfilt][i]*spec[start+i];	
    }
    
}




void fe_mel_cep(fe_t *FE, double *mfspec, double *mfcep)
{
    int32 i,j;
    /*    static int first_run=1;  */  /* unreferenced variable */
    int32 period;
    float beta;

    period = FE->MEL_FB->num_filters;

    for (i=0;i<FE->MEL_FB->num_filters; ++i)
    {
	if (mfspec[i]>0)
	    mfspec[i] = log(mfspec[i]);
	else
	    mfspec[i] = -1.0e+5;

    }
    
    for (i=0; i< FE->NUM_CEPSTRA; ++i){
	mfcep[i] = 0;
	for (j=0;j<FE->MEL_FB->num_filters; j++){
	    if (j==0)
		beta = 0.5;
	    else
		beta = 1.0;
	    mfcep[i] += beta*mfspec[j]*FE->MEL_FB->mel_cosine[i][j];
	}
		mfcep[i] /= (float)period;
    }
    return;
}

int32 fe_fft(complex *in, complex *out, int32 N, int32 invert)
{
  static int32
    s, k,			/* as above				*/
    lgN;			/* log2(N)				*/
  complex
    *f1, *f2,			/* pointers into from array		*/
    *t1, *t2,			/* pointers into to array		*/
    *ww;			/* pointer into w array			*/
  static complex
    *w, *from, *to,		/* as above				*/
    wwf2,			/* temporary for ww*f2			*/
    *buffer,			/* from and to flipflop btw out and buffer */
    *exch,			/* temporary for exchanging from and to	*/
    *wEnd;			/* to keep ww from going off end	*/
  static double
    div,			/* amount to divide result by: N or 1	*/
    x;				/* misc.				*/

  
  /* check N, compute lgN						*/
  for (k = N, lgN = 0; k > 1; k /= 2, lgN++)
  {
    if (k%2 != 0 || N < 0)
    {
      fprintf(stderr, "fft: N must be a power of 2 (is %d)\n", N);
      return(-1);
    }
  }

  /* check invert, compute div						*/
  if (invert == 1)
    div = 1.0;
  else if (invert == -1)
    div = N;
  else
  {
    fprintf(stderr, "fft: invert must be either +1 or -1 (is %d)\n", invert);
    return(-1);
  }

  /* get the to, from buffers right, and init				*/
  buffer = (complex *)calloc(N, sizeof(complex));
  if (lgN%2 == 0)
  {
    from = out;
    to = buffer;
  }
  else
  {
    to = out;
    from = buffer;
  }

  
  for (s = 0; s<N; s++)
  {
      from[s].r = in[s].r/div;
      from[s].i = in[s].i/div;

  }

  /* w = exp(-2*PI*i/N), w[k] = w^k					*/
  w = (complex *) calloc(N/2, sizeof(complex));
  for (k = 0; k < N/2; k++)
  {
    x = -6.28318530717958647*invert*k/N;
    w[k].r = cos(x);
    w[k].i = sin(x);
  }
  wEnd = &w[N/2];
  
  /* go for it!								*/
  for (k = N/2; k > 0; k /= 2)
  {
    for (s = 0; s < k; s++)
    {
      /* initialize pointers						*/
      f1 = &from[s]; f2 = &from[s+k];
      t1 = &to[s]; t2 = &to[s+N/2];
      ww = &w[0];
      /* compute <s,k>							*/
      while (ww < wEnd)
      {
        /* wwf2 = ww*f2							*/
        wwf2.r = f2->r*ww->r - f2->i*ww->i;
        wwf2.i = f2->r*ww->i + f2->i*ww->r;
        /* t1 = f1+wwf2							*/
        t1->r = f1->r + wwf2.r;
        t1->i = f1->i + wwf2.i;
        /* t2 = f1-wwf2							*/
        t2->r = f1->r - wwf2.r;
        t2->i = f1->i - wwf2.i;
        /* increment							*/
        f1 += 2*k; f2 += 2*k;
        t1 += k; t2 += k;
        ww += k;
      }
    }
    exch = from; from = to; to = exch;
  }
  free(buffer);
  free(w);
  return(0);
}



char **fe_create_2d(int32 d1, int32 d2, int32 elem_size)
{
    char *store;
    char **out;
    int32 i, j;
    store = calloc(d1 * d2, elem_size);

    if (store == NULL) {
	fprintf(stderr,"fe_create_2d failed\n");
	return(NULL);
    }
    
    out = calloc(d1, sizeof(void *));

    if (out == NULL) {
	fprintf(stderr,"fe_create_2d failed\n");
	free(store);
	return(NULL);
    }
    
    for (i = 0, j = 0; i < d1; i++, j += d2) {
	out[i] = &((char *)store)[j*elem_size];
    }

    return out;
}

void fe_free_2d(void **arr)
{
    if (arr!=NULL){
	free(arr[0]);
	free(arr);
    }
    
}

void fe_parse_general_params(param_t *P, fe_t *FE)
{

    if (P->SAMPLING_RATE != 0) 
	FE->SAMPLING_RATE = P->SAMPLING_RATE;
    else
	FE->SAMPLING_RATE = DEFAULT_SAMPLING_RATE;

    if (P->FRAME_RATE != 0) 
	FE->FRAME_RATE = P->FRAME_RATE;
    else 
	FE->FRAME_RATE = DEFAULT_FRAME_RATE;
    
    if (P->WINDOW_LENGTH != 0) 
	FE->WINDOW_LENGTH = P->WINDOW_LENGTH;
    else 
	FE->WINDOW_LENGTH = (float)DEFAULT_WINDOW_LENGTH;
    
    if (P->FB_TYPE != 0) 
	FE->FB_TYPE = P->FB_TYPE;
    else 
	FE->FB_TYPE = DEFAULT_FB_TYPE;
 
    if (P->PRE_EMPHASIS_ALPHA != 0) 
	FE->PRE_EMPHASIS_ALPHA = P->PRE_EMPHASIS_ALPHA;
    else 
	FE->PRE_EMPHASIS_ALPHA = (float)DEFAULT_PRE_EMPHASIS_ALPHA;
 
    if (P->NUM_CEPSTRA != 0) 
	FE->NUM_CEPSTRA = P->NUM_CEPSTRA;
    else 
	FE->NUM_CEPSTRA = DEFAULT_NUM_CEPSTRA;

    if (P->FFT_SIZE != 0) 
	FE->FFT_SIZE = P->FFT_SIZE;
    else 
	FE->FFT_SIZE = DEFAULT_FFT_SIZE;
 
}

void fe_parse_melfb_params(param_t *P, melfb_t *MEL)
{
    if (P->SAMPLING_RATE != 0) 
	MEL->sampling_rate = P->SAMPLING_RATE;
    else 
	MEL->sampling_rate = DEFAULT_SAMPLING_RATE;

    if (P->FFT_SIZE != 0) 
	MEL->fft_size = P->FFT_SIZE;
    else {
      if (MEL->sampling_rate == BB_SAMPLING_RATE)
	MEL->fft_size = DEFAULT_BB_FFT_SIZE;
      if (MEL->sampling_rate == NB_SAMPLING_RATE)
	MEL->fft_size = DEFAULT_NB_FFT_SIZE;
    else 
	MEL->fft_size = DEFAULT_FFT_SIZE;
    }
 
    if (P->NUM_CEPSTRA != 0) 
	MEL->num_cepstra = P->NUM_CEPSTRA;
    else 
	MEL->num_cepstra = DEFAULT_NUM_CEPSTRA;
 
    if (P->NUM_FILTERS != 0)	
	MEL->num_filters = P->NUM_FILTERS;
    else {
      if (MEL->sampling_rate == BB_SAMPLING_RATE)
	MEL->num_filters = DEFAULT_BB_NUM_FILTERS;
      else if (MEL->sampling_rate == NB_SAMPLING_RATE)
	MEL->num_filters = DEFAULT_NB_NUM_FILTERS;
      else {
	fprintf(stderr,"Please define the number of MEL filters needed\n");
	fprintf(stderr,"Modify include/new_fe.h and new_fe_sp.c\n");
	fflush(stderr); exit(0);
      }
    }

    if (P->UPPER_FILT_FREQ != 0)	
      MEL->upper_filt_freq = P->UPPER_FILT_FREQ;
    else{
      if (MEL->sampling_rate == BB_SAMPLING_RATE)
	MEL->upper_filt_freq = (float) DEFAULT_BB_UPPER_FILT_FREQ; /* RAH, typecast */
      else if (MEL->sampling_rate == NB_SAMPLING_RATE)
	MEL->upper_filt_freq = DEFAULT_NB_UPPER_FILT_FREQ;
      else {
	fprintf(stderr,"Please define the upper filt frequency needed\n");
	fprintf(stderr,"Modify include/new_fe.h and new_fe_sp.c\n");
	fflush(stderr); exit(0);
      }
    } 
    
    
    if (P->LOWER_FILT_FREQ != 0)	
      MEL->lower_filt_freq = P->LOWER_FILT_FREQ;
    else {
      if (MEL->sampling_rate == BB_SAMPLING_RATE)
	MEL->lower_filt_freq = (float) DEFAULT_BB_LOWER_FILT_FREQ; /*RAH, typecast  */
      else if (MEL->sampling_rate == NB_SAMPLING_RATE)
	MEL->lower_filt_freq = DEFAULT_NB_LOWER_FILT_FREQ;
      else {
	fprintf(stderr,"Please define the lower filt frequency needed\n");
	fprintf(stderr,"Modify include/new_fe.h and new_fe_sp.c\n");
	fflush(stderr); exit(0);
      }
    } 
}

void fe_print_current(fe_t *FE)
{
    fprintf(stderr,"Current FE Parameters:\n");
    fprintf(stderr,"\tSampling Rate:             %f\n",FE->SAMPLING_RATE);
    fprintf(stderr,"\tFrame Size:                %d\n",FE->FRAME_SIZE);
    fprintf(stderr,"\tFrame Shift:               %d\n",FE->FRAME_SHIFT);
    fprintf(stderr,"\tFFT Size:                  %d\n",FE->FFT_SIZE);
    fprintf(stderr,"\tNumber of Overflow Samps:  %d\n",FE->NUM_OVERFLOW_SAMPS);
    fprintf(stderr,"\tStart Utt Status:          %d\n",FE->START_FLAG);
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
#define int32 int

#ifndef	M_PI
#define M_PI	(3.14159265358979323846)
#endif	/* M_PI */

#define FORWARD_FFT 1
#define INVERSE_FFT -1

typedef struct { double r, i; } complex;

/* functions */
int32 fe_build_melfilters(melfb_t *MEL_FB);
int32 fe_compute_melcosine(melfb_t *MEL_FB);
float fe_mel(float x);
float fe_melinv(float x);
void fe_pre_emphasis(int16 *in, double *out, int32 len, float factor, int16 prior);
void fe_hamming_window(double *in, double *window, int32 in_len);
void fe_init_hamming(double *win, int32 len);
void fe_spec_magnitude(double *data, int32 data_len, double *spec, int32 fftsize);
void fe_frame_to_fea(fe_t *FE, double *in, double *fea);
void fe_mel_spec(fe_t *FE, double *spec, double *mfspec);
void fe_mel_cep(fe_t *FE, double *mfspec, double *mfcep);
int32 fe_fft(complex *in, complex *out, int32 N, int32 invert);
void fe_short_to_double(int16 *in, double *out, int32 len);
char **fe_create_2d(int32 d1, int32 d2, int32 elem_size);
void fe_free_2d(void **arr);
void fe_print_current(fe_t *FE);
void fe_parse_general_params(param_t *P, fe_t *FE);
void fe_parse_melfb_params(param_t *P, melfb_t *MEL);
void fe_create_hamming (double *in, int32 in_len);



/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/***********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 2000 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 * Created
 */

#include <stdio.h>
#include "libutil.h"

#include "cmd_ln_args.h"

static arg_t arg[] = {
    { "-logbase",
      ARG_FLOAT32,
      "1.0003",
      "Base in which all log-likelihoods calculated" },
#if 0
    /* Commented out; must be s3_1x39 */
    { "-feat",
      ARG_STRING,
      NULL,
      "Feature type: Must be s3_1x39 / s2_4x / cep_dcep[,%d] / cep[,%d] / %d,%d,...,%d" },
#endif
    { "-lminmemory",
      ARG_INT32,
      "0",
      "Load language model into memory (default: use disk cache for lm"},
    { "-log3table",
      ARG_INT32,
      "1",
      "Determines whether to use the log3 table or to compute the values at run time."},
    { "-vqeval",
      ARG_INT32,
      "3",
      "How many vectors should be analyzed by VQ when building the shortlist. It speeds up the decoder, but at a cost."},

    { "-cmn",
      ARG_STRING,
      "current",
      "Cepstral mean normalization scheme (default: Cep -= mean-over-current-sentence(Cep))" },
    { "-varnorm",
      ARG_STRING,
      "no",
      "Variance normalize each utterance (yes/no; only applicable if CMN is also performed)" },
    { "-agc",
      ARG_STRING,
      "max",
      "Automatic gain control for c0 ('max' or 'none'); (max: c0 -= max-over-current-sentence(c0))" },
    { "-mdef",
      REQARG_STRING,
      NULL,
      "Model definition input file" },
    { "-dict",
      REQARG_STRING,
      NULL,
      "Pronunciation dictionary input file" },
    { "-fdict",
      REQARG_STRING,
      NULL,
      "Filler word pronunciation dictionary input file" },
#if 0
    /* Commented out; not supported */
    { "-compsep",
      ARG_STRING,
      "",	/* Default: No compound word (NULL separator char) */
      "Separator character between components of a compound word (NULL if none)" },
#endif
    { "-lm",
      REQARG_STRING,
      NULL,
      "Word trigram language model input file" },
    { "-fillpen",
      ARG_STRING,
      NULL,
      "Filler word probabilities input file" },
    { "-silprob",
      ARG_FLOAT32,
      "0.1",
      "Default silence word probability" },
    { "-fillprob",
      ARG_FLOAT32,
      "0.1",
      "Default non-silence filler word probability" },
    { "-lw",
      ARG_FLOAT32,
      "8.5",
      "Language weight" },
    { "-wip",
      ARG_FLOAT32,
      "0.7",
      "Word insertion penalty" },
    { "-uw",
      ARG_FLOAT32,
      "0.7",
      "Unigram weight" },
    { "-mean",
      REQARG_STRING,
      NULL,
      "Mixture gaussian means input file" },
    { "-var",
      REQARG_STRING,
      NULL,
      "Mixture gaussian variances input file" },
    { "-varfloor",
      ARG_FLOAT32,
      "0.0001",
      "Mixture gaussian variance floor (applied to data from -var file)" },
    { "-mixw",
      REQARG_STRING,
      NULL,
      "Senone mixture weights input file" },
    { "-mixwfloor",
      ARG_FLOAT32,
      "0.0000001",
      "Senone mixture weights floor (applied to data from -mixw file)" },
    { "-subvq",
      ARG_STRING,
      NULL,
      "Sub-vector quantized form of acoustic model" },
    { "-tmat",
      REQARG_STRING,
      NULL,
      "HMM state transition matrix input file" },
    { "-tmatfloor",
      ARG_FLOAT32,
      "0.0001",
      "HMM state transition probability floor (applied to -tmat file)" },
    { "-Nlextree",
      ARG_INT32,
      "3",
      "No. of lextrees to be instantiated; entries into them staggered in time" },
    { "-epl",
      ARG_INT32,
      "3",
      "Entries Per Lextree; #successive entries into one lextree before lextree-entries shifted to the next" },
    { "-subvqbeam",
      ARG_FLOAT64,
      "3.0e-3",
      "Beam selecting best components within each mixture Gaussian [0(widest)..1(narrowest)]" },
    { "-beam",
      ARG_FLOAT64,
      "1.0e-55",
      "Beam selecting active HMMs (relative to best) in each frame [0(widest)..1(narrowest)]" },
    { "-pbeam",
      ARG_FLOAT64,
      "1.0e-50",
      "Beam selecting HMMs transitioning to successors in each frame [0(widest)..1(narrowest)]" },
    { "-wbeam",
      ARG_FLOAT64,
      "1.0e-35",
      "Beam selecting word-final HMMs exiting in each frame [0(widest)..1(narrowest)]" },
    { "-ctl",
      ARG_STRING,
      NULL,
      "Control file listing utterances to be processed" },
    { "-utt",
      ARG_STRING,
      NULL,
      "Utterance file to be processed (-ctlcount argument times)" },
    { "-ctloffset",
      ARG_INT32,
      "0",
      "No. of utterances at the beginning of -ctl file to be skipped" },
    { "-ctlcount",
      ARG_INT32,
      "1000000000",	/* A big number to approximate the default: "until EOF" */
      "No. of utterances to be processed (after skipping -ctloffset entries)" },
    { "-cepdir",
      ARG_STRING,
      NULL,
      "Input cepstrum files directory (prefixed to filespecs in control file)" },
    { "-bptbldir",
      ARG_STRING,
      NULL,
      "Directory in which to dump word Viterbi back pointer table (for debugging)" },
    { "-outlatdir",
      ARG_STRING,
      NULL,
      "Directory in which to dump word lattices" },
    { "-outlatoldfmt",
      ARG_INT32,
      "1",
      "Whether to dump lattices in old format" },
    { "-latext",
      ARG_STRING,
      "lat.gz",
      "Filename extension for lattice files (gzip compressed, by default)" },
    { "-hmmdump",
      ARG_INT32,
      "0",
      "Whether to dump active HMM details to stderr (for debugging)" },
    { "-lextreedump",
      ARG_INT32,
      "0",
      "Whether to dump the lextree structure to stderr (for debugging)" },
    { "-maxwpf",
      ARG_INT32,
      "20",
      "Max no. of distinct word exits to maintain at each frame" },
    { "-maxhistpf",
      ARG_INT32,
      "100",
      "Max no. of histories to maintain at each frame" },
    { "-bghist",
      ARG_INT32,
      "0",
      "Bigram-mode: If TRUE only one BP entry/frame; else one per LM state" },
    { "-maxhmmpf",
      ARG_INT32,
      "20000",
      "Max no. of active HMMs to maintain at each frame; approx." },
    { "-hmmhistbinsize",
      ARG_INT32,
      "5000",
      "Performance histogram: #frames vs #HMMs active; #HMMs/bin in this histogram" },
    { "-ptranskip",
      ARG_INT32,
      "0",
      "Use wbeam for phone transitions every so many frames (if >= 1)" },
    { "-hypseg",
      ARG_STRING,
      NULL,
      "Recognition result file, with word segmentations and scores" },
    { "-treeugprob",
      ARG_INT32,
      "1",
      "If TRUE (non-0), Use unigram probs in lextree" },
    { "-maxhyplen",
      ARG_INT32,
      "1000",
      "Maximum number of words in a partial hypothesis (for block decoding)" },
    { "-maxcepvecs",
      ARG_INT32,
      "256",
      "Maximum number of cepstral vectors that can be obtained from a single sample buffer" },
    { "-samprate",
      ARG_INT32,
      "8000",
      "Sampling rate (only 8K and 16K currently supported)" },
    { "-nfilt",
      ARG_INT32,
      "31",
      "Number of mel filters" },
    { "-lowerf",
      ARG_FLOAT32,
      "200",
      "Lower edge of filters" },
    { "-upperf",
      ARG_FLOAT32,
      "3500",
      "Upper edge of filters" },
    
    { NULL, ARG_INT32, NULL, NULL }
};

static char **liveargs = NULL;		/* RAH, make global so we can free it later */

void  parse_args_file(char *live_args)
{
  /*    static char **liveargs; */	/* RAH, 4.17.01 */
    static int32 nliveargs;
    int32 nargs, maxarglen;
    char  *argline, *targ; 
    FILE *fp;

    if (live_args == NULL) {
      cmd_ln_print_help(stderr, arg);
      return;
    }
    if ((fp = fopen(live_args,"r")) == NULL)
	E_FATAL("Unable to open arguments file %s for reading\n",live_args);

    argline = (char*) ckd_calloc(10000,sizeof(char)); /* Longest line allowed */
    nargs = 1;
    maxarglen = 0;
    while (fgets(argline,10000,fp) != NULL){
        if ((targ = strtok(argline," \t\n")) == NULL)
            continue; /* Empty line in argfile */
      if ((int32) strlen(targ) > maxarglen) maxarglen = strlen(targ);
	nargs++; 

        while ((targ = strtok(NULL," \t\n")) != NULL){
	if ((int32) strlen(targ) > maxarglen) maxarglen = strlen(targ);
	    nargs++; 
	}
    }
    rewind(fp);

    nliveargs = nargs;
    liveargs = (char**) ckd_calloc_2d(nargs,maxarglen+1,sizeof(char));

    nargs = 1;
    while (fgets(argline,10000,fp) != NULL){
        if ((targ = strtok(argline," \t\n")) == NULL)
            continue; /* Empty line in argfile */

        strcpy(liveargs[nargs++],targ);
        while ((targ = strtok(NULL," \t\n")) != NULL){
            strcpy(liveargs[nargs++],targ);
	}
    }
    fclose(fp);

    assert(nargs == nliveargs);
    free(argline);
    cmd_ln_parse(arg, nliveargs, liveargs);
    return;
}

/* RAH, 4.17.01, free memory that was allocated above */
void parse_args_free()
{
  cmd_ln_free();		/* Free stuff allocated in cmd_ln_parse */
  ckd_free_2d ((void **) liveargs);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * prim_type.h -- Primitive types; more machine-independent.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 12-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added arraysize_t, point_t, fpoint_t.
 * 
 * 01-Feb-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Added anytype_t.
 * 
 * 08-31-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon
 * 		Created.
 */


#ifndef _LIBUTIL_PRIM_TYPE_H_
#define _LIBUTIL_PRIM_TYPE_H_


typedef int		int32;
typedef short		int16;
typedef char		int8;
typedef unsigned int	uint32;
typedef unsigned short	uint16;
typedef unsigned char	uint8;
typedef float		float32;
typedef double		float64;

typedef union anytype_s {
    void *ptr;		/* User defined data types at this ptr */
    int32 int32;
    uint32 uint32;
    float32 float32;
    float64 float64;
} anytype_t;


/* Useful constants */
#define MAX_INT32		((int32) 0x7fffffff)
#define MAX_INT16		((int16) 0x00007fff)
#define MAX_INT8		((int8)  0x0000007f)

#define MAX_NEG_INT32		((int32) 0x80000000)
#define MAX_NEG_INT16		((int16) 0xffff8000)
#define MAX_NEG_INT8		((int8)  0xffffff80)

#define MAX_UINT32		((uint32) 0xffffffff)
#define MAX_UINT16		((uint16) 0x0000ffff)
#define MAX_UINT8		((uint8)  0x000000ff)

/* The following are approximate; IEEE floating point standards might quibble! */
#define MAX_POS_FLOAT32		3.4e+38f
#define MIN_POS_FLOAT32		1.2e-38f	/* But not 0 */
#define MAX_POS_FLOAT64		1.8e+307
#define MIN_POS_FLOAT64		2.2e-308

/* Will the following really work?? */
#define MAX_NEG_FLOAT32		((float32) (-MAX_POS_FLOAT32))
#define MIN_NEG_FLOAT32		((float32) (-MIN_POS_FLOAT32))
#define MAX_NEG_FLOAT64		((float64) (-MAX_POS_FLOAT64))
#define MIN_NEG_FLOAT64		((float64) (-MIN_POS_FLOAT64))


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * profile.c -- For timing and event counting.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 11-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added ptmr_init().
 * 
 * 19-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if (! WIN32)
#include <unistd.h>
#include <sys/time.h>
#include <sys/resource.h>
#else
#include <windows.h>
#include <time.h>
#endif

#include "profile.h"
#include "err.h"


#if (__ALPHA_OSF1__)
extern uint32 rpcc( void );	/* On an alpha, use the RPCC instruction */
#endif


void pctr_reset (pctr_t *ctr)
{
    ctr->count = 0;
}


void pctr_reset_all (pctr_t *ctr)
{
    for (; ctr->name; ctr++)
	pctr_reset (ctr);
}


void pctr_print_all (FILE *fp, pctr_t *ctr)
{
    if (! ctr->name)
	return;
    
    fprintf (fp, "CTR:");
    for (; ctr->name; ctr++)
	fprintf (fp, "  %d %s", ctr->count, ctr->name);
    fprintf (fp, "\n");
}


int32 host_pclk (int32 dummy)
{
    int32 mhz = 0;
#if (__ALPHA_OSF1__)
    int32 i, j, k, besti, bestj, diff;
    uint32 rpcc_start, rpcc_end;
    struct rusage start, stop;
    float64 t;
    
    memset (&start, 0, sizeof(struct rusage));
    memset (&stop, 0, sizeof(struct rusage));
    
    getrusage (RUSAGE_SELF, &start);
    rpcc_start = rpcc();
    /* Consume some cpu cycles; dummy to forced compiler not to optimize loop away */
    dummy &= 0x7fffffff;
    dummy |= 0x70000000;
    for (i = 1; i < 100000000; i++)
	if (i > dummy)
	    return (i);
    rpcc_end = rpcc();
    getrusage (RUSAGE_SELF, &stop);
    
    t = (stop.ru_utime.tv_sec - start.ru_utime.tv_sec) + 
	((stop.ru_utime.tv_usec - start.ru_utime.tv_usec) * 0.000001);
    mhz = ((rpcc_end - rpcc_start) / t) * 0.000001 + 0.5;
    diff = (int32)0x7fffffff;
    for (i = 100; i <= 1000; i += 100) {
	for (j = 1; j <= 10; j++) {
	    k = i/j - mhz;
	    if (k < 0)
		k = -k;
	    if (k < diff) {
		diff = k;
		besti = i;
		bestj = j;
	    }
	}
    }
    mhz = besti/bestj;
    E_INFO("%d ticks in %.3f sec; machine clock rate = %d MHz\n",
	   rpcc_end - rpcc_start, t, mhz);
#endif
    
    return mhz;
}


#if (WIN32)

#define TM_LOWSCALE	1e-7
#define TM_HIGHSCALE	(4294967296.0 * TM_LOWSCALE);

static float64 make_sec (FILETIME *tm)
{
    float64 dt;
    
    dt = tm->dwLowDateTime * TM_LOWSCALE;
    dt += tm->dwHighDateTime * TM_HIGHSCALE;
    
    return (dt);
}

#else

static float64 make_sec (struct timeval *s)
{
    return (s->tv_sec + s->tv_usec * 0.000001);
}

#endif


void ptmr_start (ptmr_t *tm)
{
#if (! WIN32)
    struct timeval e_start;	/* Elapsed time */
    
#if (! _HPUX_SOURCE)
    struct rusage start;	/* CPU time */
    
    /* Unix but not HPUX */
    getrusage (RUSAGE_SELF, &start);
    tm->start_cpu = make_sec (&start.ru_utime) + make_sec (&start.ru_stime);
#endif
    /* Unix + HP */
    gettimeofday (&e_start, 0);
    tm->start_elapsed = make_sec (&e_start);
#else
    HANDLE pid;
    FILETIME t_create, t_exit, kst, ust;
    
    /* PC */
    pid = GetCurrentProcess();
    GetProcessTimes (pid, &t_create, &t_exit, &kst, &ust);
    tm->start_cpu = make_sec (&ust) + make_sec (&kst);

    tm->start_elapsed = (float64)clock() / CLOCKS_PER_SEC;
#endif
}


void ptmr_stop (ptmr_t *tm)
{
    float64 dt_cpu, dt_elapsed;
    
#if (! WIN32)
    struct timeval e_stop;	/* Elapsed time */
    
#if (! _HPUX_SOURCE)
    struct rusage stop;		/* CPU time */
    
    /* Unix but not HPUX */
    getrusage (RUSAGE_SELF, &stop);
    dt_cpu = make_sec (&stop.ru_utime) + make_sec (&stop.ru_stime) - tm->start_cpu;
#else
    dt_cpu = 0.0;
#endif
    /* Unix + HP */
    gettimeofday (&e_stop, 0);
    dt_elapsed = (make_sec (&e_stop) - tm->start_elapsed);
#else
    HANDLE pid;
    FILETIME t_create, t_exit, kst, ust;
    
    /* PC */
    pid = GetCurrentProcess();
    GetProcessTimes (pid, &t_create, &t_exit, &kst, &ust);
    dt_cpu = make_sec (&ust) + make_sec (&kst) - tm->start_cpu;
    dt_elapsed = ((float64)clock() / CLOCKS_PER_SEC) - tm->start_elapsed;
#endif

    tm->t_cpu += dt_cpu;
    tm->t_elapsed += dt_elapsed;

    tm->t_tot_cpu += dt_cpu;
    tm->t_tot_elapsed += dt_elapsed;
}


void ptmr_reset (ptmr_t *tm)
{
    tm->t_cpu = 0.0;
    tm->t_elapsed = 0.0;
}


void ptmr_init (ptmr_t *tm)
{
    tm->t_cpu = 0.0;
    tm->t_elapsed = 0.0;
    tm->t_tot_cpu = 0.0;
    tm->t_tot_elapsed = 0.0;
}


void ptmr_reset_all (ptmr_t *tm)
{
    for (; tm->name; tm++)
	ptmr_reset (tm);
}


void ptmr_print_all (FILE *fp, ptmr_t *tm, float64 norm)
{
    if (norm != 0.0) {
	norm = 1.0/norm;
	for (; tm->name; tm++)
	    fprintf (fp, "  %6.2fx %s", tm->t_cpu * norm, tm->name);
    }
}


int32 host_endian ( void )
{
    FILE *fp;
    int32 BYTE_ORDER_MAGIC;
    char *file;
    char buf[8];
    int32 k, endian;
    
    file = "/tmp/__EnDiAn_TeSt__";
    
    if ((fp = fopen(file, "wb")) == NULL) {
	E_ERROR("fopen(%s,wb) failed\n", file);
	return -1;
    }
    
    BYTE_ORDER_MAGIC = (int32)0x11223344;
    
    k = (int32) BYTE_ORDER_MAGIC;
    if (fwrite (&k, sizeof(int32), 1, fp) != 1) {
	E_ERROR("fwrite(%s) failed\n", file);
	fclose (fp);
	unlink(file);
	return -1;
    }
    
    fclose (fp);
    if ((fp = fopen (file, "rb")) == NULL) {
	E_ERROR ("fopen(%s,rb) failed\n", file);
	unlink(file);
	return -1;
    }
    if (fread (buf, 1, sizeof(int32), fp) != sizeof(int32)) {
	E_ERROR ("fread(%s) failed\n", file);
	fclose (fp);
	unlink(file);
	return -1;
    }
    fclose (fp);
    unlink(file);
    
    /* If buf[0] == lsB of BYTE_ORDER_MAGIC, we are little-endian */
    endian = (buf[0] == (BYTE_ORDER_MAGIC & 0x000000ff)) ? 1 : 0;
    
    return (endian);
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * profile.h -- For timing and event counting.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 11-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added ptmr_init().
 * 
 * 19-Jun-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Created from earlier Sphinx-3 version.
 */


#ifndef _LIBUTIL_PROFILE_H_
#define _LIBUTIL_PROFILE_H_


#include "prim_type.h"


/*
 * Generic event counter for profiling.  User is responsible for allocating an array
 * of the desired number.  There should be a sentinel with name = NULL.
 */
typedef struct {
    const char *name;		/* Counter print name; NULL terminates array of counters.
				   Used by pctr_print_all */
    int32 count;		/* Counter value */
} pctr_t;


void pctr_reset (pctr_t *ctr);
void pctr_reset_all (pctr_t *ctr);
void pctr_print_all (FILE *fp, pctr_t *ctr);


/*
 * Generic timer structures and functions for coarse-grained performance measurements
 * using standard system calls.
 */
typedef struct {
    const char *name;		/* Timer print name; NULL terminates an array of timers.
				   Used by ptmr_print_all */
    float64 t_cpu;		/* CPU time accumulated since most recent reset op */
    float64 t_elapsed;		/* Elapsed time accumulated since most recent reset */
    float64 t_tot_cpu;		/* Total CPU time since creation */
    float64 t_tot_elapsed;	/* Total elapsed time since creation */
    float64 start_cpu;		/* ---- FOR INTERNAL USE ONLY ---- */
    float64 start_elapsed;	/* ---- FOR INTERNAL USE ONLY ---- */
} ptmr_t;


/* Start timing using tmr */
void ptmr_start (ptmr_t *tmr);

/* Stop timing and accumulate tmr->{t_cpu, t_elapsed, t_tot_cpu, t_tot_elapsed} */
void ptmr_stop (ptmr_t *tmr);

/* Reset tmr->{t_cpu, t_elapsed} to 0.0 */
void ptmr_reset (ptmr_t *tmr);

/* Reset tmr->{t_cpu, t_elapsed, t_tot_cpu, t_tot_elapsed} to 0.0 */
void ptmr_init (ptmr_t *tmr);


/*
 * Reset t_cpu, t_elapsed of all timer modules in array tmr[] to 0.0.
 * The array should be terminated with a sentinel with .name = NULL.
 */
void ptmr_reset_all (ptmr_t *tmr);

/*
 * Print t_cpu for all timer modules in tmr[], normalized by norm (i.e., t_cpu/norm).
 * The array should be terminated with a sentinel with .name = NULL.
 */
void ptmr_print_all (FILE *fp, ptmr_t *tmr, float64 norm);


/*
 * Return the processor clock speed (in MHz); only available on some machines (Alphas).
 * The dummy argument can be any integer value.
 */
int32 host_pclk (int32 dummy);


/*
 * Check the native byte-ordering of the machine by writing a magic number to a
 * temporary file and reading it back.
 * Return value: 0 if BIG-ENDIAN, 1 if LITTLE-ENDIAN, -1 if error.
 */
int32 host_endian ( void );


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * s3types.h -- Types specific to s3 decoder.
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 13-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Changed typedef source for s3ssid_t from int32 to s3pid_t.
 * 		Changed s3senid_t from int16 to int32 (to conform with composite senid
 * 		which is int32).
 * 
 * 04-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added senone sequence ID (s3ssid_t).
 * 
 * 12-Jul-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started.
 */


#ifndef _S3_S3TYPES_H_
#define _S3_S3TYPES_H_


#include "libutil.h"


/*
 * Size definitions for more semantially meaningful units.
 * Illegal value definitions, limits, and tests for specific types.
 * NOTE: Types will be either int32 or smaller; only smaller ones may be unsigned (i.e.,
 * no type will be uint32).
 */

typedef int8		s3cipid_t;	/* Ci phone id */
#define BAD_S3CIPID	((s3cipid_t) -1)
#define NOT_S3CIPID(p)	((p)<0)
#define IS_S3CIPID(p)	((p)>=0)
#define MAX_S3CIPID	127

typedef int32		s3pid_t;	/* Phone id (triphone or ciphone) */
#define BAD_S3PID	((s3pid_t) -1)
#define NOT_S3PID(p)	((p)<0)
#define IS_S3PID(p)	((p)>=0)
#define MAX_S3PID	((int32)0x7ffffffe)

typedef s3pid_t		s3ssid_t;	/* Senone sequence id (triphone or ciphone) */
#define BAD_S3SSID	((s3ssid_t) -1)
#define NOT_S3SSID(p)	((p)<0)
#define IS_S3SSID(p)	((p)>=0)
#define MAX_S3SSID	((int32)0x7ffffffe)

typedef int32		s3tmatid_t;	/* Transition matrix id; there can be as many as pids */
#define BAD_S3TMATID	((s3tmatid_t) -1)
#define NOT_S3TMATID(t)	((t)<0)
#define IS_S3TMATID(t)	((t)>=0)
#define MAX_S3TMATID	((int32)0x7ffffffe)

typedef int32		s3wid_t;	/* Dictionary word id */
#define BAD_S3WID	((s3wid_t) -1)
#define NOT_S3WID(w)	((w)<0)
#define IS_S3WID(w)	((w)>=0)
#define MAX_S3WID	((int32)0x7ffffffe)

typedef uint16		s3lmwid_t;	/* LM word id (uint16 for conserving space) */
#define BAD_S3LMWID	((s3lmwid_t) 0xffff)
#define NOT_S3LMWID(w)	((w)==BAD_S3LMWID)
#define IS_S3LMWID(w)	((w)!=BAD_S3LMWID)
#define MAX_S3LMWID	((uint32)0xfffe)

typedef int32		s3latid_t;	/* Lattice entry id */
#define BAD_S3LATID	((s3latid_t) -1)
#define NOT_S3LATID(l)	((l)<0)
#define IS_S3LATID(l)	((l)>=0)
#define MAX_S3LATID	((int32)0x7ffffffe)

typedef int16   	s3frmid_t;	/* Frame id (must be SIGNED integer) */
#define BAD_S3FRMID	((s3frmid_t) -1)
#define NOT_S3FRMID(f)	((f)<0)
#define IS_S3FRMID(f)	((f)>=0)
#define MAX_S3FRMID	((int32)0x7ffe)

typedef int16   	s3senid_t;	/* Senone id */
#define BAD_S3SENID	((s3senid_t) -1)
#define NOT_S3SENID(s)	((s)<0)
#define IS_S3SENID(s)	((s)>=0)
#define MAX_S3SENID	((int16)0x7ffe)

typedef int16   	s3mgauid_t;	/* Mixture-gaussian codebook id */
#define BAD_S3MGAUID	((s3mgauid_t) -1)
#define NOT_S3MGAUID(m)	((m)<0)
#define IS_S3MGAUID(m)	((m)>=0)
#define MAX_S3MGAUID	((int32)0x00007ffe)


#define S3_START_WORD		"<s>"
#define S3_FINISH_WORD		"</s>"
#define S3_SILENCE_WORD		"<sil>"
#define S3_UNKNOWN_WORD		"<UNK>"
#define S3_SILENCE_CIPHONE	"SIL"

#define S3_LOGPROB_ZERO		((int32) 0xc8000000)	/* Approx -infinity!! */
/* #define S3_MAX_FRAMES		30000   */ /* Frame = 10msec */  /* RAH, I believe this is unreasonably large and not feasible */ /* Frame = 10msec */
#define S3_MAX_FRAMES		15000    /* RAH, I believe this is still too large, but better than before */

#ifndef USE_ICC
#define __declspec(x) 
#define align(x)
#endif

#endif
sed -e '/include/s/<libutil\/libutil.h>/"libutil.h"/g' $1 > blah ; mv blah $1
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * str2words.c -- Convert a string to an array of words
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 21-Oct-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "str2words.h"


int32 str2words (char *line, char **ptr, int32 max_ptr)
{
    int32 i, n;
    
    n = 0;	/* #words found so far */
    i = 0;	/* For scanning through the input string */
    for (;;) {
	/* Skip whitespace before next word */
	for (; line[i] && (isspace(line[i])); i++);
	if (! line[i])
	    break;
	
	if (n >= max_ptr) {
	    /*
	     * Pointer array size insufficient.  Restore NULL chars inserted so far
	     * to space chars.  Not a perfect restoration, but better than nothing.
	     */
	    for (; i >= 0; --i)
		if (line[i] == '\0')
		    line[i] = ' ';
	    
	    return -1;
	}
	
	/* Scan to end of word */
	ptr[n++] = line+i;
	for (; line[i] && (! isspace(line[i])); i++);
	if (! line[i])
	    break;
	line[i++] = '\0';
    }
    
    return n;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * str2words.h -- Convert a line to an array of words
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 07-Apr-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created.
 */


#ifndef _LIBUTIL_STR2WORDS_H_
#define _LIBUTIL_STR2WORDS_H_


#include "prim_type.h"


/*
 * Convert a line to an array of "words", based on whitespace separators.  A word
 * is a string with no whitespace chars in it.
 * Note that the string line is modified as a result: NULL chars are placed after
 * every word in the line.
 * Return value: No. of words found; -1 if no. of words in line exceeds n_wptr.
 */
int32 str2words (char *line,	/* In: line to be parsed */
		 char **wptr,	/* In/Out: Array of pointers to words found in line.
				   The array must be allocated by the caller */
		 int32 n_wptr);	/* In: Size of wptr array */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * subvq.c
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Updated subvq_free () to free allocated memory
 * 
 * 17-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added handling of a single sub-vector in subvq_mgau_shortlist().
 * 
 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changes due to moving subvq_t.{frm_sen_eval,frm_gau_eval} to cont_mgau.h.
 * 
 * 14-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_t.{frm_sen_eval,frm_gau_eval}.  Changed subvq_frame_eval to
 * 		return the normalization factor.
 * 
 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_subvec_eval_logs3().
 * 
 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changed ci_active flags input to sen_active in subvq_frame_eval().
 * 
 * 21-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Bugfix in subvq_init() that used g for allocating working areas, even
 *		though g wasn't defined.
 * 
 * 20-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_gautbl_eval_logs3() and used it in subvq_frame_eval().
 * 
 * 12-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "subvq.h"
/* #include "cmd_ln_args.h"	*/ /* RAH, added so we can allow for -vqeval parameter */
#include "s3types.h"
#if defined(THRD) 
#include "utt.h"
#ifdef NEW_EVAL_LOGS3
#include "barrier.h"
#include <pthread.h>
#endif
#endif

/* RAH, 5.8.01, VQ_EVAL determines how many vectors are used to
 * compute the shortlist, for now this value is only relevant when n_sv =3.
 * Setting it to 1 means that only the CEP values are estimated, 2 means that 
 * CEP and delta values are estimated, 3 means all three are estimated.
 * Note, we must adjust the beam widths as we muck around with these.
 */
int VQ_EVAL = 3;		


/*
 * Precompute variances/(covariance-matrix-determinants) to simplify Mahalanobis distance
 * calculation.  Also, calculate 1/(det) for the original codebooks, based on the VQ vars.
 * (See comment in libmisc/vector.h.)
 */
static void subvq_maha_precomp (subvq_t *svq, float64 floor)
{
    int32 s;
    float32 *lrd;
    vector_gautbl_t *gautbl;
    
    E_INFO("Precomputing Mahalanobis distance invariants\n");
    
    lrd = (float32 *) ckd_calloc (svq->n_sv * svq->vqsize, sizeof(float32));
    
    for (s = 0; s < svq->n_sv; s++) {
	gautbl = &(svq->gautbl[s]);

	vector_gautbl_var_floor (gautbl, floor);
	
	gautbl->lrd = lrd;
	lrd += svq->vqsize;
	vector_gautbl_maha_precomp (gautbl);
    }
}


static void subvq_map_compact (subvq_t *vq, mgau_model_t *g)
{
    int32 r, c, c2, s;
    
    if (g) {
	if ((g->n_mgau != vq->origsize.r) || (g->max_comp != vq->origsize.c))
	    E_FATAL("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
		    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
    
    /*
     * Compress map entries by removing invalid ones.  NOTE: There's not much of a consistency
     * check to ensure that the entries remaining do map correctly on to the valid entries in
     * the original (parent) mixture Gaussian model g.  The only check we have is to verify
     * the NUMBER of valid entries (components) in each mixture.
     */
    for (r = 0; r < vq->origsize.r; r++) {
	for (c = 0, c2 = 0; c < vq->origsize.c; c++) {
	    if (vq->map[r][c][0] < 0) {
		/* All ought to be < 0 */
		for (s = 1; s < vq->n_sv; s++) {
		    if (vq->map[r][c][s] >= 0)
			E_FATAL("Partially undefined map[%d][%d]\n", r, c);
		}
	    } else {
		if (c2 != c) {
		    for (s = 0; s < vq->n_sv; s++) {
			if (vq->map[r][c][s] < 0)
			    E_FATAL("Partially undefined map[%d][%d]\n", r, c);
			vq->map[r][c2][s] = vq->map[r][c][s];
		    }
		}
		c2++;
	    }
	}
	
	if (g && (c2 != mgau_n_comp (g, r)))
	    E_FATAL("Mixture %d: #Valid components conflict: %d (SubVQ) vs %d (Original)\n",
		    r, c2, mgau_n_comp(g,r));
	
	/* Invalidate the remaining map entries, for good measure */
	for (; c2 < vq->origsize.c; c2++) {
	    for (s = 0; s < vq->n_sv; s++)
		vq->map[r][c2][s] = -1;
	}
    }
}


/*
 * At this point, a map entries is an index within the subvector; i.e., map[r][c][s] points to
 * a subvq codeword within subvector s.  In evaluating a complete density using it subvq
 * component scores, these maps are used, with 2 lookups for each sub-vector.  To reduce the
 * lookups, linearize the map entries by viewing the subvq scores as a linear array rather than
 * a 2-D array.
 */
static void subvq_map_linearize (subvq_t *vq)
{
    int32 r, c, s;
    
    for (r = 0; r < vq->origsize.r; r++) {
	for (c = 0; (c < vq->origsize.c) && (vq->map[r][c][0] >= 0); c++) {
	    for (s = 0; s < vq->n_sv; s++)
		vq->map[r][c][s] = (s * vq->vqsize) + vq->map[r][c][s];
	}
    }
}


subvq_t *subvq_init (char *file, float64 varfloor, int32 max_sv, mgau_model_t *g)
{
    FILE *fp;
    char line[16384];
    int32 n_sv;		/* #Subvectors in file, as opposed to that used */
    int32 s, k, l, n, r, c;
    char *strp;
    subvq_t *vq;
    
    VQ_EVAL = cmd_ln_int32 ("-vqeval");	/* RAH, Currently only works when n_sv = 3, values computed but ignored in other cases */

    E_INFO("Loading Mixture Gaussian sub-VQ file '%s' (vq_eval: %d)\n", file,VQ_EVAL);
    
    vq = (subvq_t *) ckd_calloc (1, sizeof(subvq_t));
    
    fp = myfopen(file, "r");
    
    /* Read until "Sub-vectors" */
    for (;;) {
	if (fgets (line, sizeof(line), fp) == NULL)
	    E_FATAL("Failed to read VQParam header\n");
	if (sscanf (line, "VQParam %d %d -> %d %d",
		    &(vq->origsize.r), &(vq->origsize.c), &(vq->n_sv), &(vq->vqsize)) == 4)
	    break;
    }
    
    if (g) {
	if ((g->n_mgau != vq->origsize.r) || (g->max_comp != vq->origsize.c))
	    E_FATAL("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
		    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
    
    if (max_sv < 0)
      max_sv = vq->n_sv;
    if (max_sv < vq->n_sv)
      E_INFO("Using %d subvectors out of %d\n", max_sv, vq->n_sv);
    else if (max_sv > vq->n_sv) {
      E_WARN("#Subvectors specified(%d) > available(%d); using latter\n", max_sv, vq->n_sv);
      max_sv = vq->n_sv;
    }
    
    n_sv = vq->n_sv;
    vq->n_sv = max_sv;
    if (vq->n_sv < VQ_EVAL)	/* RAH, 5.9.01, sanity check to make sure VQ_EVAL isn't higher than the n_sv */
      VQ_EVAL = vq->n_sv;
    vq->featdim = (int32 **) ckd_calloc (vq->n_sv, sizeof(int32 *));
    vq->gautbl = (vector_gautbl_t *) ckd_calloc (vq->n_sv, sizeof(vector_gautbl_t));
    vq->map = (int32 ***) ckd_calloc_3d (vq->origsize.r, vq->origsize.c, vq->n_sv,
					 sizeof(int32));
    
    /* Read subvector sizes and feature dimension maps */
    for (s = 0; s < n_sv; s++) {
	if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Subvector %d length %d%n", &k, &l, &n) != 2) || (k != s))
	    E_FATAL("Error reading length(subvector %d)\n", s);
	
	if (s < vq->n_sv) {
	    vq->gautbl[s].veclen = l;
	    vq->featdim[s] = (int32 *) ckd_calloc (vq->gautbl[s].veclen, sizeof(int32));
	
	    for (strp = line+n, c = 0; c < vq->gautbl[s].veclen; c++) {
		if (sscanf (strp, "%d%n", &(vq->featdim[s][c]), &n) != 1)
		    E_FATAL("Error reading subvector(%d).featdim(%d)\n", s, c);
		strp += n;
	    }
	    
	    vector_gautbl_alloc (&(vq->gautbl[s]), vq->vqsize, vq->gautbl[s].veclen);
	}
    }
    
    /* Echo info for sanity check */
    E_INFO("Original #codebooks(states)/codewords: %d x %d\n", vq->origsize.r, vq->origsize.c);
    E_INFO("Subvectors: %d, VQsize: %d\n", vq->n_sv, vq->vqsize);
    for (s = 0; s < vq->n_sv; s++) {
	E_INFO("SV %d feature dims(%d): ", s, vq->gautbl[s].veclen);
	for (c = 0; c < vq->gautbl[s].veclen; c++)
	    fprintf (stderr, " %2d", vq->featdim[s][c]);
	fprintf (stderr, "\n");
    }
    fflush (stderr);
    
    /* Read VQ codebooks and maps for each subvector */
    for (s = 0; s < n_sv; s++) {
#if 1
      int32 veclen =  vq->gautbl[s].veclen;
      int a_veclen = (veclen%4)?veclen+4-(veclen%4):veclen;
#endif
      E_INFO("Reading subvq %d%s\n", s, (s < vq->n_sv) ? "" : " (not used)");
	
	E_INFO("Reading codebook\n");
	if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Codebook %d", &k) != 1) || (k != s))
	    E_FATAL("Error reading codebook header\n", s);
	
	for (r = 0; r < vq->vqsize; r++) {

	    if (fgets (line, sizeof(line), fp) == NULL)
		E_FATAL("Error reading row(%d)\n", r);
	    
	    if (s >= vq->n_sv)
		continue;
	    
	    for (strp = line, c = 0; c < veclen; c++) {
		if (sscanf (strp, "%f %f%n",
			    &(vq->gautbl[s].mean[r][c]), &(vq->gautbl[s].var[r][c]), &k) != 2) {
		    E_FATAL("Error reading row(%d) col(%d)\n", r, c);

		}
		strp += k;
	    }

#if 1
	    for (;c<a_veclen;c++) {
	      vq->gautbl[s].mean[r][c]=0.0;
	      vq->gautbl[s].var[r][c]=0.0;
	    }
#endif
	}
	
	E_INFO("Reading map\n");
	if ((fgets (line, sizeof(line), fp) == NULL) ||
	    (sscanf (line, "Map %d", &k) != 1) || (k != s))
	    E_FATAL("Error reading map header\n", s);
	
	for (r = 0; r < vq->origsize.r; r++) {
	    if (fgets (line, sizeof(line), fp) == NULL)
		E_FATAL("Error reading row(%d)\n", r);
	    
	    if (s >= vq->n_sv)
		continue;
	    
	    for (strp = line, c = 0; c < vq->origsize.c; c++) {
		if (sscanf (strp, "%d%n", &(vq->map[r][c][s]), &k) != 1)
		    E_FATAL("Error reading row(%d) col(%d)\n", r, c);
		strp += k;
	    }
	}
	
	fflush (stdout);
    }
    
    if ((fscanf (fp, "%s", line) != 1) || (strcmp (line, "End") != 0))
	E_FATAL("Error reading 'End' token\n");
    
    fclose (fp);
    
    subvq_maha_precomp (vq, varfloor);
    subvq_map_compact (vq, g);
    subvq_map_linearize (vq);
    
    n = 0;
    for (s = 0; s < n_sv; s++) {
	if (vq->gautbl[s].veclen > n)
	    n = vq->gautbl[s].veclen;
    }
    assert (n > 0);
#ifdef THRD
    for (s=0; s < vq->n_sv; s++)
      vq->thrd_subvec[s] = (float32 *) ckd_calloc (n, sizeof(float32));
    
    for (s = 0; s < NUM_THREADS; s++) {
      vq->thrd_gauscore[s] = (int32 *) ckd_calloc (vq->origsize.c, sizeof(int32));
      vq->thrd_mgau_sl[s] = (int32 *) ckd_calloc (vq->origsize.c + 1, sizeof(int32));
    }

#endif
#ifdef USE_ICC
    vq->subvec = (float32 *) _mm_malloc (n*sizeof(float32),16);
#else
    vq->subvec = (float32 *) ckd_calloc (n, sizeof(float32));
#endif
    vq->vqdist = (int32 **) ckd_calloc_2d (vq->n_sv, vq->vqsize, sizeof(int32));

    vq->gauscore = (int32 *) ckd_calloc (vq->origsize.c, sizeof(int32));
    vq->mgau_sl = (int32 *) ckd_calloc (vq->origsize.c + 1, sizeof(int32));

    return vq;
}


/*
 * Based on previously computed subvq scores (Mahalanobis distances), determine the active
 * components in the given mixture (using the vq->map).
 * Return value: #Candidates in the returned shortlist.
 */
static int32 subvq_mgau_shortlist (subvq_t *vq,
				   int32 m,	/* In: Mixture index */
				   int32 n,	/* In: #Components in specified mixture */
				   int32 beam)	/* In: Threshold to select active components */
{
    int32 *gauscore;
    int32 *map;
    int32 i, v, bv, th, nc;
    int32 *sl;
    int32 *vqdist;
    
    vqdist = vq->vqdist[0];	/* Since map is linearized for efficiency, must also
				   look at vqdist[][] as vqdist[] */
    gauscore = vq->gauscore;
    sl = vq->mgau_sl;
    
    /* Special case when vq->n_sv == 3; for speed */
    map = vq->map[m][0];
    bv = MAX_NEG_INT32;
    
    switch (vq->n_sv) {
    case 3:
	for (i = 0; i < n; i++) {
	  if (VQ_EVAL == 1) {
	    v = (int32) vqdist[*map];/* If we are not weighting the cep values, we need to adjust the subvqbeam */
	    map += 3;
	  } else {
	    /* RAH, we are ignoring the delta-delta, scoring the delta twice, strangely this works better than weighting the scores  */
	    /* I believe it has to do with the beam widths */
	    if (VQ_EVAL == 2) {
	      v = vqdist[*(map++)];
	      v += 2 * vqdist[*map]; /* RAH Count delta twice, we can keep the same subvqbeam as vq_eval = 3 if we double the delta*/
	      map += 2;
	    } else {
	      v = vqdist[*(map++)];/* Standard way */
	      v += vqdist[*(map++)]; /*  */
	      v += vqdist[*(map++)]; /*  */
	    }
	  }

	  gauscore[i] = v;
	  
	  if (bv < v)
	    bv = v;
	}
	break;
    case 2:
	for (i = 0; i < n; i++) {
	    v = vqdist[*(map++)];
	    v += vqdist[*(map++)];
	    gauscore[i] = v;
	    
	    if (bv < v)
		bv = v;
	}
	break;
    case 1:
      for (i = 0; i < n; i++) {
	v = vqdist[*(map++)];
	gauscore[i] = v;
	
	if (bv < v)
	  bv = v;
      }
      break;
    default:
      E_FATAL("#Subvectors %d not yet implemented\n", vq->n_sv);
    }
    
    th = bv + beam;
    nc = 0;
    for (i = 0; i < n; i++) {
      if (gauscore[i] >= th)
	sl[nc++] = i;
    }
    sl[nc] = -1;
    
    return nc;
}

#if 0
void subvq_subvec_eval_logs3 (subvq_t *vq, float32 *feat, int32 s)
{
    int32 i;
    int32 *featdim;
    
    /* Extract subvector from feat */
    featdim = vq->featdim[s];
    for (i = 0; i < vq->gautbl[s].veclen; i++)
	vq->subvec[i] = feat[featdim[i]];
    
    /* Evaluate distances between extracted subvector and corresponding codebook */
    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
}
#endif

void subvq_gautbl_eval_logs3 (subvq_t *vq, float32 *feat)
{
    int32 s, i;
    int32 *featdim;
    
    for (s = 0; s < vq->n_sv; s++) {
	/* Extract subvector from feat */
	featdim = vq->featdim[s];
	for (i = 0; i < vq->gautbl[s].veclen; i++) {
	  vq->subvec[i] = feat[featdim[i]];
	}
	
	/* Evaluate distances between extracted subvector and corresponding codebook */
    
	/* RAH, only evaluate the first VQ_EVAL set of features */
	if (s < VQ_EVAL) {
	  vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, 
				   vq->vqdist[s]);
	}
	/*printf("vqsize %d veclen %d\n",vq->vqsize,vq->gautbl[s].veclen);*/

    }
}

#ifdef THRD
#ifdef NEW_EVAL_LOGS3

int32 sema = 0;
extern pthread_mutex_t update_lock;
extern barrier_t *score_barrier;


void thrd_subvq_gautbl_eval_logs3 (int subvec_num, subvq_t *vq, float32 *feat)
{

  if (NUM_THREADS == 1) {
    int32 s, i;
    int32 *featdim;
    
    for (s=0; s < vq->n_sv; s++) {
      /* Extract subvector from feat */
      featdim = vq->featdim[s];
      for (i = 0; i < vq->gautbl[s].veclen; i++) {
	vq->subvec[i] = feat[featdim[i]];
      }

      if (s < VQ_EVAL)
	/* Evaluate distances between extracted subvector and corresponding codebook */
	
	/* RAH, only evaluate the first VQ_EVAL set of features */
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[s]);
    }
    
  } else { /* NUM_THREADS > 1 */


  int32 s, i;
  int32 *featdim;
  const int32 vqsize = vq->vqsize;
  const int32 n_sv = vq->n_sv;
  const int32 remainder = (vqsize * n_sv)%NUM_THREADS;
  int32 chunk_size = (vqsize * n_sv)/NUM_THREADS;
  int32 offset;
  int32 subv_ex;
  
  s = subvec_num*chunk_size; /* subvec_num is now the thread no. */
  if (remainder>subvec_num) { s++; chunk_size++; };

  offset = s % vqsize;
  s /= vqsize; /* determine which vector to process */
  if (DEBUG&0x4) fprintf(stderr,"thrd %d chunk_size %d offset %d s %d\n",
			 subvec_num,chunk_size, offset, s);

  assert(s<n_sv && "subvec index out of range!!\n");

#if (NUM_THREADS>1)
  pthread_mutex_lock(&update_lock);

  subv_ex = (sema++)%NUM_THREADS;

  pthread_mutex_unlock(&update_lock);
#else
  subv_ex = (sema++)%NUM_THREADS;
#endif

  if (subv_ex < n_sv) {
    if (DEBUG&0x4) 
      fprintf(stderr,"thread %d subvec %d veclen %d\n",subvec_num,subv_ex,
	      vq->gautbl[subv_ex].veclen);
    /* Extract subvector from feat */
    featdim = vq->featdim[subv_ex];
    for (i = 0; i < vq->gautbl[subv_ex].veclen; i++)
      vq->thrd_subvec[subv_ex][i] = feat[featdim[i]];
  }

  if (DEBUG&0x4) fprintf(stderr,"thread %d before barrier \n",subvec_num);
  
  thread_barrier(subvec_num,score_barrier);

  if (DEBUG&0x4) fprintf(stderr,"thread %d after barrier \n",subvec_num);

  /* Evaluate distances between extracted subvector and corresponding codebook */
  
  /* RAH, only evaluate the first VQ_EVAL set of features */
  if (s < VQ_EVAL) {
    if (offset+chunk_size > vqsize) {
      if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d offset %d size %d\n",
			     subvec_num,s,offset,vqsize-offset);
      vector_gautbl_eval_logs3(&(vq->gautbl[s]), offset, vqsize-offset, vq->thrd_subvec[s], vq->vqdist[s]);
      chunk_size -= (vqsize-offset);
    } else {
      if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d offset %d size %d\n",
			     subvec_num,s,offset,chunk_size);
      vector_gautbl_eval_logs3(&(vq->gautbl[s]), offset, chunk_size, vq->thrd_subvec[s], vq->vqdist[s]);
      chunk_size = 0;
    }
    
    while (chunk_size>0) {
      s++;
      if (chunk_size > vqsize) {
	if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d offset %d size %d\n",
			       subvec_num,s,0,vqsize);
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vqsize, vq->thrd_subvec[s], vq->vqdist[s]);
	chunk_size-=vqsize;
      } else {
	if (DEBUG&0x4) fprintf(stderr,"thread %d subvec_eval %d offset %d size %d\n",
			       subvec_num,s,0,chunk_size);
	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, chunk_size, vq->thrd_subvec[s], vq->vqdist[s]);
	chunk_size=0;
      }

    }
  }

  thread_barrier(subvec_num,score_barrier);

  }
}
#endif /* end of NEW_EVAL_LOGS3 */

#if 0
void thrd_subvq_gautbl_eval_logs3 (int subvec_num, subvq_t *vq, float32 *feat)
{
  int32 s, i;
  int32 *featdim;

  s = subvec_num;

  /* Extract subvector from feat */
  featdim = vq->featdim[s];
  for (i = 0; i < vq->gautbl[s].veclen; i++)
    vq->thrd_subvec[s][i] = feat[featdim[i]];
    
  /* Evaluate distances between extracted subvector and corresponding codebook */
  
  /* RAH, only evaluate the first VQ_EVAL set of features */

  if (s < VQ_EVAL) 
    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->thrd_subvec[s], vq->vqdist[s]);


}
#endif
#endif /* end THRD */



int32 subvq_frame_eval (subvq_t *vq, mgau_model_t *g, int32 beam, float32 *feat,
			int32 *sen_active, int32 *senscr)
{
  int32 s;
  int32 best, ns, ng;
  
  best = MAX_NEG_INT32;
  ns = 0;
  ng = 0;
  
  if (! vq) {
    /* No subvq model, use the original (SLOW!!) */
    for (s = 0; s < g->n_mgau; s++) {
      if ((! sen_active) || sen_active[s]) {
	senscr[s] = mgau_eval (g, s, NULL, feat);
	if (best < senscr[s])
	  best = senscr[s];
	ns++;
	ng += mgau_n_comp (g, s);
      } else
	senscr[s] = S3_LOGPROB_ZERO;
    }
  } else {
    /* Evaluate subvq model for given feature vector */
    subvq_gautbl_eval_logs3 (vq, feat);

    /* Find mixture component shortlists using subvq scores, and evaluate senones */
    for (s = 0; s < g->n_mgau; s++) {
      if ((! sen_active) || sen_active[s]) {
	ng += subvq_mgau_shortlist (vq, s, mgau_n_comp(g,s), beam);
	
	senscr[s] = mgau_eval (g, s, vq->mgau_sl, feat);
	if (best < senscr[s])
	  best = senscr[s];
	
	ns++;
	
      } else
	senscr[s] = S3_LOGPROB_ZERO;
    }
  }
    
    /* Normalize senone scores */
    for (s = 0; s < g->n_mgau; s++)
	senscr[s] -= best;
    
    g->frm_sen_eval = ns;
    g->frm_gau_eval = ng;
    
    return best;
}

/* RAH, free memory allocated by subvq_init() */
void subvq_free (subvq_t *s)
{
  int i;

  if (s) {
    
    for (i=0;i<s->n_sv;i++) {
      /*      vector_gautbl_free (&(s->gautbl[i]));*/
      if (s->featdim[i]) ckd_free ((void *) s->featdim[i]);
    }


    if (s->featdim) 
      ckd_free ((void *) s->featdim);

    /* Free gaussian table */
    if (s->gautbl) 
      ckd_free ((void *)s->gautbl);      


    /* Free map */
    if (s->map)
      ckd_free_3d ((void ***) s->map);

    if (s->subvec) 
      ckd_free ((void *) s->subvec);

    if (s->vqdist) 
      ckd_free_2d ((void **) s->vqdist);

    if (s->gauscore) 
      ckd_free ((void *) s->gauscore);

    if (s->mgau_sl) 
      ckd_free ((void *) s->mgau_sl);

	
    ckd_free ((void *)s);


  }
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * subvq.h
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Updated subvq_free () to free more allocated memory
 * 
 * 15-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Moved subvq_t.{frm_sen_eval,frm_gau_eval} to cont_mgau.h.
 * 
 * 14-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_t.{frm_sen_eval,frm_gau_eval}.  Changed subvq_frame_eval to
 * 		return the normalization factor.
 * 
 * 06-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_subvec_eval_logs3().
 * 
 * 14-Oct-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Changed ci_active flags input to sen_active in subvq_frame_eval().
 * 
 * 20-Jul-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added subvq_gautbl_eval_logs3().
 * 
 * 12-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_SUBVQ_H_
#define _S3_SUBVQ_H_


#include "libutil.h"
#include "cont_mgau.h"
#include "vector.h"

typedef struct {
    arraysize_t origsize;	/* origsize.r = #codebooks (or states) in original model;
				   origsize.c = max #codewords/codebook in original model */
    int32 n_sv;			/* #Subvectors */
    int32 vqsize;		/* #Codewords in each subvector quantized mean/var table */
    int32 **featdim;		/* featdim[s] = Original feature dimensions in subvector s */
    vector_gautbl_t *gautbl;	/* Vector-quantized Gaussians table for each sub-vector */
    int32 ***map;		/* map[i][j] = map from original codebook(i)/codeword(j) to
				   sequence of nearest vector quantized subvector codewords;
				   so, each map[i][j] is of length n_sv.  Finally, map is
				   LINEARIZED, so that it indexes into a 1-D array of scores
				   rather than a 2-D array (for faster access). */
    
    /* Working space used during evaluation */

    float32 *subvec;		/* Subvector extracted from feature vector */
    int32 **vqdist;		/* vqdist[i][j] = score (distance) for i-th subvector compared
				   to j-th subvector-codeword */
    int32 *gauscore;		/* Subvq-based approx. Gaussian density scores for one mixture */
    int32 *mgau_sl;		/* Shortlist for one mixture (based on gauscore[]) */

  /*** These are thread specific arrays **/
#ifdef THRD
    float32 *thrd_subvec[NUM_THREADS]; /* Subvector extracted from feature vector */
#if 0
    int32 **thrd_vqdist[NUM_THREADS];  /* vqdist[i][j] = score (distance) for i-th subvector compared
				   to j-th subvector-codeword */
#endif
    int32 *thrd_gauscore[NUM_THREADS]; /* Subvq-based approx. Gaussian density scores for one mixture */
    int32 *thrd_mgau_sl[NUM_THREADS];  /* Shortlist for one mixture (based on gauscore[]) */
#endif

} subvq_t;


/*
 * SubVQ file format:
 *   VQParam #Original-Codebooks #Original-Codewords/codebook(max) -> #Subvectors #VQ-codewords
 *   Subvector 0 length <length> <feature-dim> <feature-dim> <feature-dim> ...
 *   Subvector 1 length <length> <feature-dim> <feature-dim> <feature-dim> ...
 *   ...
 *   Codebook 0
 *   Row 0 of mean/var values (interleaved) for subvector 0 codebook (in 1 line)
 *   Row 1 of above
 *   Row 2 of above
 *   ...
 *   Map 0
 *   Mappings for state 0 codewords (in original model) to codewords of this subvector codebook
 *   Mappings for state 1 codewords (in original model) to codewords of this subvector codebook
 *   Mappings for state 2 codewords (in original model) to codewords of this subvector codebook
 *   ...
 *   Repeated for each subvector codebook 1
 *   Repeated for each subvector codebook 2
 *   ...
 *   End
 */
subvq_t *subvq_init (char *file,	/* In: Subvector model file */
		     float64 varfloor,	/* In: Floor to be applied to variance values */
		     int32 max_sv,	/* In: Use the first so many subvectors instead of all;
					   if <0, use all */
		     mgau_model_t *g);	/* In: Original model from which this subvq model was
					   built, for cross-validation; optional */

void subvq_free (subvq_t *vq);


/*
 * Evaluate senone scores for one frame.  If subvq model is available, for each senone, first
 * get approximate Gaussian density scores using it; obtain a shortlist of Gaussians using
 * these scores, then evaluate the shortlist exactly.  If no subvq model, evaluate senones
 * using all Gaussian densities.  Finally, scale senone scores by subtracting the best.
 * Return value: The normalization factor (best senone absolute score).
 */
int32 subvq_frame_eval (subvq_t *vq,	/* In: Sub-vector model */
			mgau_model_t *g,/* In: Exact mixture Gaussian model */
			int32 beam,	/* In: (Logs3) threshold for selecting shortlist;
					   range = [-infinity(widest beam), 0(narrowest)] */
			float32 *feat,	/* In: Input feature vector for this frame */
			int32 *sen_active,	/* In: Active flags for each senone (optional).
						   If not NULL, only active ones evaluated */
			int32 *senscr);	/* Out: Normalized senone scores */

/*
 * Evaluate the Mahalanobis distances between the given feature vector and each entry in the
 * given subvq codebook.  Save results, as logs3 values, in vq->vqdist[][].
 */
void subvq_gautbl_eval_logs3 (subvq_t *vq,	/* In/Out: Reference subvq structure */
			      float32 *feat);	/* In: Subvectors extracted from this, and
						   compared to relevant subvq codewords */

/*
 * Evaluate the codewords for a single given subvector sv, wrt the input feature vector.
 * Save results, as logs3 values, in vq->vqdist[sv][].
 * (Basically, like subvq_gautbl_eval_logs3, but for a single given subvector instead of all.)
 */
void subvq_subvec_eval_logs3 (subvq_t *vq,	/* In/Out: Reference subvq structure */
			      float32 *feat,	/* In: Input feature subvector extracted from
						 * this, and compared to relevant codewords */
			      int32 sv);	/* In: ID of subvector being evaluated */
#ifdef THRD
void thrd_subvq_gautbl_eval_logs3 (int subvec_num, subvq_t *vq, float32 *feat);

#endif

#endif

agc.c,23
void agc_max 110,4638

agc.h,28
#define _S3_AGC_H_105,4600

ascr.c,28
ascr_t *ascr_init 107,4560

ascr.h,55
#define _S3_ASCR_H_105,4560
} ascr_t;ascr_t118,4825

barrier.c,107
barrier_t * thread_barrier_init(55,2441
void thread_barrier_destroy(69,2788
void thread_barrier(75,2942

barrier.h,85
typedef struct barrier_struct barrier_struct54,2420
} barrier_t;barrier_t62,2969

beam.c,28
beam_t *beam_init 108,4584

beam.h,55
#define _S3_BEAM_H_105,4565
} beam_t;beam_t120,5058

bio.c,385
#define BIO_HDRARG_MAX	110,4707
#define END_COMMENT	111,4733
static void bcomment_read 114,4773
static int32 swap_check(126,5000
void bio_hdrarg_free 152,5481
int32 bio_writehdr_version 165,5693
int32 bio_readhdr 182,6003
static uint32 chksum_accum 240,7684
static void swap_buf 272,8299
int32 bio_fread 298,8745
int32 bio_fread_1d 313,9049
void bio_verify_chksum 335,9680

bio.h,187
#define _S3_BIO_H_105,4569
#define BYTE_ORDER_MAGIC	111,4613
#define SWAP_INT16(SWAP_INT16114,4716
#define SWAP_INT32(SWAP_INT32117,4856
#define SWAP_FLOAT32(SWAP_FLOAT32123,5079

bitvec.c,33
int32 bitvec_count_set 107,4544

bitvec.h,452
#define _LIBUTIL_BITVEC_H_111,4752
typedef uint32 *bitvec_t;bitvec_t118,4829
#define bitvec_uint32size(bitvec_uint32size125,5024
#define bitvec_alloc(bitvec_alloc127,5068
#define bitvec_free(bitvec_free129,5148
#define bitvec_set(bitvec_set131,5195
#define bitvec_clear(bitvec_clear133,5258
#define bitvec_clear_all(bitvec_clear_all135,5323
#define bitvec_is_set(bitvec_is_set137,5397
#define bitvec_is_clear(bitvec_is_clear139,5461

blah,1745
subvq.c:    vq->vqdist 1,0
subvq.c:    int32 *vqdist;2,89
subvq.c:    vqdist 3,116
subvq.c:	    v 5,254
subvq.c:	    v 6,370
subvq.c:	      v 8,540
subvq.c:	    v 11,685
subvq.c:	v 13,756
subvq.c:    vector_gautbl_eval_logs3(&(vq->gautbl[14,787
subvq.c:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,14,787
subvq.c:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec,14,787
subvq.c:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[14,787
subvq.c:	vector_gautbl_eval_logs3(&(vq->gautbl[15,885
subvq.c:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,15,885
subvq.c:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec,15,885
subvq.c:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[15,885
subvq.c~:    vq->vqdist 18,1057
subvq.c~:    int32 *vqdist;19,1147
subvq.c~:    vqdist 20,1175
subvq.c~:	    v 22,1315
subvq.c~:	    v 23,1432
subvq.c~:	      v 25,1604
subvq.c~:	    v 28,1752
subvq.c~:	v 30,1825
subvq.c~:    vector_gautbl_eval_logs3(&(vq->gautbl[31,1857
subvq.c~:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,31,1857
subvq.c~:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec,31,1857
subvq.c~:    vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[31,1857
subvq.c~:	vector_gautbl_eval_logs3(&(vq->gautbl[32,1956
subvq.c~:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize,32,1956
subvq.c~:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec,32,1956
subvq.c~:	vector_gautbl_eval_logs3(&(vq->gautbl[s]), 0, vq->vqsize, vq->subvec, vq->vqdist[32,1956
subvq.h:    int32 **vqdist;35,2131

case.c,72
void lcase(110,4705
void ucase(117,4787
int32 strcmp_nocase 124,4869

case.h,114
#define _LIBUTIL_CASE_H_108,4697
#define UPPER_CASE(UPPER_CASE115,4784
#define LOWER_CASE(LOWER_CASE118,4888

ckd_alloc.c,505
void *__ckd_calloc__(140,5358
void *__ckd_malloc__(154,5654
void *__ckd_realloc__(166,5891
char *__ckd_salloc__ 180,6170
void **__ckd_calloc_2d__ 192,6425
void **__ckd_calloc_2d__a 207,6864
void ckd_free_2da 226,7382
void ckd_free_2d 236,7505
void ***__ckd_calloc_3d__ 243,7578
void ckd_free_3d 268,8274
typedef struct mylist_s mylist_s281,8576
} mylist_t;mylist_t287,8909
static mylist_t *head 288,8921
#define MIN_MYALLOC	290,8952
char *__mymalloc__ 293,9022
void __myfree__ 363,10972

ckd_alloc.h,445
#define _LIBUTIL_CKD_ALLOC_H_130,5235
#define ckd_calloc(ckd_calloc194,7333
#define ckd_malloc(ckd_malloc195,7401
#define ckd_realloc(ckd_realloc196,7464
#define ckd_salloc(ckd_salloc197,7536
#define ckd_calloc_2d(ckd_calloc_2d198,7599
#define ckd_calloc_3d(ckd_calloc_3d199,7683
#define ckd_calloc_2da(ckd_calloc_2da200,7775
#define ckd_free(ckd_free202,7862
#define mymalloc(mymalloc226,8784
#define myfree(myfree227,8843

cmd_ln.c,509
typedef struct argval_s argval_s124,5169
} argval_t;argval_t127,5294
static argval_t *argval 128,5306
static hash_table_t *ht;129,5338
static const char *arg_type2str 133,5388
static int32 arg_strlen 162,5931
static arg_t *tmp_defn;184,6327
static int32 cmp_name 186,6352
static int32 *arg_sort 191,6499
static int32 arg_str2val 207,6781
static void arg_dump 243,7542
int32 cmd_ln_parse 319,9386
void cmd_ln_print_help 409,11863
const void *cmd_ln_access 416,11994
void cmd_ln_free 430,12300

cmd_ln.h,561
#define _LIBUTIL_CMD_LN_H_109,4829
#define ARG_REQUIRED	114,4882
#define ARG_INT32	117,4950
#define ARG_FLOAT32	118,4970
#define ARG_FLOAT64	119,4992
#define ARG_STRING	120,5014
#define REQARG_INT32	123,5080
#define REQARG_FLOAT32	124,5128
#define REQARG_FLOAT64	125,5180
#define REQARG_STRING	126,5232
typedef int32 argtype_t;argtype_t127,5282
} arg_t;arg_t135,5550
#define cmd_ln_str(cmd_ln_str157,6527
#define cmd_ln_int32(cmd_ln_int32158,6582
#define cmd_ln_float32(cmd_ln_float32159,6643
#define cmd_ln_float64(cmd_ln_float64160,6708

cmd_ln_args.h,0

cmn.c,112
static float32 *cmn_mean 115,5045
static float32 *cmn_var 116,5078
void cmn 119,5112
void cmn_free 184,6924

cmn.h,84
#define _S3_CMN_H_108,4786
#define CMN_WIN_HWM 128,5497
#define CMN_WIN 129,5570

cmn_prior.c,25
void cmn_prior(101,4501

cmn_prior.h,90
#define _S3_CMN_PRIOR_H_105,4604
#define CMN_WIN_HWM 116,4836
#define CMN_WIN 117,4909

cont_mgau.c,627
#define MGAU_PARAM_VERSION	118,4975
#define MGAU_MIXW_VERSION	119,5056
#define MGAU_MEAN	120,5132
#define MGAU_VAR	121,5153
static int32 mgau_file_read(128,5286
static int32 mgau_mixw_read(317,10994
static void mgau_uninit_compact 429,14638
static void mgau_var_floor 467,15521
int32 mgau_var_nzvec_floor 487,15943
static int32 mgau_precomp 522,16668
mgau_model_t *mgau_init 549,17387
int32 mgau_comp_eval 582,18369
int32 mgau_eval 624,19128
float64 mgau_eval_inner(710,21141
  for (;i<veclen;813,24445
    diff1 814,24470
float64 mgau_eval_inner(844,25096
int32 mgau_eval 906,26473
void mgau_free 961,27560

cont_mgau.c~,627
#define MGAU_PARAM_VERSION	117,4976
#define MGAU_MIXW_VERSION	118,5057
#define MGAU_MEAN	119,5133
#define MGAU_VAR	120,5154
static int32 mgau_file_read(127,5287
static int32 mgau_mixw_read(316,10995
static void mgau_uninit_compact 428,14639
static void mgau_var_floor 466,15522
int32 mgau_var_nzvec_floor 486,15944
static int32 mgau_precomp 521,16669
mgau_model_t *mgau_init 548,17388
int32 mgau_comp_eval 581,18370
int32 mgau_eval 623,19129
float64 mgau_eval_inner(709,21142
  for (;i<veclen;812,24446
    diff1 813,24471
float64 mgau_eval_inner(843,25097
int32 mgau_eval 905,26474
void mgau_free 960,27561

cont_mgau.h,526
#define _S3_CONT_MGAU_H_112,4905
} mgau_t;mgau_t156,6924
} mgau_model_t;mgau_model_t172,7624
#define mgau_n_mgau(mgau_n_mgau176,7662
#define mgau_max_comp(mgau_max_comp177,7700
#define mgau_veclen(mgau_veclen178,7741
#define mgau_n_comp(mgau_n_comp179,7779
#define mgau_mean(mgau_mean180,7826
#define mgau_var(mgau_var181,7874
#define mgau_mixw(mgau_mixw182,7921
#define mgau_lrd(mgau_lrd183,7969
#define mgau_frm_sen_eval(mgau_frm_sen_eval184,8016
#define mgau_frm_gau_eval(mgau_frm_gau_eval185,8065

corpus.c,310
corpus_t *corpus_load_headid 122,5228
static int32 sep_tailid 201,7249
corpus_t *corpus_load_tailid 232,8008
char *corpus_lookup 310,10051
main 323,10266
int32 ctl_read_entry 353,10879
ptmr_t ctl_process 389,11663
ptmr_t ctl_process_utt 439,12780
void ctl_infile 487,13840
void ctl_outfile 515,14506

corpus.h,61
#define _S3_CORPUS_H_120,5232
} corpus_t;corpus_t136,5697

dict.c,632
#define DELIM	117,5139
#define DEFAULT_NUM_PHONE	118,5202
static s3cipid_t dict_ciphone_id 121,5246
const char *dict_ciphone_str 143,5796
s3wid_t dict_add_word 156,6146
static int32 dict_read 211,7630
static s3wid_t *dict_comp_head 263,8961
static int32 dict_build_comp 289,9719
dict_t *dict_init 345,11236
s3wid_t dict_wordid 448,14316
s3wid_t _dict_basewid 461,14514
char *_dict_wordstr 470,14661
s3wid_t _dict_nextalt 479,14814
int32 dict_filler_word 488,14968
s3wid_t dict_wids2compwid 502,15254
int32 dict_word2basestr 528,15833
void dict_free 550,16333
main 587,17185
#define _DICT_MEM_LEAK_TEST_ 602,17664

dict.h,683
#define _S3_DICT_H_114,5093
} dictword_t;dictword_t133,5834
} dict_t;dict_t152,7012
#define dict_size(dict_size198,8791
#define dict_basewid(dict_basewid199,8827
#define dict_wordstr(dict_wordstr200,8876
#define dict_nextalt(dict_nextalt201,8922
#define dict_pronlen(dict_pronlen202,8967
#define dict_pron(dict_pron203,9016
#define dict_filler_start(dict_filler_start204,9067
#define dict_filler_end(dict_filler_end205,9116
#define dict_startwid(dict_startwid206,9161
#define dict_finishwid(dict_finishwid207,9202
#define dict_silwid(dict_silwid208,9245
#define dict_first_phone(dict_first_phone209,9283
#define dict_last_phone(dict_last_phone210,9339

dict2pid.c,350
static glist_t ldiph_comsseq 116,4924
static glist_t rdiph_comsseq 143,5617
static glist_t single_comsseq 170,6303
static glist_t single_lc_comsseq 199,7080
static s3ssid_t ssidlist2comsseq 224,7654
dict2pid_t *dict2pid_build 292,9909
void dict2pid_comsenscr 480,15719
void dict2pid_comsseq2sen_active 503,16143
void dict2pid_dump 524,16595

dict2pid.h,235
#define _S3_DICT2PID_H_108,4692
} dict2pid_t;dict2pid_t167,8039
#define dict2pid_internal(dict2pid_internal170,8106
#define dict2pid_n_comstate(dict2pid_n_comstate171,8161
#define dict2pid_n_comsseq(dict2pid_n_comsseq172,8211

err.c,236
_E__pr_header(123,5079
_E__pr_info_header(130,5237
_E__pr_warn(139,5464
_E__pr_info(151,5641
void _E__die_error(162,5813
void _E__fatal_sys_error(178,6041
void _E__sys_error(196,6314
void _E__abort_error(212,6559
main(226,6767

err.h,259
#define _LIBUTIL_ERR_H_103,4559
#define E_ABORT 128,5200
#define E_FATAL 132,5336
#define E_FATAL_SYSTEM	135,5471
#define E_WARN_SYSTEM	138,5606
#define E_ERROR_SYSTEM	141,5734
#define E_INFO	145,5899
#define E_WARN	147,5976
#define E_ERROR	149,6051

feat.c,662
#define FEAT_VERSION	164,6946
#define N_FEAT	166,6974
#define FEAT_DCEP_WIN	168,6994
int32 feat_readfile 170,7020
int32 feat_writefile 277,9842
int32 feat_s2mfc_read 318,10889
static int32 feat_stream_len_sum 418,13616
float32 **feat_vector_alloc 429,13792
float32 ***feat_array_alloc 454,14381
static void feat_s2_4x_cep2feat 482,15066
static void feat_s3_1x39_cep2feat 545,16697
static void feat_s3_cep 600,17968
static void feat_s3_cep_dcep 614,18415
void feat_1s_c_d_dd_cep2feat 641,19127
feat_t *feat_init 688,20267
void feat_print 824,24469
int32 feat_s2mfc2feat 844,24851
int32	feat_s2mfc2feat_block(955,28389
void feat_free 1115,33139

feat.h,413
#define _S3_FEAT_H_108,4702
#define LIVEBUFBLOCKSIZE 114,4747
typedef struct feat_s feat_s123,5085
} feat_t;feat_t141,6273
#define feat_name(feat_name144,6304
#define feat_cepsize(feat_cepsize145,6338
#define feat_cepsize_used(feat_cepsize_used146,6378
#define feat_n_stream(feat_n_stream147,6427
#define feat_stream_len(feat_stream_len148,6468
#define feat_window_size(feat_window_size149,6518

filename.c,58
void path2basename 113,4683
void strip_fileext 124,4909

filename.h,38
#define _LIBUTIL_FILENAME_H_105,4579

fillpen.c,86
fillpen_t *fillpen_init 119,5181
int32 fillpen 194,7887
void fillpen_free 202,8094

fillpen.h,64
#define _S3_FILLPEN_H_106,4616
} fillpen_t;fillpen_t120,5015

glist.c,663
glist_t glist_add_ptr 116,4835
glist_t glist_add_int32 127,5064
glist_t glist_add_uint32 138,5297
glist_t glist_add_float32 149,5533
glist_t glist_add_float64 160,5772
int32 glist_chkdup_ptr 171,6011
int32 glist_chkdup_int32 183,6184
int32 glist_chkdup_uint32 195,6361
int32 glist_chkdup_float32 207,6541
int32 glist_chkdup_float64 219,6724
void glist_apply_ptr 231,6907
void glist_apply_int32 240,7050
void glist_apply_uint32 249,7196
void glist_apply_float32 258,7345
void glist_apply_float64 267,7497
void glist_free 276,7649
void glist_myfree 288,7789
int32 glist_count 301,7990
gnode_t *glist_tail 311,8124
glist_t glist_reverse 323,8274

glist.h,403
#define _LIBUTIL_GLIST_H_119,5111
typedef struct gnode_s gnode_s127,5215
} gnode_t;gnode_t130,5333
typedef gnode_t *glist_t;glist_t131,5344
#define gnode_ptr(gnode_ptr135,5440
#define gnode_int32(gnode_int32136,5478
#define gnode_uint32(gnode_uint32137,5520
#define gnode_float32(gnode_float32138,5564
#define gnode_float64(gnode_float64139,5609
#define gnode_next(gnode_next140,5654

hash.c,504
static void prime_sieve 127,5151
static int32 prime[151,5673
static int32 prime_size 160,6023
hash_table_t *hash_new 173,6268
static uint32 key2hash 191,6780
static char *makekey 223,7283
static int32 keycmp_nocase 240,7615
static int32 keycmp_case 260,7941
static int32 lookup 283,8396
int32 hash_lookup 307,8919
int32 hash_lookup_bkey 319,9131
static int32 enter 332,9401
int32 hash_enter 362,10063
int32 hash_enter_bkey 373,10267
glist_t hash_tolist 386,10534
void hash_free 415,10956

hash.h,418
#define _LIBUTIL_HASH_H_123,5283
typedef struct hash_entry_s hash_entry_s139,5745
} hash_entry_t;hash_entry_t147,6191
} hash_table_t;hash_table_t155,6555
#define hash_entry_val(hash_entry_val159,6593
#define hash_entry_key(hash_entry_key160,6630
#define hash_entry_len(hash_entry_len161,6667
#define hash_table_size(hash_table_size162,6704
#define HASH_CASE_YES	173,7054
#define HASH_CASE_NO	174,7079

heap.c,323
typedef struct heap_s heap_s117,4858
} heapnode_t;heapnode_t124,5255
static void heap_dump 128,5277
heap_t heap_new 144,5529
static heapnode_t *subheap_insert 155,5688
int32 heap_insert 193,6489
static heapnode_t *subheap_pop 205,6666
int32 heap_pop 241,7336
int32 heap_top 260,7587
int32 heap_destroy 277,7806

heap.h,72
#define _LIBUTIL_HEAP_H_106,4615
typedef void *heap_t;heap_t112,4667

hmm.c,150
void hmm_dump 129,5673
void hmm_clear 161,6485
int32 hmm_vit_eval_5st 178,6814
int32 hmm_vit_eval_3st 286,9403
int32 hmm_dump_vit_eval 394,12147

hmm.h,88
#define _S3_HMM_H_114,5056
} hmm_state_t;hmm_state_t159,6662
} hmm_t;hmm_t167,7023

hyp.h,52
#define _S3_HYP_H_105,4556
} hyp_t;hyp_t118,5056

io.c,262
FILE *fopen_comp 122,4901
void fclose_comp 194,6565
FILE *fopen_compchk 207,6710
#define FREAD_RETRY_COUNT	266,7975
int32 fread_retry(268,8005
#define STAT_RETRY_COUNT	310,8780
int32 stat_retry 312,8809
int32 stat_mtime 332,9140
FILE *_myfopen 343,9297

io.h,66
#define _LIBUTIL_IO_H_111,4786
#define myfopen(myfopen148,5946

kb.c,86
void kb_init 115,5050
void kb_lextree_active_swap 332,12529
void kb_free 344,12857

kb.h,49
#define _S3_KB_H_108,4714
} kb_t;kb_t166,6663

kbcore.c,59
kbcore_t *kbcore_init 114,4869
void kbcore_free 252,9263

kbcore.h,499
#define _S3_KBCORE_H_111,4850
} kbcore_t;kbcore_t142,5348
#define kbcore_fcb(kbcore_fcb189,7423
#define kbcore_mdef(kbcore_mdef190,7457
#define kbcore_dict(kbcore_dict191,7493
#define kbcore_dict2pid(kbcore_dict2pid192,7529
#define kbcore_lm(kbcore_lm193,7572
#define kbcore_fillpen(kbcore_fillpen194,7604
#define kbcore_dict2lmwid(kbcore_dict2lmwid195,7645
#define kbcore_mgau(kbcore_mgau196,7697
#define kbcore_svq(kbcore_svq197,7733
#define kbcore_tmat(kbcore_tmat198,7767

lextree.c,553
static lextree_node_t *lextree_node_alloc 123,5237
lextree_t *lextree_build 144,5774
static int32 lextree_subtree_free 396,13839
void lextree_free 427,14724
void lextree_ci_active 471,15898
void lextree_ssid_active 485,16151
void lextree_utt_end 502,16459
static void lextree_node_print 522,16842
static void lextree_subtree_print 531,17117
void lextree_dump 547,17503
void lextree_enter 570,18071
void lextree_active_swap 615,19074
int32 lextree_hmm_eval 627,19334
void lextree_hmm_histbin 723,21565
void lextree_hmm_propagate 763,22453

lextree.h,880
#define _S3_LEXTREE_H_112,4850
} lextree_node_t;lextree_node_t157,7124
#define lextree_node_wid(lextree_node_wid160,7192
#define lextree_node_prob(lextree_node_prob161,7232
#define lextree_node_ssid(lextree_node_ssid162,7274
#define lextree_node_composite(lextree_node_composite163,7316
#define lextree_node_frame(lextree_node_frame164,7367
} lextree_lcroot_t;lextree_lcroot_t174,7680
} lextree_t;lextree_t195,8774
#define lextree_type(lextree_type198,8839
#define lextree_root(lextree_root199,8877
#define lextree_lcroot(lextree_lcroot200,8915
#define lextree_n_lc(lextree_n_lc201,8956
#define lextree_n_node(lextree_n_node202,8994
#define lextree_active(lextree_active203,9035
#define lextree_next_active(lextree_next_active204,9076
#define lextree_n_active(lextree_n_active205,9127
#define lextree_n_next_active(lextree_n_next_active206,9172

libutil.h,204
#define _LIBUTIL_LIBUTIL_H_108,4694
#define SLEEP_SEC(SLEEP_SEC138,5179
#define SLEEP_SEC(SLEEP_SEC140,5256
#define TRUE	144,5362
#define FALSE	145,5377
#define M_PI	149,5414
#define PI	151,5494

live.c,566
#define START_BLOCK 115,4991
static fe_t  *fe;117,5014
static kb_t  *kb;119,5033
static kbcore_t *kbcore;120,5051
static FILE  *hmmdumpfp;121,5076
static int32 maxwpf;122,5101
static int32 maxhistpf;123,5122
static int32 maxhmmpf;124,5146
static int32 ptranskip;125,5169
static partialhyp_t *parthyp 127,5194
static float32 *dummyframe;128,5231
barrier_t *score_barrier;134,5380
void live_initialize_decoder(139,5487
int32 live_free_memory 192,7347
int32 live_get_partialhyp(216,8224
int32 sample_blk 277,10086
int32 live_utt_decode_block 280,10116

live.h,38
} partialhyp_t;partialhyp_t103,4395

lm.c,887
#define MIN_PROB_F	126,5424
static char *darpa_hdr 129,5462
static int LM_IN_MEMORY 130,5507
int32 lm_delete 134,5596
static void lm_uw 194,6832
static void lm2logs3 213,7338
void lm_set_param 236,7894
static int32 lm_fread_int32 272,8760
static lm_t *lm_read_dump 288,9113
lm_t *lm_read 554,17526
void lm_cache_reset 592,18563
void lm_cache_stats_dump 649,19896
int32 lm_ug_score 668,20480
int32 lm_uglist 679,20694
int32 lm_ug_wordprob 686,20785
static void load_bg 712,21194
#define BINARY_SEARCH_THRESH	745,22170
static int32 find_bg 748,22255
int32 lm_bglist 771,22701
int32 lm_bg_wordprob 796,23180
int32 lm_bg_score 823,23768
static void load_tg 865,24573
static int32 find_tg 948,26830
int32 lm_tglist 969,27177
int32 lm_tg_score 1008,28055
s3lmwid_t lm_wid 1078,29923
void lm_free 1089,30120
static int32 sentence_lmscore 1110,30589
main 1148,31485

lm.h,956
#define _S3_LM_H_114,5010
} lmlog_t;lmlog_t125,5188
} ug_t;ug_t135,5570
} bg_t;bg_t142,5766
} tg_t;tg_t147,5864
} membg_t;membg_t157,6149
typedef struct tginfo_s tginfo_s167,6673
} tginfo_t;tginfo_t175,7057
} lm_tgcache_entry_t;lm_tgcache_entry_t184,7293
#define LOG2_BG_SEG_SZ 201,8122
#define BG_SEG_SZ 202,8149
#define LM_TGCACHE_SIZE	204,8198
typedef struct lm_s lm_s212,8402
} lm_t;lm_t268,10740
#define lm_lmwid2dictwid(lm_lmwid2dictwid271,10798
#define lm_n_ug(lm_n_ug272,10851
#define lm_n_bg(lm_n_bg273,10885
#define lm_n_tg(lm_n_tg274,10919
#define lm_wordstr(lm_wordstr275,10953
#define lm_startwid(lm_startwid276,10997
#define lm_finishwid(lm_finishwid277,11040
#define lm_access_type(lm_access_type278,11084
} wordprob_t;wordprob_t285,11308
#define LM_TGPROB(LM_TGPROB381,14573
#define LM_BGPROB(LM_BGPROB382,14635
#define LM_UGPROB(LM_UGPROB383,14697
#define LM_RAWSCORE(LM_RAWSCORE384,14743

logs3.c,564
static int USE_LOG3_ADD_TABLE 115,4983
static float64 F 116,5019
static float64 B,137,6051
static float64 B, logB,137,6051
static float64 B, logB, invlogB,137,6051
static float64 B, logB, invlogB, invlog10B;137,6051
static uint16 *add_tbl 138,6095
static int32 add_tbl_size;139,6153
int32 logs3_init 142,6182
int32 logs3_add 218,7662
int32 logs3 248,8463
int32 log_to_logs3 262,8717
float64 log_to_logs3_factor 271,8864
float64 logs3_to_log 277,8927
float64 logs3_to_p 286,9074
int32 log10_to_logs3 292,9156
void logs_free 300,9310
main 308,9400

logs3.h,30
#define _S3_LOGS3_H_108,4691

main_live_pretend.c,48
#define MAXSAMPLES 106,4857
int main 108,4886

main_live_pretend.c~,48
#define MAXSAMPLES 106,4857
int main 108,4886

mdef.c,849
#define MODEL_DEF_VERSION	135,5698
void mdef_dump 138,5732
int32 mdef_hmm_cmp 169,6521
static void ciphone_add 185,6802
static ph_lc_t *find_ph_lc 195,7114
static ph_rc_t *find_ph_rc 204,7293
static void triphone_add 213,7472
s3cipid_t mdef_ciphone_id 254,8647
const char *mdef_ciphone_str 267,8860
int32 mdef_phone_str 276,9028
s3pid_t mdef_phone_id 298,9544
s3pid_t mdef_phone_id_nearest 329,10442
int32 mdef_phone_components 394,12138
int32 mdef_is_ciphone 413,12474
static void parse_tmat_senmap 423,12708
static void parse_base_line 462,14026
static void parse_tri_line 509,15412
static void sseq_compress 572,17441
static int32 noncomment_line(618,18618
mdef_t *mdef_init 631,18887
void mdef_sseq2sen_active 841,26218
void mdef_free_recursive_lc 866,26848
void mdef_free_recursive_rc 879,27066
void mdef_free 894,27336

mdef.h,1021
#define _S3_MDEF_H_116,5084
    WORD_POSN_BEGIN 124,5165
    WORD_POSN_END 125,5220
    WORD_POSN_SINGLE 126,5271
    WORD_POSN_INTERNAL 127,5340
    WORD_POSN_UNDEFINED 128,5397
} word_posn_t;word_posn_t129,5481
#define N_WORD_POSN	130,5496
#define WPOS_NAME	131,5572
} ciphone_t;ciphone_t139,5843
} phone_t;phone_t152,6343
typedef struct ph_rc_s ph_rc_s159,6559
} ph_rc_t;ph_rc_t163,6780
typedef struct ph_lc_s ph_lc_s165,6792
} ph_lc_t;ph_lc_t169,7007
} mdef_t;mdef_t201,8496
#define mdef_is_fillerphone(mdef_is_fillerphone204,8556
#define mdef_n_ciphone(mdef_n_ciphone205,8614
#define mdef_n_phone(mdef_n_phone206,8658
#define mdef_n_sseq(mdef_n_sseq207,8699
#define mdef_n_emit_state(mdef_n_emit_state208,8738
#define mdef_n_sen(mdef_n_sen209,8788
#define mdef_n_tmat(mdef_n_tmat210,8825
#define mdef_pid2ssid(mdef_pid2ssid211,8864
#define mdef_pid2tmatid(mdef_pid2tmatid212,8913
#define mdef_silphone(mdef_silphone213,8964
#define mdef_sen2cimap(mdef_sen2cimap214,9001

new_fe.c,138
fe_t *fe_init(137,5831
int32 fe_start_utt(193,7699
int32 fe_process_utt(211,8329
int32 fe_end_utt(328,12932
int32 fe_close(387,14848

new_fe.h,1153
#define _NEW_FE_H_88,4193
} param_t;param_t118,4737
}melfb_t;melfb_t132,5002
} fe_t;fe_t152,5393
#define MEL_SCALE 156,5404
#define LOG_LINEAR 157,5424
#define DEFAULT_SAMPLING_RATE 160,5467
#define DEFAULT_FRAME_RATE 161,5505
#define DEFAULT_FRAME_SHIFT 162,5536
#define DEFAULT_WINDOW_LENGTH 163,5568
#define DEFAULT_FFT_SIZE 164,5607
#define DEFAULT_FB_TYPE 165,5636
#define DEFAULT_NUM_CEPSTRA 166,5670
#define DEFAULT_NUM_FILTERS 167,5701
#define DEFAULT_LOWER_FILT_FREQ 168,5732
#define DEFAULT_UPPER_FILT_FREQ 169,5774
#define DEFAULT_PRE_EMPHASIS_ALPHA 170,5816
#define DEFAULT_START_FLAG 171,5856
#define BB_SAMPLING_RATE 173,5886
#define DEFAULT_BB_FFT_SIZE 174,5917
#define DEFAULT_BB_FRAME_SHIFT 175,5949
#define DEFAULT_BB_NUM_FILTERS 176,5984
#define DEFAULT_BB_LOWER_FILT_FREQ 177,6018
#define DEFAULT_BB_UPPER_FILT_FREQ 178,6063
#define NB_SAMPLING_RATE 180,6109
#define DEFAULT_NB_FFT_SIZE 181,6139
#define DEFAULT_NB_FRAME_SHIFT 182,6181
#define DEFAULT_NB_NUM_FILTERS 183,6215
#define DEFAULT_NB_LOWER_FILT_FREQ 184,6249
#define DEFAULT_NB_UPPER_FILT_FREQ 185,6288
#define DEFAULT_BLOCKSIZE 188,6330

new_fe_sp.c,565
int32 fe_build_melfilters(107,4756
int32 fe_compute_melcosine(182,7195
float fe_mel(208,7788
float fe_melinv(213,7869
void fe_pre_emphasis(219,7960
void fe_short_to_double(231,8205
void fe_create_hamming(240,8341
void fe_hamming_window(254,8559
void fe_frame_to_fea(267,8739
void fe_spec_magnitude(297,9405
void fe_mel_spec(348,10429
void fe_mel_cep(368,10906
int32 fe_fft(400,11533
char **fe_create_2d(508,13955
void fe_free_2d(535,14455
void fe_parse_general_params(544,14546
void fe_parse_melfb_params(584,15454
void fe_print_current(651,17550

new_fe_sp.h,160
#define int32 87,4174
#define M_PI	90,4206
#define FORWARD_FFT 93,4263
#define INVERSE_FFT 94,4285
typedef struct { double r, i; } complex;complex96,4309

parse_args_file.c,126
static arg_t arg[105,4556
static char **liveargs 349,11638
void  parse_args_file(351,11718
void parse_args_free(404,13214

prim_type.h,976
#define _LIBUTIL_PRIM_TYPE_H_111,4785
typedef int		int32;int32114,4817
typedef short		int16;int16115,4837
typedef char		int8;int8116,4859
typedef unsigned int	uint32;uint32117,4879
typedef unsigned short	uint16;uint16118,4908
typedef unsigned char	uint8;uint8119,4939
typedef float		float32;float32120,4968
typedef double		float64;float64121,4992
typedef union anytype_s anytype_s123,5018
} anytype_t;anytype_t129,5180
#define MAX_INT32	133,5218
#define MAX_INT16	134,5258
#define MAX_INT8	135,5298
#define MAX_NEG_INT32	137,5338
#define MAX_NEG_INT16	138,5382
#define MAX_NEG_INT8	139,5426
#define MAX_UINT32	141,5470
#define MAX_UINT16	142,5512
#define MAX_UINT8	143,5554
#define MAX_POS_FLOAT32	146,5678
#define MIN_POS_FLOAT32	147,5712
#define MAX_POS_FLOAT64	148,5762
#define MIN_POS_FLOAT64	149,5796
#define MAX_NEG_FLOAT32	152,5870
#define MIN_NEG_FLOAT32	153,5926
#define MAX_NEG_FLOAT64	154,5982
#define MIN_NEG_FLOAT64	155,6038

profile.c,431
void pctr_reset 129,4989
void pctr_reset_all 135,5045
void pctr_print_all 142,5133
int32 host_pclk 154,5346
#define TM_LOWSCALE	204,6541
#define TM_HIGHSCALE	205,6566
static float64 make_sec 207,6618
static float64 make_sec 219,6799
void ptmr_start 227,6905
void ptmr_stop 256,7611
void ptmr_reset 294,8544
void ptmr_init 301,8625
void ptmr_reset_all 310,8759
void ptmr_print_all 317,8843
int32 host_endian 327,9039

profile.h,89
#define _LIBUTIL_PROFILE_H_108,4710
} pctr_t;pctr_t122,5098
} ptmr_t;ptmr_t143,5885

s3types.h,2192
#define _S3_S3TYPES_H_113,4939
typedef int8		s3cipid_t;s3cipid_t126,5239
#define BAD_S3CIPID	127,5282
#define NOT_S3CIPID(NOT_S3CIPID128,5319
#define IS_S3CIPID(IS_S3CIPID129,5350
#define MAX_S3CIPID	130,5381
typedef int32		s3pid_t;s3pid_t132,5406
#define BAD_S3PID	133,5467
#define NOT_S3PID(NOT_S3PID134,5500
#define IS_S3PID(IS_S3PID135,5529
#define MAX_S3PID	136,5558
typedef s3pid_t		s3ssid_t;s3ssid_t138,5597
#define BAD_S3SSID	139,5671
#define NOT_S3SSID(NOT_S3SSID140,5706
#define IS_S3SSID(IS_S3SSID141,5736
#define MAX_S3SSID	142,5766
typedef int32		s3tmatid_t;s3tmatid_t144,5806
#define BAD_S3TMATID	145,5890
#define NOT_S3TMATID(NOT_S3TMATID146,5929
#define IS_S3TMATID(IS_S3TMATID147,5961
#define MAX_S3TMATID	148,5993
typedef int32		s3wid_t;s3wid_t150,6035
#define BAD_S3WID	151,6084
#define NOT_S3WID(NOT_S3WID152,6117
#define IS_S3WID(IS_S3WID153,6146
#define MAX_S3WID	154,6175
typedef uint16		s3lmwid_t;s3lmwid_t156,6214
#define BAD_S3LMWID	157,6288
#define NOT_S3LMWID(NOT_S3LMWID158,6329
#define IS_S3LMWID(IS_S3LMWID159,6371
#define MAX_S3LMWID	160,6412
typedef int32		s3latid_t;s3latid_t162,6450
#define BAD_S3LATID	163,6499
#define NOT_S3LATID(NOT_S3LATID164,6536
#define IS_S3LATID(IS_S3LATID165,6567
#define MAX_S3LATID	166,6598
typedef int16   	s3frmid_t;s3frmid_t168,6639
#define BAD_S3FRMID	169,6707
#define NOT_S3FRMID(NOT_S3FRMID170,6744
#define IS_S3FRMID(IS_S3FRMID171,6775
#define MAX_S3FRMID	172,6806
typedef int16   	s3senid_t;s3senid_t174,6843
#define BAD_S3SENID	175,6887
#define NOT_S3SENID(NOT_S3SENID176,6924
#define IS_S3SENID(IS_S3SENID177,6955
#define MAX_S3SENID	178,6986
typedef int16   	s3mgauid_t;s3mgauid_t180,7023
#define BAD_S3MGAUID	181,7087
#define NOT_S3MGAUID(NOT_S3MGAUID182,7126
#define IS_S3MGAUID(IS_S3MGAUID183,7158
#define MAX_S3MGAUID	184,7190
#define S3_START_WORD	187,7233
#define S3_FINISH_WORD	188,7262
#define S3_SILENCE_WORD	189,7293
#define S3_UNKNOWN_WORD	190,7326
#define S3_SILENCE_CIPHONE	191,7359
#define S3_LOGPROB_ZERO	193,7393
#define S3_MAX_FRAMES	195,7609
#define __declspec(__declspec198,7727
#define align(align199,7750

scpt,70
sed -e '/include/s/<libutil\/libutil.h>/"libutil.h"/g' $1 > blah 1,0

str2words.c,26
int32 str2words 113,4680

str2words.h,39
#define _LIBUTIL_STR2WORDS_H_105,4584

subvq.c,473
int VQ_EVAL 147,6383
static void subvq_maha_precomp 155,6630
static void subvq_map_compact 177,7108
static void subvq_map_linearize 233,9033
subvq_t *subvq_init 246,9324
static int32 subvq_mgau_shortlist 429,15288
void subvq_subvec_eval_logs3 510,17246
void subvq_gautbl_eval_logs3 525,17692
int32 sema 552,18361
void thrd_subvq_gautbl_eval_logs3 557,18448
void thrd_subvq_gautbl_eval_logs3 666,21826
int32 subvq_frame_eval 692,22420
void subvq_free 745,23665

subvq.h,58
#define _S3_SUBVQ_H_124,5415
} subvq_t;subvq_t163,7187

threading.c,1241
pthread_mutex_t update_lock 59,2530
int thread_arrived 61,2588
int wk_idx 62,2612
thread_args_t thread_data_array[64,2629
pthread_t thread[66,2695
int32 best_array[69,2736
int32 wbest_array[70,2767
int32 ns_array[71,2799
int32 ng_array[72,2828
int32 *he_best_array[74,2858
int32 *he_wbest_array[75,2893
lextree_node_t ***next_active_array[77,2930
int32 *next_active_size[78,2980
int32 *private_n[79,3018
lextree_node_t **double_next_active(83,3071
void threading_support_init(92,3408
static int32 thrd_subvq_mgau_shortlist 113,4108
void *frame_eval_thrd_work(195,6090
void dict2pid_comsenscr_thrd_work(313,8871
void lextree_hmm_eval_thrd_work(342,9514
int32 ln_lock(392,10729
int32 ln_lock_child(418,11118
void ln_unlock(442,11479
void lextree_hmm_ppg_thrd_work(455,11678
void ThreadJoin(567,14698
void lextree_ssid_active_thrd_work 581,14966
void sseq2sen_active_thrd_work(601,15396
void sen_active_thrd_work(653,16864
void *scoring_thrd_work(811,20877
void thrd_sen_active_phase(852,21899
void thrd_scoring_phase(889,22691
void new_lextree_hmm_eval_thrd_work(961,24556
void new_thrd_lextree_hmm_eval(1005,25899
void new_lextree_hmm_ppg_thrd_work(1062,27397
void new_thrd_lextree_hmm_propagate(1100,28468

threading.h,173
} sen_active_args_t;sen_active_args_t64,2601
} scoring_args_t;scoring_args_t76,2786
} searching_args_t;searching_args_t90,2981
} thread_args_t;thread_args_t108,3390

tmat.c,196
#define TMAT_PARAM_VERSION	119,5018
void tmat_dump 122,5054
int32 tmat_chk_uppertri 143,5585
int32 tmat_chk_1skip 159,5933
tmat_t *tmat_init 174,6228
void tmat_free 280,9741
main 292,10000

tmat.h,55
#define _S3_TMAT_H_114,4956
} tmat_t;tmat_t131,5441

unlimit.c,23
void unlimit 115,4769

unlimit.h,37
#define _LIBUTIL_UNLIMIT_H_105,4606

utt.c,336
void matchseg_write 134,5517
void utt_begin 164,6346
void utt_end 195,7116
void utt_word_trans 368,12558
void utt_decode 437,14398
sen_active_args_t sen_active_args;626,20526
scoring_args_t scoring_args;627,20561
searching_args_t searching_args;628,20590
void utt_decode_block 639,20961
void single_utt_decode_block 921,29627

utt.c~,336
void matchseg_write 134,5517
void utt_begin 164,6346
void utt_end 195,7116
void utt_word_trans 368,12558
void utt_decode 437,14398
sen_active_args_t sen_active_args;626,20528
scoring_args_t scoring_args;627,20563
searching_args_t searching_args;628,20592
void utt_decode_block 639,20963
void single_utt_decode_block 921,29629

utt.h,51
#define _UTT_H_88,4190
#define MAXHYPLEN 93,4245

vector.c,975
float64 vector_sum_norm 122,5158
void vector_floor 143,5606
void vector_nz_floor 153,5760
void vector_print(163,5938
int32 vector_is_zero 174,6116
int32 vector_maxcomp_int32 183,6301
int32 vector_mincomp_int32 196,6481
int32 vector_maxcomp_float32 209,6661
int32 vector_mincomp_float32 222,6845
void vector_accum 235,7029
int32 vector_cmp 244,7160
int32 vector_mean 259,7367
float64 vector_dist_eucl 282,7789
float64 vector_maha_precomp 295,7994
float64 vector_dist_maha 310,8323
int32 vector_vqlabel 326,8622
float64 vector_vqgen 351,9078
float64 vector_pdf_entropy 455,11994
float64 vector_pdf_cross_entropy 472,12245
void vector_gautbl_alloc 487,12501
void vector_gautbl_free 506,13241
void vector_gautbl_var_floor 514,13419
void vector_gautbl_maha_precomp 523,13608
void vector_gautbl_eval_logs3 537,13842
float64 vector_gautbl_eval_logs3_inner(602,15235
float64 vector_gautbl_eval_logs3_inner(667,16933
void vector_gautbl_eval_logs3 751,18830

vector.h,215
#define _S3_VECTOR_H_112,4940
typedef float32 *vector_t;vector_t117,4986
} arraysize_t;arraysize_t124,5130
} point_t;point_t129,5241
} fpoint_t;fpoint_t134,5352
} vector_gautbl_t;vector_gautbl_t298,12373

vithist.c,833
vithist_t *vithist_init 117,4978
static vithist_entry_t *vithist_entry_alloc 148,5865
int32 vithist_utt_begin 173,6469
static int32 vh_lmstate_find 210,7283
static void vithist_lmstate_enter 237,7877
vithist_entry_t *vithist_id2entry 265,8640
static void vithist_enter 274,8814
void vithist_rescore 302,9597
static void vithist_frame_gc 367,11234
void vithist_prune 410,12124
static void vithist_lmstate_reset 472,13684
void vithist_frame_windup 498,14233
int32 vithist_utt_end 514,14586
int32 vithist_partialutt_end 595,16723
void vithist_utt_reset 645,17860
static void vithist_lmstate_subtree_dump 663,18176
static void vithist_lmstate_dump 685,18735
void vithist_dump 718,19515
glist_t vithist_backtrace 779,21122
} dagnode_t;dagnode_t816,21789
void vithist_dag_write 822,21861
void vithist_free 999,27008

vithist.h,1176
#define _S3_VITHIST_H_114,4920
} vh_lmstate_t;vh_lmstate_t132,5409
} vithist_entry_t;vithist_entry_t148,6031
#define vithist_entry_wid(vithist_entry_wid150,6051
#define vithist_entry_sf(vithist_entry_sf151,6093
#define vithist_entry_ef(vithist_entry_ef152,6133
#define vithist_entry_ascr(vithist_entry_ascr153,6173
#define vithist_entry_lscr(vithist_entry_lscr154,6217
#define vithist_entry_score(vithist_entry_score155,6261
#define vithist_entry_pred(vithist_entry_pred156,6307
#define vithist_entry_valid(vithist_entry_valid157,6351
} vh_lms2vh_t;vh_lms2vh_t176,7396
} vithist_t;vithist_t202,8640
#define VITHIST_BLKSIZE	205,8655
#define VITHIST_MAXBLKS	206,8702
#define VITHIST_ID2BLK(VITHIST_ID2BLK207,8731
#define VITHIST_ID2BLKOFFSET(VITHIST_ID2BLKOFFSET208,8769
#define vithist_n_entry(vithist_n_entry211,8883
#define vithist_bestscore(vithist_bestscore212,8928
#define vithist_bestvh(vithist_bestvh213,8977
#define vithist_lms2vh_root(vithist_lms2vh_root214,9020
#define vithist_lwidlist(vithist_lwidlist215,9077
#define vithist_first_entry(vithist_first_entry216,9124
#define vithist_last_entry(vithist_last_entry217,9181

wid.c,70
s3lmwid_t *wid_dict_lm_map 107,4577
int32 wid_wordprob2alt 149,5552

wid.h,28
#define _S3_WID_H_104,4576
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#ifdef THRD
#include <assert.h>
#include <pthread.h>
#include "barrier.h"
#include "threading.h"

extern barrier_t *score_barrier;
pthread_mutex_t update_lock = PTHREAD_MUTEX_INITIALIZER;

int thread_arrived = 0;
int wk_idx = 0;

thread_args_t thread_data_array[NUM_THREADS];
#if (NUM_THREADS>1)
pthread_t thread[NUM_THREADS-1];
int status;
#endif

int32 best_array[NUM_THREADS];
int32 wbest_array[NUM_THREADS];
int32 ns_array[NUM_THREADS];
int32 ng_array[NUM_THREADS];

int32 *he_best_array[NUM_THREADS];
int32 *he_wbest_array[NUM_THREADS];

lextree_node_t ***next_active_array[NUM_THREADS];
int32 *next_active_size[NUM_THREADS];
int32 *private_n[NUM_THREADS];

extern int VQ_EVAL;

lextree_node_t **double_next_active(int32 t, int32 ltn, int32* array_size)
{
  next_active_size[t][ltn] <<=1;
  next_active_array[t][ltn] = (lextree_node_t **) realloc(next_active_array[t][ltn],
			      next_active_size[t][ltn]*sizeof(lextree_node_t *));
  *array_size = next_active_size[t][ltn];
  return next_active_array[t][ltn];
}

void threading_support_init(kb_t* kb)
{ 
  int32 n, i;

  for (n=0; n<NUM_THREADS; n++) {
    next_active_size[n] = (int32 *) ckd_calloc(kb->n_lextree<<1,sizeof(int32));
    next_active_array[n] = (lextree_node_t***) 
      ckd_calloc(kb->n_lextree<<1, sizeof(lextree_node_t **));
    private_n[n] = (int32 *) ckd_calloc(kb->n_lextree<<1,sizeof(int32));

    for (i=0; i < (kb->n_lextree <<1); i++) {
      next_active_size[n][i] = 16;
      next_active_array[n][i] = (lextree_node_t**) 
	ckd_calloc(16, sizeof(lextree_node_t *));
    }

    he_best_array[n] = (int32 *) ckd_calloc(kb->n_lextree<<1,sizeof(int32));
    he_wbest_array[n] = (int32 *) ckd_calloc(kb->n_lextree<<1,sizeof(int32));
  }
}

static int32 thrd_subvq_mgau_shortlist (int t, 
					subvq_t *vq,
					int32 m,	/* In: Mixture index */
					int32 n,	/* In: #Components in specified mixture */
					int32 beam)	/* In: Threshold to select active components */
{
    int32 *gauscore;
    int32 *map;
    int32 i, v, bv, th, nc;
    int32 *sl;
    int32 *vqdist;
    
    vqdist = vq->vqdist[0];	/* Since map is linearized for efficiency, must also
				   look at vqdist[][] as vqdist[] */
    gauscore = vq->thrd_gauscore[t];
    sl = vq->thrd_mgau_sl[t];
    
    /* Special case when vq->n_sv == 3; for speed */
    map = vq->map[m][0];
    bv = MAX_NEG_INT32;
    
    switch (vq->n_sv) {
    case 3:
	for (i = 0; i < n; i++) {
	  if (VQ_EVAL == 1) {
	    v = (int32) vqdist[*map];/* If we are not weighting the cep values, we need to adjust the subvqbeam */
	    map += 3;
	  } else {
	    /* RAH, we are ignoring the delta-delta, scoring the delta twice, strangely this works better than weighting the scores  */
	    /* I believe it has to do with the beam widths */
	    if (VQ_EVAL == 2) {
	    v = vqdist[*(map++)];
	      v += 2 * vqdist[*map]; /* RAH Count delta twice, we can keep the same subvqbeam as vq_eval = 3 if we double the delta*/
	      map += 2;
	    } else {
	      v = vqdist[*(map++)];/* Standard way */
	      v += vqdist[*(map++)]; /*  */
	      v += vqdist[*(map++)]; /*  */
	    }
	  }

	    gauscore[i] = v;
	    
	    if (bv < v)
		bv = v;
	}
	break;
    case 2:
	for (i = 0; i < n; i++) {
	    v = vqdist[*(map++)];
	    v += vqdist[*(map++)];
	    gauscore[i] = v;
	    
	    if (bv < v)
		bv = v;
	}
	break;
    case 1:
      for (i = 0; i < n; i++) {
	v = vqdist[*(map++)];
	gauscore[i] = v;
	
	if (bv < v)
	  bv = v;
      }
      break;
    default:
      E_FATAL("#Subvectors %d not yet implemented\n", vq->n_sv);
    }
    
    th = bv + beam;
    nc = 0;
    for (i = 0; i < n; i++) {
      if (gauscore[i] >= th)
	sl[nc++] = i;
    }
    sl[nc] = -1;
    
    return nc;
}


void *frame_eval_thrd_work(thread_args_t* thrd_args)
{
  int t = thrd_args->id;
  int32 start = thrd_args->feval_start;
  int32 end = thrd_args->feval_end;
  scoring_args_t* my_data = thrd_args->score_args;
  subvq_t *vq = my_data->vq;
  mgau_model_t *g = my_data->g;
  int32 beam = my_data->beam;
  float32 *feat = my_data->feat;
  int32 *sen_active = my_data->sen_active;
  int32 *senscr = my_data->senscr;

  int32 s;
  int32 best, ns, ng;
  
  best = MAX_NEG_INT32;
  ns = 0;
  ng = 0;

  if (!vq) {

    /* No subvq model, use the original (SLOW!!) */
    for (s = start; s < end; s++) {
      if ((! sen_active) || sen_active[s]) {
	senscr[s] = mgau_eval (g, s, NULL, feat);
	if (best < senscr[s])
	  best = senscr[s];
	ns++;
	ng += mgau_n_comp (g, s);
      } else
	senscr[s] = S3_LOGPROB_ZERO;
    }
  } else {
    int go = -1;

    /* Evaluate subvq model for given feature vector */
    if (NUM_THREADS > 1) {
#ifdef NEW_EVAL_LOGS3
      thrd_subvq_gautbl_eval_logs3 (t, vq, feat);
#else
      pthread_mutex_lock(&update_lock); 
      
      go = wk_idx++;

      pthread_mutex_unlock(&update_lock); 

      if (NUM_THREADS >= vq->n_sv) {
	if (go < vq->n_sv) 
	  thrd_subvq_gautbl_eval_logs3 (go, vq, feat);
      } else {

 	while (go < vq->n_sv) {
	  thrd_subvq_gautbl_eval_logs3 (go, vq, feat);
	  
	  pthread_mutex_lock(&update_lock);
	  go = wk_idx++;
	  pthread_mutex_unlock(&update_lock);
 	};
      }
      
      thread_barrier(thrd_args->id,score_barrier); 
      if (DEBUG & 2) printf("thread %d barrier 0\n",thrd_args->id);
  
#endif /* end of NEW_EVAL_LOGS3 */

    } else /* NUM_THREADS == 1 */
      /*thrd_subvq_gautbl_eval_logs3(t,vq,feat);*/
      subvq_gautbl_eval_logs3(vq,feat);

    /* Find mixture component shortlists using subvq scores, and evaluate senones */
    for (s = start; s < end; s++) {
      if ((! sen_active) || sen_active[s]) {
	ng += thrd_subvq_mgau_shortlist (t, vq, s, mgau_n_comp(g,s), beam);
	
	senscr[s] = mgau_eval (g, s, vq->thrd_mgau_sl[t], feat);
	if (best < senscr[s])
	  best = senscr[s];
	
	ns++;
	
      } else
	senscr[s] = S3_LOGPROB_ZERO;
    }
  }

  best_array[t] = best;
  ns_array[t] = ns;
  ng_array[t] = ng;
#if (NUM_THREADS>1)
  pthread_mutex_lock(&update_lock);
#endif
  
  if (thread_arrived<NUM_THREADS-1) 
    thread_arrived++;
  else {
    thread_arrived = 0;
    best = best_array[0];
    for (s = 0; s< NUM_THREADS; s++) {
      if (best < best_array[s])
	best = best_array[s];
    }
    best_array[0] = best;
  }
#if (NUM_THREADS>1)    
  pthread_mutex_unlock(&update_lock);
#endif
  thread_barrier(thrd_args->id,score_barrier);
  if (DEBUG & 2) printf("thread %d barrier 0a\n",thrd_args->id);
  

  best = best_array[0];
  for (s = start; s < end; s++) {
    senscr[s] -= best;
  }
  return NULL;
}

void dict2pid_comsenscr_thrd_work(thread_args_t* thrd_args) 
{
  scoring_args_t *my_data = thrd_args->score_args;
  int32 start = thrd_args->com_start;
  int32 end = thrd_args->com_end;
  dict2pid_t *d2p = my_data->d2p;
  int32 *comsenscr = my_data->comsenscr;
  int32 *senscr = my_data->senscr;
  int32 i, j;
  int32 best;
  s3senid_t *comstate, k;

  for (i = start; i < end; i++) {

    comstate = d2p->comstate[i];
    
    best = senscr[comstate[0]];
    for (j = 1;; j++) {
      k = comstate[j];
      if (NOT_S3SENID(k))
	break;
      if (best < senscr[k])
	best = senscr[k];
    }
    
    comsenscr[i] = best + d2p->comwt[i];
  }
}

void lextree_hmm_eval_thrd_work(thread_args_t* thrd_args)
{
    int32 best, wbest, n_st;
    int32 i, k;
    const int32 start = thrd_args->hmmeval_start;
    const int32 end = thrd_args->hmmeval_end;
    const searching_args_t *s_args = thrd_args->search_args;
    const lextree_t *lextree = thrd_args->lextree;
    const kbcore_t *kbc = s_args->kbc;
    const ascr_t *ascr = s_args->ascr;
    const int32 frm = s_args->frm;
    FILE *fp = s_args->fp;

    lextree_node_t **list, *ln;
    mdef_t *mdef;
    dict2pid_t *d2p;
    
    mdef = kbc->mdef;
    d2p = kbc->dict2pid;
    n_st = mdef_n_emit_state (mdef);
    
    list = lextree->active;
    best = MAX_NEG_INT32;
    wbest = MAX_NEG_INT32;

    assert(!fp && n_st==3 && "not qualified");
    for (i = start; i < end; i++) {

      ln = list[i];
      
      assert (ln->frame == frm);
      
      if (! ln->composite)
	k = hmm_vit_eval_3st (&(ln->hmm), mdef->sseq[ln->ssid], ascr->sen);
      else
	k = hmm_vit_eval_3st (&(ln->hmm), d2p->comsseq[ln->ssid], ascr->comsen);
      
      if (best < k)
	best = k;
      
      if (IS_S3WID(ln->wid)) {
	if (wbest < k)
	  wbest = k;
      }
    }
    thrd_args->best = best;
    thrd_args->wbest = wbest;

}

int32 ln_lock(int32 t1, lextree_node_t*ln)
{
  int32 retry, skip=0;

  do 
    {
      retry = 0;
#if (NUM_THREADS>1)
      pthread_mutex_lock(&update_lock);
#endif
      if (ln->synch != 0) {
	if (ln->synch > t1) 
	  skip = 1;
	else
	  retry = 1;
      } else
	ln->synch = t1;
#if (NUM_THREADS>1)
      pthread_mutex_unlock(&update_lock);
#endif
    }
  while (retry);

  return skip;
}

int32 ln_lock_child(int32 t1, lextree_node_t*ln)
{
  int32 retry, skip=0;

  do 
    {
      retry = 0;
#if (NUM_THREADS>1)
      pthread_mutex_lock(&update_lock);
#endif
      if (ln->synch != 0) {
	retry = 1;
      } else
	ln->synch = t1;
      
#if (NUM_THREADS>1)
      pthread_mutex_unlock(&update_lock);
#endif
    }
  while (retry);
  
  return skip;
}

void ln_unlock(int32 t, lextree_node_t*ln)
{
#if (NUM_THREADS>1)
  pthread_mutex_lock(&update_lock);
#endif  
  ln->synch = 0;

#if (NUM_THREADS>1)  
  pthread_mutex_unlock(&update_lock);
#endif
}


void lextree_hmm_ppg_thrd_work(thread_args_t* thrd_args)
{
    mdef_t *mdef;
    int32 nf, newscore;
    const lextree_t *lextree = thrd_args->lextree;
    lextree_node_t **list = lextree->active;
    lextree_node_t *ln, *ln2;
    hmm_t *hmm, *hmm2;
    gnode_t *gn;
    int32 i, n;
    const int32 t = thrd_args->id;
    const int32 t1 = t+1;
    const int32 ltn = thrd_args->lextree_num;

    const int32 start = thrd_args->hmmppg_start;
    const int32 end = thrd_args->hmmppg_end;
    const searching_args_t *s_args = thrd_args->search_args;

    kbcore_t *kbc = s_args->kbc;
    const int32 cf = s_args->frm;
    const int32 th = s_args->th;
    const int32 wth = s_args->wth;
    const int32 pth = s_args->pth;
    vithist_t* vh = s_args->vithist;
    lextree_node_t **next_active = next_active_array[t][ltn];
    int32 next_active_array_size = next_active_size[t][ltn];
    
    mdef = kbcore_mdef(kbc);
    
    nf = cf+1;
    
    /*list = lextree->active;*/
    
    assert(lextree->n_next_active==0);
    n = 0;

    for (i = start; i < end; i++) {
      ln = list[i];
      hmm = &(ln->hmm);

      if ((!ln_lock(t1,ln)) && (ln->frame < nf)) {
	if (hmm->bestscore >= th) {		/* Active in next frm */

	  ln->frame = nf;

	  if (n==next_active_array_size) 
	    next_active = double_next_active(t, ltn, &next_active_array_size);
	  next_active[n++] = ln;
	} else {				/* Deactivate */

	  if (ln->frame !=nf) {
	    ln->frame = -1;
	    hmm_clear (hmm, mdef_n_emit_state(mdef));
	  };
	}
      }

      ln_unlock(t1,ln);
      
      if (NOT_S3WID(ln->wid)) {		/* Not a leaf node */
	
	if (hmm->out.score < pth)
	  continue;			/* HMM exit score not good enough */
	
	/* Transition to each child */
	for (gn = ln->children; gn; gn = gnode_next(gn)) {
	  ln2 = gnode_ptr(gn);
	  hmm2 = &(ln2->hmm);

	  if (!ln_lock_child(t1,ln2)) {
	    newscore = hmm->out.score + (ln2->prob - ln->prob);
	  
	    if ((newscore >= th) && (hmm2->in.score < newscore)) {
	      hmm2->in.score = newscore;
	      hmm2->in.history = hmm->out.history;
	      
	      if (ln2->frame != nf) {
		ln2->frame = nf;
		
		if (n==next_active_array_size) {
		  next_active = double_next_active(t, ltn, &next_active_array_size);
		}
		next_active[n++] = ln2;
	      }
	    }
	  }
	  ln_unlock(t1,ln2);
	}
      } else {			/* Leaf node; word exit */
	    if (hmm->out.score < wth)
		continue;		/* Word exit score not good enough */
	    
	    /* Rescore the LM prob for this word wrt all possible predecessors */

	    /* The children functions have a couple shared variables, more 
	       investigations can unravel them to have less conservative 
	       fine-grained locking    */
#if (NUM_THREADS>1)
	    pthread_mutex_lock(&update_lock);
#endif
	    vithist_rescore (vh, kbc, ln->wid, cf,
			     hmm->out.score - ln->prob, hmm->out.history, lextree->type);
#if (NUM_THREADS>1)
	    pthread_mutex_unlock(&update_lock);
#endif
      }
    }
    if (DEBUG & 0x2) printf("thrd %d lextree %d n %d\n",t,ltn,n);
    private_n[t][ltn] = n;

}

void ThreadJoin() {
#if (NUM_THREADS>1)
    int t,rc;

  for(t=0;t < NUM_THREADS-1;t++) {
    rc = pthread_join(thread[t], (void **)&status);
    if (rc)	  {
      printf("ERROR; return code from pthread_join() is %d\n", rc);
      exit(-1);
    }
  }
#endif
}

void lextree_ssid_active_thrd_work (thread_args_t* t_args, int32 *ssid, 
				    int32 *comssid)
{
  lextree_t *lextree = t_args->lextree;
  lextree_node_t **list, *ln;
  int32 i;
  int start = t_args->hmmeval_start;
  int end = t_args->hmmeval_end;
  
  list = lextree->active;
  
  for (i = start; i < end; i++) {
    ln = list[i];
    if (ln->composite) 
      comssid[ln->ssid] = 1;
    else 
      ssid[ln->ssid] = 1;
  }
}

void sseq2sen_active_thrd_work(thread_args_t* t_args)
{
  int32 ss, cs, i, j;
  s3senid_t *csp, *sp;	/* Composite state pointer */
  mdef_t*mdef = t_args->sa_args->mdef;
  dict2pid_t*d2p = t_args->sa_args->d2p;
  kb_t* kb = t_args->sa_args->kb;
  int32 *sseq = kb->ssid_active;
  int32 *comssid = kb->comssid_active;
  int32 *sen = kb->sen_active;
  int32 n_sseq =  mdef_n_sseq(mdef);
  int32 n_comsseq = d2p->n_comsseq;
  int32 s_start, s_end, c_start, c_end;
  int32 mdef_chunk_size = n_sseq / NUM_THREADS;
  int32 mdef_remainder = n_sseq % NUM_THREADS;
  int32 d2p_chunk_size = n_comsseq / NUM_THREADS;
  int32 d2p_remainder = n_comsseq % NUM_THREADS;
  int32 t = t_args->id;

  s_start = (t==0) ? 0 : 
    (t*mdef_chunk_size + ((t <= mdef_remainder) ? t : mdef_remainder));
  s_end = s_start + mdef_chunk_size + 
    ((t < mdef_remainder) ? 1 : 0);
 
  c_start = (t==0) ? 0 : 
    (t*d2p_chunk_size + ((t <= d2p_remainder) ? t : d2p_remainder));
  c_end = c_start + d2p_chunk_size + 
    ((t < d2p_remainder) ? 1 : 0);
 
  for (ss = s_start; ss < s_end; ss++) {
    if (sseq[ss]) {
      sp = mdef->sseq[ss];
      for (i = 0; i < mdef_n_emit_state(mdef); i++)
	sen[sp[i]] = 1;
    }
  }
  
  for (ss = c_start; ss < c_end; ss++) {
    if (comssid[ss]) {
      csp = d2p->comsseq[ss];
      
      for (i = 0; i < mdef_n_emit_state(mdef); i++) {
	cs = csp[i];
	sp = d2p->comstate[cs];
	
	for (j = 0; IS_S3SENID(sp[j]); j++)
	  sen[sp[j]] = 1;
      }
    }
  }
}

void sen_active_thrd_work(thread_args_t* t_args) 
{
  int32 i;
  const int t = t_args->id;
  int32 chunk_size, remainder;
  int32 s, e;
  lextree_t* lextree;
  const kb_t* kb = t_args->sa_args->kb;
  const mdef_t *mdef = t_args->sa_args->mdef;
  const dict2pid_t *d2p = t_args->sa_args->d2p;
  int32* array_ptr;

  chunk_size = mdef_n_sseq(mdef) / NUM_THREADS;
  remainder = mdef_n_sseq(mdef) % NUM_THREADS;

  s = (t==0) ? 0 : (t*chunk_size + ((t <= remainder) ? t : remainder));
  e =  s + chunk_size + ((t < remainder) ? 1 : 0);
  array_ptr = kb->ssid_active;

#ifdef SSE2
  {
    int32* chunk_ptr = &array_ptr[s]   ;
    int32* end_ptr   = &array_ptr[e-3] ;

    while (((int)chunk_ptr)%16)
      *chunk_ptr++ = 0;
    
    __asm {
      pxor    xmm0, xmm0          ;
      mov     eax, [chunk_ptr]    ;
      mov     ecx, [end_ptr]      ;

    zero_out1:
      movdqa  [eax], xmm0         ;
      add     eax, 16             ;
      cmp     eax, ecx            ;
      jl      zero_out1           ;
      mov     [chunk_ptr], eax    ;
    }
    end_ptr+=3;
    for (;chunk_ptr<end_ptr;chunk_ptr++)
      *chunk_ptr=0;
  }
#else
#pragma novector
  for (i=s; i<e; i++)
    array_ptr[i]=0;
#endif
  
  chunk_size = dict2pid_n_comsseq(d2p) / NUM_THREADS;
  remainder = dict2pid_n_comsseq(d2p) % NUM_THREADS;

  s = (t==0) ? 0 : (t*chunk_size + ((t <= remainder) ? t : remainder));
  e =  s + chunk_size + ((t < remainder) ? 1 : 0);
  array_ptr = kb->comssid_active;
  
#ifdef SSE2
  {
    int32* chunk_ptr = &array_ptr[s]   ;
    int32* end_ptr   = &array_ptr[e-3] ;
    
    while (((int)chunk_ptr)%16)
      *chunk_ptr++ = 0;

    __asm {
      pxor    xmm0, xmm0          ;
      mov     eax, [chunk_ptr]    ;
      mov     ecx, [end_ptr]      ;

    zero_out2:
      movdqa  [eax], xmm0         ;
      add     eax, 16             ;
      cmp     eax, ecx            ;
      jl      zero_out2           ;
      mov     [chunk_ptr], eax    ;
    }
    end_ptr+=3;
    for (;chunk_ptr<end_ptr;chunk_ptr++)
      *chunk_ptr=0;
  }
#else
#pragma novector
  for (i=s; i<e; i++)
    array_ptr[i]=0;
#endif
  
  chunk_size = mdef_n_sen(mdef) / NUM_THREADS;
  remainder = mdef_n_sen(mdef) % NUM_THREADS;

  s = (t==0) ? 0 : (t*chunk_size + ((t <= remainder) ? t : remainder));
  e =  s + chunk_size + ((t < remainder) ? 1 : 0);
  array_ptr = kb->sen_active;
  
#ifdef SSE2
  {
    int32* chunk_ptr = &array_ptr[s]   ;
    int32* end_ptr   = &array_ptr[e-3] ;
    
    while (((int)chunk_ptr)%16)
      *chunk_ptr++ = 0;

    __asm {
      pxor    xmm0, xmm0          ;
      mov     eax, [chunk_ptr]    ;
      mov     ecx, [end_ptr]      ;

    zero_out3:
      movdqa  [eax], xmm0         ;
      add     eax, 16             ;
      cmp     eax, ecx            ;
      jl      zero_out3           ;
      mov     [chunk_ptr], eax    ;
    }
    end_ptr+=3;
    for (;chunk_ptr<end_ptr;chunk_ptr++)
      *chunk_ptr=0;
  }
#else
#pragma novector
  for (i=s; i<e; i++)
   array_ptr[i]=0;
#endif

  thread_barrier(t_args->id,score_barrier);
  
  for (i = 0; i < (kb->n_lextree <<1); i++) {

    lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
      kb->fillertree[i - kb->n_lextree];

    if (lextree->n_active >= NUM_THREADS) {
      chunk_size = lextree->n_active / NUM_THREADS;
      remainder = lextree->n_active % NUM_THREADS;

      t_args->lextree = lextree;
      t_args->hmmeval_start = (t==0) ? 0 : 
	(t*chunk_size + ((t <= remainder) ? t : remainder));
      t_args->hmmeval_end = t_args->hmmeval_start + chunk_size + 
	((t < remainder) ? 1 : 0);
      
      lextree_ssid_active_thrd_work(t_args, kb->ssid_active, 
				    kb->comssid_active);
      
    } else if (t==NUM_THREADS-1) {
      
      t_args->lextree = lextree;
      t_args->hmmeval_start = 0;
      t_args->hmmeval_end = lextree->n_active;
      
      lextree_ssid_active_thrd_work(t_args, kb->ssid_active, 
				    kb->comssid_active);
    };
  }
    
  thread_barrier(t_args->id,score_barrier);
  sseq2sen_active_thrd_work(t_args);
}

void *scoring_thrd_work(void* thrd_args)
{
  
  thread_args_t* t_args = (thread_args_t*) thrd_args;

  sen_active_thrd_work(t_args);
  thread_barrier(t_args->id,score_barrier);
  thread_barrier(t_args->id,score_barrier);

  frame_eval_thrd_work(t_args);

  thread_barrier(t_args->id,score_barrier);
  if (DEBUG & 2) printf("thread %d barrier 1\n",t_args->id);

  dict2pid_comsenscr_thrd_work(t_args);

  if (PHASES != 0x1) {
    if (PHASES & 0x2) {
      thread_barrier(t_args->id,score_barrier);
    
      thread_barrier(t_args->id, score_barrier);
      if (DEBUG & 2) printf("thread %d barrier 2\n",t_args->id);
      
      new_lextree_hmm_eval_thrd_work(thrd_args);
    }
    
    if (PHASES & 0x4) {
      thread_barrier(t_args->id, score_barrier);
      if (DEBUG & 2) printf("thread %d barrier 3\n",t_args->id);

      thread_barrier(t_args->id, score_barrier);
      if (DEBUG & 2) printf("thread %d barrier 4\n",t_args->id);
      
      new_lextree_hmm_ppg_thrd_work(thrd_args);
    };
  }

  return NULL;
}


void thrd_sen_active_phase(sen_active_args_t* sa_args)
{
  int32 t;
#if (NUM_THREADS > 1)
  pthread_attr_t attr;
  int rc;

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
#endif

  for(t=0;t < NUM_THREADS;t++) {
    thread_data_array[t].sa_args = sa_args;
    thread_data_array[t].id = t;

    /* create threads */
#if (NUM_THREADS > 1)
    if (t < NUM_THREADS-1) {
	rc = pthread_create(&thread[t], &attr, scoring_thrd_work,
			    (void*) &thread_data_array[t]); 

	if (rc) {
	  printf("ERROR; return code from pthread_create() is %d\n", rc);
	  exit(-1);
	}
    }
#endif
  }
#if (NUM_THREADS > 1)
  pthread_attr_destroy(&attr);
#endif
  sen_active_thrd_work(&thread_data_array[NUM_THREADS-1]);

  thread_barrier(NUM_THREADS-1,score_barrier);

}

void thrd_scoring_phase(scoring_args_t* score_args)
{
  int rc;
  int t;
  int feval_chunk_size, feval_remainder, feval_tmp;
  int com_chunk_size, com_remainder, com_tmp;
  int32 ns, ng, s;

  feval_chunk_size = score_args->g->n_mgau / NUM_THREADS;
  feval_remainder = score_args->g->n_mgau % NUM_THREADS;

  com_chunk_size = score_args->d2p->n_comstate / NUM_THREADS;
  com_remainder = score_args->d2p->n_comstate % NUM_THREADS;

  wk_idx = 0;

  for(t=0;t < NUM_THREADS;t++) {
    if (t==0) {
      thread_data_array[t].feval_start = 0;
      thread_data_array[t].com_start = 0;
    } else {
      thread_data_array[t].feval_start = thread_data_array[t-1].feval_end;
      thread_data_array[t].com_start = thread_data_array[t-1].com_end;
    }

    feval_tmp = thread_data_array[t].feval_start + feval_chunk_size;
    com_tmp = thread_data_array[t].com_start + com_chunk_size;
      
    if (feval_remainder) {
      feval_tmp++;
      feval_remainder--;
    }

    if (com_remainder) {
      com_tmp++;
      com_remainder--;
    }
      
    thread_data_array[t].feval_end = feval_tmp;
    thread_data_array[t].com_end = com_tmp;
    thread_data_array[t].score_args = score_args;
    
    thread_data_array[t].id = t;

  }

  thread_barrier(NUM_THREADS-1,score_barrier);
  
  frame_eval_thrd_work(&thread_data_array[NUM_THREADS-1]);

  thread_barrier(NUM_THREADS-1,score_barrier);
  if (DEBUG & 2) printf("thread %d barrier 1\n",NUM_THREADS-1);

  ns = ng = 0;
  for (s = 0; s< NUM_THREADS; s++) {
    ns += ns_array[s];
    ng += ng_array[s];
  }

  score_args->g->frm_sen_eval = ns;
  score_args->g->frm_gau_eval = ng;

  dict2pid_comsenscr_thrd_work(&thread_data_array[NUM_THREADS-1]);

  if (PHASES == 0x1)
    ThreadJoin();
  else {
    thread_barrier(NUM_THREADS-1,score_barrier);
    if (DEBUG & 2) printf("thread %d barrier 1\n",NUM_THREADS-1);
  };
}

void new_lextree_hmm_eval_thrd_work(thread_args_t* thrd_args)
{
  int32 i;
  int t = thrd_args->id;
  int chunk_size, remainder;
  const kb_t* kb = thrd_args->search_args->kb;
  lextree_t* lextree;

  for (i = 0; i < (kb->n_lextree <<1); i++) {

    lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
      kb->fillertree[i - kb->n_lextree];

    if (lextree->n_active >= NUM_THREADS) {
      chunk_size = lextree->n_active / NUM_THREADS;
      remainder = lextree->n_active % NUM_THREADS;

      thrd_args->lextree = lextree;
      thrd_args->hmmeval_start = (t==0) ? 0 : 
	(t*chunk_size + ((t <= remainder) ? t : remainder));
      thrd_args->hmmeval_end = thrd_args->hmmeval_start + chunk_size + 
	((t < remainder) ? 1 : 0);

      if (DEBUG&0x2) printf("thread %d lextree %d start %d end %d n_active %d\n",
			t, i,thrd_args->hmmeval_start, 
			thrd_args->hmmeval_end,lextree->n_active);
      lextree_hmm_eval_thrd_work(thrd_args);

      he_best_array[t][i] = thrd_args->best;
      he_wbest_array[t][i] = thrd_args->wbest;
    } else if (t==NUM_THREADS-1) {
      thrd_args->lextree = lextree;
      thrd_args->hmmeval_start = 0;
      thrd_args->hmmeval_end = lextree->n_active;

      lextree_hmm_eval_thrd_work(thrd_args);

      he_best_array[t][i] = thrd_args->best;
      he_wbest_array[t][i] = thrd_args->wbest;
    };
    
  }
}

void new_thrd_lextree_hmm_eval(searching_args_t* search_args, int32* besthmmscr,
			       int32* bestwordscr, int32 *n_hmm_eval, 
			       int32 *frm_nhmm)
{
  int32 t, i, best, wbest;
  kb_t * kb = search_args->kb;
  lextree_t* lextree;
  
  for(t=0;t < NUM_THREADS;t++) 
    thread_data_array[t].search_args = search_args;
  
  thread_barrier(NUM_THREADS-1,score_barrier);
  if (DEBUG & 2) printf("thread %d barrier 2\n",NUM_THREADS-1);
  
  new_lextree_hmm_eval_thrd_work(&thread_data_array[NUM_THREADS-1]);
  
  if (PHASES >= 0x4) {
    thread_barrier(NUM_THREADS-1,score_barrier);
    if (DEBUG & 2) printf("thread %d barrier 3\n",NUM_THREADS-1);
  } else
    ThreadJoin();

  best = MAX_NEG_INT32;
  wbest = MAX_NEG_INT32;

  for (i = 0; i < (kb->n_lextree <<1); i++) {
    lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
      kb->fillertree[i - kb->n_lextree];

    if (lextree->n_active) {
      best = he_best_array[NUM_THREADS-1][i];
      wbest = he_wbest_array[NUM_THREADS-1][i];
    }
    
    if (lextree->n_active >= NUM_THREADS) {
      for (t = 0; t<NUM_THREADS-1; t++) {
	if (best < he_best_array[t][i])
	  best = he_best_array[t][i];
	if (wbest < he_wbest_array[t][i])
	  wbest = he_wbest_array[t][i];
      }
    }
    
    lextree->best = best;
    lextree->wbest = wbest;
    
    if (*besthmmscr < best)
      *besthmmscr = best;
    if (*bestwordscr < wbest)
      *bestwordscr = wbest;

    *n_hmm_eval += lextree->n_active;
    *frm_nhmm += lextree->n_active;
  }

}

void new_lextree_hmm_ppg_thrd_work(thread_args_t* thrd_args)
{
  int32 i;
  int t = thrd_args->id;
  int chunk_size, remainder;
  kb_t* kb = thrd_args->search_args->kb;
  lextree_t* lextree;

  for (i = 0; i < (kb->n_lextree <<1); i++) {
    lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
      kb->fillertree[i - kb->n_lextree];
    
    if (lextree->n_active >= NUM_THREADS) {
      chunk_size = lextree->n_active / NUM_THREADS;
      remainder = lextree->n_active % NUM_THREADS;
      
      thrd_args->lextree = lextree;
      thrd_args->hmmppg_start = (t==0) ? 0 : 
	(t*chunk_size + ((t <= remainder) ? t : remainder));
      thrd_args->hmmppg_end = thrd_args->hmmppg_start + chunk_size + 
	((t < remainder) ? 1 : 0);
      thrd_args->lextree_num = i;
      
      lextree_hmm_ppg_thrd_work(thrd_args);

    } else if (t==NUM_THREADS-1) {
      thrd_args->lextree = lextree;
      thrd_args->hmmppg_start = 0;
      thrd_args->hmmppg_end = lextree->n_active;
      thrd_args->lextree_num = i;
      
      lextree_hmm_ppg_thrd_work(thrd_args);

    };
    
  }
}

void new_thrd_lextree_hmm_propagate(searching_args_t* search_args)
{
  int32 t, i;
  kb_t * kb = search_args->kb;
  lextree_t* lextree;
  int32 sum;
  
  for(t=0;t < NUM_THREADS;t++) 
    thread_data_array[t].search_args = search_args;
  
  thread_barrier(NUM_THREADS-1,score_barrier);
  if (DEBUG & 2) printf("thread %d barrier 4\n",NUM_THREADS-1);
    
  new_lextree_hmm_ppg_thrd_work(&thread_data_array[NUM_THREADS-1]);
  
#if (NUM_THREADS>1)
  ThreadJoin();
#endif

  for (i=0; i < (kb->n_lextree << 1); i++) {
    lextree = (i < kb->n_lextree) ? kb->ugtree[i] :
      kb->fillertree[i - kb->n_lextree];
    
    sum = 0;
    
    if (lextree->n_active >= NUM_THREADS) {
    
      for (t=0; t<NUM_THREADS; t++) {
	if (private_n[t][i]) {
	  memcpy(&lextree->next_active[sum], next_active_array[t][i],
		 private_n[t][i]*sizeof(lextree_node_t *));
	  sum += private_n[t][i];
	}
      } 
      
      lextree->n_next_active = sum;
    } else if (private_n[NUM_THREADS-1][i]) {
      
      memcpy(lextree->next_active, next_active_array[NUM_THREADS-1][i],
	     private_n[NUM_THREADS-1][i]*sizeof(lextree_node_t *));
      
      lextree->n_next_active = private_n[NUM_THREADS-1][i];
    } else {
      lextree->n_next_active = 0;
    }
  } 

}

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


#include "subvq.h"
#include "dict2pid.h"
#include "lextree.h"
#include "kbcore.h"
#include "kb.h"
#include "ascr.h"
#include <pthread.h>

typedef struct {
  kb_t *kb;
  mdef_t *mdef;
  dict2pid_t *d2p;
} sen_active_args_t;

typedef struct {
  subvq_t* vq;
  mgau_model_t * g;
  int32 beam;
  float32 *feat;
  int32* sen_active;
  int32* senscr;
  
  dict2pid_t *d2p;
  int32 *comsenscr;
} scoring_args_t;

typedef struct {
  kb_t *kb;
  lextree_t *lextree;
  kbcore_t *kbc;
  ascr_t *ascr;
  int32 frm;
  FILE *fp;

  int32 ptranskip;
  vithist_t *vithist;
  int32 th, pth, wth;
  
} searching_args_t;

typedef struct {
  int id;
  int32 feval_start, feval_end;
  int32 com_start, com_end;
  int32 hmmeval_start, hmmeval_end;
  int32 hmmppg_start, hmmppg_end;

  int32 best, wbest; /* hmm_eval results */
  int32 lextree_num;
#ifdef NEW_PAR
  int32 n_mgau, n_comstate;
#endif
  lextree_t* lextree;
  sen_active_args_t *sa_args;
  scoring_args_t *score_args;
  searching_args_t *search_args;
} thread_args_t;

void ThreadJoin();
void threading_support_init(kb_t* kb);
void *frame_eval_thrd_work(thread_args_t* thrd_args);

void dict2pid_comsenscr_thrd_work(thread_args_t* thrd_args);
void lextree_hmm_eval_thrd_work(thread_args_t* thrd_args);
void lextree_hmm_ppg_thrd_work(thread_args_t* thrd_args);
void thrd_scoring_phase(scoring_args_t* score_args);
void new_thrd_lextree_hmm_eval(searching_args_t* search_args, int32* besthmmscr,
			       int32* bestwordscr, int32 *n_hmm_eval, 
			       int32 *frm_nhmm);
void new_lextree_hmm_eval_thrd_work(thread_args_t* thrd_args);
void new_thrd_lextree_hmm_propagate(searching_args_t* search_args);
void new_lextree_hmm_ppg_thrd_work(thread_args_t* thrd_args);

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * tmat.c
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added tmat_free to free allocated memory 
 *
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added tmat_chk_1skip(), and made tmat_chk_uppertri() public.
 * 
 * 10-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Made tmat_dump() public.
 * 
 * 11-Mar-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started based on original S3 implementation.
 */


#include "tmat.h"
#include "bio.h"
#include "vector.h"
#include "logs3.h"


#define TMAT_PARAM_VERSION		"1.0"


void tmat_dump (tmat_t *tmat, FILE *fp)
{
    int32 i, src, dst;
    
    for (i = 0; i < tmat->n_tmat; i++) {
	fprintf (fp, "TMAT %d = %d x %d\n", i, tmat->n_state, tmat->n_state+1);
	for (src = 0; src < tmat->n_state; src++) {
	    for (dst = 0; dst <= tmat->n_state; dst++)
		fprintf (fp, " %12d", tmat->tp[i][src][dst]);
	    fprintf (fp, "\n");
	}
	fprintf (fp, "\n");
    }
    fflush (fp);
}


/*
 * Check model tprob matrices that they conform to upper-triangular assumption;
 * i.e. no "backward" transitions allowed.
 */
int32 tmat_chk_uppertri (tmat_t *tmat)
{
    int32 i, src, dst;
    
    /* Check that each tmat is upper-triangular */
    for (i = 0; i < tmat->n_tmat; i++) {
	for (dst = 0; dst < tmat->n_state; dst++)
	    for (src = dst+1; src < tmat->n_state; src++)
		if (tmat->tp[i][src][dst] > S3_LOGPROB_ZERO)
		    return -1;
    }
    
    return 0;
}


int32 tmat_chk_1skip (tmat_t *tmat)
{
    int32 i, src, dst;
    
    for (i = 0; i < tmat->n_tmat; i++) {
	for (src = 0; src < tmat->n_state; src++)
	    for (dst = src+3; dst <= tmat->n_state; dst++)
		if (tmat->tp[i][src][dst] > S3_LOGPROB_ZERO)
		    return -1;
    }
    
    return 0;
}


tmat_t *tmat_init (char *file_name, float64 tpfloor)
{
    char tmp;
    int32 n_src, n_dst;
    FILE *fp;
    int32 byteswap, chksum_present;
    uint32 chksum;
    float32 **tp;
    int32 i, j, k, tp_per_tmat;
    char **argname, **argval;
    tmat_t *t;
    
    E_INFO("Reading HMM transition probability matrices: %s\n", file_name);

    t = (tmat_t *) ckd_calloc (1, sizeof(tmat_t));

    if ((fp = fopen(file_name, "rb")) == NULL)
	E_FATAL_SYSTEM("fopen(%s,rb) failed\n", file_name);
    
    /* Read header, including argument-value info and 32-bit byteorder magic */
    if (bio_readhdr (fp, &argname, &argval, &byteswap) < 0)
	E_FATAL("bio_readhdr(%s) failed\n", file_name);
    
    /* Parse argument-value list */
    chksum_present = 0;
    for (i = 0; argname[i]; i++) {
	if (strcmp (argname[i], "version") == 0) {
	    if (strcmp(argval[i], TMAT_PARAM_VERSION) != 0)
		E_WARN("Version mismatch(%s): %s, expecting %s\n",
			file_name, argval[i], TMAT_PARAM_VERSION);
	} else if (strcmp (argname[i], "chksum0") == 0) {
	    chksum_present = 1;	/* Ignore the associated value */
	}
    }
    bio_hdrarg_free (argname, argval);
    argname = argval = NULL;
    
    chksum = 0;
    
    /* Read #tmat, #from-states, #to-states, arraysize */
    if ((bio_fread (&(t->n_tmat), sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&n_src, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&n_dst, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(bio_fread (&i, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {
	E_FATAL("bio_fread(%s) (arraysize) failed\n", file_name);
    }
    if (t->n_tmat >= MAX_S3TMATID)
	E_FATAL("%s: #tmat (%d) exceeds limit (%d)\n", file_name, t->n_tmat, MAX_S3TMATID);
    if (n_dst != n_src+1)
	E_FATAL("%s: #from-states(%d) != #to-states(%d)-1\n", file_name, n_src, n_dst);
    t->n_state = n_src;
    
    if (i != t->n_tmat * n_src * n_dst) {
	E_FATAL("%s: #float32s(%d) doesn't match dimensions: %d x %d x %d\n",
		file_name, i, t->n_tmat, n_src, n_dst);
    }

    /* Allocate memory for tmat data */
    t->tp = (int32 ***) ckd_calloc_3d (t->n_tmat, n_src, n_dst, sizeof(int32));

    /* Temporary structure to read in the float data */
    tp = (float32 **) ckd_calloc_2d (n_src, n_dst, sizeof(float32));

    /* Read transition matrices, normalize and floor them, and convert to logs3 domain */
    tp_per_tmat = n_src * n_dst;
    for (i = 0; i < t->n_tmat; i++) {
	if (bio_fread (tp[0], sizeof(float32), tp_per_tmat, fp,
		       byteswap, &chksum) != tp_per_tmat) {
	    E_FATAL("fread(%s) (arraydata) failed\n", file_name);
	}
	
	/* Normalize and floor */
	for (j = 0; j < n_src; j++) {
	    if (vector_sum_norm (tp[j], n_dst) == 0.0)
		E_ERROR("Normalization failed for tmat %d from state %d\n", i, j);
	    vector_nz_floor (tp[j], n_dst, tpfloor);
	    vector_sum_norm (tp[j], n_dst);

	    /* Convert to logs3.  Take care of special case when tp = 0.0! */
	    for (k = 0; k < n_dst; k++)
		t->tp[i][j][k] = (tp[j][k] == 0.0) ? S3_LOGPROB_ZERO : logs3(tp[j][k]);
	}
    }

    ckd_free_2d ((void **) tp);

    if (chksum_present)
	bio_verify_chksum (fp, byteswap, chksum);

    if (fread (&tmp, 1, 1, fp) == 1)
	E_ERROR("Non-empty file beyond end of data\n");

    fclose(fp);

    E_INFO("Read %d transition matrices of size %dx%d\n",
	   t->n_tmat, t->n_state, t->n_state+1);
    
    if (tmat_chk_uppertri (t) < 0)
	E_FATAL("Tmat not upper triangular\n");
    
    return t;
}

/* 
 *  RAH, Free memory allocated in tmat_init ()
 */
void tmat_free (tmat_t *t)
{
  if (t) {
    if (t->tp)
      ckd_free_3d ((void ***) t->tp);
    ckd_free ((void *) t);
  }
}


#if _TMAT_TEST_
/* RAH, April 26th, 2001, opened file tmat_test.out and added tmat_free(t) call, there are no memory leaks here */
main (int32 argc, char *argv[])
{
    tmat_t *t;
    float64 flr;
    FILE *fp;
    
    if (argc < 3)
	E_FATAL("Usage: %s tmat floor\n", argv[0]);
    if (sscanf (argv[2], "%lf", &flr) != 1)
	E_FATAL("Usage: %s tmat floor\n", argv[0]);

    fp = fopen ("tmat_test.out","wt");
    if (! fp) {
      fprintf (stderr,"Unable to topen tmat_test.out for writing\n");
      exit (-1);
    }

    logs3_init ((float64) 1.0001);
    
    t = tmat_init (argv[1], flr);

    tmat_dump (t,fp);
    tmat_free (t);
}
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * tmat.h
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added tmat_free to free allocated memory 
 *
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added tmat_chk_1skip(), and made tmat_chk_uppertri() public.
 * 
 * 10-Dec-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added tmat_dump().
 * 
 * 11-Mar-97	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Started based on original S3 implementation.
 */


#ifndef _S3_TMAT_H_
#define _S3_TMAT_H_


#include "libutil.h"
#include "s3types.h"


/*
 * Transition matrix data structure.  All phone HMMs are assumed to have the same
 * topology.
 */
typedef struct {
    int32 ***tp;	/* The transition matrices; int32 since probs in logs3 domain:
			   tp[tmatid][from-state][to-state] */
    int32 n_tmat;	/* #matrices */
    int32 n_state;	/* #source states in matrix (only the emitting states);
			   #destination states = n_state+1, it includes the exit state */
} tmat_t;


tmat_t *tmat_init (char *tmatfile,	/* In: input file */
		   float64 tpfloor);	/* In: floor value for each non-zero transition
					   probability */

void tmat_dump (tmat_t *tmat, FILE *fp);	/* For debugging */


/*
 * Checks that no transition matrix in the given object contains backward arcs.
 * Returns 0 if successful, -1 if check failed.
 */
int32 tmat_chk_uppertri (tmat_t *tmat);


/*
 * Checks that transition matrix arcs in the given object skip over at most 1 state.
 * Returns 0 if successful, -1 if check failed.
 */
int32 tmat_chk_1skip (tmat_t *tmat);

/*
 * RAH, add code to remove memory allocated by tmat_init
 */
void tmat_free (tmat_t *t);


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * unlimit.c -- "unlimit" the memory usage of program.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 03-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Copied from Sphinx-II sources.
 */


#if ((! defined(WIN32)) && (! defined(_HPUX_SOURCE)))
#include <sys/time.h>
#include <sys/resource.h>
#endif

#include "unlimit.h"


/*
 * The limit is set to the maximum of your system.
 */
void unlimit ( void )
{
#if ((! defined(WIN32)) && (! defined(_HPUX_SOURCE)))
  struct rlimit rl;

  getrlimit(RLIMIT_DATA,&rl);
  rl.rlim_cur = rl.rlim_max;
  setrlimit(RLIMIT_DATA,&rl);
#endif
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * unlimit.h -- "unlimit" the memory usage of program.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 03-Oct-96	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Copied from Sphinx-II sources.
 */


#ifndef _LIBUTIL_UNLIMIT_H_
#define _LIBUTIL_UNLIMIT_H_


/* To remove resource (memory) usage restrictions */
void unlimit ( void );


#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/************************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 2000 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 ************************************************
 * 
 * HISTORY
 *
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Added utt_decode_block() to allow block-based decoding 
 *		and decoding of piped input.
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Moved all utt_*() routines into utt.c to make them independent
 *		of main() during compilation
 * 
 * 29-Feb-2000	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Modified to allow runtime choice between 3-state and 5-state HMM
 * 		topologies (instead of compile-time selection).
 * 
 * 13-Aug-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added -maxwpf.
 * 
 * 10-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */

#ifdef THRD
#include "threading.h"

extern lextree_node_t **next_active_array[NUM_THREADS];
extern int32 next_active_size[NUM_THREADS];
extern int32 *he_best_array[NUM_THREADS];
extern int32 *he_wbest_array[NUM_THREADS];
#endif

#ifdef WIN32
#include <direct.h>		/* RAH, added */
#endif

#include "kb.h"
#include "corpus.h"
#include "utt.h"
#include "subvq.h"


void matchseg_write (FILE *fp, kb_t *kb, glist_t hyp, char *hdr)
{
    gnode_t *gn;
    hyp_t *h;
    int32 ascr, lscr;
    dict_t *dict;
    
    ascr = 0;
    lscr = 0;
    
    for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	ascr += h->ascr;
	lscr += h->lscr;
    }
    
    dict = kbcore_dict(kb->kbcore);
    
    fprintf (fp, "%s%s S 0 T %d A %d L %d", (hdr ? hdr : ""), kb->uttid, ascr+lscr, ascr, lscr);
    for (gn = hyp; gn && (gnode_next(gn)); gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	fprintf (fp, " %d %d %d %s", h->sf, h->ascr, h->lscr, dict_wordstr (dict, h->id));
    }
    fprintf (fp, " %d\n", kb->nfr);
    fflush (fp);
}
/*
 * Begin search at bigrams of <s>, backing off to unigrams; and fillers.  Update
 * kb->lextree_next_active with the list of active lextrees.
 */
void utt_begin (kb_t *kb)
{
    kbcore_t *kbc;
    int32 n, pred;
    
    kbc = kb->kbcore;
    
    /* Insert initial <s> into vithist structure */
    pred = vithist_utt_begin (kb->vithist, kbc);
    assert (pred == 0);	/* Vithist entry ID for <s> */
    
    /* Enter into unigram lextree[0] */
    n = lextree_n_next_active(kb->ugtree[0]);
    assert (n == 0);
    lextree_enter (kb->ugtree[0], mdef_silphone(kbc->mdef), -1, 0, pred, kb->beam->hmm);
    
    /* Enter into filler lextree */
    n = lextree_n_next_active(kb->fillertree[0]);
    assert (n == 0);
    lextree_enter (kb->fillertree[0], BAD_S3CIPID, -1, 0, pred, kb->beam->hmm);
    
    kb->n_lextrans = 1;
    
    kb_lextree_active_swap (kb);

#ifdef THRD
    threading_support_init(kb);

#endif
}

void utt_end (kb_t *kb)
{
    int32 id, ascr, lscr;
    glist_t hyp;
    gnode_t *gn;
    hyp_t *h;
    FILE *fp, *latfp;
    dict_t *dict;
    int32 i;
    
    fp = stderr;
    dict = kbcore_dict (kb->kbcore);
    
    if ((id = vithist_utt_end (kb->vithist, kb->kbcore)) >= 0) {
      if (cmd_ln_str("-bptbldir")) {
	char file[8192];
	
	sprintf (file, "%s/%s.bpt", cmd_ln_str ("-bptbldir"), kb->uttid);
	if ((latfp = fopen (file, "w")) == NULL) {
	  E_ERROR("fopen(%s,w) failed; using stdout\n", file);
	  latfp = stdout;
	}
	
	vithist_dump (kb->vithist, -1, kb->kbcore, latfp);
	if (latfp != stdout)
	  fclose (latfp);
      }
      
      hyp = vithist_backtrace (kb->vithist, id);
      
      /* Detailed backtrace */
      fprintf (fp, "\nBacktrace(%s)\n", kb->uttid);
      fprintf (fp, "%6s %5s %5s %11s %8s %4s\n",
	       "LatID", "SFrm", "EFrm", "AScr", "LScr", "Type");
      
      ascr = 0;
      lscr = 0;
      
      for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	fprintf (fp, "%6d %5d %5d %11d %8d %4d %s\n",
		 h->vhid, h->sf, h->ef, h->ascr, h->lscr, h->type,
		 dict_wordstr(dict, h->id));
	
	ascr += h->ascr;
	lscr += h->lscr;
      }
      fprintf (fp, "       %5d %5d %11d %8d (Total)\n",0,kb->nfr,ascr,lscr);
      
      /* Match */
      fprintf (fp, "\nFWDVIT: ");
      for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	if((!dict_filler_word(dict,h->id)) && (h->id!=dict_finishwid(dict)))
	  fprintf(fp,"%s ",dict_wordstr(dict, dict_basewid(dict,h->id)));
      }
      fprintf (fp, " (%s)\n\n", kb->uttid);
      
      /* Matchseg */
      if (kb->matchsegfp)
	matchseg_write (kb->matchsegfp, kb, hyp, NULL);
      matchseg_write (fp, kb, hyp, "FWDXCT: ");
      fprintf (fp, "\n");
      
      if (cmd_ln_str ("-outlatdir")) {
	char str[16384];
	int32 ispipe;
	float64 logbase;
	
	sprintf (str, "%s/%s.%s",
		 cmd_ln_str("-outlatdir"), kb->uttid, cmd_ln_str("-latext"));
	E_INFO("Writing lattice file: %s\n", str);
	
	if ((latfp = fopen_comp (str, "w", &ispipe)) == NULL)
	  E_ERROR("fopen_comp (%s,w) failed\n", str);
	else {
	  /* Write header info */
	  assert(0&&"used to be getcwd");
	  /*getcwd (str, sizeof(str));*/
	  fprintf (latfp, "# getcwd: %s\n", str);
	  
	  /* Print logbase first!!  Other programs look for it early in the DAG */
	  logbase = cmd_ln_float32 ("-logbase");
	  fprintf (latfp, "# -logbase %e\n", logbase);
	  
	  fprintf (latfp, "# -dict %s\n", cmd_ln_str ("-dict"));
	  if (cmd_ln_str ("-fdict"))
	    fprintf (latfp, "# -fdict %s\n", cmd_ln_str ("-fdict"));
	  fprintf (latfp, "# -lm %s\n", cmd_ln_str ("-lm"));
	  fprintf (latfp, "# -mdef %s\n", cmd_ln_str ("-mdef"));
	  fprintf (latfp, "# -mean %s\n", cmd_ln_str ("-mean"));
	  fprintf (latfp, "# -var %s\n", cmd_ln_str ("-var"));
	  fprintf (latfp, "# -mixw %s\n", cmd_ln_str ("-mixw"));
	  fprintf (latfp, "# -tmat %s\n", cmd_ln_str ("-tmat"));
	  fprintf (latfp, "#\n");
	  
	  fprintf (latfp, "Frames %d\n", kb->nfr);
	  fprintf (latfp, "#\n");
	  
	  vithist_dag_write (kb->vithist, hyp, dict, cmd_ln_int32("-outlatoldfmt"), latfp);
	  fclose_comp (latfp, ispipe);
	}
      }
      
      /* Free hyplist */
      for (gn = hyp; gn && (gnode_next(gn)); gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	ckd_free ((void *) h);
      }
      glist_free (hyp);
    } else
      E_ERROR("%s: No recognition\n\n", kb->uttid);
    
#if 0
    E_INFO("%4d frm;  %4d sen, %5d gau/fr, %4.1f CPU %4.1f Clk;  %5d hmm, %3d wd/fr, %4.1f CPU %4.1f Clk (%s)\n",
	   kb->nfr,
	   (kb->utt_sen_eval + (kb->nfr >> 1)) / kb->nfr,
	   (kb->utt_gau_eval + (kb->nfr >> 1)) / kb->nfr,
	   kb->tm_sen.t_cpu * 100.0 / kb->nfr, 
	   kb->tm_sen.t_elapsed * 100.0 / kb->nfr,
	   (kb->utt_hmm_eval + (kb->nfr >> 1)) / kb->nfr,
	   (vithist_n_entry(kb->vithist) + (kb->nfr >> 1)) / kb->nfr,
	   kb->tm_srch.t_cpu * 100.0 / kb->nfr, 
	   kb->tm_srch.t_elapsed * 100.0 / kb->nfr,
	   kb->uttid);
#endif
    E_INFO("%4d frm;  %4d sen, %5d gau/fr, %4.1f CPU %4.1f Clk;  %5d hmm, %3d wd/fr, %4.1f CPU %4.1f Clk (%s)\n",
	   kb->nfr,
	   (kb->utt_sen_eval + (kb->nfr >> 1)) / kb->nfr,
	   (kb->utt_gau_eval + (kb->nfr >> 1)) / kb->nfr,
	   0.0,
	   0.0, /*kb->tm_sen.t_elapsed * 100.0 / kb->nfr,*/
	   (kb->utt_hmm_eval + (kb->nfr >> 1)) / kb->nfr,
	   (vithist_n_entry(kb->vithist) + (kb->nfr >> 1)) / kb->nfr,
	   0.0,
	   0.0, /*kb->tm_srch.t_elapsed * 100.0 / kb->nfr,*/
	   kb->uttid);
    {
      int32 j, k;
      
      for (j = kb->hmm_hist_bins-1; (j >= 0) && (kb->hmm_hist[j] == 0); --j);
      E_INFO("HMMHist[0..%d](%s):", j, kb->uttid);
      for (i = 0, k = 0; i <= j; i++) {
	k += kb->hmm_hist[i];
	fprintf (stderr, " %d(%d)", kb->hmm_hist[i], (k*100)/kb->nfr);
      }
      fprintf (stderr, "\n");
      fflush (stderr);
    }
    
    kb->tot_sen_eval += kb->utt_sen_eval;
    kb->tot_gau_eval += kb->utt_gau_eval;
    kb->tot_hmm_eval += kb->utt_hmm_eval;
    kb->tot_wd_exit += vithist_n_entry(kb->vithist);

    ptmr_reset (&(kb->tm_sen));
    ptmr_reset (&(kb->tm_srch));

#if (!defined(WIN32) && !defined(sparc))
    system ("ps aguxwww | grep /live | grep -v grep"); 
#endif
    for (i = 0; i < kb->n_lextree; i++) {
      lextree_utt_end (kb->ugtree[i], kb->kbcore);
      lextree_utt_end (kb->fillertree[i], kb->kbcore);
    }
    
    vithist_utt_reset (kb->vithist);
    
    lm_cache_stats_dump (kbcore_lm(kb->kbcore));
    lm_cache_reset (kbcore_lm(kb->kbcore));
}


void utt_word_trans (kb_t *kb, int32 cf)
{
  int32 k, th;
  vithist_t *vh;
  vithist_entry_t *ve;
  int32 vhid, le, n_ci, score;
  static int32 *bs = NULL, *bv = NULL, epl;
  s3wid_t wid;
  int32 p;
  dict_t *dict;
  mdef_t *mdef;
  
  vh = kb->vithist;
  th = kb->bestscore + kb->beam->hmm;	/* Pruning threshold */
  
  if (vh->bestvh[cf] < 0)
    return;
  
  dict = kbcore_dict(kb->kbcore);
  mdef = kbcore_mdef(kb->kbcore);
  n_ci = mdef_n_ciphone(mdef);
  
  /* Initialize best exit for each distinct word-final CIphone to NONE */
  if (! bs) {
    bs = (int32 *) ckd_calloc (n_ci, sizeof(int32));
    bv = (int32 *) ckd_calloc (n_ci, sizeof(int32));
    epl = cmd_ln_int32 ("-epl");
  }
  for (p = 0; p < n_ci; p++) {
    bs[p] = MAX_NEG_INT32;
    bv[p] = -1;
  }
  
  /* Find best word exit in this frame for each distinct word-final CI phone */
  vhid = vithist_first_entry (vh, cf);
  le = vithist_n_entry (vh) - 1;
  for (; vhid <= le; vhid++) {
    ve = vithist_id2entry (vh, vhid);
    if (! vithist_entry_valid(ve))
      continue;
    
    wid = vithist_entry_wid (ve);
    p = dict_last_phone (dict, wid);
    if (mdef_is_fillerphone(mdef, p))
      p = mdef_silphone(mdef);
    
    score = vithist_entry_score (ve);
    if (score > bs[p]) {
      bs[p] = score;
      bv[p] = vhid;
    }
  }
  
  /* Find lextree instance to be entered */
  k = kb->n_lextrans++;
  k = (k % (kb->n_lextree * epl)) / epl;
  
  /* Transition to unigram lextrees */
  for (p = 0; p < n_ci; p++) {
    if (bv[p] >= 0)
      lextree_enter (kb->ugtree[k], (s3cipid_t) p, cf, bs[p], bv[p], th); /* RAH, typecast p to (s3cipid_t) to make compiler happy */
  }
  
  /* Transition to filler lextrees */
  lextree_enter (kb->fillertree[k], BAD_S3CIPID, cf, vh->bestscore[cf], vh->bestvh[cf], th);
}


/* Invoked by ctl_process in libmisc/corpus.c */
void utt_decode (void *data, char *uttfile, int32 sf, int32 ef, char *uttid)
{
  kb_t *kb;
  kbcore_t *kbcore;
  mdef_t *mdef;
  dict_t *dict;
  dict2pid_t *d2p;
  mgau_model_t *mgau;
  subvq_t *svq;
  lextree_t *lextree;
  int32 besthmmscr, bestwordscr, th, pth, wth, maxwpf, maxhistpf, maxhmmpf, ptranskip;
  int32 i, j, f;
  int32 n_hmm_eval, frm_nhmm, hb, pb, wb;
  FILE *hmmdumpfp;
  
  E_INFO("Processing: %s\n", uttid);

  kb = (kb_t *) data;
  kbcore = kb->kbcore;
  mdef = kbcore_mdef (kbcore);
  dict = kbcore_dict (kbcore);
  d2p = kbcore_dict2pid (kbcore);
  mgau = kbcore_mgau (kbcore);
  svq = kbcore_svq (kbcore);
  
  kb->uttid = uttid;
  
  hmmdumpfp = cmd_ln_int32("-hmmdump") ? stderr : NULL;
  maxwpf = cmd_ln_int32 ("-maxwpf");
  maxhistpf = cmd_ln_int32 ("-maxhistpf");
  maxhmmpf = cmd_ln_int32 ("-maxhmmpf");
  ptranskip = cmd_ln_int32 ("-ptranskip");
  
  /* Read mfc file and build feature vectors for entire utterance */
  kb->nfr = feat_s2mfc2feat(kbcore_fcb(kbcore), uttfile, cmd_ln_str("-cepdir"), sf, ef,
			    kb->feat, S3_MAX_FRAMES);
  E_INFO("%s: %d frames\n", kb->uttid, kb->nfr);
  
  for (i = 0; i < kb->hmm_hist_bins; i++)
    kb->hmm_hist[i] = 0;
  
  utt_begin (kb);
  
  n_hmm_eval = 0;
  kb->utt_sen_eval = 0;
  kb->utt_gau_eval = 0;

  for (f = 0; f < kb->nfr; f++) {
    /* Acoustic (senone scores) evaluation */
    ptmr_start (&(kb->tm_sen));
    
    /* Find active senones and composite senones, from active lextree nodes */
    if (kb->sen_active) {
      memset (kb->ssid_active, 0, mdef_n_sseq(mdef) * sizeof(int32));
      memset (kb->comssid_active, 0, dict2pid_n_comsseq(d2p) * sizeof(int32));
      /* Find active senone-sequence IDs (including composite ones) */
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ? kb->ugtree[i] :
	  kb->fillertree[i - kb->n_lextree];
	lextree_ssid_active (lextree, kb->ssid_active, kb->comssid_active);
      }
      
      /* Find active senones from active senone-sequences */
      memset (kb->sen_active, 0, mdef_n_sen(mdef) * sizeof(int32));
      mdef_sseq2sen_active (mdef, kb->ssid_active, kb->sen_active);
      
      /* Add in senones needed for active composite senone-sequences */
      dict2pid_comsseq2sen_active (d2p, mdef, kb->comssid_active, kb->sen_active);
    }
    
    /* Evaluate senone acoustic scores for the active senones */
    subvq_frame_eval (svq, mgau, kb->beam->subvq, kb->feat[f][0], kb->sen_active,
		      kb->ascr->sen);
    kb->utt_sen_eval += mgau_frm_sen_eval(mgau);
    kb->utt_gau_eval += mgau_frm_gau_eval(mgau);
    
    /* Evaluate composite senone scores from senone scores */
    dict2pid_comsenscr (kbcore_dict2pid(kbcore), kb->ascr->sen, kb->ascr->comsen);

    ptmr_stop (&(kb->tm_sen));
    
    /* Search */
    ptmr_start (&(kb->tm_srch));
    
    /* Evaluate active HMMs in each lextree; note best HMM state score */
    besthmmscr = MAX_NEG_INT32;
    bestwordscr = MAX_NEG_INT32;
    frm_nhmm = 0;
    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : kb->fillertree[i - kb->n_lextree];
      
      if (hmmdumpfp != NULL)
	fprintf (hmmdumpfp, "Fr %d Lextree %d #HMM %d\n", f, i, lextree->n_active);
      
      lextree_hmm_eval (lextree, kbcore, kb->ascr, f, hmmdumpfp);
      
      if (besthmmscr < lextree->best)
	besthmmscr = lextree->best;
      if (bestwordscr < lextree->wbest)
	bestwordscr = lextree->wbest;
      
      n_hmm_eval += lextree->n_active;
      frm_nhmm += lextree->n_active;
    }
    if (besthmmscr > 0) {
      E_ERROR("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
	      f, besthmmscr);
    }
    
    kb->hmm_hist[frm_nhmm / kb->hmm_hist_binsize]++;
    
    /* Set pruning threshold depending on whether number of active HMMs within limit */
    if (frm_nhmm > (maxhmmpf + (maxhmmpf >> 1))) {
      int32 *bin, nbin, bw;
      
      /* Use histogram pruning */
      nbin = 1000;
      bw = -(kb->beam->hmm) / nbin;
      bin = (int32 *) ckd_calloc (nbin, sizeof(int32));
      
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ?
	  kb->ugtree[i] : kb->fillertree[i - kb->n_lextree];
	
	lextree_hmm_histbin (lextree, besthmmscr, bin, nbin, bw);
      }
      
      for (i = 0, j = 0; (i < nbin) && (j < maxhmmpf); i++, j += bin[i]);
      ckd_free ((void *) bin);
      
      /* Determine hmm, phone, word beams */
      hb = -(i * bw);
      pb = (hb > kb->beam->ptrans) ? hb : kb->beam->ptrans;
      wb = (hb > kb->beam->word) ? hb : kb->beam->word;

    } else {
      hb = kb->beam->hmm;
      pb = kb->beam->ptrans;
      wb = kb->beam->word;
    }
    
    kb->bestscore = besthmmscr;
    kb->bestwordscore = bestwordscr;
    th = kb->bestscore + hb;		/* HMM survival threshold */
    pth = kb->bestscore + pb;		/* Cross-HMM transition threshold */
    wth = kb->bestwordscore + wb;		/* Word exit threshold */
    
    /*
     * For each lextree, determine if the active HMMs remain active for next
     * frame, propagate scores across HMM boundaries, and note word exits.
     */
    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : kb->fillertree[i - kb->n_lextree];
      
      /* Hack!! Use a narrow phone transition beam (wth) every so many frames */
      if ((ptranskip < 1) || ((f % ptranskip) != 0))
	lextree_hmm_propagate (lextree, kbcore, kb->vithist, f, th, pth, wth);
      else
	lextree_hmm_propagate (lextree, kbcore, kb->vithist, f, th, wth, wth);
    }
    
    /* Limit vithist entries created this frame to specified max */
    vithist_prune (kb->vithist, dict, f, maxwpf, maxhistpf, wb);
    
    /* Cross-word transitions */
    utt_word_trans (kb, f);
    
    /* Wind up this frame */
    vithist_frame_windup (kb->vithist, f, NULL, kbcore);
    
    kb_lextree_active_swap (kb);

    ptmr_stop (&(kb->tm_srch));
    
    if ((f % 100) == 0) {
      fprintf (stderr, ".");
      fflush (stderr);
    }
  }
  
  kb->utt_hmm_eval = n_hmm_eval;
  
  utt_end (kb);
  kb->tot_fr += kb->nfr;
  
  fprintf (stdout, "\n");
}

#ifdef THRD
sen_active_args_t sen_active_args;
scoring_args_t scoring_args;
searching_args_t searching_args;
#endif

/* This function decodes a block of incoming feature vectors.
 * Feature vectors have to be computed by the calling routine.
 * The utterance level index of the last feature vector decoded
 * (before the current block) must be passed. 
 * The current status of the decode is stored in the kb structure that 
 * is passed in.
 */

void utt_decode_block (float **block_feat,   /* Incoming block of featurevecs */
		       int32 block_nfeatvec, /* No. of vecs in cepblock */
		       int32 *curfrm,	     /* Utterance level index of
						frames decoded so far */
		       kb_t *kb,	     /* kb structure with all model
						and decoder info */
		       int32 maxwpf,	     /* Max words per frame */
		       int32 maxhistpf,	     /* Max histories per frame */
		       int32 maxhmmpf,	     /* Max active HMMs per frame */
		       int32 ptranskip,	     /* intervals at which wbeam
						is used for phone transitions */
		       FILE *hmmdumpfp)      /* dump file */
{
  kbcore_t *kbcore;
  mdef_t *mdef;
  dict_t *dict;
  dict2pid_t *d2p;
  mgau_model_t *mgau;
  subvq_t *svq;
  lextree_t *lextree;
  int32 besthmmscr, bestwordscr, th, pth, wth; 
  int32  i, j, t;
  int32  n_hmm_eval;
  int32 frmno; 
  int32 frm_nhmm, hb, pb, wb;
  
  kbcore = kb->kbcore;
  mdef = kbcore_mdef (kbcore);
  dict = kbcore_dict (kbcore);
  d2p = kbcore_dict2pid (kbcore);
  mgau = kbcore_mgau (kbcore);
  svq = kbcore_svq (kbcore);
  
  frmno = *curfrm;

#if 1
  memset(kb->hmm_hist, 0, kb->hmm_hist_bins*sizeof(int32));
#else
  for (i = 0; i < kb->hmm_hist_bins; i++)
    kb->hmm_hist[i] = 0;
#endif
  n_hmm_eval = 0;

  /*  E_INFO("going through %d vectors\n",block_nfeatvec);*/
  for (t = 0; t < block_nfeatvec; t++,frmno++) {
    /* Acoustic (senone scores) evaluation */

    ptmr_start (&(kb->tm_sen));
    
    /* Find active and composite senones from active lextree nodes */
    if (kb->sen_active) {

#if defined(THRD)
      sen_active_args.kb = kb;
      sen_active_args.mdef = mdef;
      sen_active_args.d2p = d2p;
      
      thrd_sen_active_phase(&sen_active_args);
#else
      memset(kb->ssid_active, 0, mdef_n_sseq(mdef) * sizeof(int32));
      memset(kb->comssid_active,0,dict2pid_n_comsseq(d2p)*sizeof(int32));
      /* moved from before mdef_sseq2sen*/
      memset (kb->sen_active, 0, mdef_n_sen(mdef) * sizeof(int32));

      /* Find active senone-sequence IDs (including composite ones) */
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ? kb->ugtree[i] :
	  kb->fillertree[i - kb->n_lextree];
	lextree_ssid_active(lextree,kb->ssid_active,kb->comssid_active);
      }
      
      /* Find active senones from active senone-sequences */
      mdef_sseq2sen_active (mdef, kb->ssid_active, kb->sen_active);
      
      /* Add in senones needed for active composite senone-sequences */
      dict2pid_comsseq2sen_active (d2p, mdef, kb->comssid_active, 
				   kb->sen_active);
#endif
    } else 
      assert(0&&"!sen_active\n");

    /* Evaluate senone acoustic scores for the active senones */
#if defined(THRD) 
  scoring_args.vq = svq;
  scoring_args.g = mgau;
  scoring_args.beam = kb->beam->subvq;
  scoring_args.feat = block_feat[t];
  scoring_args.sen_active = kb->sen_active;
  scoring_args.senscr = kb->ascr->sen;

  scoring_args.d2p = d2p;
  scoring_args.comsenscr = kb->ascr->comsen;

  thrd_scoring_phase(&scoring_args);

  kb->utt_sen_eval += mgau_frm_sen_eval(mgau);
  kb->utt_gau_eval += mgau_frm_gau_eval(mgau);
    
#else
  subvq_frame_eval (svq, mgau, kb->beam->subvq, block_feat[t], 
		    kb->sen_active, kb->ascr->sen);
  
  kb->utt_sen_eval += mgau_frm_sen_eval(mgau);
  kb->utt_gau_eval += mgau_frm_gau_eval(mgau);
  
  /*E_INFO("d2p->n_comstate %d\n",d2p->n_comstate);*/
  /* Evaluate composite senone scores from senone scores */

  dict2pid_comsenscr (d2p, kb->ascr->sen, 	
		      kb->ascr->comsen);

#endif
  if (DEBUG&0x1) {
    fprintf(stderr,"%d comstate\n",d2p->n_comstate);
    for (i=0;i<d2p->n_comstate;i++)
      fprintf(stderr,"%d %d\n",i,kb->ascr->comsen[i]);
  }

    ptmr_stop (&(kb->tm_sen));
    
    /* Search */
    ptmr_start (&(kb->tm_srch));


    /* Evaluate active HMMs in each lextree; note best HMM state score */
    besthmmscr = MAX_NEG_INT32;
    bestwordscr = MAX_NEG_INT32;
    frm_nhmm = 0;

    if (DEBUG&0x1) fprintf(stderr,"gonna search in %d trees\n",kb->n_lextree);

#if defined(THRD) && (PHASES & 0x2)
    searching_args.kbc = kbcore;
    searching_args.ascr = kb->ascr;
    searching_args.frm = frmno;
    searching_args.fp = hmmdumpfp;
    searching_args.kb = kb;

    new_thrd_lextree_hmm_eval(&searching_args, &besthmmscr, &bestwordscr, 
			      &n_hmm_eval, &frm_nhmm);
#else
    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
	kb->fillertree[i - kb->n_lextree];
      
      if (hmmdumpfp != NULL)
	fprintf (hmmdumpfp, "Fr %d Lextree %d #HMM %d\n", frmno, i, 
		 lextree->n_active);

      lextree_hmm_eval (lextree, kbcore, kb->ascr, frmno, hmmdumpfp);

      if (besthmmscr < lextree->best)
	besthmmscr = lextree->best;
      if (bestwordscr < lextree->wbest)
	bestwordscr = lextree->wbest;
      
      n_hmm_eval += lextree->n_active;
      frm_nhmm += lextree->n_active;
    }
#endif
    if (DEBUG&0x1) {
      fprintf(stderr,"n_hmm_eval %d frm_nhmm %d besthmmscr %d bestwordscr %d\n",
	      n_hmm_eval, frm_nhmm, besthmmscr, bestwordscr);
    }

#if defined(THRD) && (!(PHASES & 0x2)) && (PHASES&0x4)
    searching_args.kbc = kbcore;
    searching_args.ascr = kb->ascr;
    searching_args.frm = frmno;
    searching_args.fp = hmmdumpfp;
    searching_args.kb = kb;
#endif
    
    if (besthmmscr > 0) {
      E_ERROR("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
	      frmno, besthmmscr);
    }

    kb->hmm_hist[frm_nhmm / kb->hmm_hist_binsize]++;
    
    /* Set pruning threshold depending on whether number of active HMMs 
     * is within limit 
     */
    if (frm_nhmm > (maxhmmpf + (maxhmmpf >> 1))) {
      int32 *bin, nbin, bw;
      
      /* Use histogram pruning */
      nbin = 1000;
      bw = -(kb->beam->hmm) / nbin;
      bin = (int32 *) ckd_calloc (nbin, sizeof(int32));
      
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ?
	  kb->ugtree[i] : kb->fillertree[i - kb->n_lextree];
	
	lextree_hmm_histbin (lextree, besthmmscr, bin, nbin, bw);
      }
      
      for (i = 0, j = 0; (i < nbin) && (j < maxhmmpf); i++, j += bin[i]);
      ckd_free ((void *) bin);
      
      /* Determine hmm, phone, word beams */
      hb = -(i * bw);
      pb = (hb > kb->beam->ptrans) ? hb : kb->beam->ptrans;
      wb = (hb > kb->beam->word) ? hb : kb->beam->word;
    } else {
      hb = kb->beam->hmm;
      pb = kb->beam->ptrans;
      wb = kb->beam->word;
    }
    
    kb->bestscore = besthmmscr;
    kb->bestwordscore = bestwordscr;
    th = kb->bestscore + hb;	/* HMM survival threshold */
    pth = kb->bestscore + pb;	/* Cross-HMM transition threshold */
    wth = kb->bestwordscore + wb;	/* Word exit threshold */
    
#if defined(THRD ) && (PHASES & 0x4)
    searching_args.ptranskip = ptranskip;
    searching_args.vithist = kb->vithist;
    searching_args.th = th;
#if 0 /* To prevent divide-by-zero exception in intel cc */
    if ((ptranskip < 1) || ((frmno % (ptranskip==0)?1:ptranskip) != 0))
#else
    if ((ptranskip < 1) || ((frmno % ptranskip) != 0))
#endif
      searching_args.pth = pth;
    else
      searching_args.pth = wth;
    searching_args.wth = wth;

    new_thrd_lextree_hmm_propagate(&searching_args);
    
#else
    /*
     * For each lextree, determine if the active HMMs remain active for next
     * frame, propagate scores across HMM boundaries, and note word exits.
     */

    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
	kb->fillertree[i - kb->n_lextree];

      /* Hack! Use narrow phone transition beam (wth) every few frames */

#if 1 /* To prevent divide-by-zero exception in intel cc */
      if ((ptranskip < 1) || ((frmno % (ptranskip==0)?1:ptranskip) != 0))
#else
      if ((ptranskip < 1) || ((frmno % ptranskip) != 0))
#endif
	lextree_hmm_propagate(lextree, kbcore, kb->vithist, frmno,
			      th, pth, wth);
      else
	lextree_hmm_propagate(lextree, kbcore, kb->vithist, frmno,
			      th, wth, wth);
    }
#endif
    /* if threaded with more than 1 thread and last phase is turned
       off, then thread join is needed here. Else, thread join is
       done inside new_thrd_lextree_hmm_propagate */
  
    /* Limit vithist entries created this frame to specified max */
    vithist_prune (kb->vithist, dict, frmno, maxwpf, maxhistpf, wb);

    /* Cross-word transitions */
    utt_word_trans (kb, frmno);

    /* Wind up this frame */
    vithist_frame_windup (kb->vithist, frmno, NULL, kbcore);

    kb_lextree_active_swap (kb);

    ptmr_stop (&(kb->tm_srch));

  }

  kb->utt_hmm_eval += n_hmm_eval;
  kb->nfr += block_nfeatvec;
  
  *curfrm = frmno;
}

void single_utt_decode_block (float **block_feat,   /* Incoming block of featurevecs */
		       int32 block_nfeatvec, /* No. of vecs in cepblock */
		       int32 *curfrm,	     /* Utterance level index of
						frames decoded so far */
		       kb_t *kb,	     /* kb structure with all model
						and decoder info */
		       int32 maxwpf,	     /* Max words per frame */
		       int32 maxhistpf,	     /* Max histories per frame */
		       int32 maxhmmpf,	     /* Max active HMMs per frame */
		       int32 ptranskip,	     /* intervals at which wbeam
						is used for phone transitions */
		       FILE *hmmdumpfp)      /* dump file */
{
  kbcore_t *kbcore;
  mdef_t *mdef;
  dict_t *dict;
  dict2pid_t *d2p;
  mgau_model_t *mgau;
  subvq_t *svq;
  lextree_t *lextree;
  int32 besthmmscr, bestwordscr, th, pth, wth; 
  int32  i, j, t;
  int32  n_hmm_eval;
  int32 frmno; 
  int32 frm_nhmm, hb, pb, wb;
  
  kbcore = kb->kbcore;
  mdef = kbcore_mdef (kbcore);
  dict = kbcore_dict (kbcore);
  d2p = kbcore_dict2pid (kbcore);
  mgau = kbcore_mgau (kbcore);
  svq = kbcore_svq (kbcore);
  
  frmno = *curfrm;
#if 1
  memset(kb->hmm_hist, 0, kb->hmm_hist_bins*sizeof(int32));
#else
  for (i = 0; i < kb->hmm_hist_bins; i++)
    kb->hmm_hist[i] = 0;
#endif
  n_hmm_eval = 0;

  /*  E_INFO("going through %d vectors\n",block_nfeatvec);*/
  for (t = 0; t < block_nfeatvec; t++,frmno++) {
    /* Acoustic (senone scores) evaluation */

    ptmr_start (&(kb->tm_sen));
    
    /* Find active and composite senones from active lextree nodes */
    if (kb->sen_active) {
      memset(kb->ssid_active, 0, mdef_n_sseq(mdef) * sizeof(int32));
      memset(kb->comssid_active,0,dict2pid_n_comsseq(d2p)*sizeof(int32));
      /* moved from before mdef_sseq2sen*/
      memset (kb->sen_active, 0, mdef_n_sen(mdef) * sizeof(int32));

      /* Find active senone-sequence IDs (including composite ones) */
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ? kb->ugtree[i] :
	  kb->fillertree[i - kb->n_lextree];
	lextree_ssid_active(lextree,kb->ssid_active,kb->comssid_active);
      }
      
      /* Find active senones from active senone-sequences */
      mdef_sseq2sen_active (mdef, kb->ssid_active, kb->sen_active);
      
      /* Add in senones needed for active composite senone-sequences */
      dict2pid_comsseq2sen_active (d2p, mdef, kb->comssid_active, 
				   kb->sen_active);
    } else 
      assert(0&&"!sen_active\n");


    /* Evaluate senone acoustic scores for the active senones */
    subvq_frame_eval (svq, mgau, kb->beam->subvq, block_feat[t], 
		    kb->sen_active, kb->ascr->sen);
  
  kb->utt_sen_eval += mgau_frm_sen_eval(mgau);
  kb->utt_gau_eval += mgau_frm_gau_eval(mgau);
  
  /*E_INFO("d2p->n_comstate %d\n",d2p->n_comstate);*/
  /* Evaluate composite senone scores from senone scores */

  dict2pid_comsenscr (d2p, kb->ascr->sen, 	
		      kb->ascr->comsen);

    ptmr_stop (&(kb->tm_sen));
    
    /* Search */
    ptmr_start (&(kb->tm_srch));

    /* Evaluate active HMMs in each lextree; note best HMM state score */
    besthmmscr = MAX_NEG_INT32;
    bestwordscr = MAX_NEG_INT32;
    frm_nhmm = 0;

    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
	kb->fillertree[i - kb->n_lextree];
      
      if (hmmdumpfp != NULL)
	fprintf (hmmdumpfp, "Fr %d Lextree %d #HMM %d\n", frmno, i, 
		 lextree->n_active);

      lextree_hmm_eval (lextree, kbcore, kb->ascr, frmno, hmmdumpfp);

      if (besthmmscr < lextree->best)
	besthmmscr = lextree->best;
      if (bestwordscr < lextree->wbest)
	bestwordscr = lextree->wbest;
      
      n_hmm_eval += lextree->n_active;
      frm_nhmm += lextree->n_active;
    }
    
    if (besthmmscr > 0) {
      E_ERROR("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
	      frmno, besthmmscr);
    }

    kb->hmm_hist[frm_nhmm / kb->hmm_hist_binsize]++;
    
    /* Set pruning threshold depending on whether number of active HMMs 
     * is within limit 
     */
    if (frm_nhmm > (maxhmmpf + (maxhmmpf >> 1))) {
      int32 *bin, nbin, bw;
      
      /* Use histogram pruning */
      nbin = 1000;
      bw = -(kb->beam->hmm) / nbin;
      bin = (int32 *) ckd_calloc (nbin, sizeof(int32));
      
      for (i = 0; i < (kb->n_lextree <<1); i++) {
	lextree = (i < kb->n_lextree) ?
	  kb->ugtree[i] : kb->fillertree[i - kb->n_lextree];
	
	lextree_hmm_histbin (lextree, besthmmscr, bin, nbin, bw);
      }
      
      for (i = 0, j = 0; (i < nbin) && (j < maxhmmpf); i++, j += bin[i]);
      ckd_free ((void *) bin);
      
      /* Determine hmm, phone, word beams */
      hb = -(i * bw);
      pb = (hb > kb->beam->ptrans) ? hb : kb->beam->ptrans;
      wb = (hb > kb->beam->word) ? hb : kb->beam->word;
    } else {
      hb = kb->beam->hmm;
      pb = kb->beam->ptrans;
      wb = kb->beam->word;
    }
    
    kb->bestscore = besthmmscr;
    kb->bestwordscore = bestwordscr;
    th = kb->bestscore + hb;	/* HMM survival threshold */
    pth = kb->bestscore + pb;	/* Cross-HMM transition threshold */
    wth = kb->bestwordscore + wb;	/* Word exit threshold */
    
    /*
     * For each lextree, determine if the active HMMs remain active for next
     * frame, propagate scores across HMM boundaries, and note word exits.
     */

    for (i = 0; i < (kb->n_lextree <<1); i++) {
      lextree = (i < kb->n_lextree) ? kb->ugtree[i] : 
	kb->fillertree[i - kb->n_lextree];

      /* Hack! Use narrow phone transition beam (wth) every few frames */
      if ((ptranskip < 1) || ((frmno % ptranskip) != 0))
	lextree_hmm_propagate(lextree, kbcore, kb->vithist, frmno,
			      th, pth, wth);
      else
	lextree_hmm_propagate(lextree, kbcore, kb->vithist, frmno,
			      th, wth, wth);
    }

    /* Limit vithist entries created this frame to specified max */
    vithist_prune (kb->vithist, dict, frmno, maxwpf, maxhistpf, wb);
    
    /* Cross-word transitions */
    utt_word_trans (kb, frmno);
    
    /* Wind up this frame */
    vithist_frame_windup (kb->vithist, frmno, NULL, kbcore);
    
    kb_lextree_active_swap (kb);

    ptmr_stop (&(kb->tm_srch));
  }

  
  kb->utt_hmm_eval += n_hmm_eval;
  kb->nfr += block_nfeatvec;
  
  *curfrm = frmno;
}

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
#ifndef _UTT_H_
#define _UTT_H_

#include "libutil.h"
#include "kb.h"

#define MAXHYPLEN       1000

void utt_begin (kb_t *kb);

void utt_end (kb_t *kb);

void utt_word_trans (kb_t *kb, int32 cf);

void utt_decode (void *data, char *uttfile, int32 sf, 
			     int32 ef, char *uttid);

/* This function decodes a block of incoming feature vectors.
 * Feature vectors have to be computed by the calling routine.
 * The utterance level index of the last feature vector decoded
 * (before the current block) must be passed.
 * The current status of the decode is stored in the kb structure that
 * is passed in.
 */

void utt_decode_block (float **block_feat,   /* Incoming block of featurevecs */
                       int32 block_nfeatvec, /* No. of vecs in cepblock */
                       int32 *curfrm,        /* Utterance level index of
                                                frames decoded so far */
                       kb_t *kb,             /* kb structure with all model
                                                and decoder info */
                       int32 maxwpf,         /* Max words per frame */
                       int32 maxhistpf,      /* Max histories per frame */
                       int32 maxhmmpf,       /* Max active HMMs per frame */
                       int32 ptranskip,      /* intervals at which wbeam
                                                is used for phone transitions */
                       FILE *hmmdumpfp);     /* dump file */

void single_utt_decode_block (float **block_feat,   /* Incoming block of featurevecs */
                       int32 block_nfeatvec, /* No. of vecs in cepblock */
                       int32 *curfrm,        /* Utterance level index of
                                                frames decoded so far */
                       kb_t *kb,             /* kb structure with all model
                                                and decoder info */
                       int32 maxwpf,         /* Max words per frame */
                       int32 maxhistpf,      /* Max histories per frame */
                       int32 maxhmmpf,       /* Max active HMMs per frame */
                       int32 ptranskip,      /* intervals at which wbeam
                                                is used for phone transitions */
                       FILE *hmmdumpfp);     /* dump file */

#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * vector.c
 *
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 10-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added vector_accum(), vector_vqlabel(), and vector_vqgen().
 * 
 * 09-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added vector_is_zero(), vector_cmp(), and vector_dist_eucl().
 * 		Changed the name vector_dist_eval to vector_dist_maha.
 * 
 * 07-Oct-98	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added distance computation related functions.
 * 
 * 12-Nov-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Copied from Eric Thayer.
 */

#include "vector.h"
#include "logs3.h"
#include "s3types.h"

#if (WIN32) 
/* RAH #include <random.h> */
#include <time.h>		/* RAH */
#endif

float64 vector_sum_norm (float32 *vec, int32 len)
{
    float64 sum, f;
    int32 i;
    
    sum = 0.0;
    for (i = 0; i < len; i++)
	sum += vec[i];

    if (sum != 0.0) {
	f = 1.0 / sum;
	for (i = 0; i < len; i++)
	  /*	  vec[i] *=  f;		*/  /*  */
	  /* The compiler was complaining about the above line, to make sure we don't lose accuracy, use this  */
	  vec[i] = (float32) ((float64) vec[i] * (float64)  f);		
    }
    
    return sum;
}


void vector_floor (float32 *vec, int32 len, float64 flr)
{
    int32 i;

    for (i = 0; i < len; i++)
	if (vec[i] < flr)
	    vec[i] = (float32)flr;
}


void vector_nz_floor (float32 *vec, int32 len, float64 flr)
{
    int32 i;

    for (i = 0; i < len; i++)
	if ((vec[i] != 0.0) && (vec[i] < flr))
	    vec[i] = (float32)flr;
}


void vector_print(FILE *fp, vector_t v, int32 dim)
{
    int32 i;
    
    for (i = 0; i < dim; i++)
	fprintf (fp, " %11.4e", v[i]);
    fprintf (fp, "\n");
    fflush (fp);
}


int32 vector_is_zero (float32 *vec, int32 len)
{
    int32 i;
    
    for (i = 0; (i < len) && (vec[i] == 0.0); i++);
    return (i == len);	/* TRUE iff all mean values are 0.0 */
}


int32 vector_maxcomp_int32 (int32 *val, int32 len)
{
    int32 i, bi;
    
    bi = 0;
    for (i = 1; i < len; i++) {
	if (val[i] > val[bi])
	    bi = i;
    }
    return bi;
}


int32 vector_mincomp_int32 (int32 *val, int32 len)
{
    int32 i, bi;
    
    bi = 0;
    for (i = 1; i < len; i++) {
	if (val[i] < val[bi])
	    bi = i;
    }
    return bi;
}


int32 vector_maxcomp_float32 (float32 *val, int32 len)
{
    int32 i, bi;
    
    bi = 0;
    for (i = 1; i < len; i++) {
	if (val[i] > val[bi])
	    bi = i;
    }
    return bi;
}


int32 vector_mincomp_float32 (float32 *val, int32 len)
{
    int32 i, bi;
    
    bi = 0;
    for (i = 1; i < len; i++) {
	if (val[i] < val[bi])
	    bi = i;
    }
    return bi;
}


void vector_accum (float32 *dst, float32 *src, int32 len)
{
    int32 i;
    
    for (i = 0; i < len; i++)
	dst[i] += src[i];
}


int32 vector_cmp (float32 *v1, float32 *v2, int32 len)
{
    int32 i;
    
    for (i = 0; i < len; i++) {
	if (v1[i] < v2[i])
	    return -1;
	if (v1[i] > v2[i])
	    return 1;
    }
    
    return 0;
}


int32 vector_mean (float32 *mean, float32 **data, int32 n_vec, int32 n_dim)
{
    int32 i, j;
    float64 f;
    
    assert ((n_vec > 0) && (n_dim > 0));
    
    for (i = 0; i < n_dim; i++)
	mean[i] = 0.0;
    
    for (i = 0; i < n_vec; i++) {
	for (j = 0; j < n_dim; j++)
	    mean[j] += data[i][j];
    }
    
    f = 1.0/(float64)n_vec;
    for (i = 0; i < n_dim; i++)
	mean[i] *= (float32)f;
    
    return 0;
}


float64 vector_dist_eucl (float32 *v1, float32 *v2, int32 len)
{
    float64 d;
    int32 i;
    
    d = 0.0;
    for (i = 0; i < len; i++)
	d += (v1[i] - v2[i]) * (v1[i] - v2[i]);
    
    return d;
}


float64 vector_maha_precomp (float32 *var, int32 len)
{
    float64 det;
    int32 i;
    
    for (det = (float64)0.0, i = 0; i < len; i++) {	/* log(1.0/prod(var[i])) */
	det -= (float64) (log(var[i]));
	var[i] = (float32)(1.0 / (var[i] * 2.0));
    }
    det -= log(2.0 * PI) * len;
    
    return (det * 0.5);	/* sqrt */
}


float64 vector_dist_maha (float32 *vec, float32 *mean, float32 *varinv, float64 loginvdet,
			  int32 len)
{
    float64 dist, diff;
    int32 i;
    
    dist = loginvdet;
    for (i = 0; i < len; i++) {
	diff = (vec[i] - mean[i]);
	dist -= diff * diff * varinv[i];
    }
    
    return dist;
}


int32 vector_vqlabel (float32 *vec, float32 **mean, int32 rows, int32 cols, float64 *sqerr)
{
    int32 i, besti;
    float64 d, bestd;
    
    assert ((rows > 0) && (cols > 0));
    
    bestd = vector_dist_eucl (mean[0], vec, cols);
    besti = 0;
    
    for (i = 1; i < rows; i++) {
	d = vector_dist_eucl (mean[i], vec, cols);
	if (bestd > d) {
	    bestd = d;
	    besti = i;
	}
    }
    
    if (sqerr)
	*sqerr = bestd;
    
    return besti;
}


float64 vector_vqgen (float32 **data, int32 rows, int32 cols, int32 vqrows,
		      float64 epsilon, int32 maxiter,
		      float32 **mean, int32 *map)
{
    int32 i, j, r, it;
    static uint32 seed = 1;
    float64 sqerr, prev_sqerr=0, t;
    bitvec_t sel;
    int32 *count;
    float32 *gmean;
    ptmr_t tm;
    
    assert ((rows >= vqrows) && (maxiter >= 0) && (epsilon > 0.0));
    
    sel = bitvec_alloc (rows);
    
    ptmr_init (&tm);
    ptmr_start (&tm);
    
    /* Pick a random initial set of centroids */
#ifndef WIN32			/* RAH */
    srandom (seed);
    seed ^= random();
#else  /* RAH */
      srand ((unsigned) time(NULL)); /* RAH */
#endif
    for (i = 0; i < vqrows; i++) {
	/* Find r = a random, previously unselected row from the input */

#ifndef WIN32			/* RAH */
	r = (random() & (int32)0x7fffffff) % rows;
#else  /* RAH */
	r = (rand() & (int32)0x7fffffff) % rows; /* RAH */
#endif /* RAH */
	while (bitvec_is_set (sel, r)) {	/* BUG: possible infinite loop!! */
	    if (++r >= rows)
		r = 0;
	}
	bitvec_set (sel, r);
	
	memcpy ((void *)(mean[i]), (void *)(data[r]), cols * sizeof(float32));
	/* BUG: What if two randomly selected rows are identical in content?? */
    }
    bitvec_free (sel);
    
    count = (int32 *) ckd_calloc (vqrows, sizeof(int32));
    
    /* In k-means, unmapped means in any iteration are a problem.  Replace them with gmean */
    gmean = (float32 *) ckd_calloc (cols, sizeof(float32));
    vector_mean (gmean, mean, vqrows, cols);

    for (it = 0;; it++) {		/* Iterations of k-means algorithm */
	/* Find the current data->mean mappings (labels) */
	sqerr = 0.0;
	for (i = 0; i < rows; i++) {
	    map[i] = vector_vqlabel (data[i], mean, vqrows, cols, &t);
	    sqerr += t;
	}
	ptmr_stop(&tm);
	
	if (it == 0)
	    E_INFO("Iter %4d: %.1fs CPU; sqerr= %e\n", it, tm.t_cpu, sqerr);
	else
	    E_INFO("Iter %4d: %.1fs CPU; sqerr= %e; delta= %e\n",
		   it, tm.t_cpu, sqerr, (prev_sqerr-sqerr)/prev_sqerr);
	
	/* Check if exit condition satisfied */
	if ((sqerr == 0.0) || (it >= maxiter-1) ||
	    ((it > 0) && ( ((prev_sqerr - sqerr) / prev_sqerr) < epsilon )) )
	    break;
	prev_sqerr = sqerr;
	
	ptmr_start(&tm);
	
	/* Update (reestimate) means */
	for (i = 0; i < vqrows; i++) {
	    for (j = 0; j < cols; j++)
		mean[i][j] = 0.0;
	    count[i] = 0;
	}
	for (i = 0; i < rows; i++) {
	    vector_accum (mean[map[i]], data[i], cols);
	    count[map[i]]++;
	}
	for (i = 0; i < vqrows; i++) {
	    if (count[i] > 1) {
		t = 1.0 / (float64)(count[i]);
		for (j = 0; j < cols; j++)
		  /*		  mean[i][j] *= t; */ /* RAH, compiler was complaining about this,  */
		  mean[i][j] = (float32) ((float64) mean[i][j] * (float64) t); /*  */
	    } else if (count[i] == 0) {
		E_ERROR("Iter %d: mean[%d] unmapped\n", it, i);
		memcpy (mean[i], gmean, cols * sizeof(float32));
	    }
	}
    }
    
    ckd_free (count);
    ckd_free (gmean);
    
    return sqerr;
}


float64 vector_pdf_entropy (float32 *p, int32 len)
{
    float64 sum;
    int32 i;
    
    sum = 0.0;
#pragma novector
    for (i = 0; i < len; i++) {
	if (p[i] > 0.0)
	    sum -= p[i] * log(p[i]);
    }
    sum /= log(2.0);
    
    return sum;
}


float64 vector_pdf_cross_entropy (float32 *p1, float32 *p2, int32 len)
{
    float64 sum;
    int32 i;
    
    sum = 0.0;
    for (i = 0; i < len; i++) {
	if (p2[i] > 0.0)
	    sum -= p1[i] * log(p2[i]);
    }
    sum /= log(2.0);
    
    return sum;
}

void vector_gautbl_alloc (vector_gautbl_t *gautbl, int32 n_gau, int32 veclen)
{
  int32 tmp;
    gautbl->n_gau = n_gau;
    gautbl->veclen = veclen;
#if 1
    tmp =(veclen%4)? (veclen+4-(veclen%4)):veclen;
    gautbl->mean = (float32 **) ckd_calloc_2da (n_gau, tmp, sizeof(float32));
    gautbl->var = (float32 **) ckd_calloc_2da (n_gau, tmp, sizeof(float32));
    /*printf("n_gau %d tmp %d %p %p\n",n_gau,tmp, gautbl->mean, gautbl->var);*/
#else
    gautbl->mean = (float32 **) ckd_calloc_2d (n_gau, veclen, sizeof(float32));
    gautbl->var = (float32 **) ckd_calloc_2d (n_gau, veclen, sizeof(float32));
#endif
    gautbl->lrd = (float32 *) ckd_calloc (n_gau, sizeof(float32));
    gautbl->distfloor = logs3_to_log (S3_LOGPROB_ZERO);
}


void vector_gautbl_free (vector_gautbl_t *gautbl)
{
    ckd_free_2da ((void **) gautbl->mean);
    ckd_free_2da ((void **) gautbl->var);
    ckd_free ((void *) gautbl->lrd);
}


void vector_gautbl_var_floor (vector_gautbl_t *gautbl, float64 floor)
{
    int32 g;
    
    for (g = 0; g < gautbl->n_gau; g++)
	vector_floor (gautbl->var[g], gautbl->veclen, floor);
}


void vector_gautbl_maha_precomp (vector_gautbl_t *gautbl)
{
    int32 g;
    
    for (g = 0; g < gautbl->n_gau; g++)
	gautbl->lrd[g] = (float32) vector_maha_precomp (gautbl->var[g], gautbl->veclen);
}





#if 0 /* original code */

void vector_gautbl_eval_logs3 (vector_gautbl_t *gautbl,
			       int32 offset,
			       int32 count,
			       float32 *x,
			       int32 *score)
{
    int32 i, r;
    float64 f;
    int32 end, veclen;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, dval2, diff1, diff2;
    
    f = log_to_logs3_factor();
    
    /* Interleave evaluation of two vectors at a time for speed on pipelined machines */
    end = offset + count;
    veclen = gautbl->veclen;
    
    for (r = offset; r < end-1; r += 2) {
	m1 = gautbl->mean[r];
	m2 = gautbl->mean[r+1];
	v1 = gautbl->var[r];
	v2 = gautbl->var[r+1];
	dval1 = gautbl->lrd[r];
	dval2 = gautbl->lrd[r+1];

	for (i = 0; i < veclen; i++) {
	    diff1 = x[i] - m1[i];
	    dval1 -= diff1 * diff1 * v1[i];
	    diff2 = x[i] - m2[i];
	    dval2 -= diff2 * diff2 * v2[i];
	}
	
	if (dval1 < gautbl->distfloor)
	    dval1 = gautbl->distfloor;
	if (dval2 < gautbl->distfloor)
	    dval2 = gautbl->distfloor;

	score[r] = (int32)(f * dval1);
	score[r+1] = (int32)(f * dval2);
    }
    
    if (r < end) {
	m1 = gautbl->mean[r];
	v1 = gautbl->var[r];
	dval1 = gautbl->lrd[r];
	
	for (i = 0; i < veclen; i++) {
	    diff1 = x[i] - m1[i];
	    dval1 -= diff1 * diff1 * v1[i];
	}
	
	if (dval1 < gautbl->distfloor)
	    dval1 = gautbl->distfloor;

	score[r] = (int32)(f * dval1);
    }
}


#else /* new unrolled / SIMD code */

#ifdef SSE2 /*SIMD code */


float64 vector_gautbl_eval_logs3_inner(vector_gautbl_t *gautbl,
				       const int32 r, const float32 *x) { 

  __declspec(align(16)) static const float32 zero[4] = {0.0, 0.0, 0.0, 0.0};

  float32 *m1, *v1, *xp=x, *m1p, *v1p, tmp=0.0, *tp, vdiff;
  float64 dval1,diff;
  int32 veclen, i;

  m1p = m1 = gautbl->mean[r];
  v1p = v1 = gautbl->var[r];
  dval1 = gautbl->lrd[r];
  veclen = gautbl->veclen;
   
  i = veclen>>2;
   
   __asm
    {
      mov    ecx, [i]       ;
      movups xmm2, [zero]        ;
      mov    eax, [x]          ;
      mov    edx, [m1]         ;
      mov    ebx, [v1]         ;

    vecg_eloop:
      movups xmm0, [eax]        ; /*load 4 floats from x */
      movups xmm1, [edx]        ; /*load 4 floats from m1*/
      subps  xmm0, xmm1        ; /*xmm0 has x-m  */
      movups xmm1, [ebx]        ; /*load 4 floats from v1 */
      mulps  xmm0, xmm0        ; /*xmm0 has (x-m)^2  */
      mulps  xmm0, xmm1        ; /*xmm0 has (x-m)^2*v1 */
      addps  xmm2, xmm0        ; /*partial sum at xmm2*/
      add    eax, 16       ;
      add    ebx, 16       ;
      add    edx, 16       ;
      sub     ecx, 1        ;
      cmp     ecx, 0        ;
      jnz     vecg_eloop    ;

      pshufd xmm1, xmm2, 14    ; /* reduction */
      addps  xmm2, xmm1        ;
      pshufd xmm1, xmm2, 1     ;
      addss  xmm2, xmm1        ;
      movss  [tmp], xmm2        ;
    } 
  i<<=2;
  
  dval1 -= tmp;
  
#ifdef LOGS3_NO_LOOP   /*13 elements assumed, undef to unassume */
  diff = x[i] - m1[i];
  dval1 -= diff * diff * v1[i];
#else
  for (;i<veclen; i++) {
    diff = x[i] - m1[i];
    dval1 -= diff * diff * v1[i];
  };
#endif

  return dval1;
}

#else /*non-SIMD code */


float64 vector_gautbl_eval_logs3_inner(vector_gautbl_t *gautbl,
				       const int32 r, const float32 *x) { 

  float32 *m1, *v1;
  float64 dval1, vdiff[4], vdval[4]; 
  int32 veclen, i;

  m1 = gautbl->mean[r];
  v1 = gautbl->var[r];
  dval1 = gautbl->lrd[r];
  veclen = gautbl->veclen;
  
  /* clears vdval, reset v0 and start from the next record of m1 and v1 */
  vdval[0] = vdval[1] = vdval[2] = vdval[3] = 0.0;

#if 1
  veclen = (veclen%4)?veclen+4-(veclen%4):veclen;
  for (i = 0; i < veclen; i+=4) {
    /*_mm_prefetch(&m1[i]+16,_MM_HINT_NTA);
      _mm_prefetch(&v1[i]+16,_MM_HINT_NTA);*/

    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
    
    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];
    
    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
    
    vdiff[3] = x[i+3] - m1[i+3];
    vdval[3] += vdiff[3] * vdiff[3] * v1[i+3];
    
  }
#else
#pragma novector
  for (i = 0; i < veclen-3; i+=4) {

    vdiff[0] = x[i] - m1[i];
    vdval[0] += vdiff[0] * vdiff[0] * v1[i];
    
    vdiff[1] = x[i+1] - m1[i+1];
    vdval[1] += vdiff[1] * vdiff[1] * v1[i+1];
    
    vdiff[2] = x[i+2] - m1[i+2];
    vdval[2] += vdiff[2] * vdiff[2] * v1[i+2];
    
    vdiff[3] = x[i+3] - m1[i+3];
    vdval[3] += vdiff[3] * vdiff[3] * v1[i+3];
    
  }

  
#ifdef LOGS3_NO_LOOP

  vdiff[0] = x[i] - m1[i];
  vdval[0] += vdiff[0] * vdiff[0] * v1[i];

#else /* compiler automatically unroll the following, hence the above */

  for (;i<veclen; i++) {
   vdiff[0] = x[i] - m1[i];
   vdval[0] += vdiff[0] * vdiff[0] * v1[i];
  };

#endif
#endif /*#if 1*/  
  /* do the reduction */

  dval1 -= (vdval[0] + vdval[1] + vdval[2] +vdval[3] );

   /* Original loop
 	for (i = 0; i < veclen; i++) {
	    diff1 = x[i] - m1[i];
	    dval1 -= diff1 * diff1 * v1[i];
	}
  */

  return dval1;
}

#endif /*end unrolled code */


void vector_gautbl_eval_logs3 (vector_gautbl_t *gautbl,
			       int32 offset,
			       int32 count,
			       float32 *x,
			       int32 *score)
{
    int32 i, r;
    float64 f;
    int32 end, veclen;
    float32 *m1, *m2, *v1, *v2;
    float64 dval1, dval2, diff1, diff2;
    
    f = log_to_logs3_factor();
    
    /* Interleave evaluation of two vectors at a time for speed on pipelined machines */
    end = offset + count;
    for (r = offset; r < end; r ++) {

      dval1 =  vector_gautbl_eval_logs3_inner(gautbl, r, x);

      if (dval1 < gautbl->distfloor)
	dval1 = gautbl->distfloor;

      score[r] = (int32)(f * dval1);
    }

}




#endif /* end new unrolled code */

/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * vector.h -- vector routines.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1997 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 10-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added vector_accum(), vector_vqlabel(), and vector_vqgen().
 * 
 * 09-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Added vector_is_zero(), vector_cmp(), and vector_dist_eucl().
 * 		Changed the name vector_dist_eval to vector_dist_maha.
 * 
 * 30-Dec-95	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.
 * 		Created from Eric Thayer's version.
 */


#ifndef _S3_VECTOR_H_
#define _S3_VECTOR_H_

#include "libutil.h"


typedef float32 *vector_t;


/* Why do these belong here?? */
typedef struct {
    int32 r;		/* #rows, */
    int32 c;		/* #cols in an array */
} arraysize_t;

typedef struct {
    int32 x;		/* x-coordinate, */
    int32 y;		/* y-coordinate of a point */
} point_t;

typedef struct {
    float32 x;		/* x-coordinate, */
    float32 y;		/* y-coordinate of a point */
} fpoint_t;		/* Like point_t, but with float32 values */


/*
 * The reason for some of the "trivial" routines below is that they could be OPTIMIZED for SPEED
 * at some point.
 */


/* Floor all elements of v[0..dim-1] to min value of f */
void vector_floor(vector_t v, int32 dim, float64 f);


/* Floor all non-0 elements of v[0..dim-1] to min value of f */
void vector_nz_floor(vector_t v, int32 dim, float64 f);


/*
 * Normalize the elements of the given vector so that they sum to 1.0.  If the sum is 0.0
 * to begin with, the vector is left untouched.  Return value: The normalization factor.
 */
float64 vector_sum_norm(vector_t v, int32 dim);


/* Print vector in one line, in %11.4e format, terminated by newline */
void vector_print(FILE *fp, vector_t v, int32 dim);


/* Return TRUE iff given vector is all 0.0 */
int32 vector_is_zero (float32 *vec,	/* In: Vector to be checked */
		      int32 len);	/* In: Length of above vector */

/*
 * Search for the max or min valued component in the given vector.  The vector length must be
 * strictly > 0 (val[] must have at least one valid value).  If more than one component
 * qualifies, the first one is chosen.
 * Return value: the INDEX of the selected val[] component (not the value itself).
 */
int32 vector_maxcomp_int32 (int32 *val, int32 len);
int32 vector_mincomp_int32 (int32 *val, int32 len);
int32 vector_maxcomp_float32 (float32 *val, int32 len);
int32 vector_mincomp_float32 (float32 *val, int32 len);


/* Accumulate src into dst */
void vector_accum (float32 *dst,	/* In/Out: dst[i] += src[i] */
		   float32 *src,	/* In: See above */
		   int32 len);		/* In: Length of above vectors */

/*
 * Compare the two given vectors.  Return -1, 0, or +1 depending on v1 <, =, or > v2 (as
 * determined by the earliest unequal component).
 */
int32 vector_cmp (float32 *v1, float32 *v2,	/* In: Vectors to be compared */
		  int32 len);		/* In: Length of each vector */

/*
 * Compute the mean vector from the given set of vector data.
 * Return value: 0 if successful, -1 if any error (there shouldn't be any error).
 */
int32 vector_mean (float32 *mean,	/* Out: Computed mean; caller should allocate
					   this memory */
		   float32 **data,	/* In: Set of data over which mean is computed */
		   int32 n_vec,		/* In: #Vectors in data */
		   int32 n_dim);	/* In: Dimensionality of each vector (and mean) */

/*
 * Return the Euclidean distance (actually, distance^2) between the two given vectors.
 */
float64 vector_dist_eucl (float32 *v1, float32 *v2,	/* In: The two input vectors */
			  int32 len);	/* In: Length of each vector */

/*
 * Given a Gaussian density with mean vector m and diagonal variance vector v, and some
 * input vector x, all of length n, the Mahalanobis distance of x from the Gaussian mean m
 * is given by:
 *     {1/sqrt((2pi)^n * det(v))} * exp{-Sum((x[i] - m[i])^2 / (2v[i]))}
 * To speed up this evaluation, the first sub-expression ({1/sqrt...}) can be precomputed at
 * initialization, and so can 1/2v[i] in the second sub-expression.  Secondly, recognition
 * systems work with log-likelihood values, so these distances or likelihood values are
 * computed in log-domain.
 * 
 * Carry out the above precomputations on the given variance vector; update var with 1/2var IN
 * PLACE, and return the value of the first sub-expression as a log value.  (The variance values
 * are assumed to be strictly > 0.0.
 */
float64
vector_maha_precomp (float32 *var,	/* In/Out: Variance vector, modified to 1/2var */
		     int32 len);	/* In: Length of the above vector */

/*
 * Mahalanobis distance, using some precomputed portions of variance and determinant.
 * (Actually not "distance" at all, but Gaussian density value.)
 * Computed in log domain.
 * Return value: logbase-e(likelihood value).
 */
float64
vector_dist_maha (float32 *vec,		/* In: Vector for which distance from mean
					   being computed */
		  float32 *mean,	/* In: Mean vector */
		  float32 *varinv,	/* In: Variance vector, modified according to
					   vector_maha_precomp() */
		  float64 norm,		/* In: Normalization factor computed by
					   vector_maha_precomp() */
		  int32 len);		/* In: Length of each vector involved */

/*
 * Generate a vector quantized table for the input data, using the K-means algorithm, and the
 * Euclidean distance measure.
 * Return value: The squared quantization error of the final result.
 */
float64 vector_vqgen (float32 **data,	/* In: Input Data to be quantized */
		      int32 rows,	/* In: #Rows in input data */
		      int32 cols,	/* In: #Cols in input data (and output VQ table) */
		      int32 vqrows,	/* In: #Rows in vector quantized result */
		      float64 epsilon,	/* In: Convergence limit; stop k-means iterations when
					   the relative reduction in total squared error in
					   successive iterations ((sqerr[t]-sqerr[t+1])/sqerr[t])
					   is below this value. */
		      int32 maxiter,	/* In: Max #iterations, regardless of convlimit */
		      float32 **mean,	/* Out: Vector quantized array of centroids.  Caller
					   must allocate this array */
		      int32 *map);	/* Out: data->mean mapping; mean[map[i]] is the closest
					   quantized vector corresponding to the input vector
					   data[i].  Caller must allocate this array */

/*
 * Find the entry (row) of mean that is closest (according to Euclidean distance) to vec.
 * Return value: index of the selected row.
 */
int32 vector_vqlabel (float32 *vec,	/* In: Vector to be compared against VQ table */
		      float32 **mean,	/* In: Table of centroids */
		      int32 rows,	/* In: #Rows in mean */
		      int32 cols,	/* In: #Cols in mean (and vec) */
		      float64 *sqerr);	/* Out: Squared error (distance) between vec and the
					   selected codeword.  May be NULL if not needed. */

/*
 * Treat the given vector as a PDF and compute its entropy (-sum(p * log2(p))).  (The PDF values
 * must be >= 0.0, of course.)  The zero elements of the PDF are skipped.
 */
float64 vector_pdf_entropy (float32 *p,	/* In: Vector (PDF) whose entropy is to be computed */
			    int32 len);	/* In: Length of p[] */

/*
 * Return cross-entropy of two PDFs; like vector_entropy, but (-sum(p1 * log2(p2))).  (The PDF
 * values must be >= 0.0, of course.)  The zero elements of p2 are skipped.
 */
float64 vector_pdf_cross_entropy (float32 *p1,
				  float32 *p2,	/* In: Zero elements of p2 are skipped */
				  int32 len);

/*
 * Generic table of individual Gaussian vectors, with diagonal co-variance matrices (i.e.,
 * only the diagonal is maintained, as a vector).
 */
typedef struct {
    int32 n_gau;	/* #Gaussians in table */
    int32 veclen;	/* Vector length */
    float32 **mean;	/* n_cw x veclen mean values */
    float32 **var;	/* n_cw x veclen corresponding (diagonal) variance values */
    float32 *lrd;	/* Log(Reciprocal(Determinant(Co-var. matrix))) */
    float64 distfloor;	/* When Mahalanobis distance values are converted to logs3 domain, the
			   int32 result can underflow.  To avoid this, floor before conversion */
} vector_gautbl_t;


/*
 * The obvious allocation and free routines for vector_gautbl_t.{mean,var,lrd}.  Also sets
 * gautbl->{n_mgau, veclen, distfloor}; the last to the equivalent of S3_LOGPROB_ZERO.
 */
void vector_gautbl_alloc (vector_gautbl_t *gautbl,
			  int32 n_gau, int32 veclen);
void vector_gautbl_free (vector_gautbl_t *gautbl);


/*
 * Floor all the variance values in the given Gaussians table.
 */
void vector_gautbl_var_floor (vector_gautbl_t *gautbl,	/* In/Out: Table to be updated */
			      float64 floor);		/* In: Floor value */

/*
 * Carry out the vector_maha_precomp, above, over all the Gaussians in the given table, updating
 * gau->lrd[] as a result.  The needed memory must have been already allocated by the caller.
 */
void vector_gautbl_maha_precomp (vector_gautbl_t *gau);


/*
 * Compare the input vector to the given range of subvector codewords in the given codebook,
 * Enter the computed Mahalanobis distances, converted into logs3 values, into the given score
 * array.  (Why bother with the {offset,count} range??  For "blocking" such computation so that
 * cache behaviour is improved.)
 */
void
vector_gautbl_eval_logs3 (vector_gautbl_t *gau,	/* In: Table of Gaussians */
			  int32 offset,	/* In: First VQ codeword in the range to be evaluated */
			  int32 count,	/* In: #Codewords to be evaluated (range size) */
			  float32 *x,	/* In: Input vector being compared to codewords */
			  int32 *scr);	/* Out: Mahalanobis distance scores (logs3 values).
					   Caller must allocate this array.  Note that only
					   score[offset..offset+count-1] are updated. */

#endif /* VECTOR_H */ 


/*
 * Log record.  Maintained by RCS.
 *
 * $Log: vector.h,v $
 * Revision 1.3  2001/12/11 04:40:56  lenzo
 * License cleanup.
 *
 * Revision 1.2  2001/12/04 02:57:47  egouvea
 * Merged memory leak fixes from RAH  (egouvea@cs.cmu.edu)
 *
 * Revision 1.1.1.1  2001/01/17 05:17:15  ricky
 * Initial Import of the s3.3 decoder, has working decodeaudiofile, s3.3_live
 *
 * Revision 1.1.1.1  2000/02/28 18:05:54  rkm
 * Imported Sources
 *
 * Revision 1.1.1.1  1999/11/23 20:24:18  rkm
 * imported sources
 *
 * Revision 1.2  1995/10/09  20:55:35  eht
 * Changes for prim_type.h
 *
 * Revision 1.1  1995/08/15  13:44:14  eht
 * Initial revision
 *
 *
 */
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * vithist.c -- Viterbi history
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added vithist_free() to free allocated memory
 * 
 * 30-Dec-2000  Rita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University
 *		Added vithist_partialutt_end() to allow backtracking in
 *		the middle of an utterance
 * 
 * 13-Aug-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added maxwpf handling.
 * 
 * 24-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "vithist.h"


vithist_t *vithist_init (kbcore_t *kbc, int32 wbeam, int32 bghist)
{
    vithist_t *vh;
    lm_t *lm;
    
    E_INFO("Initializing Viterbi-history module\n");
    
    vh = (vithist_t *) ckd_calloc (1, sizeof(vithist_t));
    
    vh->entry = (vithist_entry_t **) ckd_calloc (VITHIST_MAXBLKS, sizeof(vithist_entry_t *));
    vh->n_entry = 0;
    
    vh->frame_start = (int32 *) ckd_calloc (S3_MAX_FRAMES+1, sizeof(int32));
    
    vh->bestscore = (int32 *) ckd_calloc (S3_MAX_FRAMES+1, sizeof(int32));
    vh->bestvh = (int32 *) ckd_calloc (S3_MAX_FRAMES+1, sizeof(int32));
    
    vh->wbeam = wbeam;
    vh->bghist = bghist;
    
    lm = kbcore_lm (kbc);
    vh->lms2vh_root = (vh_lms2vh_t **) ckd_calloc (lm_n_ug(lm), sizeof(vh_lms2vh_t *));
    vh->lwidlist = NULL;
    
    return vh;
}


/*
 * Allocate a new entry at vh->n_entry if one doesn't exist and return ptr to it.
 */
static vithist_entry_t *vithist_entry_alloc (vithist_t *vh)
{
    int32 b, l;
    vithist_entry_t *ve;
    
    b = VITHIST_ID2BLK(vh->n_entry);
    l = VITHIST_ID2BLKOFFSET (vh->n_entry);
    
    if (l == 0) {	/* Crossed block boundary; allocate a new block of vithist space */
	if (b >= VITHIST_MAXBLKS)
	    E_FATAL("Viterbi history array exhausted; increase VITHIST_MAXBLKS\n");
	
	assert (vh->entry[b] == NULL);
	
	ve = (vithist_entry_t *) ckd_calloc (VITHIST_BLKSIZE, sizeof(vithist_entry_t));
	vh->entry[b] = ve;
    } else
	ve = vh->entry[b] + l;
    
    vh->n_entry++;
    
    return ve;
}


int32 vithist_utt_begin (vithist_t *vh, kbcore_t *kbc)
{
    vithist_entry_t *ve;
    lm_t *lm;
    dict_t *dict;
    
    lm = kbcore_lm(kbc);
    dict = kbcore_dict(kbc);
    
    assert (vh->n_entry == 0);
    assert (vh->entry[0] == NULL);
    assert (vh->lwidlist == NULL);
    
    /* Create an initial dummy <s> entry.  This is the root for the utterance */
    ve = vithist_entry_alloc (vh);
    
    ve->wid = dict_startwid(dict);
    ve->sf = -1;
    ve->ef = -1;
    ve->ascr = 0;
    ve->lscr = 0;
    ve->score = 0;
    ve->pred = -1;
    ve->type = 0;
    ve->valid = 1;
    ve->lmstate.lm3g.lwid[0] = lm_startwid(lm);
    ve->lmstate.lm3g.lwid[1] = BAD_S3LMWID;
    
    vh->n_frm = 0;
    vh->frame_start[0] = 1;
    vh->bestscore[0] = MAX_NEG_INT32;
    vh->bestvh[0] = -1;
    
    return 0;
}


static int32 vh_lmstate_find (vithist_t *vh, vh_lmstate_t *lms)
{
    vh_lms2vh_t *lms2vh;
    s3lmwid_t lwid;
    gnode_t *gn;
    
    lwid = lms->lm3g.lwid[0];
    if ((lms2vh = vh->lms2vh_root[lwid]) == NULL)
	return -1;
    
    assert (lms2vh->state == lwid);
    
    lwid = lms->lm3g.lwid[1];
    for (gn = lms2vh->children; gn; gn = gnode_next(gn)) {
	lms2vh = (vh_lms2vh_t *) gnode_ptr (gn);
	if (lms2vh->state == lwid)
	    return lms2vh->vhid;
    }
    
    return -1;
}


/*
 * Enter a new LMstate into the current frame LMstates trees; called ONLY IF not already
 * present.
 */
static void vithist_lmstate_enter (vithist_t *vh, int32 vhid, vithist_entry_t *ve)
{
    vh_lms2vh_t *lms2vh, *child;
    s3lmwid_t lwid;
    
    lwid = ve->lmstate.lm3g.lwid[0];
    if ((lms2vh = vh->lms2vh_root[lwid]) == NULL) {
	lms2vh = (vh_lms2vh_t *) ckd_calloc (1, sizeof(vh_lms2vh_t));
	vh->lms2vh_root[lwid] = lms2vh;
	
	lms2vh->state = lwid;
	lms2vh->children = NULL;
	
	vh->lwidlist = glist_add_int32 (vh->lwidlist, (int32) lwid);
    } else {
	assert (lms2vh->state == lwid);
    }
    
    child = (vh_lms2vh_t *) ckd_calloc (1, sizeof(vh_lms2vh_t));
    child->state = ve->lmstate.lm3g.lwid[1];
    child->children = NULL;
    child->vhid = vhid;
    child->ve = ve;
    
    lms2vh->children = glist_add_ptr (lms2vh->children, (void *)child);
}


vithist_entry_t *vithist_id2entry (vithist_t *vh, int32 id)
{
    vithist_entry_t *ve;

    ve = vh->entry[VITHIST_ID2BLK(id)] + VITHIST_ID2BLKOFFSET(id);
    return ve;
}


static void vithist_enter (vithist_t *vh, kbcore_t *kbc, vithist_entry_t *tve)
{
    vithist_entry_t *ve;
    int32 vhid;
    
    /* Check if an entry with this LM state already exists in current frame */
    vhid = vh_lmstate_find (vh, &(tve->lmstate));
    if (vhid < 0) {	/* Not found; allocate new entry */
	vhid = vh->n_entry;
	ve = vithist_entry_alloc (vh);
	
	*ve = *tve;
	vithist_lmstate_enter (vh, vhid, ve);	/* Enter new vithist info into LM state tree */
   } else {
	ve = vh->entry[VITHIST_ID2BLK(vhid)] + VITHIST_ID2BLKOFFSET(vhid);
	
	if (ve->score < tve->score)
	    *ve = *tve;
    }
    
    /* Update best exit score in this frame */
    if (vh->bestscore[vh->n_frm] < tve->score) {
	vh->bestscore[vh->n_frm] = tve->score;
	vh->bestvh[vh->n_frm] = vhid;
    }
}


void vithist_rescore (vithist_t *vh, kbcore_t *kbc,
		      s3wid_t wid, int32 ef, int32 score, int32 pred, int32 type)
{
    vithist_entry_t *pve, tve;
    s3lmwid_t lwid;
    int32 se, fe;
    int32 i;
    
    assert (vh->n_frm == ef);
    
    pve = vh->entry[VITHIST_ID2BLK(pred)] + VITHIST_ID2BLKOFFSET(pred);
    
    /* Create a temporary entry with all the info currently available */
    tve.wid = wid;
    tve.sf = pve->ef + 1;
    tve.ef = ef;
    tve.type = type;
    tve.valid = 1;
    tve.ascr = score - pve->score;
    
    if (pred == 0) {	/* Special case for the initial <s> entry */
	se = 0;
	fe = 1;
    } else {
	se = vh->frame_start[pve->ef];
	fe = vh->frame_start[pve->ef + 1];
    }
    
    if (dict_filler_word (kbcore_dict(kbc), wid)) {
	tve.lscr = fillpen (kbcore_fillpen(kbc), wid);
	tve.score = score + tve.lscr;
	tve.pred = pred;
	tve.lmstate.lm3g = pve->lmstate.lm3g;
	
	vithist_enter (vh, kbc, &tve);
    } else {
	lwid = kbcore_dict2lmwid (kbc, wid);
	tve.lmstate.lm3g.lwid[0] = lwid;
	
	for (i = se; i < fe; i++) {
	    pve = vh->entry[VITHIST_ID2BLK(i)] + VITHIST_ID2BLKOFFSET(i);
	    
	    if (pve->valid) {
 	        tve.lscr = lm_tg_score (kbcore_lm(kbc),
					pve->lmstate.lm3g.lwid[1],
					pve->lmstate.lm3g.lwid[0],
					lwid);
	      
		tve.score = pve->score + tve.ascr + tve.lscr;
		
		if ((tve.score - vh->wbeam) >= vh->bestscore[vh->n_frm]) {
		    tve.pred = i;
		    tve.lmstate.lm3g.lwid[1] = pve->lmstate.lm3g.lwid[0];
		    
		    vithist_enter (vh, kbc, &tve);
		}
	    }
	}
    }
}


/*
 * Garbage collect invalid entries in current frame, right after marking invalid entries.
 */
static void vithist_frame_gc (vithist_t *vh, int32 frm)
{
    vithist_entry_t *ve, *tve;
    int32 se, fe, te, bs, bv;
    int32 i, j;
    
    se = vh->frame_start[frm];
    fe = vh->n_entry - 1;
    te = se;
    
    bs = MAX_NEG_INT32;
    bv = -1;
    for (i = se; i <= fe; i++) {
	ve = vh->entry[VITHIST_ID2BLK(i)] + VITHIST_ID2BLKOFFSET(i);
	if (ve->valid) {
	    if (i != te) {	/* Move i to te */
		tve = vh->entry[VITHIST_ID2BLK(te)] + VITHIST_ID2BLKOFFSET(te);
		*tve = *ve;
	    }
	    
	    if (ve->score > bs) {
		bs = ve->score;
		bv = te;
	    }
	    
	    te++;
	}
    }
    
    assert (bs == vh->bestscore[frm]);
    vh->bestvh[frm] = bv;
    
    /* Free up entries [te..n_entry-1] */
    i = VITHIST_ID2BLK(vh->n_entry - 1);
    j = VITHIST_ID2BLK(te - 1);
    for (; i > j; --i) {
	ckd_free ((void *) vh->entry[i]);
	vh->entry[i] = NULL;
    }
    vh->n_entry = te;
}


void vithist_prune (vithist_t *vh, dict_t *dict, int32 frm,
		    int32 maxwpf, int32 maxhist, int32 beam)
{
    int32 se, fe, filler_done, th;
    vithist_entry_t *ve;
    heap_t h;
    s3wid_t *wid;
    int32 i;
    
    assert (frm >= 0);
    
    se = vh->frame_start[frm];
    fe = vh->n_entry - 1;
    
    th = vh->bestscore[frm] + beam;
    
    h = heap_new ();
    wid = (s3wid_t *) ckd_calloc (maxwpf+1, sizeof(s3wid_t));
    wid[0] = BAD_S3WID;
    
    for (i = se; i <= fe; i++) {
	ve = vh->entry[VITHIST_ID2BLK(i)] + VITHIST_ID2BLKOFFSET(i);
	heap_insert (h, (void *)ve, -(ve->score));
	ve->valid = 0;
    }
    
    /* Mark invalid entries: beyond maxwpf words and below threshold */
    filler_done = 0;
    while ((heap_pop (h, (void **)(&ve), &i) > 0) && (ve->score >= th) && (maxhist > 0)) {
	if (dict_filler_word (dict, ve->wid)) {
	    /* Major HACK!!  Keep only one best filler word entry per frame */
	    if (filler_done)
		continue;
	    filler_done = 1;
	}
	
	/* Check if this word already valid (e.g., under a different history) */
	for (i = 0; IS_S3WID(wid[i]) && (wid[i] != ve->wid); i++);
	if (NOT_S3WID(wid[i])) {
	    /* New word; keep only if <maxwpf words already entered, even if >= thresh */
	    if (maxwpf > 0) {
		wid[i] = ve->wid;
		wid[i+1] = BAD_S3WID;
		
		--maxwpf;
		--maxhist;
		ve->valid = 1;
	    }
	} else if (! vh->bghist) {
	    --maxhist;
	    ve->valid = 1;
	}
    }
    
    ckd_free ((void *) wid);
    heap_destroy (h);
    
    /* Garbage collect invalid entries */
    vithist_frame_gc (vh, frm);
}


static void vithist_lmstate_reset (vithist_t *vh)
{
    gnode_t *lgn, *gn;
    int32 i;
    vh_lms2vh_t *lms2vh, *child;
    
    for (lgn = vh->lwidlist; lgn; lgn = gnode_next(lgn)) {
	i = (int32) gnode_int32 (lgn);
	lms2vh = vh->lms2vh_root[i];
	
	for (gn = lms2vh->children; gn; gn = gnode_next(gn)) {
	    child = (vh_lms2vh_t *) gnode_ptr (gn);
	    ckd_free ((void *) child);
	}
	glist_free (lms2vh->children);
	
	ckd_free ((void *) lms2vh);
	
	vh->lms2vh_root[i] = NULL;
    }
    
    glist_free (vh->lwidlist);
    vh->lwidlist = NULL;
}


void vithist_frame_windup (vithist_t *vh, int32 frm, FILE *fp, kbcore_t *kbc)
{
    assert (vh->n_frm == frm);
    
    vh->n_frm++;
    vh->frame_start[vh->n_frm] = vh->n_entry;
    
    if (fp)
	vithist_dump (vh, frm, kbc, fp);
    
    vithist_lmstate_reset (vh);
    
    vh->bestscore[vh->n_frm] = MAX_NEG_INT32;
    vh->bestvh[vh->n_frm] = -1;
}

int32 vithist_utt_end (vithist_t *vh, kbcore_t *kbc)
{
    int32 f, i, b, l;
    int32 sv, nsv, scr, bestscore, bestvh, vhid;
    vithist_entry_t *ve, *bestve=0;
    s3lmwid_t endwid;
    lm_t *lm;
    dict_t *dict;
    
    /* Find last frame with entries in vithist table */
    for (f = vh->n_frm-1; f >= 0; --f) {
	sv = vh->frame_start[f];	/* First vithist entry in frame f */
	nsv = vh->frame_start[f+1];	/* First vithist entry in next frame (f+1) */
	
	if (sv < nsv)
	    break;
    }
    if (f < 0)
	return -1;
    
    if (f != vh->n_frm-1)
	E_ERROR("No word exit in frame %d, using exits from frame %d\n", vh->n_frm-1, f);
    
    /* Terminate in a final </s> node (make this optional?) */
    lm = kbcore_lm (kbc);
    endwid = lm_finishwid (lm);
    
    bestscore = MAX_NEG_INT32;
    bestvh = -1;
    
    for (i = sv; i < nsv; i++) {
	b = VITHIST_ID2BLK (i);
	l = VITHIST_ID2BLKOFFSET (i);
	ve = vh->entry[b] + l;
	
	scr = ve->score;
	scr += lm_tg_score (lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid);
	
	if (bestscore < scr) {
	    bestscore = scr;
	    bestvh = i;
	    bestve = ve;
	}
    }
    assert (bestvh >= 0);

    dict = kbcore_dict (kbc);
    
    if (f != vh->n_frm-1) {
	E_ERROR("No word exit in frame %d, using exits from frame %d\n", vh->n_frm-1, f);
	
	/* Add a dummy silwid covering the remainder of the utterance */
	assert (vh->frame_start[vh->n_frm-1] == vh->frame_start[vh->n_frm]);
	vh->n_frm -= 1;
	vithist_rescore (vh, kbc, dict_silwid (dict), vh->n_frm, bestve->score, bestvh, -1);
	vh->n_frm += 1;
	vh->frame_start[vh->n_frm] = vh->n_entry;
	
	return vithist_utt_end (vh, kbc);
    }
    
    /* Create an </s> entry */
    vhid = vh->n_entry;
    ve = vithist_entry_alloc (vh);
    
    ve->wid = dict_finishwid (dict);
    ve->sf = (bestve->ef == BAD_S3FRMID) ? 0 : bestve->ef + 1;
    ve->ef = vh->n_frm;
    ve->ascr = 0;
    ve->lscr = bestscore - bestve->score;
    ve->score = bestscore;
    ve->pred = bestvh;
    ve->type = 0;
    ve->valid = 1;
    ve->lmstate.lm3g.lwid[0] = endwid;
    ve->lmstate.lm3g.lwid[1] = ve->lmstate.lm3g.lwid[0];
    
    return vhid;
}


int32 vithist_partialutt_end (vithist_t *vh, kbcore_t *kbc)
{
    int32 f, i, b, l;
    int32 sv, nsv, scr, bestscore, bestvh;
    vithist_entry_t *ve, *bestve;
    s3lmwid_t endwid;
    lm_t *lm;
    
    /* Find last frame with entries in vithist table */
    for (f = vh->n_frm-1; f >= 0; --f) {
	sv = vh->frame_start[f];	/* First vithist entry in frame f */
	nsv = vh->frame_start[f+1];	/* First vithist entry in next frame (f+1) */
	
	if (sv < nsv)
	    break;
    }
    if (f < 0)
	return -1;
    
    if (f != vh->n_frm-1){
	E_ERROR("No word exits from last frame in block %d\n",vh->n_frm-1);
	return -1;
    }
    
    /* Terminate in a final </s> node (make this optional?) */
    lm = kbcore_lm (kbc);
    endwid = lm_finishwid (lm);
    
    bestscore = MAX_NEG_INT32;
    bestvh = -1;
    
    for (i = sv; i < nsv; i++) {
	b = VITHIST_ID2BLK (i);
	l = VITHIST_ID2BLKOFFSET (i);
	ve = vh->entry[b] + l;
	
	scr = ve->score;
	scr += lm_tg_score (lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid);
	
	if (bestscore < scr) {
	    bestscore = scr;
	    bestvh = i;
	    bestve = ve;
	}
    }

    return bestvh;
}


void vithist_utt_reset (vithist_t *vh)
{
    int32 b;
    
    vithist_lmstate_reset (vh);
    
    for (b = VITHIST_ID2BLK(vh->n_entry-1); b >= 0; --b) {
	ckd_free ((void *) vh->entry[b]);
	vh->entry[b] = NULL;
    }
    vh->n_entry = 0;
    
    vh->bestscore[0] = MAX_NEG_INT32;
    vh->bestvh[0] = -1;
}


#if 0
static void vithist_lmstate_subtree_dump (vithist_t *vh, kbcore_t *kbc,
					  vh_lmstate2vithist_t *lms2vh, int32 level, FILE *fp)
{
    gnode_t *gn;
    vh_lmstate2vithist_t *child;
    int32 i;
    lm_t *lm;
    
    lm = kbcore_lm (kbc);
    
    for (gn = lms2vh->children; gn; gn = gnode_next(gn)) {
	child = (vh_lmstate2vithist_t *) gnode_ptr (gn);
	
	for (i = 0; i < level; i++)
	    fprintf (fp, "\t");
	fprintf (fp, "\t%s -> %d\n", lm_wordstr(lm, child->state), child->vhid);
	
	vithist_lmstate_subtree_dump (vh, kbc, child, level+1, fp);
    }
}


static void vithist_lmstate_dump (vithist_t *vh, kbcore_t *kbc, FILE *fp)
{
    glist_t gl;
    gnode_t *lgn, *gn;
    int32 i;
    vh_lmstate2vithist_t *lms2vh;
    mdef_t *mdef;
    lm_t *lm;
    
    mdef = kbcore_mdef (kbc);
    lm = kbcore_lm (kbc);
    
    fprintf (fp, "LMSTATE\n");
    for (lgn = vh->lwidlist; lgn; lgn = gnode_next(lgn)) {
	i = (int32) gnode_int32 (lgn);
	
	gl = vh->lmstate_root[i];
	assert (gl);
	
	for (gn = gl; gn; gn = gnode_next(gn)) {
	    lms2vh = (vh_lmstate2vithist_t *) gnode_ptr (gn);
	    
	    fprintf (fp, "\t%s.%s -> %d\n",
		     lm_wordstr(lm, i), mdef_ciphone_str (mdef, lms2vh->state), lms2vh->vhid);
	    vithist_lmstate_subtree_dump (vh, kbc, lms2vh, 1, fp);
	}
    }
    fprintf (fp, "END_LMSTATE\n");
    fflush (fp);
}
#endif


void vithist_dump (vithist_t *vh, int32 frm, kbcore_t *kbc, FILE *fp)
{
    int32 b, l, i, j;
    dict_t *dict;
    lm_t *lm;
    vithist_entry_t *ve;
    s3lmwid_t lwid;
    int32 sf, ef;
    
    dict = kbcore_dict (kbc);
    lm = kbcore_lm (kbc);
    
    if (frm >= 0) {
	sf = frm;
	ef = frm;
	
	fprintf (fp, "VITHIST  frame %d  #entries %d\n",
		 frm, vh->frame_start[sf+1] - vh->frame_start[sf]);
    } else {
	sf = 0;
	ef = vh->n_frm - 1;
	
	fprintf (fp, "VITHIST  #frames %d  #entries %d\n", vh->n_frm, vh->n_entry);
    }
    fprintf (fp, "\t%7s %5s %5s %11s %9s %8s %7s %4s Word (LM-state)\n",
	     "Seq/Val", "SFrm", "EFrm", "PathScr", "SegAScr", "SegLScr", "Pred", "Type");
    
    for (i = sf; i <= ef; i++) {
	fprintf (fp, "%5d BS: %11d BV: %8d\n", i, vh->bestscore[i], vh->bestvh[i]);
	
	for (j = vh->frame_start[i]; j < vh->frame_start[i+1]; j++) {
	    /* This entry */
	    b = VITHIST_ID2BLK(j);
	    l = VITHIST_ID2BLKOFFSET (j);
	    ve = vh->entry[b] + l;
	    
	    fprintf (fp, "\t%c%6d %5d %5d %11d %9d %8d %7d %4d %s",
		     (ve->valid ? ' ' : '*'), j,
		     ve->sf, ve->ef, ve->score, ve->ascr, ve->lscr, ve->pred, ve->type,
		     dict_wordstr (dict, ve->wid));
	    
	    fprintf (fp, " (%s", lm_wordstr (lm, ve->lmstate.lm3g.lwid[0]));
	    lwid = ve->lmstate.lm3g.lwid[1];
	    if (IS_S3LMWID(lwid))
		fprintf (fp, ", %s", lm_wordstr (lm, lwid));
	    fprintf (fp, ")\n");
	}
	
	if (j == vh->frame_start[i])
	    fprintf (fp, "\n");
    }

#if 0    
    if (vh->lwidlist)
	vithist_lmstate_dump (vh, kbc, fp);
#endif

    fprintf (fp, "END_VITHIST\n");
    fflush (fp);
}

glist_t vithist_backtrace (vithist_t *vh, int32 id)
{
    vithist_entry_t *ve;
    int32 b, l;
    glist_t hyp;
    hyp_t *h;
    
    hyp = NULL;
    
    while (id > 0) {
	b = VITHIST_ID2BLK(id);
	l = VITHIST_ID2BLKOFFSET(id);
	ve = vh->entry[b] + l;
	
	h = (hyp_t *) ckd_calloc (1, sizeof(hyp_t));
	h->id = ve->wid;
	h->sf = ve->sf;
	h->ef = ve->ef;
	h->ascr = ve->ascr;
	h->lscr = ve->lscr;
	h->type = ve->type;
	h->vhid = id;
	
	hyp = glist_add_ptr (hyp, h);
	
	id = ve->pred;
    }
    
    return hyp;
}


typedef struct {
    s3wid_t wid;
    int32 fef, lef;
    int32 seqid;	/* Node sequence no. */
    glist_t velist;	/* Vithist entries for this dagnode */
} dagnode_t;


/*
 * Header written BEFORE this function is called.
 */
void vithist_dag_write (vithist_t *vh, glist_t hyp, dict_t *dict, int32 oldfmt, FILE *fp)
{
    glist_t *sfwid;		/* To maintain <start-frame, word-id> pair dagnodes */
    vithist_entry_t *ve, *ve2;
    gnode_t *gn, *gn2, *gn3;
    dagnode_t *dn, *dn2;
    int32 sf, ef, n_node;
    int32 f, i;
    hyp_t *h;
    
    sfwid = (glist_t *) ckd_calloc (vh->n_frm+1, sizeof(glist_t));
    
    n_node = 0;
    for (i = 0; i < vh->n_entry; i++) {	/* This range includes the dummy <s> and </s> entries */
	ve = vh->entry[VITHIST_ID2BLK(i)] + VITHIST_ID2BLKOFFSET(i);
	if (! ve->valid)
	    continue;
	
	/*
	 * The initial <s> entry (at 0) is a dummy, with start/end frame = -1.  But the old S3
	 * code treats it like a real word, so we have to reintroduce it in the dag file with
	 * a start time of 0.  And shift the start time of words starting at frame 0 up by 1.
	 * MAJOR HACK!!
	 */
	if (ve->sf <= 0) {
	    assert (ve->sf >= -1);
	    assert ((ve->ef == -1) || (ve->ef > 1));
	    
	    sf = ve->sf + 1;
	    ef = (ve->ef < 0) ? 0 : ve->ef;
	} else {
	    sf = ve->sf;
	    ef = ve->ef;
	}
	
	for (gn = sfwid[sf]; gn; gn = gnode_next(gn)) {
	    dn = (dagnode_t *) gnode_ptr(gn);
	    if (dn->wid == ve->wid)
		break;
	}
	if (! gn) {
	    dn = (dagnode_t *) ckd_calloc (1, sizeof(dagnode_t));
	    dn->wid = ve->wid;
	    dn->fef = ef;
	    dn->lef = ef;
	    dn->seqid = -1;	/* Initially all invalid, selected ones validated below */
	    dn->velist = NULL;
	    n_node++;
	    
	    sfwid[sf] = glist_add_ptr (sfwid[sf], (void *) dn);
	} else {
	    dn->lef = ef;
	}
	
	/*
	 * Check if an entry already exists under dn->velist (generated by a different
	 * LM context; retain only the best scoring one.
	 */
	for (gn = dn->velist; gn; gn = gnode_next(gn)) {
	    ve2 = (vithist_entry_t *) gnode_ptr (gn);
	    if (ve2->ef == ve->ef)
		break;
	}
	if (gn) {
	    if (ve->score > ve2->score)
		gnode_ptr(gn) = (void *)ve;
	} else
	    dn->velist = glist_add_ptr (dn->velist, (void *) ve);
    }
    
    /*
     * Validate segments with >1 end times; if only 1 end time, can be pruned.
     * But keep segments in the original hypothesis, regardless; mark them first.
     */
    for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	for (gn2 = sfwid[h->sf]; gn2; gn2 = gnode_next(gn2)) {
	    dn = (dagnode_t *) gnode_ptr (gn2);
	    if (h->id == dn->wid)
		dn->seqid = 0;	/* Do not discard (prune) this dagnode */
	}
    }
    
    /* Validate startwid and finishwid nodes */
    dn = (dagnode_t *) gnode_ptr(sfwid[0]);
    assert (dn->wid == dict_startwid(dict));
    dn->seqid = 0;
    dn = (dagnode_t *) gnode_ptr(sfwid[vh->n_frm]);
    assert (dn->wid == dict_finishwid(dict));
    dn->seqid = 0;
    
    /* Now prune dagnodes with only 1 end frame if not validated above */
    i = 0;
    for (f = vh->n_frm; f >= 0; --f) {
	for (gn = sfwid[f]; gn; gn = gnode_next(gn)) {
	    dn = (dagnode_t *) gnode_ptr(gn);
	    if ((dn->lef > dn->fef) || (dn->seqid >= 0))
		dn->seqid = i++;
	    else
		dn->seqid = -1;		/* Flag: discard */
	}
    }
    n_node = i;
    
    /* Write nodes info; the header should have been written before this function is called */
    fprintf (fp, "Nodes %d (NODEID WORD STARTFRAME FIRST-ENDFRAME LAST-ENDFRAME)\n", n_node);
    for (f = vh->n_frm; f >= 0; --f) {
	for (gn = sfwid[f]; gn; gn = gnode_next(gn)) {
	    dn = (dagnode_t *) gnode_ptr(gn);
	    if (dn->seqid >= 0) {
		fprintf (fp, "%d %s %d %d %d\n",
			 dn->seqid, dict_wordstr(dict, dn->wid), f, dn->fef, dn->lef);
	    }
	}
    }
    fprintf (fp, "#\n");
    
    fprintf (fp, "Initial %d\nFinal %d\n", n_node-1, 0);
    fprintf (fp, "#\n");
    
    fprintf (fp, "BestSegAscr 0 (NODEID ENDFRAME ASCORE)\n");
    fprintf (fp, "#\n");
    
    /* Edges */
    if (oldfmt)
	fprintf (fp, "Edges (FROM-NODEID TO-NODEID ASCORE)\n");
    else
	fprintf (fp, "Edges (FROM-NODEID ENDFRAME ASCORE)\n");
    for (f = vh->n_frm-1; f >= 0; --f) {
	for (gn = sfwid[f]; gn; gn = gnode_next(gn)) {
	    dn = (dagnode_t *) gnode_ptr(gn);
	    /* Look for transitions from this dagnode to later ones, if not discarded */
	    if (dn->seqid < 0)
		continue;
	    
	    for (gn2 = dn->velist; gn2; gn2 = gnode_next(gn2)) {
		ve = (vithist_entry_t *) gnode_ptr (gn2);
		
		sf = (ve->ef < 0) ? 1 : (ve->ef + 1);
		
		if (oldfmt) {
		    for (gn3 = sfwid[sf]; gn3; gn3 = gnode_next(gn3)) {
			dn2 = (dagnode_t *) gnode_ptr(gn3);
			if (dn2->seqid >= 0)
			    fprintf (fp, "%d %d %d\n", dn->seqid, dn2->seqid, ve->ascr);
		    }
		} else {
		    for (gn3 = sfwid[sf]; gn3; gn3 = gnode_next(gn3)) {
			dn2 = (dagnode_t *) gnode_ptr(gn3);
			if (dn2->seqid >= 0) {
			    fprintf (fp, "%d %d %d\n", dn->seqid, sf-1, ve->ascr);
			    break;
			}
		    }
		}
	    }
	}
    }
    fprintf (fp, "End\n");
    
    /* Free dagnodes structure */
    for (f = 0; f <= vh->n_frm; f++) {
	for (gn = sfwid[f]; gn; gn = gnode_next(gn)) {
	    dn = (dagnode_t *) gnode_ptr(gn);
	    
	    glist_free (dn->velist);
	    ckd_free ((void *) dn);
	}
	
	glist_free (sfwid[f]);
    }
    ckd_free ((void *) sfwid);
}

/* 
 * RAH, free memory allocated in vithist_free 
 */
void vithist_free (vithist_t *v)
{
  if (v) {
    ckd_free ((void *) v);
  }

}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * vithist.h -- Viterbi history
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)
 *              Added vithist_free() to free allocated memory
 * 
 * 30-Sep-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 *		Added vithist_entry_t.ascr.
 * 
 * 13-Aug-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Added maxwpf handling.
 * 
 * 24-May-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#ifndef _S3_VITHIST_H_
#define _S3_VITHIST_H_


#include "libutil.h"
#include "s3types.h"
#include "kbcore.h"
#include "hyp.h"
#include <pthread.h>

/*
 * LM state.  Depending on type of LM (word-ngram, class-ngram, FSG, etc.), the contents
 * of LM state will vary.  Accommodate them with a union.  For now, only trigram LM in it.
 * (Not completely thought out; some of this might have to change later.)
 */
typedef union {
    struct {
	s3lmwid_t lwid[2];	/* 2-word history; [0] is most recent */
    } lm3g;
} vh_lmstate_t;


/*
 * Viterbi history entry.
 */
typedef struct {
    s3wid_t wid;		/* Dictionary word ID; exact word that just exited */
    s3frmid_t sf, ef;		/* Start and end frames for this entry */
    int32 ascr;			/* Acoustic score for this node */
    int32 lscr;			/* LM score for this node, given its Viterbi history */
    int32 score;		/* Total path score ending here */
    int32 pred;			/* Immediate predecessor */
    int32 type;			/* >=0: regular n-gram word; <0: filler word entry */
    int32 valid;		/* Whether it should be a valid history for LM rescoring */
    vh_lmstate_t lmstate;	/* LM state */
} vithist_entry_t;

#define vithist_entry_wid(ve)	((ve)->wid)
#define vithist_entry_sf(ve)	((ve)->sf)
#define vithist_entry_ef(ve)	((ve)->ef)
#define vithist_entry_ascr(ve)	((ve)->ascr)
#define vithist_entry_lscr(ve)	((ve)->lscr)
#define vithist_entry_score(ve)	((ve)->score)
#define vithist_entry_pred(ve)	((ve)->pred)
#define vithist_entry_valid(ve)	((ve)->valid)


/* 
 * In each frame, there are several word exits.  There can be several exit instances of the
 * same word, corresponding to different LM histories.  Generally, each exit is associated
 * with an LM state.  We only need to retain the best entry for each LM state.  The following
 * structure is for this purpose.
 * For all exits in the current frame, all n-word histories (assuming an N-gram LM) ending in
 * a given word are arranged in a tree, with the most recent history word at the root.  The
 * leaves of the tree point to the (current best) vithist entry with that history in the
 * current frame.
 */
typedef struct {		/* Mapping from LM state to vithist entry */
    int32 state;		/* (Part of) the state information */
    int32 vhid;			/* Associated vithist ID (only for leaf nodes) */
    vithist_entry_t *ve;	/* Entry ptr corresponding to vhid (only for leaf nodes) */
    glist_t children;		/* Children of this node in the LM state tree; data.ptr of
				   type (vh_lms2vh_t *) */
} vh_lms2vh_t;


/*
 * Memory management of Viterbi history entries done in blocks.  Initially, one block of
 * VITHIST_BLKSIZE entries allocated.  If exhausted, another block allocated, and so on.
 * So we can have several discontiguous blocks allocated.  Entries are identified by a
 * global, running sequence no.
 */
typedef struct {
    vithist_entry_t **entry;	/* entry[i][j]= j-th entry in the i-th block allocated */
    int32 *frame_start;		/* For each frame, the first vithist ID in that frame; (the
				   last is just before the first of the next frame) */
    int32 n_entry;		/* Total #entries used (generates global seq no. or ID) */
    int32 n_frm;		/* No. of frames processed so far in this utterance */
    
    int32 bghist;		/* If TRUE (bigram-mode) only one entry/word/frame; otherwise
				   multiple entries allowed, one per distinct LM state */
    
    int32 wbeam;		/* Pruning beamwidth */
    
    int32 *bestscore;		/* Best word exit score in each frame */
    int32 *bestvh;		/* Vithist entry ID with the best exit score in each frame */
    
    vh_lms2vh_t **lms2vh_root;	/* lms2vh[w]= Root of LM states ending in w in current frame */
    glist_t lwidlist;		/* List of LM word IDs with entries in lms2vh_root */
} vithist_t;


#define VITHIST_BLKSIZE		16384	/* (1 << 14) */
#define VITHIST_MAXBLKS		256
#define VITHIST_ID2BLK(i)	((i) >> 14)
#define VITHIST_ID2BLKOFFSET(i)	((i) & 0x00003fff)	/* 14 LSB */

/* Access macros; not meant for arbitrary use */
#define vithist_n_entry(vh)		((vh)->n_entry)
#define vithist_bestscore(vh)		((vh)->bestscore)
#define vithist_bestvh(vh)		((vh)->bestvh)
#define vithist_lms2vh_root(vh,w)	((vh)->lms2vh_root[w])
#define vithist_lwidlist(vh)		((vh)->lwidlist)
#define vithist_first_entry(vh,f)	((vh)->frame_start[f])
#define vithist_last_entry(vh,f)	((vh)->frame_start[f+1] - 1)


/* One-time intialization: Allocate and return an initially empty vithist module */
vithist_t *vithist_init (kbcore_t *kbc, int32 wbeam, int32 bghist);


/*
 * Invoked at the beginning of each utterance; vithist initialized with a root <s> entry.
 * Return value: Vithist ID of the root <s> entry.
 */
int32 vithist_utt_begin (vithist_t *vh, kbcore_t *kbc);


/*
 * Invoked at the end of each utterance; append a final </s> entry that results in the best
 * path score (i.e., LM including LM transition to </s>).
 * Return the ID of the appended entry if successful, -ve if error (empty utterance).
 */
int32 vithist_utt_end (vithist_t *vh, kbcore_t *kbc);


/*
 * Invoked at the end of each block of a live decode.
 * Returns viterbi histories of partial decodes
 */
int32 vithist_partialutt_end (vithist_t *vh, kbcore_t *kbc);

/* Invoked at the end of each utterance to clear up and deallocate space */
void vithist_utt_reset (vithist_t *vh);


/*
 * Viterbi backtrace.  Return value: List of hyp_t pointer entries for the individual word
 * segments.  Caller responsible for freeing the list.
 */
glist_t vithist_backtrace (vithist_t *vh,
			   int32 id);		/* ID from which to begin backtrace */

/*
 * Return ptr to entry corresponding to the given vithist ID.
 */
vithist_entry_t *vithist_id2entry (vithist_t *vh, int32 id);


/*
 * Like vithist_enter, but LM-rescore this word exit wrt all histories that ended at the
 * same time as the given, tentative pred.  Create a new vithist entry for each predecessor
 * (but, of course, only the best for each distinct LM state will be retained; see above).
 */
void vithist_rescore (vithist_t *vh,
		      kbcore_t *kbc,
		      s3wid_t wid,
		      int32 ef,		/* In: End frame for this word instance */
		      int32 score,	/* In: Does not include LM score for this entry */
		      int32 pred,	/* In: Tentative predecessor */
		      int32 type);

/* Invoked at the end of each frame */
void vithist_frame_windup (vithist_t *vh,	/* In/Out: Vithist module to be updated */
			   int32 frm,		/* In: Frame in which being invoked */
			   FILE *fp,		/* In: If not NULL, dump vithist entries
						   this frame to the file (for debugging) */
			   kbcore_t *kbc);	/* In: Used only for dumping to fp, for
						   debugging */

/*
 * Mark up to maxwpf best words, and variants within beam of best frame score as valid,
 * and the remaining as invalid.
 */
void vithist_prune (vithist_t *vh,
		    dict_t *dict,	/* In: Dictionary, for distinguishing filler words */
		    int32 frm,		/* In: Frame in which being invoked */
		    int32 maxwpf,	/* In: Max unique words per frame to be kept valid */
		    int32 maxhist,	/* In: Max histories to maintain per frame */
		    int32 beam);	/* In: Entry score must be >= frame bestscore+beam */

/*
 * Dump the Viterbi history data to the given file (for debugging/diagnostics).
 */
void vithist_dump (vithist_t *vh,
		   int32 frm,		/* In: If >= 0, print only entries made in this frame,
					   otherwise print all entries */
		   kbcore_t *kbc,
		   FILE *fp);

/*
 * Write a word lattice file (that can be input as -inlatdir argument to old s3 decoder).
 * Note: The header must be written before this function is called.
 */
void vithist_dag_write (vithist_t *vh,	/* In: From which word segmentations are to be dumped */
			glist_t hyp,	/* In: Some word segments can be pruned; however, but
					 * those in hyp always retained */
			dict_t *dict,	/* In: Dictionary; for generating word string names */
			int32 oldfmt,	/* In: If TRUE, old format, edges: srcnode dstnode ascr;
					 * else new format, edges: srcnode endframe ascr */
			FILE *fp);	/* Out: File to be written */

extern pthread_mutex_t update_lock;
#endif
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * wid.c -- Mapping word-IDs between LM and dictionary.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 01-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */


#include "wid.h"


s3lmwid_t *wid_dict_lm_map (dict_t *dict, lm_t *lm)
{
    int32 u, n;
    s3wid_t w;
    s3lmwid_t *map;
    
    assert (dict_size(dict) > 0);
    map = (s3lmwid_t *) ckd_calloc (dict_size(dict), sizeof(s3lmwid_t));
    for (n = 0; n < dict_size(dict); n++)
	map[n] = BAD_S3LMWID;
    
    n = 0;
    for (u = 0; u < lm_n_ug(lm); u++) {
	w = dict_wordid (dict, lm_wordstr(lm, u));
	lm_lmwid2dictwid(lm, u) = w;
	
	if (NOT_S3WID(w)) {
	    n++;
	} else {
	    if (dict_filler_word (dict, w))
		E_ERROR("Filler dictionary word '%s' found in LM\n", lm_wordstr(lm, u));
	    
	    if (w != dict_basewid (dict, w)) {
		E_ERROR("LM word '%s' is an alternative pronunciation in dictionary\n",
			lm_wordstr(lm, u));
		
		w = dict_basewid (dict, w);
		lm_lmwid2dictwid(lm, u) = w;
	    }
	    
	    for (; IS_S3WID(w); w = dict_nextalt(dict, w))
		map[w] = (s3lmwid_t) u;
	}
    }
    
    if (n > 0)
	E_INFO("%d LM words not in dictionary; ignored\n", n);
    
    return map;
}


int32 wid_wordprob2alt (dict_t *dict, wordprob_t *wp, int32 n)
{
    int32 i, j;
    s3wid_t w;
    
    for (i = 0, j = n; i < n; i++) {
	w = wp[i].wid;
	
	for (w = dict_nextalt (dict, w); IS_S3WID(w); w = dict_nextalt (dict, w)) {
	    wp[j].wid = w;
	    wp[j].prob = wp[i].prob;
	    j++;
	}
    }
    
    return j;
}
/*
 * 
 * This file is part of the ALPBench Benchmark Suite Version 1.0
 * 
 * Copyright (c) 2005 The Board of Trustees of the University of Illinois
 * 
 * All rights reserved.
 * 
 * ALPBench is a derivative of several codes, and restricted by licenses
 * for those codes, as indicated in the source files and the ALPBench
 * license at http://www.cs.uiuc.edu/alp/alpbench/alpbench-license.html
 * 
 * The multithreading and SSE2 modifications for SpeechRec, FaceRec,
 * MPEGenc, and MPEGdec were done by Man-Lap (Alex) Li and Ruchira
 * Sasanka as part of the ALP research project at the University of
 * Illinois at Urbana-Champaign (http://www.cs.uiuc.edu/alp/), directed
 * by Prof. Sarita V. Adve, Dr. Yen-Kuang Chen, and Dr. Eric Debes.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal with the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimers.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimers in the documentation and/or other materials provided
 *       with the distribution.
 * 
 *     * Neither the names of Professor Sarita Adve's research group, the
 *       University of Illinois at Urbana-Champaign, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this Software without specific prior written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
 * SOFTWARE.
 * 
 */


/* ====================================================================
 * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * wid.c -- Mapping word-IDs between LM and dictionary.
 * 
 * **********************************************
 * CMU ARPA Speech Project
 *
 * Copyright (c) 1999 Carnegie Mellon University.
 * ALL RIGHTS RESERVED.
 * **********************************************
 * 
 * HISTORY
 * 
 * 01-Mar-1999	M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University
 * 		Started.
 */

#ifndef _S3_WID_H_
#define _S3_WID_H_


#include "libutil.h"
#include "dict.h"
#include "lm.h"


/*
 * Create mappings between dictionary and LM word-IDs.  In short:
 *    - An array of s3lmwid_t entries (map[]) is created; where map[i] is the LM word-ID for
 * 	the dictionary word-ID i.  Mappings are created for the alternative pronunciations as
 * 	well.  For words not in the LM, the corresponding entries are BAD_S3LMWID.
 *    - Similarly, lm->ug[u].dictwid is assigned the dictionary word id for unigram word u.
 * Return value: The map[] array built as described above.
 */
s3lmwid_t *wid_dict_lm_map (dict_t *dict,	/* In: Dictionary */
			    lm_t *lm);		/* In/Out: LM; lm->ug[].dictwid values are
						   updated. */

/*
 * Augment the given wordprob array with alternative pronunciations from the dictionary.
 * Return value: #entries in the augmented wordprob array (including the original ones).
 */
int32 wid_wordprob2alt (dict_t *dict,	/* In: Dictionary */
			wordprob_t *wp,	/* In/Out: Input wordprob array, to be augmented with
					   alternative pronunciations for the entries that
					   already exist in it.  Caller must have allocated
					   this array. */
			int32 n);	/* In: #Input entries in the wordprob array */

#endif
/*
 * Code for parsing ac3d modeler files
 *
 * See http://www.comp.lancs.ac.uk/computing/users/andy/ac3d/
 * for more information on ac3d.
 */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h> /* needed for toupper(), macro.. */

#include "tachyon.h" /* ray tracer api */

#define PARSE_INTERNAL
#include "ac3dparse.h" /* self protos */
#undef PARSE_INTERNAL

static texentry textable[NUMTEXS]; /* texture lookup table */
static int numtextures;         /* number of TEXDEF textures               */
static int numobjectsparsed;    /* total number of objects parsed so far   */
static apicolor scenebackcol;   /* scene background color                  */

static int stringcmp(char * a, char * b) {
  int i, s, l;

  s=strlen(a);
  l=strlen(b);

  if (s != l) 
    return 1;

  for (i=0; i<s; i++) {
    if (toupper(a[i]) != toupper(b[i])) {
      return 1;
    }
  }
  return 0;
}


static void GetAC3DString(FILE * dfile, char * str) {
   char c;
   int i=0;

   /* find opening quote */
   while ((!feof(dfile)) && ((c = fgetc(dfile)) != '"'));
    
   /* scan in string until closing quote */ 
   while ((!feof(dfile)) && ((c = fgetc(dfile)) != '"')) {
     str[i] = c; 
     i++;
   }
   str[i]='\0'; /* nul terminate the string */
}

static void reset_tex_table(void) {
  numtextures=0; 
  memset(&textable, 0, sizeof(textable));
}

static errcode add_texture(void * tex, char name[TEXNAMELEN]) {
  textable[numtextures].tex=tex;
  strcpy(textable[numtextures].name, name); 

  numtextures++;
  if (numtextures > NUMTEXS) {
    printf("Parse: %d textures allocated, texture slots full!\n", numtextures);
    numtextures--; /* keep writing over last texture if we've run out.. */
    return PARSEALLOCERR;
  }

  return PARSENOERR;
}

static errcode GetString(FILE * dfile, char * string) {
  char data[100];

  fscanf(dfile,"%s",data);
  if (stringcmp(data, string) != 0) {
    printf("parse: Expected %s, got %s \n",string, data);
    printf("parse: Error while parsing object: %d \n",numobjectsparsed);
    return PARSEBADSYNTAX;
  }

  return PARSENOERR;
}

unsigned int ParseAC3D(char * modelfile, SceneHandle scene) {
  FILE * dfile;
  char filehdr[255];
  errcode rc;
 
  reset_tex_table(); 
  dfile=NULL;

  dfile=fopen(modelfile,"r");
  if (dfile==NULL) {
    return PARSEBADFILE;
  }

  fscanf(dfile, "%s", filehdr);
  if (strcmp(filehdr, "AC3Db")) {
    printf("Unknown version of AC3D Model File Format\n");
    fclose(dfile);
    return PARSEBADFILE;
  }

  rc = GetScenedefs(dfile, scene); 
  if (rc != PARSENOERR)
    return rc;

  scenebackcol.r = 0.0; /* default background is black */
  scenebackcol.g = 0.0;
  scenebackcol.b = 0.0;

  numobjectsparsed=0;
  while ((rc = GetScene(dfile, scene)) == PARSENOERR) {
    numobjectsparsed++;
  } 
  fclose(dfile);

  if (rc == PARSEEOF)
    rc = PARSENOERR;

  rt_background(scene, scenebackcol);

  return rc;
}


static errcode GetScenedefs(FILE * dfile, SceneHandle scene) {
  apivector Ccenter, Cview, Cup;
  apiflt zoom, aspectratio;
  int raydepth, antialiasing;

  rt_outputfile(scene, "outfile.tga");
  rt_resolution(scene, 512, 512);
  rt_verbose(scene, 0);

  zoom=1.0;
  aspectratio=1.0;
  antialiasing=0;
  raydepth=6;

  Ccenter.x = 0.0;
  Ccenter.y = 0.0;
  Ccenter.z = -5.0;

  Cview.x = 0.0;
  Cview.y = 0.0;
  Cview.z = 1.0;

  Cup.x = 0.0;
  Cup.y = 1.0;
  Cup.z = 0.0;

  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth,
              Ccenter, Cview, Cup);

  { /* lighting hack */
    apivector ctr;
    apitexture tex;

    memset(&tex, 0, sizeof(apitexture));

    tex.col.r = 1.0;
    tex.col.g = 1.0;
    tex.col.b = 1.0;
    ctr.x = 0.0;
    ctr.y = 0.0;
    ctr.z = -100.0;
 
    rt_light(scene, rt_texture(scene, &tex), ctr, 1.0);
  }

  return PARSENOERR;
}

static errcode GetScene(FILE * dfile, SceneHandle scene) {
  char objtype[80];
 
  if (fscanf(dfile, "%s", objtype) != 1) {
    return PARSEEOF; /* end parsing */
  }
  if (!stringcmp(objtype, "MATERIAL")) {
    return GetMaterial(dfile, scene);
  }	
  if (!stringcmp(objtype, "OBJECT")) {
    return GetObject(dfile, scene);
  }

  printf("Found bad token: %s expected an object type\n", objtype);
  return PARSEBADSYNTAX;
}

static errcode GetMaterial(FILE * dfile, SceneHandle scene) {
  apitexture tex;
  float a,b,c,d;
  int e;
  errcode rc;
  char texname[TEXNAMELEN];

  fscanf(dfile, "%s", texname);

  rc = GetString(dfile, "RGB");
  fscanf(dfile, "%f %f %f", &a, &b, &c); 
  tex.col.r = a;
  tex.col.g = b;
  tex.col.b = c;
  tex.diffuse = (a + b + c) / 3.0;

  rc = GetString(dfile, "AMB");
  fscanf(dfile, "%f %f %f", &a, &b, &c); 
  tex.ambient= ((a + b + c) / 3.0);

  rc |= GetString(dfile, "EMIS");
  fscanf(dfile, "%f %f %f", &a, &b, &c);

  rc |= GetString(dfile, "SPEC");
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  tex.specular= (a + b + c) / 3.0;

  rc |= GetString(dfile, "SHI");
  fscanf(dfile, "%d", &e);

  rc |= GetString(dfile, "TRANS");
  fscanf(dfile, "%f", &d);  
  tex.opacity= (d > 0.99) ? 0.0 : (1.0 - d);
  tex.texturefunc = 0;

  add_texture(rt_texture(scene, &tex), texname); 

  return rc;
}

static void RmatIdentity(RotMat rmat) {
  int i, j;
  for (j=0; j<3; j++) {
    for (i=0; i<3; i++) {
      if (i==j)
        rmat[j][i] = 1.0;
      else 
        rmat[j][i] = 0.0;
    }
  }
} 

static void RmatMult(RotMat A, RotMat B, RotMat C) {
  int i, j, k;

  for (k=0; k<3; k++) {
    for (j=0; j<3; j++) {
      A[k][j] = 0.0;
      for (i=0; i<3; i++) {
        A[k][j] += B[k][i] * C[i][j];  
      }
    }
  }
}

static void RmatTmatMult(TransMat NT, RotMat R, TransMat T) {
  int i, j;
  for (j=0; j<3; j++) {
    NT[j] = 0.0;
    for (i=0; i<3; i++) {
      NT[j] += R[j][i] * T[i];
    }
  } 
}

static void tlist_add_tri(tri_list ** tlist, int v0, int v1, int v2, 
                          int smooth, int texnum) {
  tri_list * newlist;

  newlist = (tri_list *) malloc(sizeof(tri_list));
  newlist->v0 = v0;
  newlist->v1 = v1;
  newlist->v2 = v2;
  newlist->smooth = smooth;
  newlist->texnum = texnum;
  newlist->next = *tlist;  

  *tlist = newlist;
}

static void tlist_delete(tri_list ** tlist) {
  tri_list * tmp; 
  tri_list * next; 
  
  tmp = *tlist;
  
  while (tmp != NULL) {
    next = tmp->next;
    free(tmp);
    tmp = next;
  }
 
  *tlist = NULL;
}


static void clear_normals(apivector * normals, int numverts) {
  apivector tmp; 
  int i;

  tmp.x = tmp.y = tmp.z = 0.0;

  for (i=0; i<numverts; i++) {
    normals[i] = tmp;
  }
}


static void normalize(apivector * vec) {
  double length;
  length = sqrt((vec->x * vec->x) + (vec->y * vec->y) + (vec->z * vec->z));
  vec->x /= length;
  vec->y /= length;
  vec->z /= length;
}

static void renormalize_normals(apivector * normals, int numverts) {
  int i;
  
  for (i=0; i<numverts; i++) {
    normalize(&normals[i]);
  }
}

static apivector tri_normal(apivector * v0, apivector * v1, apivector * v2) {
  apivector U, V;
  apivector norm;

  U.x = v1->x - v0->x;
  U.y = v1->y - v0->y;
  U.z = v1->z - v0->z;

  V.x = v2->x - v0->x;
  V.y = v2->y - v0->y;
  V.z = v2->z - v0->z;

  norm.x = (U.y * V.z) - (U.z * V.y);
  norm.y = (U.z * V.x) - (U.x * V.z);
  norm.z = (U.x * V.y) - (U.y * V.x);  

  normalize(&norm);

  return norm;
}

static void gen_triangles(SceneHandle scene, tri_list * tlist, 
                          apivector * vertex, apivector * normal) {
  tri_list * cur;

  cur = tlist;
  while (cur != NULL) {
    if (cur->smooth) {
      rt_stri(scene, textable[cur->texnum].tex, 
        vertex[cur->v0], vertex[cur->v1], vertex[cur->v2],
        normal[cur->v0], normal[cur->v1], normal[cur->v2]);
     
    }
    else {
      rt_tri(scene, textable[cur->texnum].tex, 
        vertex[cur->v0], vertex[cur->v1], vertex[cur->v2]);
    }

    cur = cur->next;
  }
}


static errcode GetRecurseObject(SceneHandle scene, FILE *dfile, 
                                RotMat rmat, TransMat tmat) {
  char token[256], objname[128], name[128], texname[128], urlname[100];
  RotMat localrmat, newrmat;
  TransMat localtmat, newtmat;
  float txrepa, txrepb, a, b;
  int numvert, numsurf, surf, materialnum, numrefs, numkids, data;
  int i, j;
  apivector * vertexarray = NULL; 
  apivector * normalarray = NULL; 
  int * refarray = NULL;
  tri_list * tlist = NULL;
  errcode rc = PARSENOERR;

  /* zero out variables */
  numvert = numsurf = surf = materialnum = numrefs = numkids = data = 0;

  RmatIdentity(localrmat);
  localtmat[0] = 0.0;
  localtmat[1] = 0.0;
  localtmat[2] = 0.0;
  fscanf(dfile, "%s", objname);
  fscanf(dfile, "%s", token);
  if (!stringcmp(token, "NAME")) {
    GetAC3DString(dfile, name);
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "DATA")) {
    fscanf(dfile, "%d", &data);
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "TEXTURE")) {
    fscanf(dfile, "%s", texname);
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "TEXREP")) {
    fscanf(dfile, "%f %f", &txrepa, &txrepb);
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "ROT")) {
    for (j=0; j<3; j++) {
      for(i=0; i<3; i++) {
        fscanf(dfile, "%f", &localrmat[j][i]);
      }
    } 
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "LOC")) {
    for (j=0; j<3; j++) {
      fscanf(dfile, "%f", &localtmat[j]);
    } 
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "ROT")) {
    for (j=0; j<3; j++) {
      for(i=0; i<3; i++) {
        fscanf(dfile, "%f", &localrmat[j][i]);
      }
    } 
    fscanf(dfile, "%s", token);
  } 

  /* Perform Matrix Transforms for local coordinate system */
  RmatTmatMult(newtmat, rmat, localtmat);
  newtmat[0] += tmat[0]; 
  newtmat[1] += tmat[1]; 
  newtmat[2] += tmat[2]; 
  RmatMult(newrmat, rmat, localrmat);

  if (!stringcmp(token, "URL")) {
    fscanf(dfile, "%s", urlname);
    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "TEXTURE")) {
    GetAC3DString(dfile, token);
    fscanf(dfile, "%s", token);
  }  
  if (!stringcmp(token, "NUMVERT")) {
    TransMat vtx, tvtx;

    fscanf(dfile, "%d", &numvert);

    vertexarray = (apivector *) malloc(numvert * sizeof(apivector));
    normalarray = (apivector *) malloc(numvert * sizeof(apivector));

    /* initialize the normal array */
    clear_normals(normalarray, numvert);

    /* load and transform vertices */
    for (i=0; i<numvert; i++) {
      fscanf(dfile, "%f %f %f", &vtx[0], &vtx[1], &vtx[2]);
      /* transform vertices */
      RmatTmatMult(tvtx, newrmat, vtx);
      vertexarray[i].x = tvtx[0] + newtmat[0];
      vertexarray[i].y = tvtx[1] + newtmat[1];
      vertexarray[i].z = tvtx[2] + newtmat[2];
    }    

    fscanf(dfile, "%s", token);
  } 
  if (!stringcmp(token, "NUMSURF")) {
    fscanf(dfile, "%d", &numsurf);
    fscanf(dfile, "%s", token);

    for (j=0; j<numsurf; j++) {
      numrefs = surf = materialnum = 0;
      
      if (!stringcmp(token, "SURF")) {

/* COMPILER BUG!!! */
/* This is messed up friend.. */
/* if done using a normal fscanf() the program nails its */
/* stack, and seg faults.  This *must* be a compiler or  */
/* libc bug. */ 
#if 1	
        fscanf(dfile, "%s", token);
        sscanf(token, "%x", &surf);
#else
        fscanf(dfile, "%x", &surf);
#endif
        fscanf(dfile, "%s", token);
      } 
      if (!stringcmp(token, "MAT")) {
        fscanf(dfile, "%d", &materialnum);
        fscanf(dfile, "%s", token);
      } 
      if (!stringcmp(token, "REFS")) 
        fscanf(dfile, "%d", &numrefs);  
      else 
        return (rc |= PARSEBADSYNTAX);

      refarray = (int *) malloc(numrefs * sizeof(int));
      for (i=0; i<numrefs; i++) {
        fscanf(dfile, "%d %f %f", &refarray[i], &a, &b);  
      }  

      /* generate triangles/polygons here */
      /* ignore all lines, points and other non-surface primatives */
      if ((surf & 0xF) == 0) {
        int v0, vold, vnew;
        apivector trinorm;
        
        /* add in surface normal to vertices */
        trinorm = tri_normal(&vertexarray[refarray[1]],         
                             &vertexarray[refarray[0]], 
                             &vertexarray[refarray[2]]); 
       
        for (i=0; i<numrefs; i++) {
          normalarray[refarray[i]].x += trinorm.x;
          normalarray[refarray[i]].y += trinorm.y;
          normalarray[refarray[i]].z += trinorm.z;
        }

        v0 = refarray[0];
        vold = refarray[1];

        for (i=2; i<numrefs; i++) {
          vnew = refarray[i];
          tlist_add_tri(&tlist, vold, v0, vnew, surf & 0x10, materialnum);
          vold = vnew; 
        }
      }
    
      free(refarray);
      refarray=NULL;
      fscanf(dfile, "%s", token);
    }
  } 

  if ((vertexarray != NULL) && (normalarray != NULL)) {
    /* now that all vertex normals have been summed, we'll renormalize */
    renormalize_normals(normalarray, numvert);

    gen_triangles(scene, tlist, vertexarray, normalarray);
    tlist_delete(&tlist); 
  }

  /* free vertex and normal arrays */
  if (vertexarray != NULL) 
    free(vertexarray);
  vertexarray = NULL;

  if (normalarray != NULL) 
    free(normalarray);
  normalarray = NULL;



  if (!stringcmp(token, "KIDS")) 
    fscanf(dfile, "%d", &numkids);
  else 
    return (rc |= PARSEBADSYNTAX);

  /* Recurse to handle child geometry */ 
  while (numkids > 0) {
    rc |= GetString(dfile, "OBJECT");
    rc |= GetRecurseObject(scene, dfile, newrmat, newtmat); 
    numkids--;
  }
 
  return rc; 
}

static errcode GetObject(FILE *dfile, SceneHandle scene) {
  RotMat defaultrmat;
  TransMat defaulttmat;
  errcode rc;

  RmatIdentity(defaultrmat);
  defaulttmat[0] = 0.0;
  defaulttmat[1] = 0.0;
  defaulttmat[2] = 0.0;

  rc = GetRecurseObject(scene, dfile, defaultrmat, defaulttmat);

  return rc;
}



 
/*
 * definitions for parsing ac3d modeler files
 *  
 */

#define PARSENOERR       0
#define PARSEBADFILE     1
#define PARSEBADSUBFILE  2
#define PARSEBADSYNTAX   4
#define PARSEEOF         8
#define PARSEALLOCERR    16

unsigned int ParseAC3D(char *, SceneHandle);

#ifdef PARSE_INTERNAL
#define NUMTEXS 8192
#define TEXNAMELEN 24

typedef float RotMat[3][3]; 
typedef float TransMat[3];

typedef struct {
  char name[TEXNAMELEN];
  void * tex;
} texentry;

typedef struct tri_list_t {
  int v0;     /* index of vertex 0 */
  int v1;     /* index of vertex 1 */
  int v2;     /* index of vertex 2 */
  int smooth; /* smoothed or flat shaded flag */
  int texnum; /* index of texture to use */
  struct tri_list_t * next; /* pointer to next triangle */
} tri_list;

typedef unsigned int errcode;
static errcode add_texture(void * tex, char name[TEXNAMELEN]);

static void tlist_add_tri(tri_list ** tlist, int v0, int v1, int v2,
                          int smooth, int texnum);
static void tlist_delete(tri_list ** tlist);
static void clear_normals(apivector * normals, int numverts);
static void normalize(apivector * vec);
static void renormalize_normals(apivector * normals, int numverts);
static apivector tri_normal(apivector * v0, apivector * v1, apivector * v2);
static void gen_triangles(SceneHandle, tri_list * tlist, apivector * vertex,
                          apivector * normal);
static errcode GetMaterial(FILE *, SceneHandle);
static errcode GetString(FILE *, char *);
static errcode GetScenedefs(FILE *, SceneHandle);
static errcode GetScene(FILE *, SceneHandle);
static errcode GetObject(FILE *, SceneHandle);
#endif

/* main.c 
 * This file contains the main program and driver for the raytracer.
 *
 *  $Id: animskull.c,v 1.11 2002/07/03 04:59:28 johns Exp $
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "tachyon.h"

int rt_mynode(void); /* proto */

typedef struct {      /* Scalar Volume Visualization Data */
  int loaded;            /* Volume data memory residence flag */
  int xres;              /* volume X axis size                */
  int yres;              /* volume Y axis size                */
  int zres;              /* volume Z axis size                */
  apiflt opacity;        /* opacity per unit length           */
  char name[80];         /* Volume data filename              */
  unsigned char * data;  /* pointer to raw byte volume data   */
} scalarvol;

#define MAXFRAMES 100
#define RAD 6.28

#ifdef cube
#define RFILE "/cfs/johns/anim/frame"
#endif

#ifndef cube 
#define RFILE "outfile"
#endif

int main(int argc, char **argv) {
  SceneHandle scene;
  int i;
  int xres, yres, raydepth, antialiasing, verbosemode;
  apiflt zoom, aspectratio;
  apivector Ccenter, Cview, Cup;
  apivector ctr1;
  apitexture tex1, tex2;
  apivector min3, max3;
  scalarvol vol;
  apiflt xc,yc;
  char fname[1000];
  char fname2[2000];

  rt_initialize(&argc, &argv); 

  scene = rt_newscene();

  xres=256; yres=256;
  aspectratio=1.0; raydepth=18;
  antialiasing=1; verbosemode=0; zoom=1.0;
 
  Ccenter.x=0.0; Ccenter.y=0.0; Ccenter.z=-8.0;
  Cview.x=0.0;   Cview.y=0.0;   Cview.z=1.0;
  Cup.x=0.0;     Cup.y=-1.0;     Cup.z=0.0;
  ctr1.x=20.0;  ctr1.y=20.0; ctr1.z=-40.0;
  
  tex1.col.r=1.0; tex1.col.g=1.0; tex1.col.b=1.0;
  tex1.ambient=1.0;  
  tex1.diffuse=0.0;
  tex1.specular=0.0; 
  tex1.opacity=8.0;
  tex1.texturefunc=0;
  tex2=tex1;

  min3.x=-1.0; min3.y=-1.0; min3.z=-0.40;
  max3.x=1.0;  max3.y=1.0;  max3.z=0.40;

  vol.loaded=0;
   
  for (i=0; i<MAXFRAMES; i++) {  
    sprintf(fname,".%4.4d.tga",i);
    strcpy(fname2,RFILE);
    strcat(fname2, fname);
     
    rt_initialize(&argc, &argv); 
    if (rt_mynode()==0) printf("Rendering: %s \n",fname2);

    xc=cos(6.28 * i / (1.0 * MAXFRAMES));
    yc=sin(6.28 * i / (1.0 * MAXFRAMES));
    Ccenter.x = xc*3.0;
    Ccenter.z = yc*3.0;
    Cview.x =  -xc;
    Cview.z =  -yc;

    rt_outputfile(scene, fname2);
    rt_resolution(scene, xres, yres);
    rt_verbose(scene, verbosemode);

    rt_camera_setup(scene, zoom, aspectratio, antialiasing, 
		raydepth, Ccenter, Cview, Cup);

    rt_light(scene, rt_texture(scene, &tex1), ctr1, 1.0); 

    rt_scalarvol(scene, rt_texture(scene, &tex2), min3, max3, 256, 256, 100, 
	"/disk7/cube/vol/head.256x256x109", &vol);   

    rt_renderscene(scene);
  }
  rt_finalize(); 

  return 0;
}
   
/*  
 * This file contains the main program and driver for the raytracer.
 *
 *  $Id: animspheres2.c,v 1.11 2002/07/03 04:59:29 johns Exp $
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "tachyon.h"

#define XRES 352 
#define YRES 240
#define NUMSP 12 

#define MYPI 3.1415926
#define MYTPI 6.282

int rt_mynode(void);

#define MAXFRAMES 400
#define MAXX 1.0 
#define MAXY 1.0 
#define MAXZ 1.0 

#define MINX -1.0
#define MINY -1.0
#define MINZ -1.0

#define LOOP 200.0
#define LOOP2 100.0
#define RAD 6.28

#ifdef cube
#define RFILE "/cfs/johns/anim/frame"
#endif

#ifndef cube 
#define RFILE "outfile"
#endif


typedef struct {
     apitexture tex;
      apivector ctr;
         apiflt rad; 
      apivector dir;
} asphere;

asphere sp[NUMSP];

apiflt randflt(void) {
  long a;
  apiflt f;
 
  a=rand() % 1000;

  f=(a*1.0) / 1000.0;
  return f; 
}


void initspheres(void) {
  int i;
  apiflt t1;

  for (i=0; i<NUMSP; i++) {
   sp[i].tex.col.r=randflt() / 3.0 + 0.66;         
   sp[i].tex.col.g=randflt() / 3.0 + 0.66;         
   sp[i].tex.col.b=randflt() / 3.0 + 0.66;         
   t1=randflt()*0.9;
   
   sp[i].tex.ambient=0.1;
   sp[i].tex.diffuse=t1;
   sp[i].tex.specular=0.9 - t1;
   sp[i].tex.opacity=1.0;
   
   sp[i].tex.scale.x=1.0;
   sp[i].tex.scale.y=1.0;
   sp[i].tex.scale.z=1.0;

   sp[i].tex.rot.x=0.0;
   sp[i].tex.rot.y=0.0;
   sp[i].tex.rot.z=0.0;
   sp[i].tex.texturefunc=rand() % 7;
    

   sp[i].ctr.x=randflt() * 2.0 - 1.0;
   sp[i].ctr.y=randflt() * 2.0 - 1.0;
   sp[i].ctr.z=randflt() * 2.0 - 1.0;

   sp[i].rad=1.00;
   
   sp[i].dir.x=randflt() * 0.05 - 0.02; 
   sp[i].dir.y=randflt() * 0.05 - 0.02; 
   sp[i].dir.z=randflt() * 0.05 - 0.02; 
  }
}


void movesp(int frame) {
  int i;

  for (i=0; i<6; i++) {
    sp[i].ctr.x = 3.0 * sin(((i + 1.0)/6.0)*MYTPI + MYTPI*((1.0 * frame) / MAXFRAMES));
    sp[i].ctr.y = 3.0 * cos(((i + 1.0)/6.0)*MYTPI + MYTPI*((1.0 * frame) / MAXFRAMES));
    sp[i].ctr.z = 1.0;
  }

  for (i=0; i<6; i++) {
    sp[i+6].ctr.x = 3.0 + 3.0 * sin(((i + 1.0)/6.0)*MYTPI + MYTPI*((1.0 * frame) / MAXFRAMES));
    sp[i+6].ctr.y = 1.0;
    sp[i+6].ctr.z = 3.0 * cos(((i + 1.0)/6.0)*MYTPI + MYTPI*((1.0 * frame) / MAXFRAMES));
  }

}

void drawsp(SceneHandle scene) {
  int i;
  apitexture p1;  
  apivector ct1, n1;

  for (i=0; i<NUMSP; i++) {
    rt_sphere(scene, rt_texture(scene, &sp[i].tex), sp[i].ctr, sp[i].rad);   
  }

  p1.col.r=1.0;
  p1.col.g=1.0;
  p1.col.b=1.0;
  p1.ambient=0.1;
  p1.diffuse=0.5;
  p1.specular=0.4;
  p1.opacity=1.0;
 
  ct1.x=0.0;
  ct1.y=-5.10;
  ct1.z=0.0;

  n1.x=0.0;
  n1.y=1.0;
  n1.z=0.0;
 
  rt_plane(scene, rt_texture(scene, &p1), ct1, n1);  

}

int main(int argc, char **argv) {
  SceneHandle scene;
  int i;
  int xres, yres, raydepth, antialiasing, verbosemode;
  apiflt zoom, aspectratio;
  apivector Ccenter, Cview, Cup;
  apivector ctr1, ctr2;
  apitexture tex1, tex2;
  char fname[100];
  char fname2[200];

  scene = rt_newscene();

  xres=XRES; 
  yres=YRES;
  aspectratio=1.0;
  raydepth=18;
  antialiasing=0; 
  verbosemode=0;
  zoom=1.0;
 
  Ccenter.x=1.5; Ccenter.y=3.0; Ccenter.z=-8.0;
  Cview.x=0.0;   Cview.y=-0.2;   Cview.z=0.8;
  Cup.x=0.0;     Cup.y=1.0;     Cup.z=0.0;

  ctr1.x=20.0;  ctr1.y=20.0; ctr1.z=-40.0;
  ctr2.x=-20.0; ctr2.y=20.0; ctr2.z=-40.0;
  
  tex1.col.r=1.0;
  tex1.col.g=0.5;
  tex1.col.b=0.0;
  tex1.ambient=1.0;
  tex1.opacity=1.0;
  tex2=tex1;
  tex2.col.r=0.0;
  tex2.col.b=1.0;

  initspheres();
   
  for (i=0; i<MAXFRAMES; i++) {  
    sprintf(fname,".%4.4d.tga",i);
    strcpy(fname2,RFILE);
    strcat(fname2, fname);

    rt_initialize(&argc, &argv); 
    if (rt_mynode()==0) printf("Rendering: %s \n",fname2);

    rt_outputfile(scene, fname2);
    rt_resolution(scene, xres, yres);
    rt_verbose(scene, verbosemode);

    rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth,
      Ccenter, Cview, Cup);

    rt_light(scene, rt_texture(scene, &tex1), ctr1, 1.0);
    rt_light(scene, rt_texture(scene, &tex2), ctr2, 1.0);
    movesp(i);  
    drawsp(scene);

    rt_renderscene(scene);
  }

  return 0;
}
   
/* main.c 
 * This file contains the main program and driver for the raytracer.
 *
 *  $Id: animspheres.c,v 1.13 2002/07/03 04:59:28 johns Exp $
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tachyon.h"

int rt_mynode(void); /* proto */

/* Number of frames to render */
#define MAXFRAMES 400

/* Number of bouncing spheres */
#define NUMSP 16 

/* NTSC Resolution */
/* #define XRES 640 
   #define YRES 480
*/

/* MPEG-1 Resolution */
#define XRES 352
#define YRES 240

#define MAXX 1.0 
#define MAXY 1.0 
#define MAXZ 1.0 

#define MINX -1.0
#define MINY -1.0
#define MINZ -1.0

#define LOOP 200.0
#define LOOP2 100.0
#define RAD 6.28

typedef struct {
     apitexture tex;
      apivector ctr;
         apiflt rad; 
      apivector dir;
     void * voidtex;
} asphere;

asphere sp[NUMSP];

apiflt randflt(void) {
  long a;
  apiflt f;
 
  a=rand() % 1000;

  f=(a*1.0) / 1000.0;
  return f; 
}


void initspheres(void) {
  int i;
  apiflt t1;

  for (i=0; i<NUMSP; i++) {
   sp[i].tex.col.r=randflt() / 3.0 + 0.66;         
   sp[i].tex.col.g=randflt() / 3.0 + 0.66;         
   sp[i].tex.col.b=randflt() / 3.0 + 0.66;         
   t1=randflt()*0.9;
   
   sp[i].tex.ambient=0.1;
   sp[i].tex.diffuse=t1;
   sp[i].tex.specular=0.9 - t1;
   sp[i].tex.opacity=1.0;
   
   sp[i].tex.scale.x=1.0;
   sp[i].tex.scale.y=1.0;
   sp[i].tex.scale.z=1.0;

   sp[i].tex.rot.x=0.0;
   sp[i].tex.rot.y=0.0;
   sp[i].tex.rot.z=0.0;
   sp[i].tex.texturefunc=rand() % 7;

   sp[i].ctr.x=randflt() * 2.0 - 1.0;
   sp[i].ctr.y=randflt() * 2.0 - 1.0;
   sp[i].ctr.z=randflt() * 2.0 - 1.0;

   sp[i].rad=randflt()*0.5 + 0.05;
   
   sp[i].dir.x=randflt() * 0.05 - 0.02; 
   sp[i].dir.y=randflt() * 0.05 - 0.02; 
   sp[i].dir.z=randflt() * 0.05 - 0.02; 
  }
}

void movesp(void) {
  int i;

  for (i=0; i<NUMSP; i++) {
    sp[i].ctr.x += sp[i].dir.x;
    sp[i].ctr.y += sp[i].dir.y;
    sp[i].ctr.z += sp[i].dir.z;
 
    if (sp[i].ctr.x > MAXX) {
      sp[i].ctr.x = MAXX;
      sp[i].dir.x = -sp[i].dir.x;
    }
    if (sp[i].ctr.x < MINX) {
      sp[i].ctr.x = MINX;
      sp[i].dir.x = -sp[i].dir.x;
    }

    if (sp[i].ctr.y > MAXY) {
      sp[i].ctr.y = MAXY;
      sp[i].dir.y = -sp[i].dir.y;
    }
    if (sp[i].ctr.y < MINY) {
      sp[i].ctr.y = MINY;
      sp[i].dir.y = -sp[i].dir.y;
    }

    if (sp[i].ctr.z > MAXZ) {
      sp[i].ctr.z = MAXZ;
      sp[i].dir.z = -sp[i].dir.z;
    }
    if (sp[i].ctr.z < MINZ) {
      sp[i].ctr.z = MINZ;
      sp[i].dir.z = -sp[i].dir.z;
    }
    sp[i].tex.ctr.x = sp[i].dir.x;
    sp[i].tex.ctr.y = sp[i].dir.y;
    sp[i].tex.ctr.z = sp[i].dir.z;
  }
}

void drawsp(SceneHandle scene) {
  int i;
  apitexture p1;  
  apivector ct1, n1;

  for (i=0; i<NUMSP; i++) {
    sp[i].voidtex = rt_texture(scene, &sp[i].tex);
    rt_sphere(scene, sp[i].voidtex, sp[i].ctr, sp[i].rad);   
  }

  p1.col.r=1.0;
  p1.col.g=1.0;
  p1.col.b=1.0;
  p1.ambient=0.1;
  p1.diffuse=0.5;
  p1.specular=0.4;
  p1.opacity=1.0;
 
  ct1.x=0.0;
  ct1.y=-1.10;
  ct1.z=0.0;

  n1.x=0.0;
  n1.y=1.0;
  n1.z=0.0;
 
  rt_plane(scene, rt_texture(scene, &p1), ct1, n1);  
}

int main(int argc, char **argv) {
  SceneHandle scene;
  int i, j;
  apivector Ccenter, Cview, Cup;
  apivector ctr1, ctr2;
  apitexture tex1, tex2;
  void * vtx1, * vtx2;
  char fname[100];

  rt_initialize(&argc, &argv); 

  Ccenter.x=0.0; Ccenter.y=0.0; Ccenter.z=-3.0;
  Cview.x=0.0;   Cview.y=0.0;   Cview.z=1.0;
  Cup.x=0.0;     Cup.y=1.0;     Cup.z=0.0;

  ctr1.x=20.0;  ctr1.y=20.0; ctr1.z=-40.0;
  ctr2.x=-20.0; ctr2.y=20.0; ctr2.z=-40.0;
  
  tex1.col.r=1.0;
  tex1.col.g=0.5;
  tex1.col.b=0.0;
  tex1.ambient=1.0;
  tex1.opacity=1.0;
  tex2=tex1;
  tex2.col.r=0.0;
  tex2.col.b=1.0;

  initspheres();
  
 
  for (i=0; i<MAXFRAMES; i++) {  
    scene = rt_newscene();
    vtx1=rt_texture(scene, &tex1);
    vtx2=rt_texture(scene, &tex2);

    sprintf(fname,"outfile.%4.4d.tga",i);

    if (rt_mynode()==0) printf("Rendering: %s\n", fname);

    rt_outputfile(scene, fname);
    rt_resolution(scene, XRES, YRES);
    rt_verbose(scene, 0);

    rt_camera_setup(scene, 1.0, 1.0, 0, 5, Ccenter, Cview, Cup);

    movesp(); 
    drawsp(scene);

    rt_light(scene, vtx1, ctr1, 1.0);
    rt_light(scene, vtx2, ctr2, 1.0);

    rt_renderscene(scene);

    rt_deletescene(scene);

    for (j=0; j<NUMSP; j++)
      free(sp[i].voidtex);  
  }

  rt_finalize();

  return 0;
}
   
/*
 * api.c - This file contains all of the API calls that are defined for
 *         external driver code to use.  
 * 
 *  $Id: api.c,v 1.131 2004/02/03 06:09:11 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"

#include "parallel.h"
#include "threads.h"

#include "box.h"
#include "cylinder.h"
#include "plane.h"
#include "quadric.h"
#include "ring.h"
#include "sphere.h"
#include "triangle.h"
#include "vol.h"
#include "extvol.h"

#include "texture.h"
#include "light.h"
#include "render.h"
#include "trace.h"
#include "camera.h"
#include "vector.h"
#include "intersect.h"
#include "shade.h"
#include "util.h"
#include "imap.h"
#include "global.h"
#include "ui.h"
#include "shade.h"

typedef void * SceneHandle;
typedef vector apivector;
typedef color  apicolor;

typedef struct {
  int texturefunc; /* which texture function to use */
  apicolor col;    /* base object color */
  int shadowcast;  /* does the object cast a shadow */
  apiflt ambient;  /* ambient lighting */
  apiflt diffuse;  /* diffuse reflection */
  apiflt specular; /* specular reflection */
  apiflt opacity;  /* how opaque the object is */
  apivector ctr;   /* origin of texture */
  apivector rot;   /* rotation of texture around origin */ 
  apivector scale; /* scale of texture on x,y,z */
  apivector uaxs;  /* planar map U axis */
  apivector vaxs;  /* planar map V axis */
  char * imap[96]; /* name of image map*/
} apitexture;

apivector rt_vector(apiflt x, apiflt y, apiflt z) {
  apivector v;

  v.x = x;
  v.y = y;
  v.z = z;

  return v;
}

apicolor rt_color(float r, float g, float b) {
  apicolor c;
  
  c.r = r;
  c.g = g;
  c.b = b;
  
  return c;
}

int rt_initialize(int * argc, char ***argv) {
  InitTextures();

  if (!parinitted) {
    rt_par_init(argc, argv); 
    parinitted=1;
  }

  return rt_mynode(); /* return our node id */ 
}

void rt_finalize(void) {
  rt_par_finish();
}

void rt_renderscene(SceneHandle voidscene) {
  scenedef * scene = (scenedef *) voidscene;
  renderscene(scene);
}

void rt_aa_maxsamples(SceneHandle voidscene, int maxsamples) {
  scenedef * scene = (scenedef *) voidscene;

  if (maxsamples >= 0)
    scene->antialiasing=maxsamples;
  else  
    scene->antialiasing=0;
}

void rt_camera_setup(SceneHandle voidscene, apiflt zoom, apiflt aspectratio, 
	int antialiasing, int raydepth, 
	apivector camcent, apivector viewvec, apivector upvec) {
  scenedef * scene = (scenedef *) voidscene;

  camerasetup(scene, zoom, camcent, viewvec, upvec);

  scene->aspectratio=aspectratio;

  rt_aa_maxsamples(voidscene, antialiasing);

  scene->raydepth=raydepth; 
}

void rt_camera_projection(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;
  cameraprojection(&scene->camera, mode);
}

void rt_camera_dof(SceneHandle voidscene, flt focallength, flt aperture) {
  scenedef * scene = (scenedef *) voidscene;
  cameradof(&scene->camera, focallength, aperture);
}

void rt_camera_position(SceneHandle voidscene, apivector camcent, 
                        apivector viewvec, apivector upvec) {
  scenedef * scene = (scenedef *) voidscene;
  cameraposition(&scene->camera, camcent, viewvec, upvec);
}

void rt_get_camera_position(SceneHandle voidscene, apivector * camcent, 
                        apivector * viewvec, apivector * upvec, apivector * rightvec) {
  scenedef * scene = (scenedef *) voidscene;
  
  getcameraposition(&scene->camera, camcent, viewvec, upvec, rightvec);
}

void rt_camera_frustum(SceneHandle voidscene, flt left, flt right, flt bottom, flt top) {
  scenedef * scene = (scenedef *) voidscene;
  camerafrustum(&scene->camera, left, right, bottom, top);
}

void rt_outputfile(SceneHandle voidscene, const char * outname) {
  scenedef * scene = (scenedef *) voidscene;
  if (strlen(outname) > 0) {
    strcpy((char *) &scene->outfilename, outname);
    scene->writeimagefile = 1;
  }
  else {
    scene->writeimagefile = 0;
  }
}

void rt_outputformat(SceneHandle voidscene, int format) {
  scenedef * scene = (scenedef *) voidscene;
  scene->imgformat = format; 
}

void rt_resolution(SceneHandle voidscene, int hres, int vres) {
  scenedef * scene = (scenedef *) voidscene;
  scene->hres=hres;
  scene->vres=vres;
  scene->scenecheck = 1;
}

void rt_get_resolution(SceneHandle voidscene, int *hres, int *vres) {
  scenedef * scene = (scenedef *) voidscene;
  *hres = scene->hres;
  *vres = scene->vres;
}

void rt_verbose(SceneHandle voidscene, int v) {
  scenedef * scene = (scenedef *) voidscene;
  scene->verbosemode = v;
}

void rt_rawimage(SceneHandle voidscene, unsigned char *img) {
  scenedef * scene = (scenedef *) voidscene;
  scene->img = img;
  scene->imginternal = 0;
  scene->scenecheck = 1;
}

void rt_set_numthreads(SceneHandle voidscene, int numthreads) {
  scenedef * scene = (scenedef *) voidscene;
#ifdef THR
  if (numthreads > 0) {
    scene->numthreads = numthreads;
  }
  else {
    scene->numthreads = NUM_THREADS; /*rt_thread_numprocessors();*/
  }

  /* force set of # kernel threads  */
  rt_thread_setconcurrency(scene->numthreads);

#else
  scene->numthreads = 1;
#endif
  scene->scenecheck = 1;
}

void rt_background(SceneHandle voidscene, apicolor col) {
  scenedef * scene = (scenedef *) voidscene;
  scene->background.r = col.r;
  scene->background.g = col.g;
  scene->background.b = col.b;
}

void rt_fog_parms(SceneHandle voidscene, apicolor col, apiflt start, apiflt end, apiflt density) {
  scenedef * scene = (scenedef *) voidscene;
  scene->fog.col = col;
  scene->fog.start = start;
  scene->fog.end = end;
  scene->fog.density = density;
}

void rt_fog_mode(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;

  switch (mode) {
    case RT_FOG_LINEAR:
      scene->fog.fog_fctn = fog_color_linear;
      break;

    case RT_FOG_EXP:
      scene->fog.fog_fctn = fog_color_exp;
      break;

    case RT_FOG_EXP2:
      scene->fog.fog_fctn = fog_color_exp2;
      break;

    case RT_FOG_NONE: 
    default:
      scene->fog.fog_fctn = NULL;
      break;
  }
}

void rt_trans_mode(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;
  scene->transmode = mode; 
}

void rt_boundmode(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;
  scene->boundmode = mode;
  scene->scenecheck = 1;
}

void rt_boundthresh(SceneHandle voidscene, int threshold) {
  scenedef * scene = (scenedef *) voidscene;
 
  if (threshold > 1) {
    scene->boundthresh = threshold;
  }
  else {
    if (rt_mynode() == 0) {
      rt_ui_message(MSG_0, "Out-of-range automatic bounding threshold.\n");
      rt_ui_message(MSG_0, "Automatic bounding threshold reset to default.\n");
    }
    scene->boundthresh = BOUNDTHRESH;
  }
  scene->scenecheck = 1;
}

void rt_shadermode(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;

  /* Main shader used for whole scene */
  switch (mode) {
    case RT_SHADER_LOWEST:
      scene->shader = (color (*)(void *)) lowest_shader;
      break;
    case RT_SHADER_LOW:
      scene->shader = (color (*)(void *)) low_shader;
      break;
    case RT_SHADER_MEDIUM:
      scene->shader = (color (*)(void *)) medium_shader;
      break;
    case RT_SHADER_HIGH:
      scene->shader = (color (*)(void *)) full_shader;
      break;
    case RT_SHADER_FULL:
      scene->shader = (color (*)(void *)) full_shader;
      break;
    case RT_SHADER_AUTO:
    default:
      scene->shader = NULL;
      break;
  }
}

void rt_phong_shader(SceneHandle voidscene, int mode) {
  scenedef * scene = (scenedef *) voidscene;
  switch (mode) {
    case RT_SHADER_NULL_PHONG:
      scene->phongfunc = shade_nullphong;
      break;
    case RT_SHADER_BLINN_FAST:
      scene->phongfunc = shade_blinn_fast;
      break;
    case RT_SHADER_BLINN:
      scene->phongfunc = shade_blinn;
      break;
    default: 
    case RT_SHADER_PHONG:
      scene->phongfunc = shade_phong;
      break;
  }
}

SceneHandle rt_newscene(void) {
  scenedef * scene;
  SceneHandle voidscene;
  apicolor bgcolor;

  bgcolor.r = 0.0;
  bgcolor.g = 0.0;
  bgcolor.b = 0.0;

  scene = (scenedef *) malloc(sizeof(scenedef));
  memset(scene, 0, sizeof(scenedef));             /* clear all valuas to 0  */

  voidscene = (SceneHandle) scene;

  rt_outputfile(voidscene, "/tmp/outfile.tga");   /* default output file    */
  rt_outputformat(voidscene, RT_FORMAT_TARGA);    /* default iamge format   */
  rt_resolution(voidscene, 512, 512);             /* 512x512 resolution     */
  rt_verbose(voidscene, 0);                       /* verbose messages off   */
  rt_rawimage(voidscene, NULL);                   /* raw image output off   */
  rt_boundmode(voidscene, RT_BOUNDING_ENABLED);   /* spatial subdivision on */
  rt_boundthresh(voidscene, BOUNDTHRESH);         /* default threshold      */
  rt_camera_setup(voidscene, 1.0, 1.0, 0, 6,
                  rt_vector(0.0, 0.0, 0.0),
                  rt_vector(0.0, 0.0, 1.0),
                  rt_vector(0.0, 1.0, 0.0));
  rt_camera_dof(voidscene, 1.0, 0.0);
  rt_shadermode(voidscene, RT_SHADER_AUTO);
  rt_phong_shader(voidscene, RT_SHADER_BLINN);

  rt_background(voidscene, bgcolor);
  rt_fog_mode(voidscene, RT_FOG_NONE);
  rt_fog_parms(voidscene, bgcolor, 0.0, 1.0, 1.0);
  rt_trans_mode(voidscene, RT_TRANS_ORIG);

  scene->objgroup.boundedobj = NULL;
  scene->objgroup.unboundedobj = NULL;
  scene->objgroup.numobjects = 0;

  scene->texlist = NULL;
  scene->lightlist = NULL;
  scene->numlights = 0;
  scene->scenecheck = 1;
  scene->parbuf = NULL;
  scene->threads = NULL;
  scene->threadparms = NULL;
 
  rt_set_numthreads(voidscene, -1);         /* auto determine num threads */ 

  /* number of distributed memory nodes, fills in array of node/cpu info */
  scene->nodes = rt_getcpuinfo(&scene->cpuinfo);
  scene->mynode = rt_mynode();

  return scene;
}



void rt_deletescene(SceneHandle voidscene) {
  scenedef * scene = (scenedef *) voidscene;
  list * cur, * next;

  if (scene != NULL) {
    if (scene->imginternal) {
      free(scene->img);
    }

    /* tear down and deallocate persistent rendering threads */
    destroy_render_threads(scene);

    /* tear down and deallocate persistent scanline receives */
    if (scene->parbuf != NULL)
      rt_delete_scanlinereceives(scene->parbuf);

    free(scene->cpuinfo);
    free_objects(scene->objgroup.boundedobj);
    free_objects(scene->objgroup.unboundedobj);

    cur = scene->lightlist;
    while (cur != NULL) {
      next = cur->next;
      free(cur); /* we don't free list contents, other code did this already */
      cur = next;
    }    

    cur = scene->texlist;
    while (cur != NULL) {
      next = cur->next;
      free(cur->item); /* free texture */
      free(cur);       /* free list entry */
      cur = next;
    }    

    free(scene);
  }
}

void apitextotex(apitexture * apitex, texture * tx) {
  standard_texture * tex = (standard_texture *) tx;
 
  switch(apitex->texturefunc) {
    case RT_TEXTURE_3D_CHECKER: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(checker_texture);
      break;

    case RT_TEXTURE_GRIT: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(grit_texture);
      break;

    case RT_TEXTURE_MARBLE: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(marble_texture);
      break;

    case RT_TEXTURE_WOOD: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(wood_texture);
      break;

    case RT_TEXTURE_GRADIENT: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(gnoise_texture);
      break;
	
    case RT_TEXTURE_CYLINDRICAL_CHECKER: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(cyl_checker_texture);
      break;

    case RT_TEXTURE_CYLINDRICAL_IMAGE: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(image_cyl_texture);
      tex->img=LoadMIPMap((char *) apitex->imap);
      break;

    case RT_TEXTURE_SPHERICAL_IMAGE: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(image_sphere_texture);
      tex->img=LoadMIPMap((char *) apitex->imap);
      break;

    case RT_TEXTURE_PLANAR_IMAGE: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(image_plane_texture);
      tex->img=LoadMIPMap((char *) apitex->imap);
      break;

    case RT_TEXTURE_CONSTANT: 
    default: 
      tex->texfunc=(color(*)(const void *, const void *, void *))(constant_texture);
      break;
  }

       tex->ctr = apitex->ctr;
       tex->rot = apitex->rot;
     tex->scale = apitex->scale;
      tex->uaxs = apitex->uaxs;
      tex->vaxs = apitex->vaxs;
   tex->ambient = apitex->ambient;
   tex->diffuse = apitex->diffuse;
  tex->specular = apitex->specular;
   tex->opacity = apitex->opacity;
       tex->col = apitex->col; 

  tex->flags = RT_TEXTURE_SHADOWCAST;
  tex->phong = 0.0;
  tex->phongexp = 0.0;
  tex->phongtype = 0;
}

void * rt_texture(SceneHandle sc, apitexture * apitex) {
  scenedef * scene = (scenedef *) sc;
  texture * tex;
  list * lst;

  tex=malloc(sizeof(standard_texture));
  apitextotex(apitex, tex); 

  /* add texture to the scene texture list */
  lst = (list *) malloc(sizeof(list));
  lst->item = (void *) tex;
  lst->next = scene->texlist;
  scene->texlist = lst;

  return(tex);
}

void rt_tex_color(void * voidtex, apicolor col) {
  standard_texture * tex = (standard_texture *) voidtex;
  tex->col = col;
}

void rt_tex_phong(void * voidtex, apiflt phong, apiflt phongexp, int type) {
  texture * tex = (texture *) voidtex;
  tex->phong = phong;
  tex->phongexp = phongexp;
  tex->phongtype = type;
}

static void add_bounded_object(scenedef * scene, object * obj) {
  object * objtemp;

  if (obj == NULL)
    return;

  obj->id = new_objectid(scene);

  objtemp = scene->objgroup.boundedobj;
  scene->objgroup.boundedobj = obj;
  obj->nextobj = objtemp;

  scene->scenecheck = 1;
}

static void add_unbounded_object(scenedef * scene, object * obj) {
  object * objtemp;

  if (obj == NULL)
    return;

  obj->id = new_objectid(scene);

  objtemp = scene->objgroup.unboundedobj;
  scene->objgroup.unboundedobj = obj;
  obj->nextobj = objtemp;

  scene->scenecheck = 1;
}

void * rt_light(SceneHandle voidscene, void * tex, apivector ctr, apiflt rad) {
  point_light * li;
  scenedef * scene = (scenedef *) voidscene;
  list * lst;

  li=newpointlight(tex, ctr, rad);

  /* add light to the scene lightlist */
  lst = (list *) malloc(sizeof(list));
  lst->item = (void *) li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights++;

  /* add light as an object as well... */
  add_bounded_object((scenedef *) scene, (object *)li);

  return li;
}

void * rt_directional_light(SceneHandle voidscene, void * tex, apivector dir) {
  directional_light * li;
  scenedef * scene = (scenedef *) voidscene;
  list * lst;

  VNorm(&dir);
  li=newdirectionallight(tex, dir);

  /* add light to the scene lightlist */
  lst = (list *) malloc(sizeof(list));
  lst->item = (void *) li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights++;

  return li;
}

void * rt_spotlight(SceneHandle voidscene, void * tex, apivector ctr, apiflt rad, apivector dir,
                  apiflt start, apiflt end) {
  flt fallstart, fallend;
  point_light * li;
  scenedef * scene = (scenedef *) voidscene;
  list * lst;

  fallstart = start * 3.1415926 / 180.0;
  fallend   = end   * 3.1415926 / 180.0;
  VNorm(&dir);
  li = newspotlight(tex, ctr, rad, dir, fallstart, fallend);

  /* add light to the scene lightlist */
  lst = (list *) malloc(sizeof(list));
  lst->item = (void *) li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights++;
 
  /* add light as an object as well... */
  add_bounded_object(scene, (object *) li);

  return li;
}

void rt_light_attenuation(void * vli, apiflt Kc, apiflt Kl, apiflt Kq) {
  light_set_attenuation((point_light *) vli, Kc, Kl, Kq);
}

void rt_scalarvol(SceneHandle scene, void * tex, apivector min, apivector max,
	int xs, int ys, int zs, const char * fname, scalarvol * invol) {
  add_bounded_object((scenedef *) scene, (object *) newscalarvol(tex, min, max, xs, ys, zs, fname, invol));
}

void rt_extvol(SceneHandle scene, void * tex, apivector min, apivector max, int samples, flt (* evaluator)(flt, flt, flt)) {
  add_bounded_object((scenedef *) scene, (object *) newextvol(tex, min, max, samples, evaluator));
}

void rt_box(SceneHandle scene, void * tex, apivector min, apivector max) {
  add_bounded_object((scenedef *) scene, (object *) newbox(tex, min, max));
} 

void rt_cylinder(SceneHandle scene, void * tex, apivector ctr, apivector axis, apiflt rad) {
  add_unbounded_object((scenedef *) scene, newcylinder(tex, ctr, axis, rad));
}

void rt_fcylinder(SceneHandle scene, void * tex, apivector ctr, apivector axis, apiflt rad) {
  add_bounded_object((scenedef *) scene, newfcylinder(tex, ctr, axis, rad));
}

void rt_plane(SceneHandle scene, void * tex, apivector ctr, apivector norm) {
  add_unbounded_object((scenedef *) scene, newplane(tex, ctr, norm));
} 

void rt_ring(SceneHandle scene, void * tex, apivector ctr, apivector norm, apiflt a, apiflt b) {
  add_bounded_object((scenedef *) scene, newring(tex, ctr, norm, a, b));
} 

void rt_sphere(SceneHandle scene, void * tex, apivector ctr, apiflt rad) {
  add_bounded_object((scenedef *) scene, newsphere(tex, ctr, rad));
}

void rt_tri(SceneHandle scene, void * tex, apivector v0, apivector v1, apivector v2) {
  add_bounded_object((scenedef *) scene, newtri(tex, v0, v1, v2));
} 

void rt_stri(SceneHandle scene, void * tex, apivector v0, apivector v1, apivector v2, 
		apivector n0, apivector n1, apivector n2) {
  add_bounded_object((scenedef *) scene, newstri(tex, v0, v1, v2, n0, n1, n2));
} 

void rt_vcstri(SceneHandle scene, void * tex, apivector v0, apivector v1, apivector v2, 
		apivector n0, apivector n1, apivector n2,
		apicolor c0, apicolor c1, apicolor c2) {
  add_bounded_object((scenedef *) scene, newvcstri(tex, v0, v1, v2, n0, n1, n2, c0, c1, c2));
} 

void rt_quadsphere(SceneHandle scene, void * tex, apivector ctr, apiflt rad) {
  quadric * q;
  flt factor;
  q=(quadric *) newquadric();
  factor= 1.0 / (rad*rad);
  q->tex=tex;
  q->ctr=ctr;
 
  q->mat.a=factor;
  q->mat.b=0.0;
  q->mat.c=0.0;
  q->mat.d=0.0;
  q->mat.e=factor;
  q->mat.f=0.0;
  q->mat.g=0.0;
  q->mat.h=factor;
  q->mat.i=0.0;
  q->mat.j=-1.0;
 
  add_unbounded_object((scenedef *) scene, (object *)q);
}



/*
 * apigeom.c - This file contains all of the API calls that are defined for
 *         external driver code to use.  
 * 
 *  $Id: apigeom.c,v 1.8 2001/12/06 07:01:59 johns Exp $
 */

#include "machine.h"
#include "tachyon.h"

void VNorm(apivector *); /* hack proto, should fix later */

void rt_polycylinder(SceneHandle scene, void * tex, apivector * points, int numpts, apiflt rad) {
  apivector a;
  int i;

  if ((points == NULL) || (numpts == 0)) {
    return;
  }

  if (numpts > 0) {
    rt_sphere(scene, tex, points[0], rad);
    
    if (numpts > 1) {
      for (i=1; i<numpts; i++) {
        a.x = points[i].x - points[i-1].x;
        a.y = points[i].y - points[i-1].y;
        a.z = points[i].z - points[i-1].z;
        
        rt_fcylinder(scene, tex, points[i-1], a, rad);
        rt_sphere(scene, tex, points[i], rad);
      }
    }
  }
}

void rt_heightfield(SceneHandle scene, void * tex, apivector ctr, int m, int n, 
                    apiflt * field, apiflt wx, apiflt wy) {
  int xx,yy; 
  apivector v0, v1, v2; 
  apiflt xoff, yoff, zoff;

  xoff=ctr.x - (wx / 2.0);
  yoff=ctr.z - (wy / 2.0);
  zoff=ctr.y;

  for (yy=0; yy<(n-1); yy++) { 
    for (xx=0; xx<(m-1); xx++) {
      v0.x=wx*(xx    )/(m*1.0) + xoff; 
      v0.y=field[(yy    )*m + (xx    )] + zoff;
      v0.z=wy*(yy    )/(n*1.0) + yoff;

      v1.x=wx*(xx + 1)/(m*1.0) + xoff; 
      v1.y=field[(yy    )*m + (xx + 1)] + zoff;
      v1.z=wy*(yy    )/(n*1.0) + yoff;

      v2.x=wx*(xx + 1)/(m*1.0) + xoff; 
      v2.y=field[(yy + 1)*m + (xx + 1)] + zoff;
      v2.z=wy*(yy + 1)/(n*1.0) + yoff;

      rt_tri(scene, tex, v1, v0, v2);

      v0.x=wx*(xx    )/(m*1.0) + xoff;
      v0.y=field[(yy    )*m + (xx    )] + zoff;
      v0.z=wy*(yy    )/(n*1.0) + yoff;

      v1.x=wx*(xx    )/(m*1.0) + xoff;
      v1.y=field[(yy + 1)*m + (xx    )] + zoff;
      v1.z=wy*(yy + 1)/(n*1.0) + yoff;

      v2.x=wx*(xx + 1)/(m*1.0) + xoff;
      v2.y=field[(yy + 1)*m + (xx + 1)] + zoff;
      v2.z=wy*(yy + 1)/(n*1.0) + yoff;
 
      rt_tri(scene, tex, v0, v1, v2);
    }
  } 
} /* end of heightfield */


static void rt_sheightfield(SceneHandle scene, void * tex, apivector ctr, int m, int n, 
                    apiflt * field, apiflt wx, apiflt wy) {
  apivector * vertices;
  apivector * normals;
  apivector offset;
  apiflt xinc, yinc;
  int x, y, addr; 
   
  vertices = (apivector *) malloc(m*n*sizeof(apivector));
  normals = (apivector *) malloc(m*n*sizeof(apivector));

  offset.x = ctr.x - (wx / 2.0);
  offset.y = ctr.z - (wy / 2.0);
  offset.z = ctr.y;

  xinc = wx / ((apiflt) m-1);
  yinc = wy / ((apiflt) n-1);

  /* build vertex list */
  for (y=0; y<n; y++) { 
    for (x=0; x<m; x++) {
      addr = y*m + x;
      vertices[addr] = rt_vector(
        x * xinc + offset.x,
        field[addr] + offset.z,
        y * yinc + offset.y);
    }
  }

  /* build normals from vertex list */
  for (x=1; x<m; x++) {
    normals[x] = normals[(n - 1)*m + x] = rt_vector(0.0, 1.0, 0.0);
  }
  for (y=1; y<n; y++) {
    normals[y*m] = normals[y*m + (m-1)] = rt_vector(0.0, 1.0, 0.0);
  }
  for (y=1; y<(n-1); y++) {
    for (x=1; x<(m-1); x++) {
      addr = y*m + x;

      normals[addr] = rt_vector(
        -(field[addr + 1] - field[addr - 1]) / (2.0 * xinc), 
        1.0, 
        -(field[addr + m] - field[addr - m]) / (2.0 * yinc));

      VNorm(&normals[addr]);
    }
  }    

  /* generate actual triangles */
  for (y=0; y<(n-1); y++) {
    for (x=0; x<(m-1); x++) {
      addr = y*m + x;

      rt_stri(scene, tex, vertices[addr], vertices[addr + 1 + m], vertices[addr + 1],
                   normals[addr], normals[addr + 1 + m], normals[addr + 1]);
      rt_stri(scene, tex, vertices[addr], vertices[addr + m], vertices[addr + 1 + m],
                   normals[addr], normals[addr + m], normals[addr + 1 + m]);
    }
  }

  free(normals);
  free(vertices);
} /* end of smoothed heightfield */


static void adjust(apiflt *base, int xres, int yres, apiflt wx, apiflt wy, 
                   int xa, int ya, int x, int y, int xb, int yb, 
                   unsigned int *rndval) {
  apiflt d, v, len;
 
  len = sqrt(wx * wx + wy * wy);
 
  if (base[x + (xres*y)]==0.0) { 
    d=(abs(xa - xb) / (xres * 1.0))*wx + (abs(ya - yb) / (yres * 1.0))*wy; 

    v= (base[xa + (xres*ya)] + base[xb + (xres*yb)]) / 2.0 +
       ((((rt_rand(rndval) / RT_RAND_MAX) - 0.5)*d) / 4.0) * (len / 16.0);

    if (v < 0.0) v=0.0; 
    if (v > (xres + yres)) v=(xres + yres);
    base[x + (xres * y)]=v; 
 } 
}

static void subdivide(apiflt *base, int xres, int yres, apiflt wx, apiflt wy,
                      int x1, int y1, int x2, int y2, unsigned int *rndval) {
  int x, y;

  if (((x2 - x1) < 2) && ((y2 - y1) < 2)) { return; }

  x=(x1 + x2) / 2;
  y=(y1 + y2) / 2;

  adjust(base, xres, yres, wx, wy, x1, y1, x, y1, x2, y1, rndval);
  adjust(base, xres, yres, wx, wy, x2, y1, x2, y, x2, y2, rndval);
  adjust(base, xres, yres, wx, wy, x1, y2, x, y2, x2, y2, rndval);
  adjust(base, xres, yres, wx, wy, x1, y1, x1, y, x1, y2, rndval);

 
  if (base[x + xres*y]==0.0) {
    base[x + (xres * y)]=(base[x1 + xres*y1] + base[x2 + xres*y1] +
                          base[x2 + xres*y2] + base[x1 + xres*y2]   )/4.0;
  }
 
  subdivide(base, xres, yres, wx, wy, x1, y1 ,x ,y, rndval);
  subdivide(base, xres, yres, wx, wy, x, y1, x2, y, rndval);
  subdivide(base, xres, yres, wx, wy, x, y, x2, y2, rndval);
  subdivide(base, xres, yres, wx, wy, x1, y, x, y2, rndval);
}

void rt_landscape(SceneHandle scene, void * tex, int m, int n, 
              	apivector ctr, apiflt wx, apiflt wy) {
  int totalsize, x, y;
  apiflt * field; 
  unsigned int rndval; /* random number.. */

  totalsize=m*n;
  rndval = totalsize;
 
  field=(apiflt *) malloc(totalsize*sizeof(apiflt));

  for (y=0; y<n; y++) {
    for (x=0; x<m; x++) {
       field[x + y*m]=0.0;
    }
  }

  field[0 + 0            ] = rt_rand(&rndval) / RT_RAND_MAX;
  field[m - 1            ] = rt_rand(&rndval) / RT_RAND_MAX;
  field[0     + m*(n - 1)] = rt_rand(&rndval) / RT_RAND_MAX;
  field[m - 1 + m*(n - 1)] = rt_rand(&rndval) / RT_RAND_MAX;

  subdivide(field, m, n, wx, wy, 0, 0, m-1, n-1, &rndval);

  rt_sheightfield(scene, tex, ctr, m, n, field, wx, wy);

  free(field);
}

/*
 * apitrigeom.c - This file contains code for generating triangle tesselated
 *                geometry, for use with OpenGL, XGL, etc.
 * 
 *  $Id: apitrigeom.c,v 1.7 2000/08/15 05:32:08 johns Exp $
 */

#include "machine.h"
#include "tachyon.h"
#include "apitrigeom.h"

/* XXX Hack!  This needs cleanup.. */
void VNorm(apivector * a);
void VCross(apivector * a, apivector * b, apivector * c);
void VAddS(apiflt a, apivector * A, apivector * B, apivector * C);
void VAdd(apivector * a, apivector * b, apivector * c);
void VSub(apivector * a, apivector * b, apivector * c);
apiflt VDot(apivector *a, apivector *b);

#define CYLFACETS 36
#define RINGFACETS 36
#define SPHEREFACETS 25

void rt_tri_fcylinder(SceneHandle scene, void * tex, apivector ctr, apivector axis, apiflt rad) {
  apivector x, y, z, tmp;
  double u, v, u2, v2;
  int j;
  apivector p1, p2, p3, p4;
  apivector n1, n2;

  z = axis;
  VNorm(&z);
  tmp.x = z.y - 2.1111111;
  tmp.y = -z.z + 3.14159267;
  tmp.z = z.x - 3.915292342341;
  VNorm(&z);
  VNorm(&tmp);
  VCross(&z, &tmp, &x);
  VNorm(&x);
  VCross(&x, &z, &y);
  VNorm(&y);

  for (j=0; j<CYLFACETS; j++) {
     u = rad * sin((6.28 * j) / (CYLFACETS - 1.0));
     v = rad * cos((6.28 * j) / (CYLFACETS - 1.0));
    u2 = rad * sin((6.28 * (j + 1.0)) / (CYLFACETS - 1.0));
    v2 = rad * cos((6.28 * (j + 1.0)) / (CYLFACETS - 1.0));

    p1.x = p1.y = p1.z = 0.0;
    p4 = p3 = p2 = p1;

    VAddS(u, &x, &p1, &p1);
    VAddS(v, &y, &p1, &p1);
    n1 = p1;
    VNorm(&n1);
    VAddS(1.0, &ctr, &p1, &p1);
  

    VAddS(u2, &x, &p2, &p2);
    VAddS(v2, &y, &p2, &p2);
    n2 = p2;
    VNorm(&n2);
    VAddS(1.0, &ctr, &p2, &p2);

    VAddS(1.0, &axis, &p1, &p3);
    VAddS(1.0, &axis, &p2, &p4);

    rt_stri(scene, tex, p1, p2, p3, n1, n2, n1);
    rt_stri(scene, tex, p3, p2, p4, n1, n2, n2);
  }
}

void rt_tri_cylinder(SceneHandle scene, void * tex, apivector ctr, apivector axis, apiflt rad) {
  rt_fcylinder(scene, tex, ctr, axis, rad);
}

void rt_tri_ring(SceneHandle scene, void * tex, apivector ctr, apivector norm, apiflt a, apiflt b) {
  apivector x, y, z, tmp;
  double u, v, u2, v2;
  int j;
  apivector p1, p2, p3, p4;
  apivector n1, n2;

  z = norm;
  VNorm(&z);
  tmp.x = z.y - 2.1111111;
  tmp.y = -z.z + 3.14159267;
  tmp.z = z.x - 3.915292342341;
  VNorm(&z);
  VNorm(&tmp);
  VCross(&z, &tmp, &x);
  VNorm(&x);
  VCross(&x, &z, &y);
  VNorm(&y);

  for (j=0; j<RINGFACETS; j++) {
     u = sin((6.28 * j) / (RINGFACETS - 1.0));
     v = cos((6.28 * j) / (RINGFACETS - 1.0));
    u2 = sin((6.28 * (j + 1.0)) / (RINGFACETS - 1.0));
    v2 = cos((6.28 * (j + 1.0)) / (RINGFACETS - 1.0));

    p1.x = p1.y = p1.z = 0.0;
    p4 = p3 = p2 = p1;

    VAddS(u, &x, &p1, &p1);
    VAddS(v, &y, &p1, &p1);
    n1 = p1;
    VNorm(&n1);
    VAddS(a, &n1, &ctr, &p1);
    VAddS(b, &n1, &ctr, &p3);

    VAddS(u2, &x, &p2, &p2);
    VAddS(v2, &y, &p2, &p2);
    n2 = p2;
    VNorm(&n2);
    VAddS(a, &n2, &ctr, &p2);
    VAddS(b, &n2, &ctr, &p4);

    rt_stri(scene, tex, p1, p2, p3, norm, norm, norm);
    rt_stri(scene, tex, p3, p2, p4, norm, norm, norm);

  }
} 

void rt_tri_box(SceneHandle scene, void * tex, apivector min, apivector max) {
  /* -XY face */
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(min.x, max.y, min.z), 
                     rt_vector(max.x, max.y, min.z));
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(max.x, max.y, min.z), 
                     rt_vector(max.x, min.y, min.z));

  /* +XY face */
  rt_tri(scene, tex, rt_vector(min.x, min.y, max.z),
                     rt_vector(max.x, max.y, max.z),
                     rt_vector(min.x, max.y, max.z)); 
  rt_tri(scene, tex, rt_vector(min.x, min.y, max.z),
                     rt_vector(max.x, min.y, max.z),
                     rt_vector(max.x, max.y, max.z)); 

  /* -YZ face */
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(min.x, max.y, max.z),
                     rt_vector(min.x, min.y, max.z)); 
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(min.x, max.y, min.z),
                     rt_vector(min.x, max.y, max.z)); 

  /* +YZ face */
  rt_tri(scene, tex, rt_vector(max.x, min.y, min.z),
                     rt_vector(max.x, min.y, max.z),
                     rt_vector(max.x, max.y, max.z));
  rt_tri(scene, tex, rt_vector(max.x, min.y, min.z),
                     rt_vector(max.x, max.y, max.z),
                     rt_vector(max.x, max.y, min.z));

  /* -XZ face */
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(min.x, min.y, max.z), 
                     rt_vector(max.x, min.y, max.z));
  rt_tri(scene, tex, rt_vector(min.x, min.y, min.z),
                     rt_vector(max.x, min.y, max.z), 
                     rt_vector(max.x, min.y, min.z));

  /* +XZ face */
  rt_tri(scene, tex, rt_vector(min.x, max.y, min.z),
                     rt_vector(max.x, max.y, max.z),
                     rt_vector(min.x, max.y, max.z)); 
  rt_tri(scene, tex, rt_vector(min.x, max.y, min.z),
                     rt_vector(max.x, max.y, min.z),
                     rt_vector(max.x, max.y, max.z)); 
}

void rt_tri_sphere(SceneHandle scene, void * tex, apivector ctr, apiflt rad) {
}

void rt_tri_plane(SceneHandle scene, void * tex, apivector ctr, apivector norm) {
  rt_tri_ring(scene, tex, ctr, norm, 0.0, 10000.0);
} 


/*
 * apitrigeom.h - header for functions to generate triangle tesselated 
 *                geometry for use with OpenGL, XGL, etc.
 *
 */

void rt_tri_fcylinder(SceneHandle, void *, apivector, apivector, apiflt);
void rt_tri_cylinder(SceneHandle, void *, apivector, apivector, apiflt);
void rt_tri_ring(SceneHandle, void *, apivector, apivector, apiflt, apiflt);
void rt_tri_plane(SceneHandle, void *, apivector, apivector);
void rt_tri_box(SceneHandle, void *, apivector, apivector);

/* 
 * box.c - This file contains the functions for dealing with boxes.
 *
 *  $Id: box.c,v 1.16 2002/07/09 16:14:30 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "box.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

int box_bbox(void * obj, vector * min, vector * max) {
  box * b = (box *) obj;

  *min = b->min;
  *max = b->max;

  return 1;
}

static object_methods box_methods = {
  (void (*)(const void *, void *))(box_intersect),
  (void (*)(const void *, const void *, const void *, void *))(box_normal),
  box_bbox, 
  free 
};

box * newbox(void * tex, vector min, vector max) {
  box * b;
  
  b=(box *) malloc(sizeof(box));
  memset(b, 0, sizeof(box));
  b->methods = &box_methods;
  b->tex = tex;
  b->min = min; 
  b->max = max;

  return b;
}

void box_intersect(const box * bx, ray * ry) {
  flt a, tx1, tx2, ty1, ty2, tz1, tz2;
  flt tnear, tfar;

  tnear= -FHUGE;
  tfar= FHUGE;

  if (ry->d.x == 0.0) {
    if ((ry->o.x < bx->min.x) || (ry->o.x > bx->max.x)) return;
  }
  else {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if (tx1 > tx2) { a=tx1; tx1=tx2; tx2=a; } 
    if (tx1 > tnear) tnear=tx1;   
    if (tx2 < tfar)   tfar=tx2;   
  } 
  if (tnear > tfar) return; 
  if (tfar < 0.0) return;
  
  if (ry->d.y == 0.0) { 
    if ((ry->o.y < bx->min.y) || (ry->o.y > bx->max.y)) return;
  }
  else {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if (ty1 > ty2) { a=ty1; ty1=ty2; ty2=a; } 
    if (ty1 > tnear) tnear=ty1;   
    if (ty2 < tfar)   tfar=ty2;   
  }
  if (tnear > tfar) return; 
  if (tfar < 0.0) return;
 
  if (ry->d.z == 0.0) { 
    if ((ry->o.z < bx->min.z) || (ry->o.z > bx->max.z)) return;
  }
  else {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if (tz1 > tz2) { a=tz1; tz1=tz2; tz2=a; } 
    if (tz1 > tnear) tnear=tz1;   
    if (tz2 < tfar)   tfar=tz2;   
  }
  if (tnear > tfar) return; 
  if (tfar < 0.0) return;

  ry->add_intersection(tnear, (const object *) bx, ry);
  ry->add_intersection(tfar, (object *) bx, ry);
}

void box_normal(const box * bx, const vector * pnt, const ray * incident, vector * N) {
  vector a, b, c; 
  flt t;
 
  c.x=(bx->max.x + bx->min.x) / 2.0;
  c.y=(bx->max.y + bx->min.y) / 2.0;
  c.z=(bx->max.z + bx->min.z) / 2.0;
 
  VSub((vector *) pnt, &c, N);
  b=(*N);

  a.x=fabs(N->x);
  a.y=fabs(N->y);
  a.z=fabs(N->z);
 
  N->x=0.0;  N->y=0.0;  N->z=0.0;

  t=MYMAX(a.x, MYMAX(a.y, a.z));  

  if (t==a.x) N->x=b.x;  

  if (t==a.y) N->y=b.y; 

  if (t==a.z) N->z=b.z;

  VNorm(N);
}

/* 
 * box.h - This file contains the defines for boxes etc.
 *
 *  $Id: box.h,v 1.8 2002/08/04 21:43:34 johns Exp $
 */

 
typedef struct {
  RT_OBJECT_HEAD
  vector min;
  vector max;
} box; 


box * newbox(void * tex, vector min, vector max);
void box_intersect(const box *, ray *);
void box_normal(const box *, const vector *, const ray *, vector *);
/*
 * camera.c - This file contains all of the functions for doing camera work.
 *
 *  $Id: camera.c,v 1.42 2003/01/28 05:58:07 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "camera.h"
#include "util.h"
#include "intersect.h"

/* 
 * camera_init()
 *   take camera parameters stored in scene definition and do all 
 *   necessary initialization and whatever pre-calculation can be done. 
 */
void camera_init(scenedef *scene) {
  flt sx, sy;
  
  /* setup function pointer for camera ray generation */
  switch (scene->camera.projection) {
    case RT_PROJECTION_PERSPECTIVE:
      if (scene->antialiasing > 0) {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_aa_perspective_ray;
      } else {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_perspective_ray;
      }
      break;

    case RT_PROJECTION_PERSPECTIVE_DOF:
      scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_aa_dof_ray;
      break;

    case RT_PROJECTION_ORTHOGRAPHIC:
      if (scene->antialiasing > 0) {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_aa_orthographic_ray;
      } else {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_orthographic_ray;
      }
      break;

    case RT_PROJECTION_FISHEYE:
      if (scene->antialiasing > 0) {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_aa_fisheye_ray;
      } else {
        scene->camera.cam_ray = (color (*)(void *,flt,flt)) cam_fisheye_ray;
      }
      break;
  }

  sx = (flt) scene->hres; 
  sy = (flt) scene->vres;

  /* assuming viewvec is a unit vector, then the center of the */
  /* image plane is the camera center + vievec                 */
  switch (scene->camera.projection) { 
    case RT_PROJECTION_ORTHOGRAPHIC:
      scene->camera.projcent = scene->camera.center;

      /* assuming viewvec is a unit vector, then the lower left    */
      /* corner of the image plane is calculated below             */
      scene->camera.lowleft.x = scene->camera.projcent.x +
        (scene->camera.left   * scene->camera.rightvec.x) +
        (scene->camera.bottom * scene->camera.upvec.x);
      scene->camera.lowleft.y = scene->camera.projcent.y +
        (scene->camera.left   * scene->camera.rightvec.y) +
        (scene->camera.bottom * scene->camera.upvec.y);
      scene->camera.lowleft.z = scene->camera.projcent.z +
        (scene->camera.left   * scene->camera.rightvec.z) +
        (scene->camera.bottom * scene->camera.upvec.z);
      break;
  
    case RT_PROJECTION_PERSPECTIVE_DOF:
      scene->camera.projcent.x = scene->camera.center.x + 
                        (scene->camera.focallength * scene->camera.viewvec.x);
      scene->camera.projcent.y = scene->camera.center.y + 
                        (scene->camera.focallength * scene->camera.viewvec.y);
      scene->camera.projcent.z = scene->camera.center.z + 
                        (scene->camera.focallength * scene->camera.viewvec.z);

      /* assuming viewvec is a unit vector, then the lower left    */
      /* corner of the image plane is calculated below             */
      scene->camera.lowleft.x = scene->camera.projcent.x +
        (scene->camera.left   * scene->camera.rightvec.x) +
        (scene->camera.bottom * scene->camera.upvec.x);
      scene->camera.lowleft.y = scene->camera.projcent.y +
        (scene->camera.left   * scene->camera.rightvec.y) +
        (scene->camera.bottom * scene->camera.upvec.y);
      scene->camera.lowleft.z = scene->camera.projcent.z +
        (scene->camera.left   * scene->camera.rightvec.z) +
        (scene->camera.bottom * scene->camera.upvec.z);
      break;

    case RT_PROJECTION_FISHEYE:
      scene->camera.projcent.x = scene->camera.center.x + 
                        (scene->camera.focallength * scene->camera.viewvec.x);
      scene->camera.projcent.y = scene->camera.center.y + 
                        (scene->camera.focallength * scene->camera.viewvec.y);
      scene->camera.projcent.z = scene->camera.center.z + 
                        (scene->camera.focallength * scene->camera.viewvec.z);

      break;

    case RT_PROJECTION_PERSPECTIVE:
    default:
      scene->camera.projcent.x = scene->camera.center.x + 
                        (scene->camera.focallength * scene->camera.viewvec.x);
      scene->camera.projcent.y = scene->camera.center.y + 
                        (scene->camera.focallength * scene->camera.viewvec.y);
      scene->camera.projcent.z = scene->camera.center.z + 
                        (scene->camera.focallength * scene->camera.viewvec.z);

      /* assuming viewvec is a unit vector, then the lower left    */
      /* corner of the image plane is calculated below             */
      /* for normal perspective rays, we are really storing the    */
      /* direction to the lower left, not the lower left itself,   */
      /* since this allows us to eliminate a subtraction per pixel */
      scene->camera.lowleft.x = scene->camera.projcent.x +
        (scene->camera.left   * scene->camera.rightvec.x) +
        (scene->camera.bottom * scene->camera.upvec.x)
        - scene->camera.center.x;
      scene->camera.lowleft.y = scene->camera.projcent.y +
        (scene->camera.left   * scene->camera.rightvec.y) +
        (scene->camera.bottom * scene->camera.upvec.y)
        - scene->camera.center.y;
      scene->camera.lowleft.z = scene->camera.projcent.z +
        (scene->camera.left   * scene->camera.rightvec.z) +
        (scene->camera.bottom * scene->camera.upvec.z)
        - scene->camera.center.z;
      break;
  }

  /* size of image plane */
  scene->camera.px = scene->camera.right - scene->camera.left; 
  scene->camera.py = scene->camera.top - scene->camera.bottom; 
  scene->camera.psx = scene->camera.px / scene->hres;
  scene->camera.psy = scene->camera.py / scene->vres;

  scene->camera.iplaneright.x = scene->camera.px * scene->camera.rightvec.x / sx;
  scene->camera.iplaneright.y = scene->camera.px * scene->camera.rightvec.y / sx;
  scene->camera.iplaneright.z = scene->camera.px * scene->camera.rightvec.z / sx;
  
  scene->camera.iplaneup.x = scene->camera.py * scene->camera.upvec.x / sy;
  scene->camera.iplaneup.y = scene->camera.py * scene->camera.upvec.y / sy;
  scene->camera.iplaneup.z = scene->camera.py * scene->camera.upvec.z / sy;
}


/* 
 * camray_init() 
 *   initializes a camera ray which will be reused over and over
 *   by the current worker thread.  This includes attaching thread-specific
 *   data to this ray.
 */
void camray_init(scenedef *scene, ray *primary, unsigned long serial, 
                 unsigned long * mbox) {
  primary->add_intersection = add_regular_intersection; /* func ptr */
  primary->serial = serial;
  primary->mbox = mbox;
  primary->scene = scene;
  primary->depth = scene->raydepth;
  primary->randval = 12345678; /* random number seed */

  /* orthographic ray direction is always coaxial with view direction */
  primary->d = scene->camera.viewvec; 

  /* for perspective rendering without depth of field */
  primary->o = scene->camera.center;
}


#if 0
/*
 * cam_aa_dof_ray() 
 *  Generate a perspective camera ray incorporating
 *  antialiasing and depth-of-field.
 */
color cam_aa_dof_ray(ray * ry, flt x, flt y) {
  color col, sample;
  color colsum, colsumsq, colvar;
  int samples, samplegroup; 
  scenedef * scene=ry->scene;
  flt dx, dy, rnsamples, ftmp;
  flt maxvar;

  sample=cam_dof_ray(ry, x, y);     /* generate primary ray */
  colsum = sample;                  /* accumulate first sample */
  colsumsq.r = colsum.r * colsum.r; /* accumulate first squared sample */
  colsumsq.g = colsum.g * colsum.g;
  colsumsq.b = colsum.b * colsum.b;

  /* perform antialiasing if enabled.                           */
  /* samples are run through a very simple box filter averaging */
  /* each of the sample pixel colors to produce a final result  */
  /* No special weighting is done based on the jitter values in */
  /* the circle of confusion nor for the jitter within the      */
  /* pixel in the image plane.                                  */ 

  samples = 1; /* only one ray cast so far */
  while (samples < scene->antialiasing) {
#if 0
    samplegroup = scene->antialiasing;
#else
    if (samples > 32) {
      samplegroup = samples + 1;
    } else {
      samplegroup = samples + 32;
    }
#endif

    for (; samples <= samplegroup; samples++) {
      /* calculate random eye aperture offset */
      dx = ((rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5) * 
           ry->scene->camera.aperture * ry->scene->hres; 
      dy = ((rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5) * 
           ry->scene->camera.aperture * ry->scene->vres; 

      /* perturb the eye center by the random aperture offset */
      ry->o.x = ry->scene->camera.center.x + 
                dx * ry->scene->camera.iplaneright.x +
                dy * ry->scene->camera.iplaneup.x;
      ry->o.y = ry->scene->camera.center.y + 
                dx * ry->scene->camera.iplaneright.y +
                dy * ry->scene->camera.iplaneup.y;
      ry->o.z = ry->scene->camera.center.z + 
                dx * ry->scene->camera.iplaneright.z +
                dy * ry->scene->camera.iplaneup.z;

      /* shoot the ray, jittering the pixel position in the image plane */
      sample=cam_dof_ray(ry,
                        x + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5,
                        y + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5);
  
      colsum.r += sample.r;               /* accumulate samples */
      colsum.g += sample.g;
      colsum.b += sample.b;

      colsumsq.r += sample.r * sample.r;  /* accumulate squared samples */
      colsumsq.g += sample.g * sample.g;
      colsumsq.b += sample.b * sample.b;
    }

    /* calculate the variance for the color samples we've taken so far */
    rnsamples = 1.0 / samples;
    ftmp = colsum.r * rnsamples;
    colvar.r = ((colsumsq.r * rnsamples) - ftmp*ftmp) * rnsamples;
    ftmp = colsum.g * rnsamples;
    colvar.g = ((colsumsq.g * rnsamples) - ftmp*ftmp) * rnsamples;
    ftmp = colsum.b * rnsamples;
    colvar.b = ((colsumsq.b * rnsamples) - ftmp*ftmp) * rnsamples;

    maxvar = 0.002; /* default maximum color variance to accept */
 
    /* early exit antialiasing if we're below maximum allowed variance */
    if ((colvar.r < maxvar) && (colvar.g < maxvar) && (colvar.b < maxvar)) {
      break; /* no more samples should be needed, we are happy now */
    } 
  }

  /* average sample colors, back to range 0.0 - 1.0 */ 
  col.r = colsum.r * rnsamples;
  col.g = colsum.g * rnsamples;
  col.b = colsum.b * rnsamples;

  return col;
}


#else

/*
 * cam_aa_dof_ray() 
 *  Generate a perspective camera ray incorporating
 *  antialiasing and depth-of-field.
 */
color cam_aa_dof_ray(ray * ry, flt x, flt y) {
  color col, avcol;
  int alias; 
  scenedef * scene=ry->scene;
  flt scale;
  flt dx, dy;

  col=cam_dof_ray(ry, x, y);   /* generate ray */

  /* perform antialiasing if enabled.                           */
  /* samples are run through a very simple box filter averaging */
  /* each of the sample pixel colors to produce a final result  */
  /* No special weighting is done based on the jitter values in */
  /* the circle of confusion nor for the jitter within the      */
  /* pixel in the image plane.                                  */ 
  for (alias=1; alias <= scene->antialiasing; alias++) {

    /* calculate random eye aperture offset */
    dx = ((rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5) * 
         ry->scene->camera.aperture * ry->scene->hres; 
    dy = ((rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5) * 
         ry->scene->camera.aperture * ry->scene->vres; 

    /* perturb the eye center by the random aperture offset */
    ry->o.x = ry->scene->camera.center.x + 
              dx * ry->scene->camera.iplaneright.x +
              dy * ry->scene->camera.iplaneup.x;
    ry->o.y = ry->scene->camera.center.y + 
              dx * ry->scene->camera.iplaneright.y +
              dy * ry->scene->camera.iplaneup.y;
    ry->o.z = ry->scene->camera.center.z + 
              dx * ry->scene->camera.iplaneright.z +
              dy * ry->scene->camera.iplaneup.z;

    /* shoot the ray, jittering the pixel position in the image plane */
    avcol=cam_dof_ray(ry,
                      x + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5,
                      y + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5);

    col.r += avcol.r;       /* accumulate antialiasing samples */
    col.g += avcol.g;
    col.b += avcol.b;
  }

  /* average sample colors, back to range 0.0 - 1.0 */ 
  scale = 1.0 / (scene->antialiasing + 1.0); 
  col.r *= scale;
  col.g *= scale;
  col.b *= scale;

  return col;
}
#endif

/*
 * cam_dof_ray() 
 *  Generate a perspective camera ray for depth-of-field rendering
 */
color cam_dof_ray(ray * ry, flt x, flt y) {
  flt rdx, rdy, rdz, len;
  scenedef * scene=ry->scene;

  /* starting from the lower left corner of the image plane, we move the   */
  /* center of the pel we're calculating:                       */ 
  /* lowerleft + (rightvec * X_distance) + (upvec * Y_distance) */
  /* rdx/y/z are the ray directions (unnormalized)              */
  rdx = scene->camera.lowleft.x + 
                (x * scene->camera.iplaneright.x) + 
                (y * scene->camera.iplaneup.x) - ry->o.x;

  rdy = scene->camera.lowleft.y + 
                (x * scene->camera.iplaneright.y) + 
                (y * scene->camera.iplaneup.y) - ry->o.y;

  rdz = scene->camera.lowleft.z + 
                (x * scene->camera.iplaneright.z) + 
                (y * scene->camera.iplaneup.z) - ry->o.z;

  /* normalize the ray direction vector */
  len = 1.0 / sqrt(rdx*rdx + rdy*rdy + rdz*rdz);
  ry->d.x = rdx * len;
  ry->d.y = rdy * len;
  ry->d.z = rdz * len;

  /* initialize ray attributes for a primary ray */
  ry->maxdist = FHUGE;         /* unbounded ray */
  ry->opticdist = 0.0;         /* ray is just starting */
  ry->flags = RT_RAY_REGULAR;  /* camera only generates primary rays */
  ry->serial++;                /* increment the ray serial number */

  /* trace the ray */
  reset_intersection(ry);
  intersect_objects(ry);
  return scene->shader(ry);
}


/*
 * cam_aa_perspective_ray() 
 *  Generate a perspective camera ray incorporating antialiasing.
 */
color cam_aa_perspective_ray(ray * ry, flt x, flt y) {
  color col, avcol;
  int alias; 
  scenedef * scene=ry->scene;
  flt scale;
  col=cam_perspective_ray(ry, x, y);   /* generate ray */

  /* perform antialiasing if enabled.                           */
  /* samples are run through a very simple box filter averaging */
  /* each of the sample pixel colors to produce a final result  */
  for (alias=1; alias <= scene->antialiasing; alias++) {
    avcol=cam_perspective_ray(ry,
           x + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5,
           y + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5);

    col.r += avcol.r;       /* accumulate antialiasing samples */
    col.g += avcol.g;
    col.b += avcol.b;
  }

  /* average sample colors, back to range 0.0 - 1.0 */ 
  scale = 1.0 / (scene->antialiasing + 1.0); 
  col.r *= scale;
  col.g *= scale;
  col.b *= scale;

  return col;
}


/*
 * cam_perspective_ray() 
 *  Generate a perspective camera ray, no antialiasing
 */
color cam_perspective_ray(ray * ry, flt x, flt y) {
  flt rdx, rdy, rdz, len;
  scenedef * scene=ry->scene;

  /* starting from the lower left corner of the image plane, we move the   */
  /* center of the pel we're calculating:                       */ 
  /* lowerleft + (rightvec * X_distance) + (upvec * Y_distance) */
  /* rdx/y/z are the ray directions (unnormalized)              */
  rdx = scene->camera.lowleft.x + 
                (x * scene->camera.iplaneright.x) + 
                (y * scene->camera.iplaneup.x);

  rdy = scene->camera.lowleft.y + 
                (x * scene->camera.iplaneright.y) + 
                (y * scene->camera.iplaneup.y);

  rdz = scene->camera.lowleft.z + 
                (x * scene->camera.iplaneright.z) + 
                (y * scene->camera.iplaneup.z);

  /* normalize the ray direction vector */
  len = 1.0 / sqrt(rdx*rdx + rdy*rdy + rdz*rdz);
  ry->d.x = rdx * len;
  ry->d.y = rdy * len;
  ry->d.z = rdz * len;

  /* initialize ray attributes for a primary ray */
  ry->maxdist = FHUGE;         /* unbounded ray */
  ry->opticdist = 0.0;         /* ray is just starting */
  ry->flags = RT_RAY_REGULAR;  /* camera only generates primary rays */
  ry->serial++;                /* increment the ray serial number */

  /* trace the ray */
  reset_intersection(ry);
  intersect_objects(ry);
  return scene->shader(ry);
}


/*
 * cam_aa_orthographic_ray() 
 *  Generate an orthographic camera ray, potentially incorporating
 *  antialiasing.
 */
color cam_aa_orthographic_ray(ray * ry, flt x, flt y) {
  color col, avcol;
  int alias; 
  scenedef * scene=ry->scene;
  flt scale;

  col=cam_orthographic_ray(ry, x, y);   /* generate ray */

  /* perform antialiasing if enabled.                           */
  /* samples are run through a very simple box filter averaging */
  /* each of the sample pixel colors to produce a final result  */
  for (alias=1; alias <= scene->antialiasing; alias++) {
    avcol=cam_orthographic_ray(ry,
           x + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5,
           y + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5);

    col.r += avcol.r;       /* accumulate antialiasing samples */
    col.g += avcol.g;
    col.b += avcol.b;
  }

  /* average sample colors, back to range 0.0 - 1.0 */ 
  scale = 1.0 / (scene->antialiasing + 1.0); 
  col.r *= scale;
  col.g *= scale;
  col.b *= scale;

  return col;
}

/*
 * cam_orthographic_ray() 
 *  Generate an orthographic camera ray, no antialiasing
 */
color cam_orthographic_ray(ray * ry, flt x, flt y) {
  scenedef * scene=ry->scene;

  /* starting from the lower left corner of the image plane, we move the   */
  /* center of the pel we're calculating:                       */ 
  /* lowerleft + (rightvec * X_distance) + (upvec * Y_distance) */
  ry->o.x = scene->camera.lowleft.x + 
                (x * scene->camera.iplaneright.x) + 
                (y * scene->camera.iplaneup.x);

  ry->o.y = scene->camera.lowleft.y + 
                (x * scene->camera.iplaneright.y) + 
                (y * scene->camera.iplaneup.y);

  ry->o.z = scene->camera.lowleft.z + 
                (x * scene->camera.iplaneright.z) + 
                (y * scene->camera.iplaneup.z);

  /* initialize ray attributes for a primary ray */
  ry->maxdist = FHUGE;         /* unbounded ray */
  ry->opticdist = 0.0;         /* ray is just starting */
  ry->flags = RT_RAY_REGULAR;  /* camera only generates primary rays */
  ry->serial++;                /* increment the ray serial number */

  /* trace the ray */
  reset_intersection(ry);
  intersect_objects(ry);
  return scene->shader(ry);
}

/*
 * cam_fisheye_ray() 
 *  Generate a perspective camera ray, no antialiasing
 */
color cam_fisheye_ray(ray * ry, flt x, flt y) {
  flt ax, ay;
  scenedef * scene=ry->scene;

  ax = scene->camera.left   + x * scene->camera.psx;
  ay = scene->camera.bottom + y * scene->camera.psy;

  ry->d.x = cos(ay) * (cos(ax) * scene->camera.viewvec.x + 
                       sin(ax) * scene->camera.rightvec.x) +
            sin(ay) * scene->camera.upvec.x;

  ry->d.y = cos(ay) * (cos(ax) * scene->camera.viewvec.y +
                       sin(ax) * scene->camera.rightvec.y) +
            sin(ay) * scene->camera.upvec.y;

  ry->d.z = cos(ay) * (cos(ax) * scene->camera.viewvec.z +
                       sin(ax) * scene->camera.rightvec.z) +
            sin(ay) * scene->camera.upvec.z;
        
  /* initialize ray attributes for a primary ray */
  ry->maxdist = FHUGE;         /* unbounded ray */
  ry->opticdist = 0.0;         /* ray is just starting */
  ry->flags = RT_RAY_REGULAR;  /* camera only generates primary rays */
  ry->serial++;                /* increment the ray serial number */

  /* trace the ray */
  reset_intersection(ry);
  intersect_objects(ry);
  return scene->shader(ry);
}

/*
 * cam_aa_fisheye_ray() 
 *  Generate a fisheye camera ray, potentially incorporating
 *  antialiasing.
 */
color cam_aa_fisheye_ray(ray * ry, flt x, flt y) {
  color col, avcol;
  int alias; 
  scenedef * scene=ry->scene;
  flt scale;

  col=cam_fisheye_ray(ry, x, y);   /* generate ray */

  /* perform antialiasing if enabled.                           */
  /* samples are run through a very simple box filter averaging */
  /* each of the sample pixel colors to produce a final result  */
  for (alias=1; alias <= scene->antialiasing; alias++) {
    avcol=cam_fisheye_ray(ry,
           x + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5,
           y + (rt_rand(&ry->randval) / RT_RAND_MAX) - 0.5);

    col.r += avcol.r;       /* accumulate antialiasing samples */
    col.g += avcol.g;
    col.b += avcol.b;
  }

  /* average sample colors, back to range 0.0 - 1.0 */ 
  scale = 1.0 / (scene->antialiasing + 1.0); 
  col.r *= scale;
  col.g *= scale;
  col.b *= scale;

  return col;
}


void cameraprojection(camdef * camera, int mode) {
  camera->projection=mode;    
}

void camerafrustum(camdef * camera, flt left, flt right, flt bottom, flt top) {
  camera->left = left;    
  camera->right = right;    
  camera->bottom = bottom;    
  camera->top = top;    
}

void cameradof(camdef * camera, flt focallength, flt aperture) {
  camera->focallength=focallength;    
  camera->aperture=aperture;
}

void camerasetup(scenedef * scene, flt zoom,
        vector center, vector viewvec, vector upvec) {
  flt sx, sy;
  camdef * camera = &scene->camera;
  vector newupvec;
  vector newviewvec;
  vector newrightvec;

  VCross(&upvec, &viewvec, &newrightvec);
  VNorm(&newrightvec);

  VCross(&viewvec, &newrightvec, &newupvec);
  VNorm(&newupvec);

  newviewvec=viewvec;
  VNorm(&newviewvec);

  camera->camzoom=zoom;
  camera->center=center;
  camera->viewvec=newviewvec;
  camera->rightvec=newrightvec;
  camera->upvec=newupvec;

  sx = (flt) scene->hres; 
  sy = (flt) scene->vres;

  /* calculate the width and height of the image plane in world coords */
  /* given the aspect ratio, image resolution, and zoom factor */
  camera->px=((sx / sy) / scene->aspectratio) / scene->camera.camzoom;
  camera->py=1.0 / scene->camera.camzoom;
  camera->psx = camera->px / sx;
  camera->psy = camera->py / sy;

  camera->left   = -0.5 * camera->px;
  camera->right  =  0.5 * camera->px;
  camera->bottom = -0.5 * camera->py;
  camera->top    =  0.5 * camera->py;
  camera->focallength = 1.0;
}


void cameraposition(camdef * camera, vector center, vector viewvec, 
                    vector upvec) {
  vector newupvec;
  vector newviewvec;
  vector newrightvec;

  VCross(&upvec, &viewvec, &newrightvec);
  VNorm(&newrightvec);

  VCross(&viewvec, &newrightvec, &newupvec);
  VNorm(&newupvec);

  newviewvec=viewvec;
  VNorm(&newviewvec);

  camera->center=center;
  camera->viewvec=newviewvec;
  camera->rightvec=newrightvec;
  camera->upvec=newupvec;
}

void getcameraposition(camdef * camera, vector * center, vector * viewvec, 
                    vector * upvec, vector * rightvec) {

  *center = camera->center;
  *viewvec = camera->viewvec;
  *upvec = camera->upvec;
  *rightvec = camera->rightvec;
}


/*
 * camera.h - This file contains the defines for camera routines etc.
 *
 *  $Id: camera.h,v 1.18 2003/01/28 05:58:07 johns Exp $
 */

void camera_init(scenedef *);
void camray_init(scenedef *, ray *, unsigned long, unsigned long *);

void camerasetup(scenedef *, flt, vector, vector, vector);
void cameraprojection(camdef *, int);
void cameradof(camdef *, flt, flt);
void camerafrustum(camdef *, flt, flt, flt, flt);

void cameraposition(camdef * camera, vector center, vector viewvec, 
                    vector upvec);
void getcameraposition(camdef * camera, vector * center, vector * viewvec, 
                    vector * upvec, vector *rightvec);

color cam_aa_perspective_ray(ray *, flt, flt);
color cam_perspective_ray(ray *, flt, flt);
color cam_aa_dof_ray(ray *, flt, flt);
color cam_dof_ray(ray *, flt, flt);
color cam_aa_orthographic_ray(ray *, flt, flt);
color cam_orthographic_ray(ray *, flt, flt);
color cam_fisheye_ray(ray *, flt, flt);
color cam_aa_fisheye_ray(ray *, flt, flt);


/*
 * coordsys.c -  Routines to translate from one coordinate system to another.
 *
 *  $Id: coordsys.c,v 1.2 1995/03/07 03:53:38 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "coordsys.h"

void xytopolar(flt x, flt y, flt rad, flt * u, flt * v) {
  flt r1;
  r1=x*x + y*y;  
  *v=sqrt(r1 / (rad*rad));
  if (y<0.0) 
    *u=1.0 - acos(x/sqrt(r1))/TWOPI;
  else 
    *u= acos(x/sqrt(r1))/TWOPI; 
}

void xyztocyl(vector pnt, flt height, flt * u, flt * v) {
  flt r1;

  r1=pnt.x*pnt.x + pnt.y*pnt.y;

  *v=pnt.z / height;
  if (pnt.y<0.0) 
    *u=1.0 - acos(pnt.x/sqrt(r1))/TWOPI;
  else 
    *u=acos(pnt.x/sqrt(r1))/TWOPI;
}

void xyztospr(vector pnt, flt * u, flt * v) {
  flt r1, phi, theta;
 
  r1=sqrt(pnt.x*pnt.x + pnt.y*pnt.y + pnt.z*pnt.z);

  phi=acos(-pnt.y/r1);   
  *v=phi/3.1415926;

  theta=acos((pnt.x/r1)/sin(phi))/TWOPI;

  if (pnt.z > 0.0) 
    *u = theta;
  else 
    *u = 1 - theta; 
}


/*
 * coordsys.h - defines for coordinate system routines.
 *  
 *  $Id: coordsys.h,v 1.3 1998/05/27 16:32:08 johns Exp $
 */

void xytopolar(flt, flt, flt, flt *, flt *);
void xyztocyl(vector, flt, flt *, flt *);
void xyztospr(vector, flt *, flt *);
/* 
 * cylinder.c - This file contains the functions for dealing with cylinders.
 *
 *  $Id: cylinder.c,v 1.22 2002/07/09 16:14:30 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

#define CYLINDER_PRIVATE 
#include "cylinder.h"

static object_methods cylinder_methods = {
  (void (*)(const void *, void *))(cylinder_intersect),
  (void (*)(const void *, const void *, const void *, void *))(cylinder_normal),
  cylinder_bbox, 
  free 
};

static object_methods fcylinder_methods = {
  (void (*)(const void *, void *))(fcylinder_intersect),
  (void (*)(const void *, const void *, const void *, void *))(cylinder_normal),
  fcylinder_bbox, 
  free 
};


object * newcylinder(void * tex, vector ctr, vector axis, flt rad) {
  cylinder * c;
  
  c=(cylinder *) malloc(sizeof(cylinder));
  memset(c, 0, sizeof(cylinder));
  c->methods = &cylinder_methods;

  c->tex=(texture *) tex;
  c->ctr=ctr;
  c->axis=axis;
  c->rad=rad;
  return (object *) c;
}

static int cylinder_bbox(void * obj, vector * min, vector * max) {
  return 0; /* infinite / unbounded object */
}

static void cylinder_intersect(const cylinder * cyl, ray * ry) {
  vector rc, n, D, O;  
  flt t, s, tin, tout, ln, d; 

  rc.x = ry->o.x - cyl->ctr.x;
  rc.y = ry->o.y - cyl->ctr.y;
  rc.z = ry->o.z - cyl->ctr.z; 

  VCross(&ry->d, &cyl->axis, &n);

  ln=sqrt(n.x*n.x + n.y*n.y + n.z*n.z);    /* finish length calculation */

  if (ln == 0.0) {  /* ray is parallel to the cylinder.. */
    VDOT(d, rc, cyl->axis);         
    D.x = rc.x - d * cyl->axis.x; 
    D.y = rc.y - d * cyl->axis.y;
    D.z = rc.z - d * cyl->axis.z;
    VDOT(d, D, D);
    d = sqrt(d);
    tin = -FHUGE;
    tout = FHUGE;
    /* if (d <= cyl->rad) then ray is inside cylinder.. else outside */
  }

  n.x /= ln;
  n.y /= ln;
  n.z /= ln;

  VDOT(d, rc, n);
  d = fabs(d); 

  if (d <= cyl->rad) {  /* ray intersects cylinder.. */
    VCross(&rc, &cyl->axis, &O);
    VDOT(t, O, n);
    t = - t / ln;
    VCross(&n, &cyl->axis, &O); 

    ln = sqrt(O.x*O.x + O.y*O.y + O.z*O.z);
    O.x /= ln;
    O.y /= ln;
    O.z /= ln;

    VDOT(s, ry->d, O);
    s = fabs(sqrt(cyl->rad*cyl->rad - d*d) / s);
    tin = t - s;
    ry->add_intersection(tin, (object *) cyl, ry); 
    tout = t + s;
    ry->add_intersection(tout, (object *) cyl, ry);
  }
}

static void cylinder_normal(const cylinder * cyl, const vector * pnt, const ray * incident, vector * N) {
  vector a, b;
  flt t, len;

  a.x = pnt->x - cyl->ctr.x;
  a.y = pnt->y - cyl->ctr.y;
  a.z = pnt->z - cyl->ctr.z;

  b=cyl->axis;

  len = sqrt(b.x*b.x + b.y*b.y + b.z*b.z);
  b.x /= len;
  b.y /= len;
  b.z /= len;
 
  VDOT(t, a, b);

  N->x = pnt->x - (b.x * t + cyl->ctr.x); 
  N->y = pnt->y - (b.y * t + cyl->ctr.y);
  N->z = pnt->z - (b.z * t + cyl->ctr.z);

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}

object * newfcylinder(void * tex, vector ctr, vector axis, flt rad) {
  cylinder * c;
  
  c=(cylinder *) malloc(sizeof(cylinder));
  memset(c, 0, sizeof(cylinder));
  c->methods = &fcylinder_methods;

  c->tex=(texture *) tex;
  c->ctr=ctr;
  c->axis=axis;
  c->rad=rad;

  return (object *) c;
}

static int fcylinder_bbox(void * obj, vector * min, vector * max) {
  cylinder * c = (cylinder *) obj;
  vector mintmp, maxtmp;

  mintmp.x = c->ctr.x;
  mintmp.y = c->ctr.y;
  mintmp.z = c->ctr.z;
  maxtmp.x = c->ctr.x + c->axis.x;
  maxtmp.y = c->ctr.y + c->axis.y;
  maxtmp.z = c->ctr.z + c->axis.z;

  min->x = MYMIN(mintmp.x, maxtmp.x);
  min->y = MYMIN(mintmp.y, maxtmp.y);
  min->z = MYMIN(mintmp.z, maxtmp.z);
  min->x -= c->rad;
  min->y -= c->rad;
  min->z -= c->rad;

  max->x = MYMAX(mintmp.x, maxtmp.x);
  max->y = MYMAX(mintmp.y, maxtmp.y);
  max->z = MYMAX(mintmp.z, maxtmp.z);
  max->x += c->rad;
  max->y += c->rad;
  max->z += c->rad;

  return 1;
}


static void fcylinder_intersect(const cylinder * cyl, ray * ry) {
  vector rc, n, O, hit, tmp2, ctmp4;
  flt t, s, tin, tout, ln, d, tmp, tmp3;
 
  rc.x = ry->o.x - cyl->ctr.x;  
  rc.y = ry->o.y - cyl->ctr.y;
  rc.z = ry->o.z - cyl->ctr.z;
 
  VCross(&ry->d, &cyl->axis, &n);
 
  ln=sqrt(n.x*n.x + n.y*n.y + n.z*n.z);    /* finish length calculation */
 
  if (ln == 0.0) {  /* ray is parallel to the cylinder.. */
    return;       /* in this case, we want to miss or go through the "hole" */
  }

  n.x /= ln;
  n.y /= ln;
  n.z /= ln;
 
  VDOT(d, rc, n);
  d = fabs(d);
 
  if (d <= cyl->rad) {  /* ray intersects cylinder.. */
    VCross(&rc, &cyl->axis, &O);
    VDOT(t, O, n);
    t = - t / ln;
    VCross(&n, &cyl->axis, &O);

    ln = sqrt(O.x*O.x + O.y*O.y + O.z*O.z);
    O.x /= ln;
    O.y /= ln;
    O.z /= ln;

    VDOT(s, ry->d, O);
    s = fabs(sqrt(cyl->rad*cyl->rad - d*d) / s);
    tin = t - s;

    RAYPNT(hit, (*ry), tin); 

    ctmp4=cyl->axis;
    VNorm(&ctmp4);

    tmp2.x = hit.x - cyl->ctr.x;   
    tmp2.y = hit.y - cyl->ctr.y;   
    tmp2.z = hit.z - cyl->ctr.z;   

    VDOT(tmp,  tmp2, ctmp4);
    VDOT(tmp3, cyl->axis, cyl->axis);

    if ((tmp > 0.0) && (tmp < sqrt(tmp3))) 
      ry->add_intersection(tin, (object *) cyl, ry);
    tout = t + s;

    RAYPNT(hit, (*ry), tout); 

    tmp2.x = hit.x - cyl->ctr.x;   
    tmp2.y = hit.y - cyl->ctr.y;   
    tmp2.z = hit.z - cyl->ctr.z;   

    VDOT(tmp,  tmp2, ctmp4); 
    VDOT(tmp3, cyl->axis, cyl->axis);

    if ((tmp > 0.0) && (tmp < sqrt(tmp3))) 
      ry->add_intersection(tout, (object *) cyl, ry);
  }
}

/* 
 * cylinder.h - This file contains the defines for cylinders etc.
 *
 *  $Id: cylinder.h,v 1.10 2002/08/04 21:43:34 johns Exp $
 */

object * newcylinder(void *, vector, vector, flt);
object * newfcylinder(void *, vector, vector, flt);

#ifdef CYLINDER_PRIVATE

typedef struct {
  RT_OBJECT_HEAD
  vector ctr;
  vector axis;
  flt rad;
} cylinder;

static void cylinder_intersect(const cylinder *, ray *);
static void fcylinder_intersect(const cylinder *, ray *);

static int cylinder_bbox(void * obj, vector * min, vector * max);
static int fcylinder_bbox(void * obj, vector * min, vector * max);

static void cylinder_normal(const cylinder *, const vector *, const ray *, vector *);
#endif

/*
 * extvol.c - Volume rendering helper routines etc.
 *
 *  $Id: extvol.c,v 1.27 2004/02/03 06:00:39 johns Exp $
 */

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "util.h"
#include "parallel.h"
#include "threads.h"
#include "box.h"
#include "extvol.h"
#include "trace.h"
#include "sphere.h"
#include "light.h"
#include "shade.h"


int extvol_bbox(void * obj, vector * min, vector * max) {
  box * b = (box *) obj;

  *min = b->min;
  *max = b->max;

  return 1;
}

static object_methods extvol_methods = {
  (void (*)(const void *, void *))(box_intersect),
  (void (*)(const void *, const void *, const void *, void *))(box_normal),
  extvol_bbox, 
  free 
};

extvol * newextvol(void * voidtex, vector min, vector max, 
                   int samples, flt (* evaluator)(flt, flt, flt)) { 
  extvol * xvol;
  standard_texture * tex, * xvoltex;
  
  tex = (standard_texture *) voidtex;

  xvol = (extvol *) malloc(sizeof(extvol));
  memset(xvol, 0, sizeof(extvol));

  xvol->methods = &extvol_methods;

  xvol->min=min;
  xvol->max=max;
  xvol->evaluator = evaluator;
  xvol->ambient = tex->ambient;
  xvol->diffuse = tex->diffuse;
  xvol->opacity = tex->opacity;  
  xvol->samples = samples;

  xvoltex = malloc(sizeof(standard_texture));
  memset(xvoltex, 0, sizeof(standard_texture));

  xvoltex->ctr.x = 0.0;
  xvoltex->ctr.y = 0.0;
  xvoltex->ctr.z = 0.0;
  xvoltex->rot = xvoltex->ctr;
  xvoltex->scale = xvoltex->ctr;
  xvoltex->uaxs = xvoltex->ctr;
  xvoltex->vaxs = xvoltex->ctr;
  xvoltex->flags = RT_TEXTURE_NOFLAGS;

  xvoltex->col=tex->col;
  xvoltex->ambient=1.0;
  xvoltex->diffuse=0.0;
  xvoltex->specular=0.0;
  xvoltex->opacity=1.0;
  xvoltex->img=NULL;
  xvoltex->texfunc=(color(*)(const void *, const void *, void *))(ext_volume_texture);
  xvoltex->obj = (void *) xvol; /* XXX hack! */

  xvol->tex = (texture *) xvoltex;

  return xvol;
}

color ExtVoxelColor(flt scalar) {
  color col;

  if (scalar > 1.0) 
    scalar = 1.0;

  if (scalar < 0.0)
    scalar = 0.0;

  if (scalar < 0.5) {
    col.g = 0.0;
  }
  else {
    col.g = (scalar - 0.5) * 2.0;
  }

  col.r = scalar;
  col.b = 1.0 - (scalar / 2.0);

  return col;
} 

color ext_volume_texture(const vector * hit, const texture * tx, ray * ry) {
  color col, col2;
  box * bx;
  extvol * xvol;
  flt a, tx1, tx2, ty1, ty2, tz1, tz2;
  flt tnear, tfar;
  flt t, tdist, dt, ddt, sum, tt; 
  vector pnt, bln;
  flt scalar, transval; 
  point_light * li;
  color diffint; 
  vector N, L;
  flt inten;
  standard_texture * tex = (standard_texture *) tx;

    bx = (box *) tex->obj;
  xvol = (extvol *) tex->obj;

  col.r = 0.0;
  col.g = 0.0;
  col.b = 0.0;
 
  tnear= -FHUGE;
  tfar= FHUGE;
 
  if (ry->d.x == 0.0) {
    if ((ry->o.x < bx->min.x) || (ry->o.x > bx->max.x)) return col;
  }
  else {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if (tx1 > tx2) { a=tx1; tx1=tx2; tx2=a; }
    if (tx1 > tnear) tnear=tx1;
    if (tx2 < tfar)   tfar=tx2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
 if (ry->d.y == 0.0) {
    if ((ry->o.y < bx->min.y) || (ry->o.y > bx->max.y)) return col;
  }
  else {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if (ty1 > ty2) { a=ty1; ty1=ty2; ty2=a; }
    if (ty1 > tnear) tnear=ty1;
    if (ty2 < tfar)   tfar=ty2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (ry->d.z == 0.0) {
    if ((ry->o.z < bx->min.z) || (ry->o.z > bx->max.z)) return col;
  }
  else {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if (tz1 > tz2) { a=tz1; tz1=tz2; tz2=a; }
    if (tz1 > tnear) tnear=tz1;
    if (tz2 < tfar)   tfar=tz2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (tnear < 0.0) tnear=0.0;
 
  tdist = xvol->samples;

  tt = (xvol->opacity / tdist); 

  bln.x=fabs(bx->min.x - bx->max.x);
  bln.y=fabs(bx->min.y - bx->max.y);
  bln.z=fabs(bx->min.z - bx->max.z);
  
     dt = 1.0 / tdist; 
    sum = 0.0;

/* Accumulate color as the ray passes through the voxels */
  for (t=tnear; t<=tfar; t+=dt) {
    if (sum < 1.0) {
      pnt.x=((ry->o.x + (ry->d.x * t)) - bx->min.x) / bln.x;
      pnt.y=((ry->o.y + (ry->d.y * t)) - bx->min.y) / bln.y;
      pnt.z=((ry->o.z + (ry->d.z * t)) - bx->min.z) / bln.z;

      /* call external evaluator assume 0.0 -> 1.0 range.. */ 
      scalar = xvol->evaluator(pnt.x, pnt.y, pnt.z);  

      transval = tt * scalar; 
      sum += transval; 

      col2 = ExtVoxelColor(scalar);

      col.r += transval * col2.r * xvol->ambient;
      col.g += transval * col2.g * xvol->ambient;
      col.b += transval * col2.b * xvol->ambient;

      ddt = dt;

      /* Add in diffuse shaded light sources (no shadows) */
      if (xvol->diffuse > 0.0) {
  
        /* Calculate the Volume gradient at the voxel */
        N.x = (xvol->evaluator(pnt.x - ddt, pnt.y, pnt.z)  -  
              xvol->evaluator(pnt.x + ddt, pnt.y, pnt.z)) *  8.0 * tt; 
  
        N.y = (xvol->evaluator(pnt.x, pnt.y - ddt, pnt.z)  -  
              xvol->evaluator(pnt.x, pnt.y + ddt, pnt.z)) *  8.0 * tt; 
  
        N.z = (xvol->evaluator(pnt.x, pnt.y, pnt.z - ddt)  -  
              xvol->evaluator(pnt.x, pnt.y, pnt.z + ddt)) *  8.0 * tt; 
 
        /* only light surfaces with enough of a normal.. */
        if ((N.x*N.x + N.y*N.y + N.z*N.z) > 0.0) { 
          list * cur;

          diffint.r = 0.0; 
          diffint.g = 0.0; 
          diffint.b = 0.0; 


          /* add the contribution of each of the lights.. */
          cur = ry->scene->lightlist;
          while (cur != NULL) {           /* loop for light contributions */
            li=(point_light *) cur->item; /* set li=to the current light  */
            VSUB(li->ctr, (*hit), L)
            VNorm(&L);
            VDOT(inten, N, L)
    
            /* only add light if its from the front of the surface */
            /* could add back-lighting if we wanted to later.. */
            if (inten > 0.0) {
              standard_texture * litex = (standard_texture *) li->tex;

              diffint.r += inten * litex->col.r;
              diffint.g += inten * litex->col.g;
              diffint.b += inten * litex->col.b;
            }

            cur = cur->next;
          }   

          col.r += col2.r * diffint.r * xvol->diffuse;
          col.g += col2.g * diffint.g * xvol->diffuse;
          col.b += col2.b * diffint.b * xvol->diffuse;
        }
      }
    }   
    else { 
      sum=1.0;
    }  
  }

  /* Add in transmitted ray from outside environment */
  if (sum < 1.0) {      /* spawn transmission rays / refraction */
    color transcol;
    shadedata shadevars;

    shadevars.hit=*hit;

    /* XXX this ought to be done in shade.c rather than here  */
    /*     if done in shade.c, we could do volumetric objects */
    /*     after solids are already known and handle          */
    /*     object-volume intersections better.                */
    transcol = shade_transmission(ry, &shadevars, 1.0 - sum);

    col.r += transcol.r; /* add the transmitted ray  */
    col.g += transcol.g; /* to the diffuse and       */
    col.b += transcol.b; /* transmission total..     */
  }

  return col;
}



/*
 * vol.h - Volume rendering definitions etc.
 *
 *
 *  $Id: extvol.h,v 1.10 2002/08/04 21:43:34 johns Exp $
 */

typedef struct {
  RT_OBJECT_HEAD
  vector min;
  vector max;
  flt ambient;
  flt diffuse;
  flt opacity;
  int samples;
  flt (* evaluator)(flt, flt, flt);
} extvol;

extvol * newextvol(void * voidtex, vector min, vector max, 
                   int samples, flt (* evaluator)(flt, flt, flt));
color ext_volume_texture(const vector *, const texture *, ray *);


/* 
 * fire.c 
 * This file contains the main program and driver for the raytracer.
 *
 *  $Id: fire.c,v 1.21 2002/07/03 04:35:58 johns Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "tachyon.h"

#if defined(USEOMF)
#include "omfwrite.h"
  /* AVR26 Resolution  */
#define XRES 640 
#define YRES 496    
#else
  /* MPEG-1 Resolution  */
#define XRES 640
#define YRES 480
#endif
 
#define XS 96 
#define YS 96 
#define ZS 64 
#define NUMFLAMES 120 
#define MAXFRAMES 600
#define FIREOPACITY 14.0

#define RAD 6.28
#define MXV 255

typedef struct {      /* Scalar Volume Visualization Data */
  int loaded;            /* Volume data memory residence flag */
  int xres;              /* volume X axis size                */
  int yres;              /* volume Y axis size                */
  int zres;              /* volume Z axis size                */
  apiflt opacity;        /* opacity per unit length           */
  char name[96];         /* Volume data filename              */
  unsigned char * data;  /* pointer to raw byte volume data   */
} scalarvol;

typedef struct {
  int x;
  int y;
} flm;

#ifdef cube
#define RFILE "/cfs/johns/anim/frame"
#endif

#ifndef cube 
#define RFILE "frame"
#endif

int rt_mynode(void); /* proto */

unsigned char fire[2][XS*YS*ZS + 10000];
flm flames[NUMFLAMES + 10];

void updatefire(void) {
  int x, y, z, i;
  int xx, addr, addr2, addr3, addr4;

  for (i=0; i<NUMFLAMES; i++) {
    flames[i].x += (rand() % 7) - 3;  
    flames[i].y += (rand() % 7) - 3;  

    if (flames[i].x > (XS - 3)) 
      flames[i].x = 3;
    if (flames[i].x < 3) 
      flames[i].x = (XS - 3); 
    if (flames[i].y > (YS - 3)) 
      flames[i].y = 3;
    if (flames[i].y < 3) 
      flames[i].y = (YS - 3); 

    addr = (XS*flames[i].y) + flames[i].x; 
    fire[0][addr - 1     ] = MXV;
    fire[0][addr         ] = MXV;
    fire[0][addr + 1     ] = MXV;
    fire[0][addr - 1 - XS] = MXV;
    fire[0][addr     - XS] = MXV;
    fire[0][addr + 1 - XS] = MXV;
    fire[0][addr - 1 + XS] = MXV;
    fire[0][addr     + XS] = MXV;
    fire[0][addr + 1 + XS] = MXV;

    addr = addr + XS*YS;
    fire[0][addr - 1     ] = MXV;
    fire[0][addr         ] = MXV;
    fire[0][addr + 1     ] = MXV;
    fire[0][addr - 1 - XS] = MXV;
    fire[0][addr     - XS] = MXV;
    fire[0][addr + 1 - XS] = MXV;
    fire[0][addr - 1 + XS] = MXV;
    fire[0][addr     + XS] = MXV;
    fire[0][addr + 1 + XS] = MXV;

    addr = addr + XS*YS;
    fire[0][addr - 1 ] = MXV;
    fire[0][addr     ] = MXV;
    fire[0][addr + 1 ] = MXV;
    fire[0][addr + XS] = MXV;
    fire[0][addr - XS] = MXV;
  }

  for (z=0; z<(ZS - 1); z++) {
    addr3 = z*XS*YS;
    for (y=1; y<(YS - 1); y++) {
      addr2 = y*XS + addr3;
      for (x=1; x<(XS - 1); x++) { 
        addr = x + addr2;

/* NOTE:  This address code takes the 26 points in the box surrounding
          the original point, and averages them with together, to generate
          the new point.  If you desire speed, comment out everything 
          after the "first 6 points" 
          Remember to change the divisor on the line "xx = xx / 26"
*/

      xx = fire[0][addr + 1              ] + /* first 6 adjacent neighbors */
           fire[0][addr - 1              ] +
           fire[0][addr     + XS         ] +
           fire[0][addr     - XS         ] +
           fire[0][addr           + XS*YS] +
           fire[0][addr           - XS*YS] +  

           fire[0][addr - 1 + XS] +  /* middle 4 points */    
           fire[0][addr + 1 + XS] +      
           fire[0][addr - 1 - XS] +      
           fire[0][addr + 1 - XS];      

           addr4=addr - XS*YS;     /* bottom 8 points */
     xx += fire[0][addr4 - 1] +
           fire[0][addr4 + 1];
           addr4=addr + XS - XS*YS; 
     xx += fire[0][addr4 - 1] +  
           fire[0][addr4    ] +
           fire[0][addr4 + 1]; 
           addr4=addr - XS - XS*YS;
     xx += fire[0][addr4 - 1] +   
           fire[0][addr4    ] +
           fire[0][addr4 + 1];   

           addr4=addr + XS*YS;      /* top 8 points */
     xx += fire[0][addr4 - 1] +
           fire[0][addr4 + 1];
           addr4=addr + XS + XS*YS; 
     xx += fire[0][addr4 - 1] +  
           fire[0][addr4    ] +
           fire[0][addr4 + 1];  
           addr4=addr - XS + XS*YS;
     xx += fire[0][addr4 - 1] +
           fire[0][addr4    ] +
           fire[0][addr4 + 1];

        xx = xx / 26;

        if (xx > 1) 
          fire[1][addr + XS*YS] = (unsigned char) xx - 1;
        else
          fire[1][addr + XS*YS] = 0;   

      }
    }
  }
  memcpy(&fire[0], &fire[1], (XS*YS*ZS));
}

int main(int argc, char **argv) {
  SceneHandle scene;
  int i, antialiasing;
  apiflt zoom, aspectratio;
  apivector Ccenter, Cview, Cup;
  apitexture tex1, tex2;
  apitexture p1,p2;
  scalarvol vol;
  apiflt xc,yc;
  void * t1, * t2, * vt1, * lt1;
  char fname[1000];
  char fname2[2000];
#ifdef USEOMF
  int yy;
  unsigned char * rawimage;
  unsigned char * interlacedimage;
  void * omfhandle;
#endif

  rt_initialize(&argc, &argv); 

  scene = rt_newscene();
  
#ifdef USEOMF
  rawimage = malloc(XRES*YRES*4);
  interlacedimage = malloc(XRES*YRES*4);

  omfhandle = OMFopen(XRES, YRES, AVR26, "fire.omf");
#endif

  for (i=0; i<NUMFLAMES; i++) {   /* init the little flames */
    flames[i].x=rand() % XS;
    flames[i].y=rand() % YS; 
  }

  aspectratio=1.0;  
  antialiasing=0; 
  zoom=1.0;

  Ccenter = rt_vector(0.0, 0.0, 0.0);
  Cview = rt_vector(1.0, 0.0, 0.0);
  Cup = rt_vector(0.0, 0.0, 1.0); 

  tex1.col = rt_color(1.0, 1.0, 1.0); 
  tex1.ambient=1.0;  
  tex1.diffuse=0.0;
  tex1.specular=0.0; 
  tex1.opacity=FIREOPACITY;
  tex1.texturefunc=0;
  tex2=tex1;


  vol.loaded=1;
  vol.data=fire[1];  

  p1.col = rt_color(1.0, 1.0, 1.0);
  p1.ambient=0.3; 
  p1.diffuse=0.8; 
  p1.specular=0.0; 
  p1.opacity=1.0;

  p2=p1;

  p1.texturefunc=9;
  p1.ctr = rt_vector(0.0, 0.0, 0.0);
  p1.rot = rt_vector(0.0, 0.0, 0.0);
  p1.scale = rt_vector(0.1, 0.1, 0.1);
  p1.uaxs = rt_vector(1.0, 0.0, 0.0);
  p1.vaxs = rt_vector(0.0, 1.0, 0.0);

  strcpy((char *) &p1.imap, "/disk7/cube/imaps/leafy261.ppm");

  t1=rt_texture(scene, &p1);

  p2.ambient=0.1;
  p2.diffuse=0.1;
  p2.specular=0.8;

  t2=rt_texture(scene, &p2);
  vt1=rt_texture(scene, &tex2);
  lt1=rt_texture(scene, &tex1);

  rt_resolution(scene, XRES, YRES);
  rt_verbose(scene, 0);

  rt_light(scene, lt1, rt_vector(0.0, 0.0, 40.0), 1.0);
  rt_scalarvol(scene, vt1, rt_vector(-1.0, -1.0, -1.0), 
               rt_vector(1.0, 1.0, 1.0), XS, YS, ZS, "", &vol);   

  rt_plane(scene, t1, rt_vector(0.0, 0.0, -1.01), rt_vector(0.0, 0.0, 1.0));

  rt_sphere(scene, t2, rt_vector(0.0, 0.0, 1.8), 0.8); 
 
  for (i=0; i<MAXFRAMES; i++) {  
    sprintf(fname,".%4.4d.tga",i);
    strcpy(fname2,RFILE);
    strcat(fname2, fname);

#ifdef USEOMF
  rt_outputfile(scene, "fire.tga");
  rt_rawimage(scene, rawimage);
#else
  rt_outputfile(scene, fname2);
#endif
     
    if (rt_mynode()==0) printf("Rendering: %s \n",fname2);

    xc=cos(6.28 * i / (1.0 * MAXFRAMES));
    yc=sin(6.28 * i / (1.0 * MAXFRAMES));
    Ccenter.x = xc*3.2; Ccenter.y = yc*3.2;
    Cview.x =  -xc; Cview.y =  -yc;

    srand(i); /* reset random seed.. */
              /* this was what used to cause antialiased fire to choke.. */
    updatefire(); /* run one iteration of the fire code */

    rt_camera_setup(scene, zoom, aspectratio, antialiasing, 
		6, Ccenter, Cview, Cup);

    rt_renderscene(scene);

#ifdef USEOMF
    for (yy=0; yy<YRES; yy+=2) {
      memcpy(&interlacedimage[(yy>>1)*XRES*3], &rawimage[yy*XRES*3], XRES*3);
      memcpy(&interlacedimage[((yy>>1)+1)*XRES*3], &rawimage[(yy+1)*XRES*3], XRES*3);
    }

    OMFwriteframe(omfhandle, interlacedimage);
#endif
  }

#ifdef USEOMF
  OMFclose(omfhandle);
  free(rawimage);
  free(interlacedimage);
#endif

  rt_finalize(); 

  return 0;
}
   

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tachyon.h"
#include "getargs.h"
#include "ctype.h"

static int strupncmp(const char *a, const char *b, int n) {
   while (n-- > 0) {
      if (toupper(*a) != toupper(*b)) {
         return toupper(*b) - toupper(*a);
      }
      if (*a == 0) return 0;
      a++; b++;
   }
   return 0;
}

static int compare(const char *a, const char *b) {
  if (strlen(a) != strlen(b)) 
    return -1;

  return strupncmp(a, b, strlen(a));
}

static void printusage(char **argv) {
  printf("Usage: \n");
  printf("  %s modelfile [options] \n", argv[0]);
  printf("\n");
  printf("Model file formats supported:\n");
  printf("  filename.dat -- The model files originated with this package.\n");
  printf("  filaname.ac  -- AC3D model files.\n");
#ifdef USELIBMGF
  printf("  filaname.mgf -- MGF model files.\n");
#endif
  printf("  filename.nff -- The NFF scene format used by Eric Haines' SPD.\n");
  printf("\n");
  printf("Valid options:  (** denotes default behaviour)\n");
  printf("----------------------------------------------\n");
  printf("Message Options:\n");
  printf(" +V verbose messages on \n");
  printf(" -V verbose messages off **\n");
  printf("\n");
  printf("Speed Tuning Options:\n");
  printf(" -numthreads xxx   (** default is auto-determined)\n");
  printf(" -nobounding\n");
  printf(" -boundthresh xxx  (** default threshold is 16)\n");
  printf("\n");
  printf("Shading Options:\n");
  printf("  -fullshade    best quality rendering (and slowest) **\n");
  printf("  -mediumshade  good quality rendering, but no shadows\n");
  printf("  -lowshade     low quality rendering, preview (and fast)\n");
  printf("  -lowestshade  worst quality rendering, preview (and fastest)\n");
  printf("\n");
  printf("Specular Highlight Shading Options:\n");
  printf("  -shade_phong       Phong specular highlights\n");
  printf("  -shade_blinn       Blinn's specular highlights**\n");
  printf("  -shade_blinn_fast  fast approximation to Blinn's highlights\n");
  printf("  -shade_nullphong   disable specular highlights\n");
  printf("\n");
  printf("Transparency Shading Options:\n");
  printf("  -trans_orig        Original implementation**\n");
  printf("  -trans_vmd         Opacity post-multiply used by VMD\n");
  printf("\n");
  printf("Antialiasing Options:\n");
  printf("  -aasamples xxx  (maximum supersamples taken per pixel)\n");
  printf("                  (** default is 0, or scene file determined)\n");
  printf("\n");
  printf("Output Options:\n");
  printf("  -o outfile.tga  set output file name\n");
  printf("  -format TARGA   24-bit Targa        (uncompressed) **\n");
  printf("  -format BMP     24-bit Windows BMP  (uncompressed)\n");
  printf("  -format PPM     24-bit PPM          (uncompressed)\n");
  printf("  -format RGB     24-bit SGI RGB      (uncompressed)\n");
#if defined(USEJPEG)
  printf("  -format JPEG    24-bit JPEG         (compressed, but lossy)\n");
#else
  printf("  -format JPEG    XXX Not compiled into this binary XXX\n");
#endif
#if defined(USEPNG)
  printf("  -format PNG     24-bit PNG          (compressed, lossless)\n");
#else
  printf("  -format PNG     XXX Not compiled into this binary XXX\n");
#endif
  printf("\n");
  printf("Animation Related Options:\n");
  printf(" -camfile filename.cam  Animate using file of camera positions.\n");
  printf(" -nosave                Disable writing of output frames to disk\n");
  printf("                        (only used for doing real-time rendering)\n");
  printf("\n");

#if defined(USESPACEBALL)
  printf("Interactive Spaceball Control:\n");
  printf(" -spaceball devicename \n");
  printf("\n");
#endif

}

static void initoptions(argoptions * opt) {
  memset(opt, 0, sizeof(argoptions));
  opt->filenames = (char **) malloc(sizeof(char *) * 10);
  opt->numfiles = 0;
  opt->useoutfilename = -1;
  opt->outimageformat = -1;
  opt->verbosemode = -1;
  opt->aa_maxsamples = -1;
  opt->boundmode = -1; 
  opt->boundthresh = -1; 
  opt->usecamfile = -1;
  opt->shadermode = -1;
  opt->phongfunc = -1;
  opt->transmode = -1;
  opt->numthreads = -1;
  opt->nosave = -1;
}

int useoptions(argoptions * opt, SceneHandle scene) {
  if (opt->outimageformat == -1) {
    opt->outimageformat = RT_FORMAT_TARGA;
  } 

  if (opt->useoutfilename == -1) {
    if (opt->usecamfile != -1) {
      strcpy(opt->outfilename, "cam.%04d");
    } else if (opt->numfiles > 1) {
      strcpy(opt->outfilename, "outfile.%04d");
    } else {
      strcpy(opt->outfilename, "outfile");
    }

    switch (opt->outimageformat) {
      case RT_FORMAT_PPM:
        strcat(opt->outfilename, ".ppm");
        break;  
  
      case RT_FORMAT_WINBMP:
        strcat(opt->outfilename, ".bmp");
        break;  

      case RT_FORMAT_SGIRGB:
        strcat(opt->outfilename, ".rgb");
        break;  

      case RT_FORMAT_JPEG:
        strcat(opt->outfilename, ".jpg");
        break;  

      case RT_FORMAT_PNG:
        strcat(opt->outfilename, ".png");
        break;  

      case RT_FORMAT_TARGA:
                   default:
        strcat(opt->outfilename, ".tga");
        break;  
    }
  }

  if (opt->nosave == 1) {
    strcpy(opt->outfilename, "\0");
  }

  rt_outputformat(scene, opt->outimageformat);
  rt_outputfile(scene, opt->outfilename);

  if (opt->verbosemode == 1) {
    rt_verbose(scene, 1);
  }
  if (opt->verbosemode == 0) {
    rt_verbose(scene, 0);
  }  

  if (opt->aa_maxsamples != -1) {
    rt_aa_maxsamples(scene, opt->aa_maxsamples);
  } 

  if (opt->boundmode != -1) {
    rt_boundmode(scene, opt->boundmode);
  }

  if (opt->boundthresh != -1) {
    rt_boundthresh(scene, opt->boundthresh);
  }

  if (opt->shadermode != -1) {
    rt_shadermode(scene, opt->shadermode);
  }

  if (opt->phongfunc != -1) {
    rt_phong_shader(scene, opt->phongfunc);
  }

  if (opt->transmode != -1) {
    rt_trans_mode(scene, opt->transmode);
  }

  if (opt->numthreads != -1) {
    rt_set_numthreads(scene, opt->numthreads);
  }

  return 0;
}    

static int getparm(int argc, char **argv, int num, argoptions * opt, int node) {
  if (!strcmp(argv[num], "-o")) {
    opt->useoutfilename = 1;
    sscanf(argv[num + 1], "%s", (char *) &opt->outfilename);
    return 2;
  }
  if (!strcmp(argv[num], "-numthreads")) {
    sscanf(argv[num + 1], "%d", &opt->numthreads);
    return 2;
  }
  if (!strcmp(argv[num], "-camfile")) {
    opt->usecamfile = 1;
    sscanf(argv[num + 1], "%s", &opt->camfilename[0]);
    return 2;
  }
  if (!strcmp(argv[num], "-nosave")) {
    /* disable writing of images to disk files */
    opt->nosave = 1;
    return 1;
  }
  if (!strcmp(argv[num], "-aasamples")) {
    sscanf(argv[num + 1], "%d", &opt->aa_maxsamples);
    return 2;
  }
  if (!strcmp(argv[num], "-V")) {
    /* turn verbose messages off */
    opt->verbosemode = 0;
    return 1;
  }
  if (!strcmp(argv[num], "+V")) {
    /* turn verbose messages on */
    opt->verbosemode = 1;
    return 1;
  }
  if (!strcmp(argv[num], "-nobounding")) {
    /* disable automatic spatial subdivision optimizations */
    opt->boundmode = RT_BOUNDING_DISABLED;
    return 1;
  }
  if (!strcmp(argv[num], "-boundthresh")) {
    /* set automatic bounding threshold control value */
    sscanf(argv[num + 1], "%d", &opt->boundthresh);
    return 2;
  }
  if (!strcmp(argv[num], "-fullshade")) {
    opt->shadermode = RT_SHADER_FULL;
    return 1;
  }
  if (!strcmp(argv[num], "-mediumshade")) {
    opt->shadermode = RT_SHADER_MEDIUM;
    return 1;
  }
  if (!strcmp(argv[num], "-lowshade")) {
    opt->shadermode = RT_SHADER_LOW;
    return 1;
  }
  if (!strcmp(argv[num], "-lowestshade")) {
    opt->shadermode = RT_SHADER_LOWEST;
    return 1;
  }
  if (!strcmp(argv[num], "-shade_phong")) {
    opt->phongfunc  = RT_SHADER_PHONG;
    return 1;
  }
  if (!strcmp(argv[num], "-shade_blinn")) {
    opt->phongfunc  = RT_SHADER_BLINN;
    return 1;
  }
  if (!strcmp(argv[num], "-shade_blinn_fast")) {
    opt->phongfunc  = RT_SHADER_BLINN_FAST;
    return 1;
  }
  if (!strcmp(argv[num], "-shade_nullphong")) {
    opt->phongfunc  = RT_SHADER_NULL_PHONG;
    return 1;
  }
  if (!strcmp(argv[num], "-trans_orig")) {
    opt->transmode  = RT_TRANS_ORIG;
    return 1;
  }
  if (!strcmp(argv[num], "-trans_vmd")) {
    opt->transmode  = RT_TRANS_VMD;
    return 1;
  }
  if (!strcmp(argv[num], "-format")) {
    char str[80];
    sscanf(argv[num + 1], "%s", &str[0]);

    if (!compare(str, "TARGA")) {
      opt->outimageformat = RT_FORMAT_TARGA;
    } else if (!compare(str, "BMP")) {
      opt->outimageformat = RT_FORMAT_WINBMP;
    } else if (!compare(str, "PPM")) {
      opt->outimageformat = RT_FORMAT_PPM;
    } else if (!compare(str, "RGB")) {
      opt->outimageformat = RT_FORMAT_SGIRGB;
#if defined(USEJPEG)
    } else if (!compare(str, "JPEG")) {
      opt->outimageformat = RT_FORMAT_JPEG;
#endif
#if defined(USEPNG)
    } else if (!compare(str, "PNG")) {
      opt->outimageformat = RT_FORMAT_PNG;
#endif
    } else {
      if (node == 0) 
        printf("Unknown/Unsupported Image Format: %s, defaulting to Targa...\n", str);
    }
    return 2;
  }

#if defined(USESPACEBALL)
  if (!strcmp(argv[num], "-spaceball")) {
    sscanf(argv[num + 1], "%s", &opt->spaceball[0]);
    return 2;
  }
#endif

  /* unknown parameter setting */
  if (node == 0) 
    printf("Unrecognized parameter/option flag: %s\n", argv[num]);

  return -1;
}

int getargs(int argc, char **argv, argoptions * opt, int node) {
  int i, rc;

  if (opt == NULL)
    return -1;

  if (argc < 2) {
    if (node == 0)
      printusage(argv);

    return -1;
  }

  initoptions(opt);  

  i = 1;
  while (i < argc) {
    if (argv[i][0] == '-' || argv[i][0] == '+') {
      rc = getparm(argc, argv, i, opt, node);
      if (rc != -1) {
        i += rc;
      }
      else {
        if (node == 0)
          printusage(argv);

        return -1;
      }
    }
    else {
      opt->filenames = (char **) realloc(opt->filenames, sizeof(char *) * (opt->numfiles + 10));
      opt->filenames[opt->numfiles] = 
        (char *) malloc(sizeof(char) * strlen(argv[i]));
      strcpy(opt->filenames[opt->numfiles], argv[i]);        

#if 0
{ int i; 
  for (i=0; i<opt->numfiles; i++) {
    printf("parsefile[%d]: %s\n", i, opt->filenames[i]);
  }
}
#endif

      opt->numfiles++;
      i++;
    }
  }

  if (opt->numfiles == 0) {
    if (node == 0) {
      printf("Missing model file name!\n");
      printusage(argv);
    } 
    return -1;
  }

  return 0;
}





typedef struct {
  char **filenames;       /* list of model files to render */
  int numfiles;           /* number of files to render */
  int useoutfilename;     /* command line override of output filename */
  char outfilename[FILENAME_MAX]; /* name of output image file */
  int outimageformat;     /* format of output image */
  int verbosemode;        /* verbose flags */
  int aa_maxsamples;      /* antialiasing setting */
  int boundmode;          /* bounding mode */
  int boundthresh;        /* bounding threshold */
  int usecamfile;         /* use camera file */
  char camfilename[FILENAME_MAX]; /* camera filename */
  int shadermode;         /* quality level */
  int phongfunc;          /* shader for specular highlights */
  int transmode;          /* transparency rendering mode */
  int numthreads;         /* explicit number of threads to use */
  int nosave;             /* don't write output image to disk */
  char spaceball[FILENAME_MAX];   /* spaceball serial port device */
} argoptions;

int getargs(int argc, char **argv, argoptions * opt, int node);
int useoptions(argoptions * opt, SceneHandle scene);

/*
 * global.c - any/all global data items etc should be in this file
 *
 *  $Id: global.c,v 1.16 1998/08/08 20:08:09 johns Exp $
 *
 */

int parinitted = 0;                 /* used by parallel startup code     */

/*
 * global.h - any/all global data items etc should be in this file
 *
 *  $Id: global.h,v 1.15 1998/08/08 20:08:09 johns Exp $
 *
 */

extern int parinitted;

/*
 * glwin.c -- simple code for opening an OpenGL display window, and doing
 *            BitBlt operations or whatever...
 *
 */
 
#include <stdio.h>
#include <stdlib.h>

#ifdef USEOPENGL

#if !defined(WIN32) && !defined(_MSC_VER)

#include <X11/Xlib.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>

#include "glwin.h"

typedef struct {
  int scrnum;
  Display *dpy;
  Window root;
  Window win;
  GLXContext ctx; 
  int width;
  int height;
} oglhandle;


void * glwin_create(const char * wintitle, int width, int height) {
  oglhandle * handle; 
  XSetWindowAttributes attr;
  unsigned long mask;
  XVisualInfo *visinfo;
  int attrib[] = { GLX_RGBA, GLX_RED_SIZE, 1, GLX_GREEN_SIZE, 1, 
                   GLX_BLUE_SIZE, 1, GLX_DEPTH_SIZE, 16, GLX_DOUBLEBUFFER, None };

  handle = (oglhandle *) malloc(sizeof(oglhandle));
  if (handle == NULL)
    return NULL;

  handle->width = width;
  handle->height = height;

  handle->dpy = XOpenDisplay(getenv("DISPLAY"));
  if (handle->dpy == NULL) {
    free(handle);
    return NULL;
  } 

  handle->scrnum = DefaultScreen( handle->dpy );
  handle->root = RootWindow( handle->dpy, handle->scrnum );

  visinfo = glXChooseVisual( handle->dpy, handle->scrnum, attrib );

  if (visinfo == NULL) {
    printf("Error: couldn't get an RGB, Double-buffered visual\n");
    free(handle);
    return NULL;
  }

  /* window attributes */
  attr.background_pixel = 0;
  attr.border_pixel = 0;
  attr.colormap = XCreateColormap(handle->dpy, handle->root, 
                                  visinfo->visual, AllocNone);

  attr.event_mask = StructureNotifyMask | ExposureMask;
  mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;

  handle->win = XCreateWindow(handle->dpy, handle->root, 0, 0, width, height,
                              0, visinfo->depth, InputOutput,
                              visinfo->visual, mask, &attr );

  handle->ctx = glXCreateContext( handle->dpy, visinfo, NULL, True );

  glXMakeCurrent( handle->dpy, handle->win, handle->ctx );

  XStoreName(handle->dpy, handle->win, wintitle);

  XMapWindow(handle->dpy, handle->win);

  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT);
  glwin_swap_buffers(handle);
  glClear(GL_COLOR_BUFFER_BIT);
  glwin_swap_buffers(handle);

  glwin_handle_events(handle);
  glwin_handle_events(handle);

  XFlush(handle->dpy);

  return handle;
}


void glwin_destroy(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;

  if (handle == NULL)
    return;

  XUnmapWindow(handle->dpy, handle->win);

  glXMakeCurrent(handle->dpy, None, NULL);

  XDestroyWindow(handle->dpy, handle->win);

  XCloseDisplay(handle->dpy); 
}
 
void glwin_swap_buffers(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;

  if (handle != NULL)
    glXSwapBuffers(handle->dpy, handle->win);
}

int glwin_handle_events(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;
  XEvent event;

  if (handle == NULL)
    return 0;

  XNextEvent(handle->dpy, &event);

  switch(event.type) {
    case ConfigureNotify:
     handle->width = event.xconfigure.width;
     handle->height = event.xconfigure.height;

     glShadeModel(GL_FLAT);
     glViewport(0, 0, handle->width, handle->height);
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();

     /* this is upside-down for what most code thinks, but it is */
     /* right side up for the ray tracer..                       */
     gluOrtho2D(0.0, handle->width, 0.0, handle->height);
   
     glMatrixMode(GL_MODELVIEW);
     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glPixelZoom(1.0, 1.0); /* for upside-down images that ray uses */

     return 1;
  }

  return 0;
} 

void glwin_draw_image(void * voidhandle, int xsize, int ysize, 
                      unsigned char * img) {
  glRasterPos2i(0, 0);
  glDrawPixels(xsize, ysize, GL_RGB, GL_UNSIGNED_BYTE, img);
  glwin_swap_buffers(voidhandle);
}


#else


/* 
 *  WIN32 Version 
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#include "glwin.h"

typedef struct {
  HWND hWnd;
  HDC hDC;
  HGLRC hRC;
  long scrwidth;
  long scrheight;
  int width;
  int height;
} oglhandle;

static char szAppName[] = "OpenGL";
static char szAppTitle[]="Tachyon Parallel/Multiprocessor Ray Tracer";

                                /* XXX GET RID OF THIS!!!!! */
static oglhandle * globhandle;  /* XXX GET RID OF THIS!!!!! */
                                /* XXX GET RID OF THIS!!!!! */

/*
 * declaration of myWindowProc()
 */
LONG WINAPI myWindowProc( HWND, UINT, WPARAM, LPARAM );

static int OpenWin32Connection(oglhandle * handle) {
  WNDCLASS  wc;
  HINSTANCE hInstance = GetModuleHandle(NULL);

  /* Clear (important!) and then fill in the window class structure. */
  memset(&wc, 0, sizeof(WNDCLASS));
  wc.style         = CS_OWNDC;
  wc.lpfnWndProc   = (WNDPROC) myWindowProc;
  wc.hInstance     = hInstance;
  wc.hIcon         = LoadIcon(NULL, IDI_WINLOGO);
  wc.hCursor       = LoadCursor(hInstance, IDC_ARROW);
  wc.hbrBackground = NULL; /* Default color */
  wc.lpszMenuName  = NULL;
  wc.lpszClassName = szAppName;

  if(!RegisterClass(&wc)) {
    printf("Cannot register window class.\n");
    return -1;
  }

  handle->scrwidth  = GetSystemMetrics(SM_CXSCREEN);
  handle->scrheight = GetSystemMetrics(SM_CYSCREEN); 

  return 0;
}

static HGLRC SetupOpenGL(HWND hWnd) {
  int nMyPixelFormatID;
  HDC hDC;
  HGLRC hRC;
  static PIXELFORMATDESCRIPTOR pfd = {
        sizeof (PIXELFORMATDESCRIPTOR), /* struct size      */
        1,                              /* Version number   */
        PFD_DRAW_TO_WINDOW      /* Flags, draw to a window, */
          | PFD_SUPPORT_OPENGL, /* use OpenGL               */
        PFD_TYPE_RGBA,          /* RGBA pixel values        */
        24,                     /* 24-bit color             */
        0, 0, 0,                /* RGB bits & shift sizes.  */
        0, 0, 0,                /* Don't care about them    */
        0, 0,                   /* No alpha buffer info     */
        0, 0, 0, 0, 0,          /* No accumulation buffer   */
        16,                     /* 16-bit depth buffer      */
        0,                      /* No stencil buffer        */
        0,                      /* No auxiliary buffers     */
        PFD_MAIN_PLANE,         /* Layer type               */
        0,                      /* Reserved (must be 0)     */
        0,                      /* No layer mask            */
        0,                      /* No visible mask          */
        0                       /* No damage mask           */
  };

  hDC = GetDC(hWnd);
  nMyPixelFormatID = ChoosePixelFormat(hDC, &pfd);

  /* 
   * catch errors here.
   * If nMyPixelFormat is zero, then there's
   * something wrong... most likely the window's
   * style bits are incorrect (in CreateWindow() )
   * or OpenGL isn't installed on this machine
   *
   */

  if (nMyPixelFormatID == 0) {
    printf("Error selecting OpenGL Pixel Format!!\n");
    return NULL;
  }

  SetPixelFormat( hDC, nMyPixelFormatID, &pfd );

  hRC = wglCreateContext(hDC);
  ReleaseDC(hWnd, hDC);

  return hRC;
}

static int myCreateWindow(oglhandle * handle, const char * wintitle,
                          int xpos, int ypos, int xs, int ys) {
  /* Create a main window for this application instance. */
  handle->hWnd = 
        CreateWindow(
              szAppName,          /* app name */
              wintitle,           /* Text for window title bar */
              WS_OVERLAPPEDWINDOW /* Window style */
               | WS_CLIPCHILDREN
               | WS_CLIPSIBLINGS, /* NEED THESE for OpenGL calls to work! */
              xpos, ypos,
              xs, ys,
              NULL,                  /* no parent window                */
              NULL,                  /* Use the window class menu.      */
              GetModuleHandle(NULL), /* This instance owns this window  */
              handle                 /* We don't use any extra data     */
        );

  if (!handle->hWnd) {
    printf("Couldn't Open Window!!\n");
    return -1;
  }

  handle->hDC = GetDC(handle->hWnd);
  wglMakeCurrent(handle->hDC, handle->hRC);

  /* Make the window visible & update its client area */
  ShowWindow( handle->hWnd, SW_SHOW);  /* Show the window         */
  UpdateWindow( handle->hWnd );        /* Sends WM_PAINT message  */

  return 0;
}


LONG WINAPI myWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
  PAINTSTRUCT   ps; /* Paint structure. */

  switch(msg) {
    case WM_CREATE:
      globhandle->hRC = SetupOpenGL(hwnd);
      return 0;

    case WM_SIZE:
      /* hDC = GetDC(hwnd); */
      wglMakeCurrent(globhandle->hDC, globhandle->hRC);

      glShadeModel(GL_FLAT);
      glViewport(0, 0, (GLsizei) LOWORD(lParam), (GLsizei) HIWORD (lParam));
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();

      /* this is upside-down for what most code thinks, but it is */
      /* right side up for the ray tracer..                       */
      gluOrtho2D(0.0, (GLsizei) LOWORD(lParam), 0.0, (GLsizei) HIWORD (lParam));
  
      glMatrixMode(GL_MODELVIEW);
      glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
      glPixelZoom(1.0, 1.0); /* for upside-down images that ray uses */
      return 0;

    case WM_CLOSE:
      PostQuitMessage(0);
      return 0;

    case WM_PAINT:
      BeginPaint(hwnd, &ps);
      EndPaint(hwnd, &ps);
      return 0;

    default:
      return DefWindowProc(hwnd, msg, wParam, lParam);
  }

  return 0;
}


void * glwin_create(const char * wintitle, int width, int height) {
  oglhandle * handle;
  int rc;

  handle = (oglhandle *) malloc(sizeof(oglhandle));
  if (handle == NULL)
    return NULL;
  globhandle = handle;

  rc = OpenWin32Connection(handle);
  if (rc != 0) {
    printf("OpenWin32Connection() returned an error!\n");
    free(handle);
    return NULL;
  } 

  handle->width = width;
  handle->height = height;
  
  rc = myCreateWindow(handle, wintitle, 0, 0, width, height); 
  if (rc != 0) {
    printf("CreateWindow() returned an error!\n");
    free(handle);
    return NULL;
  } 


  return handle;
}

void glwin_destroy(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;

  wglDeleteContext(handle->hRC);
  PostQuitMessage( 0 );

  /* glwin_handle_events(handle); */
}

void glwin_swap_buffers(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;
  glFlush();
}

int glwin_handle_events(void * voidhandle) {
  oglhandle * handle = (oglhandle *) voidhandle;
  MSG msg;

  if (GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    return 1;
  }

  return 0;
}

void glwin_draw_image(void * voidhandle, int xsize, int ysize, unsigned char * img) {
  oglhandle * handle = (oglhandle *) voidhandle;
  glRasterPos2i(0, 0);
  glDrawPixels(xsize, ysize, GL_RGB, GL_UNSIGNED_BYTE, img);
  glwin_swap_buffers(voidhandle);
  return;
}


#endif




#else

void * glwin_create(const char * wintitle, int width, int height) {
  return NULL;
}

void glwin_destroy(void * voidhandle) {
  return;
}

void glwin_swap_buffers(void * voidhandle) {
  return;
}

int glwin_handle_events(void * voidhandle) {
  return 0;
}

void glwin_draw_image(void * voidhandle, int xsize, int ysize, unsigned char * img) {
  return;
}

#endif


void * glwin_create(const char * wintitle, int width, int height);
void glwin_destroy(void * voidhandle);
void glwin_swap_buffers(void * voidhandle);
int glwin_handle_events(void * voidhandle);
void glwin_draw_image(void * voidhandle, int xsize, int ysize, unsigned char * img);

/*
 * grid.c - spatial subdivision efficiency structures
 *
 * $Id: grid.c,v 1.50 2002/08/05 05:27:45 johns Exp $
 * 
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"
#include "ui.h"
#include "parallel.h"

#define GRID_PRIVATE
#include "grid.h"

#ifndef cbrt
#define     cbrt(x)     ((x) > 0.0 ? pow((double)(x), 1.0/3.0) : \
                          ((x) < 0.0 ? -pow((double)-(x), 1.0/3.0) : 0.0))

#define     qbrt(x)     ((x) > 0.0 ? pow((double)(x), 1.0/4.0) : \
                          ((x) < 0.0 ? -pow((double)-(x), 1.0/4.0) : 0.0))

#endif

static object_methods grid_methods = {
  (void (*)(const void *, void *))(grid_intersect),
  (void (*)(const void *, const void *, const void *, void *))(NULL),
  grid_bbox, 
  grid_free 
};

object * newgrid(scenedef * scene, int xsize, int ysize, int zsize, vector min, vector max) {
  grid * g;
  int numcells;

  g = (grid *) malloc(sizeof(grid));
  memset(g, 0, sizeof(grid));  

  g->methods = &grid_methods;
  g->id = new_objectid(scene);

  g->xsize = xsize;
  g->ysize = ysize;
  g->zsize = zsize;

  numcells = xsize * ysize * zsize;

  g->min = min;
  g->max = max;

  VSub(&g->max, &g->min, &g->voxsize);
  g->voxsize.x /= (flt) g->xsize; 
  g->voxsize.y /= (flt) g->ysize; 
  g->voxsize.z /= (flt) g->zsize; 

  g->cells = (objectlist **) malloc(numcells * sizeof(objectlist *));
  memset(g->cells, 0, numcells * sizeof(objectlist *));

  return (object *) g;
}

static int grid_bbox(void * obj, vector * min, vector * max) {
  grid * g = (grid *) obj;
 
  *min = g->min;
  *max = g->max;

  return 1;
}

static void grid_free(void * v) {
  int i, numvoxels;
  grid * g = (grid *) v;

  /* loop through all voxels and free the object lists */
  numvoxels = g->xsize * g->ysize * g->zsize; 
  for (i=0; i<numvoxels; i++) {
    objectlist * lcur;
    objectlist * lnext;

    lcur = g->cells[i];
    while (lcur != NULL) {
      lnext = lcur->next;
      free(lcur);
      lcur = lnext;
    }
  }

  /* free the grid cells */ 
  free(g->cells);

  /* free all objects on the grid object list */
  free_objects(g->objects);   

  free(g);
}

static void globalbound(object ** rootlist, vector * gmin, vector * gmax) {
  vector min, max;
  object * cur;

  if (*rootlist == NULL)  /* don't bound non-existant objects */
    return;

  gmin->x =  FHUGE;   gmin->y =  FHUGE;   gmin->z =  FHUGE;
  gmax->x = -FHUGE;   gmax->y = -FHUGE;   gmax->z = -FHUGE;

  cur=*rootlist;
  while (cur != NULL)  {  /* Go! */
    min.x = -FHUGE; min.y = -FHUGE; min.z = -FHUGE;
    max.x =  FHUGE; max.y =  FHUGE; max.z =  FHUGE;

    if (cur->methods->bbox((void *) cur, &min, &max)) {
      gmin->x = MYMIN( gmin->x , min.x);
      gmin->y = MYMIN( gmin->y , min.y);
      gmin->z = MYMIN( gmin->z , min.z);

      gmax->x = MYMAX( gmax->x , max.x);
      gmax->y = MYMAX( gmax->y , max.y);
      gmax->z = MYMAX( gmax->z , max.z);
    }

    cur=cur->nextobj;
  }
}


static int cellbound(const grid *g, const gridindex *index, vector * cmin, vector * cmax) {
  vector min, max, cellmin, cellmax;
  objectlist * cur;
  int numinbounds = 0;

  cur = g->cells[index->z*g->xsize*g->ysize + index->y*g->xsize + index->x]; 

  if (cur == NULL)  /* don't bound non-existant objects */
    return 0;

  cellmin.x = voxel2x(g, index->x); 
  cellmin.y = voxel2y(g, index->y); 
  cellmin.z = voxel2z(g, index->z); 

  cellmax.x = cellmin.x + g->voxsize.x;
  cellmax.y = cellmin.y + g->voxsize.y;
  cellmax.z = cellmin.z + g->voxsize.z;

  cmin->x =  FHUGE;   cmin->y =  FHUGE;   cmin->z =  FHUGE;
  cmax->x = -FHUGE;   cmax->y = -FHUGE;   cmax->z = -FHUGE;

  while (cur != NULL)  {  /* Go! */
    min.x = -FHUGE; min.y = -FHUGE; min.z = -FHUGE;
    max.x =  FHUGE; max.y =  FHUGE; max.z =  FHUGE;

    if (cur->obj->methods->bbox((void *) cur->obj, &min, &max)) {
      if ((min.x >= cellmin.x) && (max.x <= cellmax.x) &&
          (min.y >= cellmin.y) && (max.y <= cellmax.y) &&
          (min.z >= cellmin.z) && (max.z <= cellmax.z)) {
      
        cmin->x = MYMIN( cmin->x , min.x);
        cmin->y = MYMIN( cmin->y , min.y);
        cmin->z = MYMIN( cmin->z , min.z);

        cmax->x = MYMAX( cmax->x , max.x);
        cmax->y = MYMAX( cmax->y , max.y);
        cmax->z = MYMAX( cmax->z , max.z);
      
        numinbounds++;
      }
    }

    cur=cur->next;
  }
 
  /* in case we get a 0.0 sized axis on the cell bounds, we'll */
  /* use the original cell bounds */
  if ((cmax->x - cmin->x) < EPSILON) {
    cmax->x += EPSILON;
    cmin->x -= EPSILON;
  }
  if ((cmax->y - cmin->y) < EPSILON) {
    cmax->y += EPSILON;
    cmin->y -= EPSILON;
  }
  if ((cmax->z - cmin->z) < EPSILON) {
    cmax->z += EPSILON;
    cmin->z -= EPSILON;
  }

  return numinbounds;
}

static int countobj(object * root) {
  object * cur;     /* counts the number of objects on a list */
  int numobj;

  numobj=0;
  cur=root;

  while (cur != NULL) {
    cur=cur->nextobj;
    numobj++;
  }
  return numobj;
}

static void gridstats(int xs, int ys, int zs, int numobj) {
  char t[128]; /* msgtxt */
  int numcells = xs*ys*zs; 
  sprintf(t, "Grid:  X:%3d  Y:%3d  Z:%3d  Cells:%9d  Obj:%9d  Obj/Cell: %7.3f",
          xs, ys, zs, numcells, numobj, ((float) numobj) / ((float) numcells));
  rt_ui_message(MSG_0, t);
}

int engrid_scene(scenedef * scene, int boundthresh) {
  grid * g;
  int numobj, numcbrt;
  vector gmin, gmax;
  gridindex index;
  char msgtxt[128];
  int numsucceeded; 
  if (scene->objgroup.boundedobj == NULL)
    return 0;

  numobj = countobj(scene->objgroup.boundedobj);

  if (scene->mynode == 0) {
    sprintf(msgtxt, "Scene contains %d objects.", numobj);
    rt_ui_message(MSG_0, msgtxt);
  }

  if (numobj > boundthresh) {
    numcbrt = (int) cbrt(4*numobj);
    globalbound(&scene->objgroup.boundedobj, &gmin, &gmax);

    g = (grid *) newgrid(scene, numcbrt, numcbrt, numcbrt, gmin, gmax);
    numsucceeded = engrid_objlist(g, &scene->objgroup.boundedobj);

    if (scene->verbosemode && scene->mynode == 0)
      gridstats(numcbrt, numcbrt, numcbrt, numsucceeded); 

    numobj = countobj(scene->objgroup.boundedobj);
    g->nextobj = scene->objgroup.boundedobj;
    scene->objgroup.boundedobj = (object *) g;

    /* now create subgrids.. */
    for (index.z=0; index.z<g->zsize; index.z++) {
      for (index.y=0; index.y<g->ysize; index.y++) {
        for (index.x=0; index.x<g->xsize; index.x++) {
          engrid_cell(scene, boundthresh, g, &index);
        }
      }
    } 
  }

  return 1;
}


static int engrid_objlist(grid * g, object ** list) {
  object * cur, * next, **prev;
  int numsucceeded = 0;

  if (*list == NULL) 
    return 0;
  
  prev = list; 
  cur = *list;

  while (cur != NULL) {
    next = cur->nextobj;

    if (engrid_object(g, cur, 1)) {
      *prev = next;
      numsucceeded++;
    }
    else {
      prev = (object **) &cur->nextobj;
    }

    cur = next;
  } 

  return numsucceeded;
}

static int engrid_cell(scenedef * scene, int boundthresh, grid * gold, gridindex *index) {
  vector gmin, gmax, gsize;
  flt len;
  int numobj, numcbrt, xs, ys, zs;
  grid * g;
  objectlist **list;
  objectlist * newobj;
  int numsucceeded;

  list = &gold->cells[index->z*gold->xsize*gold->ysize + 
                     index->y*gold->xsize  + index->x];

  if (*list == NULL)
    return 0;

  numobj =  cellbound(gold, index, &gmin, &gmax);

  VSub(&gmax, &gmin, &gsize);
  len = 1.0 / (MYMAX( MYMAX(gsize.x, gsize.y), gsize.z ));
  gsize.x *= len;  
  gsize.y *= len;  
  gsize.z *= len;  

  if (numobj > boundthresh) {
    numcbrt = (int) cbrt(2*numobj); 
    
    xs = (int) ((flt) numcbrt * gsize.x);
    if (xs < 1) xs = 1;
    ys = (int) ((flt) numcbrt * gsize.y);
    if (ys < 1) ys = 1;
    zs = (int) ((flt) numcbrt * gsize.z);
    if (zs < 1) zs = 1;

    g = (grid *) newgrid(scene, xs, ys, zs, gmin, gmax);
    numsucceeded = engrid_objectlist(g, list);

    if (scene->verbosemode && scene->mynode == 0)
      gridstats(xs, ys, zs, numsucceeded); 

    newobj = (objectlist *) malloc(sizeof(objectlist));    
    newobj->obj = (object *) g;
    newobj->next = *list;
    *list = newobj;

    g->nextobj = gold->objects;
    gold->objects = (object *) g;
  }

  return 1;
}

static int engrid_objectlist(grid * g, objectlist ** list) {
  objectlist * cur, * next, **prev;
  int numsucceeded = 0; 

  if (*list == NULL) 
    return 0;
  
  prev = list; 
  cur = *list;

  while (cur != NULL) {
    next = cur->next;

    if (engrid_object(g, cur->obj, 0)) {
      *prev = next;
      free(cur);
      numsucceeded++;
    }
    else {
      prev = &cur->next;
    }

    cur = next;
  } 

  return numsucceeded;
}



static int engrid_object(grid * g, object * obj, int addtolist) {
  vector omin, omax; 
  gridindex low, high;
  int x, y, z, zindex, yindex, voxindex;
  objectlist * tmp;
 
  if (obj->methods->bbox(obj, &omin, &omax)) { 
    if (!pos2grid(g, &omin, &low) || !pos2grid(g, &omax, &high)) {
      return 0; /* object is not wholly contained in the grid */
    }
  }
  else {
    return 0; /* object is unbounded */
  }

  /* add the object to the complete list of objects in the grid */
  if (addtolist) { 
    obj->nextobj = g->objects;
    g->objects = obj;
  }

  /* add this object to all voxels it inhabits */
  for (z=low.z; z<=high.z; z++) {
    zindex = z * g->xsize * g->ysize;
    for (y=low.y; y<=high.y; y++) {
      yindex = y * g->xsize;
      for (x=low.x; x<=high.x; x++) {
        voxindex = x + yindex + zindex; 
        tmp = (objectlist *) malloc(sizeof(objectlist));
        tmp->next = g->cells[voxindex];
        tmp->obj = obj;
        g->cells[voxindex] = tmp;
      }
    }
  }
 
  return 1;
}

static int pos2grid(grid * g, vector * pos, gridindex * index) {
  index->x = (int) ((flt) (pos->x - g->min.x) / g->voxsize.x);
  index->y = (int) ((flt) (pos->y - g->min.y) / g->voxsize.y);
  index->z = (int) ((flt) (pos->z - g->min.z) / g->voxsize.z);
  
  if (index->x == g->xsize)
    index->x--;
  if (index->y == g->ysize)
    index->y--;
  if (index->z == g->zsize)
    index->z--;

  if (index->x < 0 || index->x > g->xsize ||
      index->y < 0 || index->y > g->ysize ||
      index->z < 0 || index->z > g->zsize) 
    return 0;

  if (pos->x < g->min.x || pos->x > g->max.x ||
      pos->y < g->min.y || pos->y > g->max.y ||
      pos->z < g->min.z || pos->z > g->max.z) 
    return 0; 

  return 1;
}


/* the real thing */
static void grid_intersect(const grid * g, ray * ry) {
  flt tnear, tfar;
  vector curpos, tmax, tdelta;
  gridindex curvox, step, out; 
  int voxindex, SY, SZ;
  unsigned long serial;
#if !defined(DISABLEMBOX)
  unsigned long * mbox;
#endif
  objectlist * cur;

  if (ry->flags & RT_RAY_FINISHED)
    return;

  if (!grid_bounds_intersect(g, ry, &tnear, &tfar))
    return;
 
  if (ry->maxdist < tnear)
    return;
  
  serial=ry->serial;
#if !defined(DISABLEMBOX)
  mbox=ry->mbox;
#endif

  /* find the entry point in the grid from the near hit */ 
  curpos.x = ry->o.x + (ry->d.x * tnear);
  curpos.y = ry->o.y + (ry->d.y * tnear);
  curpos.z = ry->o.z + (ry->d.z * tnear);

  /* map the entry point to its nearest voxel */
  curvox.x = (int) ((flt) (curpos.x - g->min.x) / g->voxsize.x);
  curvox.y = (int) ((flt) (curpos.y - g->min.y) / g->voxsize.y);
  curvox.z = (int) ((flt) (curpos.z - g->min.z) / g->voxsize.z);
  if (curvox.x == g->xsize) curvox.x--;
  if (curvox.y == g->ysize) curvox.y--;
  if (curvox.z == g->zsize) curvox.z--;

  /* Setup X iterator stuff */
  if (ry->d.x < -EPSILON) {
    tmax.x = tnear + ((voxel2x(g, curvox.x) - curpos.x) / ry->d.x); 
    tdelta.x = g->voxsize.x / - ry->d.x;
    step.x = -1;
    out.x = -1;
  } else if (ry->d.x > EPSILON) {
    tmax.x = tnear + ((voxel2x(g, curvox.x + 1) - curpos.x) / ry->d.x);
    tdelta.x = g->voxsize.x / ry->d.x;
    step.x = 1;
    out.x = g->xsize;
  } else {
    tmax.x = FHUGE;
    tdelta.x = 0.0;
    step.x = 0;
    out.x = 0; /* never goes out of bounds on this axis */
  }

  /* Setup Y iterator stuff */
  if (ry->d.y < -EPSILON) {
    tmax.y = tnear + ((voxel2y(g, curvox.y) - curpos.y) / ry->d.y);
    tdelta.y = g->voxsize.y / - ry->d.y;
    step.y = -1;
    out.y = -1;
  } else if (ry->d.y > EPSILON) {
    tmax.y = tnear + ((voxel2y(g, curvox.y + 1) - curpos.y) / ry->d.y);
    tdelta.y = g->voxsize.y / ry->d.y;
    step.y = 1;
    out.y = g->ysize;
  } else {
    tmax.y = FHUGE;
    tdelta.y = 0.0; 
    step.y = 0;
    out.y = 0; /* never goes out of bounds on this axis */
  }

  /* Setup Z iterator stuff */
  if (ry->d.z < -EPSILON) {
    tmax.z = tnear + ((voxel2z(g, curvox.z) - curpos.z) / ry->d.z);
    tdelta.z = g->voxsize.z / - ry->d.z;
    step.z = -1;
    out.z = -1;
  } else if (ry->d.z > EPSILON) {
    tmax.z = tnear + ((voxel2z(g, curvox.z + 1) - curpos.z) / ry->d.z);
    tdelta.z = g->voxsize.z / ry->d.z;
    step.z = 1;
    out.z = g->zsize;
  } else {
    tmax.z = FHUGE;
    tdelta.z = 0.0; 
    step.z = 0;
    out.z = 0; /* never goes out of bounds on this axis */
  }

  /* pre-calculate row/column/plane offsets for stepping through grid */
  SY = step.y * g->xsize;
  SZ = step.z * g->xsize * g->ysize;

  /* first cell we'll be testing */
  voxindex = curvox.z*g->xsize*g->ysize + curvox.y*g->xsize + curvox.x; 

  /* Unrolled while loop by one... */
  /* Test all objects in the current cell for intersection */
  cur = g->cells[voxindex];
  while (cur != NULL) {
#if !defined(DISABLEMBOX)
    if (mbox[cur->obj->id] != serial) {
      mbox[cur->obj->id] = serial; 
      cur->obj->methods->intersect(cur->obj, ry);
    }
#else
    cur->obj->methods->intersect(cur->obj, ry);
#endif
    cur = cur->next;
  }

  /* Loop through grid cells until we're done */
  while (!(ry->flags & RT_RAY_FINISHED)) {
    /* Walk to next cell */
    if (tmax.x < tmax.y && tmax.x < tmax.z) {
      curvox.x += step.x;
      if (ry->maxdist < tmax.x || curvox.x == out.x) 
        break; 
      tmax.x += tdelta.x;
      voxindex += step.x;
    }
    else if (tmax.z < tmax.y) {
      curvox.z += step.z;
      if (ry->maxdist < tmax.z || curvox.z == out.z) 
        break;
      tmax.z += tdelta.z;
      voxindex += SZ;
    }
    else {
      curvox.y += step.y;
      if (ry->maxdist < tmax.y || curvox.y == out.y) 
        break;
      tmax.y += tdelta.y;
      voxindex += SY;
    }

    /* Test all objects in the current cell for intersection */
    cur = g->cells[voxindex];
    while (cur != NULL) {
#if !defined(DISABLEMBOX)
      if (mbox[cur->obj->id] != serial) {
        mbox[cur->obj->id] = serial; 
        cur->obj->methods->intersect(cur->obj, ry);
      }
#else
      cur->obj->methods->intersect(cur->obj, ry);
#endif
      cur = cur->next;
    }
  }
}



static int grid_bounds_intersect(const grid * g, const ray * ry, flt *hitnear, flt *hitfar) {
  flt a, tx1, tx2, ty1, ty2, tz1, tz2;
  flt tnear, tfar;

  tnear= -FHUGE;
  tfar= FHUGE;

  if (ry->d.x == 0.0) {
    if ((ry->o.x < g->min.x) || (ry->o.x > g->max.x)) return 0;
  }
  else {
    tx1 = (g->min.x - ry->o.x) / ry->d.x;
    tx2 = (g->max.x - ry->o.x) / ry->d.x;
    if (tx1 > tx2) { a=tx1; tx1=tx2; tx2=a; }
    if (tx1 > tnear) tnear=tx1;
    if (tx2 < tfar)   tfar=tx2;
  }
  if (tnear > tfar) return 0;
  if (tfar < 0.0) return 0;

  if (ry->d.y == 0.0) {
    if ((ry->o.y < g->min.y) || (ry->o.y > g->max.y)) return 0;
  }
  else {
    ty1 = (g->min.y - ry->o.y) / ry->d.y;
    ty2 = (g->max.y - ry->o.y) / ry->d.y;
    if (ty1 > ty2) { a=ty1; ty1=ty2; ty2=a; }
    if (ty1 > tnear) tnear=ty1;
    if (ty2 < tfar)   tfar=ty2;
  }
  if (tnear > tfar) return 0;
  if (tfar < 0.0) return 0;

  if (ry->d.z == 0.0) {
    if ((ry->o.z < g->min.z) || (ry->o.z > g->max.z)) return 0;
  }
  else {
    tz1 = (g->min.z - ry->o.z) / ry->d.z;
    tz2 = (g->max.z - ry->o.z) / ry->d.z;
    if (tz1 > tz2) { a=tz1; tz1=tz2; tz2=a; }
    if (tz1 > tnear) tnear=tz1;
    if (tz2 < tfar)   tfar=tz2;
  }
  if (tnear > tfar) return 0;
  if (tfar < 0.0) return 0;

  if (tnear < 0.0) {
    *hitnear = 0.0;
  } else {
    *hitnear = tnear;
  }

  *hitfar = tfar; 
  return 1;
}




/*
 * grid.h - spatial subdivision efficiency structures
 *
 * $Id: grid.h,v 1.16 2002/08/04 21:43:34 johns Exp $
 * 
 */

int engrid_scene(scenedef * scene, int boundthresh);
object * newgrid(scenedef * scene, int xsize, int ysize, int zsize, 
                 vector min, vector max);

#ifdef GRID_PRIVATE

typedef struct objectlist {
  struct objectlist * next; /* next link in the list */
  object * obj;             /* the actual object     */
} objectlist; 

typedef struct {
  RT_OBJECT_HEAD
  int xsize;           /* number of cells along the X direction */
  int ysize;           /* number of cells along the Y direction */
  int zsize;           /* number of cells along the Z direction */
  vector min;          /* the minimum coords for the box containing the grid */
  vector max;          /* the maximum coords for the box containing the grid */
  vector voxsize;      /* the size of a grid cell/voxel */
  object * objects;    /* all objects contained in the grid */
  objectlist ** cells; /* the grid cells themselves */
} grid;

typedef struct {
  int x;         /* Voxel X address */
  int y;         /* Voxel Y address */
  int z;         /* Voxel Z address */
} gridindex; 

/*
 * Convert from voxel number along X/Y/Z to corresponding coordinate.
 */
#define voxel2x(g,X)  ((X) * (g->voxsize.x) + (g->min.x))
#define voxel2y(g,Y)  ((Y) * (g->voxsize.y) + (g->min.y))
#define voxel2z(g,Z)  ((Z) * (g->voxsize.z) + (g->min.z))

/*
 * And vice-versa.
 */
#define x2voxel(g,x)            (((x) - g->min.x) / g->voxsize.x)
#define y2voxel(g,y)            (((y) - g->min.y) / g->voxsize.y)
#define z2voxel(g,z)            (((z) - g->min.z) / g->voxsize.z)


static void gridstats(int xs, int ys, int zs, int numobj);
static int grid_bbox(void * obj, vector * min, vector * max);
static void grid_free(void * v);

static int cellbound(const grid *g, const gridindex *index, vector * cmin, vector * cmax);

static int engrid_objlist(grid * g, object ** list);
static int engrid_object(grid * g, object * obj, int addtolist);

static int engrid_objectlist(grid * g, objectlist ** list);
static int engrid_cell(scenedef *, int, grid *, gridindex *);

static int pos2grid(grid * g, vector * pos, gridindex * index);
static void grid_intersect(const grid *, ray *);
static int grid_bounds_intersect(const grid * g, const ray * ry, flt *hitnear, flt *hitfar);

#endif


/*
 * hash.c - This file contains code implementing various hash tables 
 * 
 * $Id: hash.c,v 1.2 2000/11/28 19:15:01 johns Exp $
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hash.h"

#define HASH_LIMIT 0.5

/*
 *  Local types
 */
typedef struct hash_node_t {
  int data;                           /* data in hash node */
  const char * key;                   /* key for hash lookup */
  struct hash_node_t *next;           /* next node in hash chain */
} hash_node_t;

/*
 *  hash() - Hash function returns a hash number for a given key.
 *
 *  tptr: Pointer to a hash table
 *  key: The key to create a hash number for
 */
static int hash(rt_hash_t *tptr, const char *key) {
  int i=0;
  int hashvalue;
 
  while (*key != '\0')
    i=(i<<3)+(*key++ - '0');
 
  hashvalue = (((i*1103515249)>>tptr->downshift) & tptr->mask);
  if (hashvalue < 0) {
    hashvalue = 0;
  }    

  return hashvalue;
}

/*
 *  rebuild_table() - Create new hash table when old one fills up.
 *
 *  tptr: Pointer to a hash table
 */
static void rebuild_table(rt_hash_t *tptr) {
  hash_node_t **old_bucket, *old_hash, *tmp;
  int old_size, h, i;

  old_bucket=tptr->bucket;
  old_size=tptr->size;

  /* create a new table and rehash old buckets */
  rt_hash_init(tptr, old_size<<1);
  for (i=0; i<old_size; i++) {
    old_hash=old_bucket[i];
    while(old_hash) {
      tmp=old_hash;
      old_hash=old_hash->next;
      h=hash(tptr, tmp->key);
      tmp->next=tptr->bucket[h];
      tptr->bucket[h]=tmp;
      tptr->entries++;
    } /* while */
  } /* for */

  /* free memory used by old table */
  free(old_bucket);

  return;
}

/*
 *  rt_hash_init() - Initialize a new hash table.
 *
 *  tptr: Pointer to the hash table to initialize
 *  buckets: The number of initial buckets to create
 */
void rt_hash_init(rt_hash_t *tptr, int buckets) {

  /* make sure we allocate something */
  if (buckets==0)
    buckets=16;

  /* initialize the table */
  tptr->entries=0;
  tptr->size=2;
  tptr->mask=1;
  tptr->downshift=29;

  /* ensure buckets is a power of 2 */
  while (tptr->size<buckets) {
    tptr->size<<=1;
    tptr->mask=(tptr->mask<<1)+1;
    tptr->downshift--;
  } /* while */

  /* allocate memory for table */
  tptr->bucket=(hash_node_t **) calloc(tptr->size, sizeof(hash_node_t *));

  return;
}

/*
 *  hash_lookup() - Lookup an entry in the hash table and return a 
 *                  pointer to it or HASH_FAIL if it wasn't found.
 *
 *  tptr: Pointer to the hash table
 *  key: The key to lookup
 */
int rt_hash_lookup(rt_hash_t *tptr, const char *key) {
  int h;
  hash_node_t *node;


  /* find the entry in the hash table */
  h=hash(tptr, key);
  for (node=tptr->bucket[h]; node!=NULL; node=node->next) {
    if (!strcmp(node->key, key))
      break;
  }

  /* return the entry if it exists, or HASH_FAIL */
  return(node ? node->data : HASH_FAIL);
}

/*
 *  rt_hash_insert() - Insert an entry into the hash table.  If the 
 *                     entry already exists return a pointer to it, 
 *                     otherwise return HASH_FAIL.
 *
 *  tptr: A pointer to the hash table
 *  key: The key to insert into the hash table
 *  data: A pointer to the data to insert into the hash table
 */
int rt_hash_insert(rt_hash_t *tptr, const char *key, int data) {
  int tmp;
  hash_node_t *node;
  int h;


  /* check to see if the entry exists */
  if ((tmp=rt_hash_lookup(tptr, key)) != HASH_FAIL)
    return(tmp);

  /* expand the table if needed */
  while (tptr->entries>=HASH_LIMIT*tptr->size)
    rebuild_table(tptr);

  /* insert the new entry */
  h=hash(tptr, key);
  node=(struct hash_node_t *) malloc(sizeof(hash_node_t));
  node->data=data;
  node->key=key;
  node->next=tptr->bucket[h];
  tptr->bucket[h]=node;
  tptr->entries++;

  return HASH_FAIL;
}

/*
 *  rt_hash_delete() - Remove an entry from a hash table and return a pointer
 *                     to its data or HASH_FAIL if it wasn't found.
 *
 *  tptr: A pointer to the hash table
 *  key: The key to remove from the hash table
 */
int rt_hash_delete(rt_hash_t *tptr, const char *key) {
  hash_node_t *node, *last;
  int data;
  int h;

  /* find the node to remove */
  h=hash(tptr, key);
  for (node=tptr->bucket[h]; node; node=node->next) {
    if (!strcmp(node->key, key))
      break;
  }

  /* Didn't find anything, return HASH_FAIL */
  if (node==NULL)
    return HASH_FAIL;

  /* if node is at head of bucket, we have it easy */
  if (node==tptr->bucket[h])
    tptr->bucket[h]=node->next;
  else {
    /* find the node before the node we want to remove */
    for (last=tptr->bucket[h]; last && last->next; last=last->next) {
      if (last->next==node)
        break;
    }
    last->next=node->next;
  }

  /* free memory and return the data */
  data=node->data;
  free(node);

  return(data);
}



/*
 * rt_hash_destroy() - Delete the entire table, and all remaining entries.
 * 
 */
void rt_hash_destroy(rt_hash_t *tptr) {
  hash_node_t *node, *last;
  int i;

  for (i=0; i<tptr->size; i++) {
    node = tptr->bucket[i];
    while (node != NULL) { 
      last = node;   
      node = node->next;
      free(last);
    }
  }     

  /* free the entire array of buckets */
  if (tptr->bucket != NULL) {
    free(tptr->bucket);
    memset(tptr, 0, sizeof(rt_hash_t));
  }
}

/*
 *  alos() - Find the average length of search.
 *
 *  tptr: Pointer to a hash table
 */
static float alos(rt_hash_t *tptr) {
  int i,j;
  float alos=0;
  hash_node_t *node;


  for (i=0; i<tptr->size; i++) {
    for (node=tptr->bucket[i], j=0; node!=NULL; node=node->next, j++);
    if (j)
      alos+=((j*(j+1))>>1);
  } /* for */

  return(tptr->entries ? alos/tptr->entries : 0);
}


/*
 *  rt_hash_stats() - Return a string with stats about a hash table.
 *
 *  tptr: A pointer to the hash table
 */
char * rt_hash_stats(rt_hash_t *tptr) {
  static char buf[1024];

  sprintf(buf, "%u slots, %u entries, and %1.2f ALOS",
    (int)tptr->size, (int)tptr->entries, alos(tptr));

  return(buf);
}




/*
 * hash.h - This file contains prototypes for hash table code etc.
 *
 * $Id: hash.h,v 1.3 2001/12/03 07:27:05 johns Exp $
 */

#ifndef HASH_H
#define HASH_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct rt_hash_t {
  struct hash_node_t **bucket;        /* array of hash nodes */
  int size;                           /* size of the array */
  int entries;                        /* number of entries in table */
  int downshift;                      /* shift cound, used in hash function */
  int mask;                           /* used to select bits for hashing */
} rt_hash_t;

#define HASH_FAIL -1

void rt_hash_init(rt_hash_t *, int);
int rt_hash_lookup (rt_hash_t *, const char *);
int rt_hash_insert (rt_hash_t *, const char *, int);
int rt_hash_delete (rt_hash_t *, const char *);
void rt_hash_destroy(rt_hash_t *);
char *rt_hash_stats (rt_hash_t *);

#ifdef __cplusplus
}
#endif

#endif
/* 
 * fire.c 
 * This file contains the main program and driver for the raytracer.
 *
 *  $Id: hypertex.c,v 1.13 2002/07/03 04:59:29 johns Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "tachyon.h"

int rt_mynode(void); /* proto */

#define XRES 352
#define YRES 240

/* MPEG-1 Resolution  */
/*
 *#define XRES 352 
 *#define YRES 240    
 */
 
/* Pro Video Full Frame NTSC 
 *  #define XRES 768
 *  #define YRES 576
 */
 
/* PC VGA, and NTSC Resolution  
 * #define XRES 640
 * #define YRES 480
 */

#define MAXFRAMES 60
#define OPACITY 4.0

#define RAD 6.28

typedef struct {      /* Scalar Volume Visualization Data */
  int loaded;            /* Volume data memory residence flag */
  int xres;              /* volume X axis size                */
  int yres;              /* volume Y axis size                */
  int zres;              /* volume Z axis size                */
  apiflt opacity;        /* opacity per unit length           */
  char name[80];         /* Volume data filename              */
  unsigned char * data;  /* pointer to raw byte volume data   */
} scalarvol;

typedef struct {
  int x;
  int y;
} flm;

#ifdef cube
#define RFILE "/cfs/johns/anim/frame"
#endif
#ifndef cube 
#define RFILE "frame"
#endif

/* global frame number */
static int framenumber=0;

apiflt hypertex1(double x, double y, double z) {
  double value, dist;
  double xx, yy, zz;

  xx = x - 0.5;
  yy = y - 0.5;
  zz = z - 0.5;

  dist = sqrt(xx*xx + yy*yy + zz*zz);  
 
  if (dist < 0.35) {
    value = 1.0;
  }
  else {
    value = 0.0;
  }

  return value; 
}
   

apiflt hypertex2(double x, double y, double z) {
  double xx, yy, zz;
  double dist;
  double value;

  xx = x - 0.5; 
  yy = y - 0.5;
  zz = z - 0.5;

  dist = sqrt(xx*xx + yy*yy + zz*zz) + (framenumber / 200);

  value = (1.0 + cos(dist * 48.0) / (2*dist + 1.0)) / 2.0;

  value = value*value*value; 

  return value;
}

int main(int argc, char **argv) {
  SceneHandle scene;
  int i;
  int raydepth, antialiasing, verbosemode;
  apiflt zoom, aspectratio;
  apivector Ccenter, Cview, Cup;
  apivector ctr1;
  apitexture tex1, tex2;
  apivector min3, max3;
  apitexture p1;
  apivector ct1, n1;
  apiflt xc,yc;
  void * t1;
  char fname[1000];
  char fname2[2000];

  rt_initialize(&argc, &argv); 

  scene = rt_newscene();

  aspectratio=1.0; raydepth=8;
  antialiasing=0; verbosemode=0; zoom=1.0;
 
  Ccenter.x=0.0; Ccenter.y=0.0; Ccenter.z=0.0;
  Cview.x=1.0;   Cview.y=0.0;   Cview.z=0.0;
  Cup.x=0.0;     Cup.y=0.0;     Cup.z=1.0;
  ctr1.x=2.0;  ctr1.y=2.0; ctr1.z=2.0;
  
  tex1.col.r=1.0; tex1.col.g=1.0; tex1.col.b=1.0;
  tex1.ambient=0.5;  
  tex1.diffuse=1.0;
  tex1.specular=0.0; 
  tex1.opacity=OPACITY;
  tex1.texturefunc=0;
  tex2=tex1;

  min3.x=-1.0; min3.y=-1.0; min3.z=-1.0;
  max3.x=1.0;  max3.y=1.0;  max3.z=1.0;

  p1.col.r=1.0; p1.col.g=1.0; p1.col.b=1.0;
  p1.ambient=0.3; p1.diffuse=0.8; p1.specular=0.0; p1.opacity=1.0;

  p1.texturefunc=9;
    p1.ctr.x=0.0;   p1.ctr.y=0.0;   p1.ctr.z=0.0;
    p1.rot.x=0.0;   p1.rot.y=0.0;   p1.rot.z=0.0;
  p1.scale.x=0.1; p1.scale.y=0.1; p1.scale.z=0.1; 
   p1.uaxs.x=1.0;  p1.uaxs.y=0.0;  p1.uaxs.z=0.0;
   p1.vaxs.x=0.0;  p1.vaxs.y=1.0;  p1.vaxs.z=0.0;
#ifdef cube
  strcpy((char *) &p1.imap, "/cfs/johns/imaps/leafy261.ppm");
#endif
#ifndef cube
  strcpy((char *) &p1.imap, "/disk7/cube/imaps/leafy261.ppm");
#endif  

  t1=rt_texture(scene, &p1);

  for (i=0; i<MAXFRAMES; i++) {  
    rt_initialize(&argc, &argv); 

    sprintf(fname,".%4.4d.tga",i);
    strcpy(fname2,RFILE);
    strcat(fname2, fname);
    
    framenumber++;
 
    if (rt_mynode()==0) printf("Rendering: %s \n",fname2);

    xc=cos(6.28 * (i + 200) / (1.0 * MAXFRAMES));
    yc=sin(6.28 * (i + 200) / (1.0 * MAXFRAMES));
    Ccenter.x = xc*5.2; 
    Ccenter.y = yc*5.2;
    Cview.x =  -xc; 
    Cview.y =  -yc;

    rt_outputfile(scene, fname2);
    rt_resolution(scene, XRES, YRES);
    rt_verbose(scene, verbosemode);

    rt_camera_setup(scene, zoom, aspectratio, antialiasing, 
                    raydepth, Ccenter, Cview, Cup);

    rt_light(scene, rt_texture(scene, &tex1), ctr1, 1.0); 

    rt_extvol(scene, rt_texture(scene, &tex2), min3, max3, 64, hypertex1); 

    ct1.x=0.0; ct1.y=0.0; ct1.z=-1.01;
    n1.x=0.0; n1.y=0.0; n1.z=1.0;
    rt_plane(scene, t1, ct1, n1);  

    ct1.x=0.0; ct1.y=1.8; ct1.z=1.8;

    rt_renderscene(scene);
  }
  rt_finalize(); 

  return 0;
}
   
/* 
 * image.h - Image Data Structures and definitions
 *
 * One day, this file will define a common structure
 * for all image / animation / volume type data structures.
 * This will allow me to design and implement a library of
 * pixel processing routines for pre and post processing of
 * image data in the rendering process.  Good examples will be
 * image map filtering, animated image maps, DCT/IDCT algorithms,
 * scalar volume data, a common set of file format readers and converters.
 *
 */

typedef struct {
  int ID;                 /* frame number */
  unsigned int info;      /* bitmapped flags and values        */
                          /* YUV, RGB, DCT, image, animation,  */
                          /* volume, etc.                      */ 
  unsigned int loaded;    /* memory residency information */
  unsigned int xs;        /* pels in x dimension   */
  unsigned int ys;        /* pels in y dimension   */
  unsigned int zs;        /* pels in z dimension   */
  unsigned char * data;   /* raw image/volume data */
  char filename[FILENAME_MAX]; /* filename or remote access identifier */
} Frame;


/*
 *  imageio.c - This file deals with reading/writing image files
 *
 *  $Id: imageio.c,v 1.14 2001/02/26 18:37:49 johns Exp $
 */ 

/* For our puposes, we're interested only in the 3 byte per pixel 24 bit
 * truecolor sort of file..
 */

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h"
#include "ppm.h"     /* 24-bit PPM files */
#include "tgafile.h" /* 24-bit Truevision Targa files */
#include "jpeg.h"    /* JPEG files */
#include "pngfile.h" /* PNG files  */
#include "sgirgb.h"  /* 24-bit SGI RGB files */
#include "winbmp.h"  /* 24-bit Windows Bitmap files */
#include "ui.h"      /* UI error messages */

static 
int fakeimage(char * name, int * xres, int * yres, unsigned char ** imgdata) {
  int i, imgsize;
  char msgtxt[2048];
  sprintf(msgtxt, "Error loading image %s.  Faking it using solid gray.", name);
  rt_ui_message(MSG_0, msgtxt);
   
  *xres = 4;
  *yres = 4;
  imgsize = 3 * (*xres) * (*yres);
  *imgdata = malloc(imgsize);
  for (i=0; i<imgsize; i++) {
    (*imgdata)[i] = 255;
  }

  return IMAGENOERR;
}


int readimage(rawimage * img) {
  int rc;
  int xres, yres;
  unsigned char * imgdata;
  char * name = img->name;
  char msgtxt[2048];

  if (strstr(name, ".ppm")) { 
    rc = readppm(name, &xres, &yres, &imgdata);
  }
  else if (strstr(name, ".tga")) {
    rc = readtga(name, &xres, &yres, &imgdata);
  }
  else if (strstr(name, ".jpg")) {
    rc = readjpeg(name, &xres, &yres, &imgdata);
  }
  else if (strstr(name, ".png")) {
    rc = readpng(name, &xres, &yres, &imgdata);
  }
  else if (strstr(name, ".gif")) {
    rc = IMAGEUNSUP; 
  }
  else if (strstr(name, ".tiff")) {
    rc = IMAGEUNSUP; 
  }
  else if (strstr(name, ".rgb")) {
    rc = IMAGEUNSUP; 
  }
  else if (strstr(name, ".xpm")) {
    rc = IMAGEUNSUP; 
  }
  else {
    rc = readppm(name, &xres, &yres, &imgdata);
  } 

  switch (rc) {
    case IMAGEREADERR:
      sprintf(msgtxt, "Short read encountered while loading image %s", name);
      rt_ui_message(MSG_0, msgtxt);
      rc = IMAGENOERR; /* remap to non-fatal error */
      break;

    case IMAGEUNSUP:
      sprintf(msgtxt, "Cannot read unsupported format for image %s", name);
      rt_ui_message(MSG_0, msgtxt);
      break;
  }    

  /* If the image load failed, create a tiny white colored image to fake it */ 
  /* this allows a scene to render even when a file can't be loaded */
  if (rc != IMAGENOERR) {
    rc = fakeimage(name, &xres, &yres, &imgdata);
  }

  /* If we succeeded in loading the image, return it. */
  if (rc == IMAGENOERR) { 
    img->xres = xres;
    img->yres = yres;
    img->bpp = 3;  
    img->data = imgdata;
  }

  return rc;
}
 

int writeimage(char * name, int xres, int yres, unsigned char *imgdata, 
               int format) {
  if (imgdata == NULL) 
    return IMAGENULLDATA;

  switch (format) {
    case RT_FORMAT_PPM:
      return writeppm(name, xres, yres, imgdata);
    
    case RT_FORMAT_SGIRGB:
      return writergb(name, xres, yres, imgdata);

    case RT_FORMAT_JPEG:
      return writejpeg(name, xres, yres, imgdata);

    case RT_FORMAT_PNG:
      return writepng(name, xres, yres, imgdata);

    case RT_FORMAT_WINBMP:
      return writebmp(name, xres, yres, imgdata);

    case RT_FORMAT_TARGA:
    default:
      return writetga(name, xres, yres, imgdata);       
  } 
}


/*
 *  imageio.h - This file deals with reading/writing image files 
 *
 *  $Id: imageio.h,v 1.5 1999/09/01 19:34:10 johns Exp $
 */ 

/* For our puposes, we're interested only in the 3 byte per pixel 24 bit
   truecolor sort of file.. */

#define IMAGENOERR     0  /* no error */
#define IMAGEBADFILE   1  /* can't find or can't open the file */
#define IMAGEUNSUP     2  /* the image file is an unsupported format */
#define IMAGEALLOCERR  3  /* not enough remaining memory to load this image */
#define IMAGEREADERR   4  /* failed read, short reads etc */
#define IMAGEWRITEERR  5  /* failed write, short writes etc */
#define IMAGENULLDATA  6  /* image to write was a null pointer */

int readimage(rawimage *);
int writeimage(char * name, int xres, int yres, 
               unsigned char *imgdata, int format);


/*
 * imap.c - This file contains code for doing image map type things.  
 *
 *  $Id: imap.c,v 1.22 2002/07/09 18:29:52 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "imap.h"
#include "util.h"
#include "parallel.h"
#include "imageio.h"
#include "ui.h"

/* XXX globals that must be eliminated! */
rawimage * imagelist[MAXIMGS];
int numimages;

void ResetImages(void) {
  int i;
  numimages=0;
  for (i=0; i<MAXIMGS; i++) {
    imagelist[i]=NULL;
  }
}

void LoadImage(rawimage * image) {
  if (!image->loaded) {
    readimage(image);
    image->loaded=1;
  }
}

rawimage * AllocateImage(const char * filename) { 
  rawimage * newimage = NULL;
  int i, len, intable;

  intable=0;
  if (numimages!=0) {
    for (i=0; i<numimages; i++) {
      if (!strcmp(filename, imagelist[i]->name)) {
        newimage=imagelist[i];
        intable=1;
      }
    }
  }

  if (!intable) {
    newimage=malloc(sizeof(rawimage));
    newimage->loaded=0;
    newimage->xres=0;
    newimage->yres=0;
    newimage->bpp=0;
    newimage->data=NULL;
    len=strlen(filename);
    if (len > 80) 
      return NULL;
    strcpy(newimage->name, filename);

    imagelist[numimages]=newimage;  /* add new one to the table       */ 
    numimages++;                    /* increment the number of images */
  }
 
  return newimage;
}

rawimage * NewImage(int x, int y) {
  rawimage * newimage = NULL;
  newimage=malloc(sizeof(rawimage));
  if (newimage == NULL)
    return NULL;

  newimage->loaded=1;
  newimage->xres=x;
  newimage->yres=y;
  newimage->bpp=0;
  newimage->data=malloc(x*y*3);
  if (newimage->data == NULL) {
    free(newimage);
    return NULL;
  }

  return newimage;
}

void DeallocateImage(rawimage * image) {
  image->loaded=0;
  free(image->data);
}

mipmap * LoadMIPMap(const char * filename) {
  rawimage * img;
  mipmap * mip;

  img = AllocateImage(filename);
  if (img == NULL)
    return NULL;

  LoadImage(img);

  mip = CreateMIPMap(img); 
  if (mip == NULL) {
    DeallocateImage(img);
    free(mip);
    return NULL;
  }

  return mip;
}

rawimage * DecimateImage(const rawimage * image) {
  rawimage * newimage;
  int x, y, addr, addr2;

  x = (int) image->xres >> 1;
  if (x == 0)
    x = 1;

  y = (int) image->yres >> 1;
  if (y == 0)
    y = 1;

  newimage = NewImage(x, y);

  if (image->xres > 1 && image->yres > 1) {
    for (y=0; y<newimage->yres; y++) {
      for (x=0; x<newimage->xres; x++) {
        addr = (newimage->xres*y + x)*3;
        addr2 = (image->xres*y + x)*3*2;
        newimage->data[addr] = (int)
          (image->data[addr2] + 
           image->data[addr2 + 3] +
           image->data[addr2 + image->xres*3] + 
           image->data[addr2 + (image->xres + 1)*3]) >> 2; 
        addr++;
        addr2++;
        newimage->data[addr] = (int)
          (image->data[addr2] + 
           image->data[addr2 + 3] +
           image->data[addr2 + image->xres*3] + 
           image->data[addr2 + (image->xres + 1)*3]) >> 2; 
        addr++;
        addr2++;
        newimage->data[addr] = (int)
          (image->data[addr2] + 
           image->data[addr2 + 3] +
           image->data[addr2 + image->xres*3] + 
           image->data[addr2 + (image->xres + 1)*3]) >> 2; 
      }
    }
  }
  else if (image->xres == 1) {
    for (y=0; y<newimage->yres; y++) {
      addr = y*3;
      addr2 = y*3*2;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
      addr++;
      addr2++;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
      addr++;
      addr2++;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
    }
  }
  else if (image->yres == 1) {
    for (x=0; x<newimage->xres; x++) {
      addr = x*3;
      addr2 = x*3*2;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
      addr++;
      addr2++;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
      addr++;
      addr2++;
      newimage->data[addr] = (int)
        (image->data[addr2] + 
         image->data[addr2 + 3]) >> 1;
    }
  }

  return newimage;
}

mipmap * CreateMIPMap(const rawimage * image) {
  mipmap * mip;
  int xlevels, ylevels, i; 
  char msgtxt[1024];
  
  if (image == NULL) 
    return NULL;

  mip = (mipmap *) malloc(sizeof(mipmap));
  if (mip == NULL)
    return NULL;

  xlevels = 0;  
  i = abs(image->xres);
  while (i) {
    i >>= 1; 
    xlevels++;
  }
  
  ylevels = 0;  
  i = abs(image->yres);
  while (i) {
    i >>= 1; 
    ylevels++;
  }

  mip->levels = (xlevels > ylevels) ? xlevels : ylevels; 

  sprintf(msgtxt, "Creating MIP Map: xlevels: %d  ylevels: %d  levels: %d", 
          xlevels, ylevels, mip->levels);
  rt_ui_message(MSG_0, msgtxt);

  mip->images = (rawimage const **) malloc(mip->levels * sizeof(rawimage *)); 
  if (mip->images == NULL) {
    free(mip);
    return NULL;
  }
     
  for (i=0; i<mip->levels; i++) {
    mip->images[i] = NULL;
  } 

  mip->images[0] = image;
  for (i=1; i<mip->levels; i++) {
    mip->images[i] = DecimateImage(mip->images[i - 1]);
  }

  return mip;
}

color MIPMap(const mipmap * mip, flt u, flt v, flt d) {
  int mapindex;
  flt mapflt;
  color col, col1, col2;

  if ((u <= 1.0) && (u >=0.0) && (v <= 1.0) && (v >= 0.0)) {
    if (d > 1.0) 
      d = 1.0;
    else if (d < 0.0)
      d = 0.0;

    mapflt = d * (mip->levels - 0.9999); /* convert range to mapindex        */
    mapindex = (int) mapflt;             /* truncate to nearest integer      */
    mapflt = mapflt - mapindex;          /* fractional part of mip map level */

    /* interpolate between two nearest image maps */
    if (mapindex < (mip->levels - 1)) {
      col1 = ImageMap(mip->images[mapindex    ], u, v);
      col2 = ImageMap(mip->images[mapindex + 1], u, v);
      col.r = col1.r + mapflt*(col2.r - col1.r);
      col.g = col1.g + mapflt*(col2.g - col1.g);
      col.b = col1.b + mapflt*(col2.b - col1.b);
    }
    else {
      /* if mapindex is too high, use the highest,  */
      /* with no MIP-Map interpolation.             */
      col  = ImageMap(mip->images[mip->levels - 1], u, v);
    }
  } 
  else {
    col.r=0.0;
    col.g=0.0;
    col.b=0.0;
  }

  return col;
}

color ImageMap(const rawimage * image, flt u, flt v) {
  color col, colx, colx2;
  flt x, y, px, py;
  int ix, iy;
  unsigned char * ptr;

  /*
   *  Perform bilinear interpolation between 4 closest pixels.
   */
  x = (image->xres - 1.0) * u; /* floating point X location */
  ix = (int) x;                /* integer X location        */
  px = x - ix;                 /* fractional X location     */

  y = (image->yres - 1.0) * v; /* floating point Y location */
  iy = (int) y;                /* integer Y location        */
  py = y - iy;                 /* fractional Y location     */

  /* pointer to the left lower pixel */
  ptr  = image->data + ((image->xres * iy) + ix) * 3; 

  /* interpolate between left and right lower pixels */
  colx.r = (flt) ((flt)ptr[0] + px*((flt)ptr[3] - (flt) ptr[0])); 
  colx.g = (flt) ((flt)ptr[1] + px*((flt)ptr[4] - (flt) ptr[1])); 
  colx.b = (flt) ((flt)ptr[2] + px*((flt)ptr[5] - (flt) ptr[2])); 

  /* pointer to the left upper pixel */
  ptr  += image->xres * 3; 

  /* interpolate between left and right upper pixels */
  colx2.r = ((flt)ptr[0] + px*((flt)ptr[3] - (flt)ptr[0])); 
  colx2.g = ((flt)ptr[1] + px*((flt)ptr[4] - (flt)ptr[1])); 
  colx2.b = ((flt)ptr[2] + px*((flt)ptr[5] - (flt)ptr[2])); 

  /* interpolate between upper and lower interpolated pixels */
  col.r = (colx.r + py*(colx2.r - colx.r)) / 255.0;
  col.g = (colx.g + py*(colx2.g - colx.g)) / 255.0;
  col.b = (colx.b + py*(colx2.b - colx.b)) / 255.0;

  return col;
} 


/*
 * imap.h - This file contains defines etc for doing image map type things.  
 *
 *  $Id: imap.h,v 1.7 2002/07/09 18:17:25 johns Exp $
 */

void       ResetImage(void);
void       LoadImage(rawimage *);
rawimage * AllocateImage(const char *);
void       DeallocateImage(rawimage *);
void       ResetImages(void);
rawimage * DecimateImage(const rawimage *);
mipmap *   LoadMIPMap(const char *);
mipmap *   CreateMIPMap(const rawimage *);
color      MIPMap(const mipmap *, flt, flt, flt);
color      ImageMap(const rawimage *, flt, flt);
 
/* 
 * intersect.c - This file contains code for CSG and intersection routines.
 *
 *  $Id: intersect.c,v 1.36 2004/02/03 03:38:22 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "intersect.h"

unsigned int new_objectid(scenedef * scene) {
  return scene->objgroup.numobjects++; /* generate unique object ID's */
}

unsigned int max_objectid(scenedef * scene) {
  return scene->objgroup.numobjects;
}

void free_objects(object * start) {
  object * cur;
  object * next;

  cur=start; 
  while (cur != NULL) { 
    next=cur->nextobj;
    cur->methods->freeobj(cur);
    cur=next;
  }
}


void intersect_objects(ray * ry) {
  object * cur;
  object temp;

  /* do unbounded objects first, to help early-exit bounded object tests */
  temp.nextobj = ry->scene->objgroup.unboundedobj;
  cur = &temp;
  while ((cur=cur->nextobj) != NULL)          
    cur->methods->intersect(cur, ry); 

  /* do bounded objects last, taking advantage of early-exit opportunities */
  temp.nextobj = ry->scene->objgroup.boundedobj;
  cur = &temp;
  while ((cur=cur->nextobj) != NULL)          
    cur->methods->intersect(cur, ry); 
}


/* Only keeps closest intersection, CSG-unsafe */
void add_regular_intersection(flt t, const object * obj, ray * ry) {
  if (t > EPSILON) {
    /* if we hit something before maxdist update maxdist */
    if (t < ry->maxdist) {
      ry->maxdist = t;
      ry->intstruct.num=1;
      ry->intstruct.closest.obj = obj;
      ry->intstruct.closest.t = t;
    }
  }
}


int closest_intersection(flt * t, object const ** obj, ray * ry) {
  if (ry->intstruct.num > 0) {
      *t = ry->intstruct.closest.t;
    *obj = ry->intstruct.closest.obj;
  } 

  return ry->intstruct.num;
}
/* End of CSG-unsafe */


/* Only meant for shadow rays, unsafe for anything else */
void add_shadow_intersection(flt t, const object * obj, ray * ry) {
  if (t > EPSILON) {
    /* if we hit something before maxdist update maxdist */
    if (t < ry->maxdist) {
      /* if this object doesn't cast a shadow, quit out.. */
      if (!(obj->tex->flags & RT_TEXTURE_SHADOWCAST)) {
        return;
      }

      ry->maxdist = t;
      ry->intstruct.num=1;

      /* if we hit *anything* before maxdist, and we're firing a */
      /* shadow ray, then we are finished ray tracing the shadow */
      ry->flags |= RT_RAY_FINISHED;
    }
  }
}


int shadow_intersection(ray * ry) {
  if (ry->intstruct.num > 0) 
    return 1;

  return 0;
}

/* 
 * intersect.h - This file contains the declarations and defines for the
 *               functions that manage intersection, bounding and CSG..
 *
 *  $Id: intersect.h,v 1.16 2002/07/09 16:14:30 johns Exp $
 */

unsigned int new_objectid(scenedef *);
void free_objects(object *);
void intersect_objects(ray *);

void add_regular_intersection(flt, const object *, ray *);
int closest_intersection(flt *, object const **, ray *);

void add_shadow_intersection(flt, const object *, ray *);
int shadow_intersection(ray *);

#define reset_intersection(ry) \
	(ry)->intstruct.num = 0

/*
 *  jpeg.c - This file deals with JPEG format image files (reading/writing)
 *
 *  $Id: jpeg.c,v 1.6 2001/02/26 17:01:06 johns Exp $
 */ 

/*
 * This code requires support from the Independent JPEG Group's libjpeg.
 * For our purposes, we're interested only in the 3 byte per pixel 24 bit
 * RGB output.  Probably won't implement any decent checking at this point.
 */ 

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h" /* error codes etc */
#include "jpeg.h"    /* the protos for this file */

#if !defined(USEJPEG)

int readjpeg(char * name, int * xres, int * yres, unsigned char **imgdata) {
  return IMAGEUNSUP;
}

int writejpeg(char * name, int xres, int yres, unsigned char *imgdata) {
  return IMAGEUNSUP;
}

#else

#include "jpeglib.h" /* the IJG jpeg library headers */

int readjpeg(char * name, int * xres, int * yres, unsigned char **imgdata) {
  FILE * ifp;
  struct jpeg_decompress_struct cinfo; /* JPEG decompression struct */
  struct jpeg_error_mgr jerr;          /* JPEG Error handler */
  JSAMPROW row_pointer[1];             /* output row buffer */
  int row_stride;                      /* physical row width in output buf */

  /* open input file before doing any JPEG decompression setup */
  if ((ifp = fopen(name, "rb")) == NULL) 
    return IMAGEBADFILE; /* Could not open image, return error */

  /*
   * Note: The Independent JPEG Group's library does not have a way
   *       of returning errors without the use of setjmp/longjmp.
   *       This is a problem in multi-threaded environment, since setjmp
   *       and longjmp are declared thread-unsafe by many vendors currently.
   *       For now, JPEG decompression errors will result in the "default"
   *       error handling provided by the JPEG library, which is an error
   *       message and a fatal call to exit().  I'll have to work around this
   *       or find a reasonably thread-safe way of doing setjmp/longjmp..
   */

  cinfo.err = jpeg_std_error(&jerr); /* Set JPEG error handler to default */

  jpeg_create_decompress(&cinfo);    /* Create decompression context      */ 
  jpeg_stdio_src(&cinfo, ifp);       /* Set input mechanism to stdio type */
  jpeg_read_header(&cinfo, TRUE);    /* Read the JPEG header for info     */
  jpeg_start_decompress(&cinfo);     /* Prepare for actual decompression  */

  *xres = cinfo.output_width;        /* set returned image width  */
  *yres = cinfo.output_height;       /* set returned image height */

  /* Calculate the size of a row in the image */
  row_stride = cinfo.output_width * cinfo.output_components;

  /* Allocate the image buffer which will be returned to the caller */
  *imgdata = (unsigned char *) malloc(row_stride * cinfo.output_height);

  /* decompress the JPEG, one scanline at a time into the buffer */
  while (cinfo.output_scanline < cinfo.output_height) {
    row_pointer[0] = &((*imgdata)[(cinfo.output_scanline)*row_stride]);
    jpeg_read_scanlines(&cinfo, row_pointer, 1);
  }

  jpeg_finish_decompress(&cinfo);   /* Tell the JPEG library to cleanup   */
  jpeg_destroy_decompress(&cinfo);  /* Destroy JPEG decompression context */

  fclose(ifp); /* Close the input file */

  return IMAGENOERR;  /* No fatal errors */
}


int writejpeg(char * name, int xres, int yres, unsigned char *imgdata) {
  FILE *ofp;
  struct jpeg_compress_struct cinfo;   /* JPEG compression struct */
  struct jpeg_error_mgr jerr;          /* JPEG error handler */
  JSAMPROW row_pointer[1];             /* output row buffer */
  int row_stride;                      /* physical row width in output buf */

  if ((ofp = fopen(name, "wb")) == NULL) {
    return IMAGEBADFILE;
  }

  cinfo.err = jpeg_std_error(&jerr);
  jpeg_create_compress(&cinfo);
  jpeg_stdio_dest(&cinfo, ofp);

  cinfo.image_width = xres;
  cinfo.image_height = yres;
  cinfo.input_components = 3;
  cinfo.in_color_space = JCS_RGB;

  jpeg_set_defaults(&cinfo);
  jpeg_set_quality(&cinfo, 95, 0);

  jpeg_start_compress(&cinfo, TRUE);

  /* Calculate the size of a row in the image */
  row_stride = cinfo.image_width * cinfo.input_components;

  /* compress the JPEG, one scanline at a time into the buffer */
  while (cinfo.next_scanline < cinfo.image_height) {
    row_pointer[0] = &(imgdata[(yres - cinfo.next_scanline - 1)*row_stride]);
    jpeg_write_scanlines(&cinfo, row_pointer, 1);
  }

  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);

  fclose(ofp);

  return IMAGENOERR; /* No fatal errors */
}

#endif
/*
 *  jpeg.h - This file deals with JPEG format image files (reading/writing)
 *
 *  $Id: jpeg.h,v 1.2 1999/09/01 16:01:09 johns Exp $
 */ 

int readjpeg(char * name, int * xres, int * yres, unsigned char **imgdata);
int writejpeg(char * name, int xres, int yres, unsigned char *imgdata);

double jsval(double, double, double);


/*
 * light.c - This file contains declarations and defines for light sources.
 *
 *  $Id: light.c,v 1.22 2004/02/03 03:38:22 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

#define LIGHT_PRIVATE
#include "light.h"

static object_methods light_methods = {
  (void (*)(const void *, void *))(light_intersect),
  (void (*)(const void *, const void *, const void *, void *))(light_normal),
  light_bbox, 
  free 
};

directional_light * newdirectionallight(void * tex, vector dir) {
  directional_light * l;
  
  l=(directional_light *) malloc(sizeof(directional_light));
  memset(l, 0, sizeof(directional_light));
  l->methods = &light_methods;
  l->shade_diffuse = directional_light_shade_diffuse;

  l->tex=tex;
  l->tex->flags = RT_TEXTURE_SHADOWCAST | RT_TEXTURE_ISLIGHT;
  l->tex->diffuse=0.0;
  l->tex->specular=0.0;
  l->tex->opacity=1.0;

  l->dir.x=-dir.x; /* store negated light direction for high shading speed */
  l->dir.y=-dir.y;
  l->dir.z=-dir.z;

  return l;
}

point_light * newpointlight(void * tex, vector ctr, flt rad) {
  point_light * l;
  
  l=(point_light *) malloc(sizeof(point_light));
  memset(l, 0, sizeof(point_light));
  l->methods = &light_methods;
  l->shade_diffuse = simple_point_light_shade_diffuse;

  l->tex=tex;
  l->tex->flags = RT_TEXTURE_SHADOWCAST | RT_TEXTURE_ISLIGHT;
  l->tex->diffuse=0.0;
  l->tex->specular=0.0;
  l->tex->opacity=1.0;

  l->ctr=ctr;
  l->rad=rad;

  l->attenuationfunc = light_no_attenuation;
  l->Kc = 1.0;
  l->Kl = 0.0;
  l->Kq = 0.0;

  l->spotfunc = light_no_falloff;
  l->spotdir.x = 0.0;
  l->spotdir.y = 0.0;
  l->spotdir.z = 1.0;
  l->fallstart = 0.3;
  l->fallend   = 0.7;

  return l;
}

point_light * newspotlight(void * tex, vector ctr, flt rad, vector dir,
                           flt fallstart, flt fallend) {
  point_light * l;

  l=(point_light *) malloc(sizeof(point_light));
  memset(l, 0, sizeof(point_light));
  l->methods = &light_methods;
  l->shade_diffuse = point_light_shade_diffuse;

  l->tex=tex;
  l->tex->flags = RT_TEXTURE_SHADOWCAST | RT_TEXTURE_ISLIGHT;
  l->tex->diffuse=0.0;
  l->tex->specular=0.0;
  l->tex->opacity=1.0;

  l->ctr=ctr;
  l->rad=rad;

  l->attenuationfunc = light_no_attenuation;
  l->Kc = 1.0;
  l->Kl = 0.0;
  l->Kq = 0.0;

  l->spotfunc  = light_spotlight_falloff;
  l->spotdir   = dir; 
  l->fallstart = fallstart;
  l->fallend   = fallend;

  return l;
}

/*
 * Set the attenuation equation for a positional light
 */
void light_set_attenuation(point_light * li, flt Kc, flt Kl, flt Kq) {
  li->Kc = Kc;  /* constant attenuation coefficient  */
  li->Kl = Kl;  /* linear attenuation coefficient    */
  li->Kq = Kq;  /* quadratic attenuation coefficient */
 
  li->attenuationfunc = light_complex_attenuation;
  li->shade_diffuse = point_light_shade_diffuse;   /* use the complex shader */
}


/*
 * Private / Internal lighting routines.
 */



/*
 * Direction Lighting - calculate diffuse contribution of directional light
 */
static flt directional_light_shade_diffuse(directional_light * li, shadedata *shadevars) {
  flt inten;
  shadevars->L = li->dir;                 /* set light direction          */
  shadevars->Llen = FHUGE;                /* infinite distance tolight    */
  VDOT(inten, (shadevars->N), li->dir)    /* light intensity              */
  return inten;
}


/*
 * Point Light - calculate diffuse contribution of positional light
 *               This version handles the simplest case only.
 */
static flt simple_point_light_shade_diffuse(point_light * li, shadedata *shadevars) {
  flt inten, len;

  VSUB(li->ctr, (shadevars->hit), (shadevars->L))  /* find the light vector */

  /* calculate the distance to the light from the hit point */
  len = sqrt(shadevars->L.x*shadevars->L.x + shadevars->L.y*shadevars->L.y + shadevars->L.z*shadevars->L.z) + EPSILON;

  shadevars->L.x /= len;                  /* normalize the light direction */
  shadevars->L.y /= len;
  shadevars->L.z /= len;
  shadevars->Llen = len;                  /* set distance to the light */

  VDOT(inten, shadevars->N, shadevars->L) /* light intensity              */
  return inten;
}


/*
 * Point Light - calculate diffuse contribution of positional light
 *               This version handles spotlights and attenuation as well.
 */
static flt point_light_shade_diffuse(point_light * li, shadedata *shadevars) {
  flt inten, len;

  VSUB(li->ctr, (shadevars->hit), (shadevars->L))  /* find the light vector */

  /* calculate the distance to the light from the hit point */
  len = sqrt(shadevars->L.x*shadevars->L.x + shadevars->L.y*shadevars->L.y + shadevars->L.z*shadevars->L.z) + EPSILON;

  shadevars->L.x /= len;                  /* normalize the light direction */
  shadevars->L.y /= len;
  shadevars->L.z /= len;
  shadevars->Llen = len;                  /* set distance to the light */

  VDOT(inten, shadevars->N, shadevars->L) /* light intensity              */
  inten *= li->attenuationfunc(li, shadevars->Llen);
  inten *= li->spotfunc(li, &shadevars->L);
  return inten;
}


/*
 * Attenuation functions. 
 */
static flt light_no_attenuation(void * vli, flt Llen) {
  return 1.0;
}

static flt light_complex_attenuation(void * vli, flt Llen) {
  point_light * li = (point_light *) vli;
  return 1.0 / (li->Kc + ((li->Kl + li->Kq*Llen) * Llen));
}


/*
 * Falloff functions for spotlights.
 */
static flt light_no_falloff(void * vli, vector * L) {
  return 1.0;
}


static flt light_spotlight_falloff(void * vli, vector * L) {
  point_light * li = (point_light *) vli;
  flt ang, cang;

  VDOT(cang, li->spotdir, (*L)) 

  ang = acos(-cang); 
  
  if (ang > li->fallstart) {
    if (ang > li->fallend) 
      return 0.0;
    else 
      return 1.0 - ((ang - li->fallstart) / (li->fallend - li->fallstart));
  }

  return 1.0;
}


static int light_bbox(void * obj, vector * min, vector * max) {
  return 0; /* lights are unbounded currently */
}


static void light_intersect(const point_light * l, ray * ry) {
  flt b, disc, t1, t2, temp;
  vector V;

  /* Lights do not cast shadows.. */
  if (ry->flags & RT_RAY_SHADOW)
    return;

  VSUB(l->ctr, ry->o, V);
  VDOT(b, V, ry->d); 
  VDOT(temp, V, V);  

  disc=b*b + l->rad*l->rad - temp;

  if (disc<=0.0) return;
  disc=sqrt(disc);

  t2=b+disc;
  if (t2 <= SPEPSILON) 
    return;
  ry->add_intersection(t2, (object *) l, ry);  

  t1=b-disc;
  if (t1 > SPEPSILON) 
    ry->add_intersection(t1, (object *) l, ry);  
}

static void light_normal(const point_light * l, const vector * pnt, const ray * incident, vector * N) {
  flt len;

  N->x = pnt->x - l->ctr.x;
  N->y = pnt->y - l->ctr.y;
  N->z = pnt->z - l->ctr.z;

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}





/* 
 * light.h - this file includes declarations and defines for light sources.
 *
 *  $Id: light.h,v 1.14 2002/08/04 21:43:34 johns Exp $
 */

#include "shade.h"

typedef struct light_t {
  RT_OBJECT_HEAD
  flt (* shade_diffuse)(struct light_t *, shadedata *);   /* diffuse shading function       */
} light;

typedef struct point_light_t {
  RT_OBJECT_HEAD
  flt (* shade_diffuse)(struct point_light_t *, shadedata *);   /* diffuse shading function       */
  vector ctr;
  flt rad;
  flt (* attenuationfunc)(void *, flt);
  flt Kc;
  flt Kl; 
  flt Kq;
  flt (* spotfunc)(void *, vector *);
  vector spotdir;
  flt fallstart;
  flt fallend;
} point_light; 

typedef struct directional_light_t {
  RT_OBJECT_HEAD
  flt (* shade_diffuse)(struct directional_light_t *, shadedata *);   /* diffuse shading function       */
  vector dir;
} directional_light; 

directional_light * newdirectionallight(void *, vector);

point_light * newpointlight(void *, vector, flt);
point_light * newspotlight(void * tex, vector ctr, flt rad, vector dir,
                           flt fallstart, flt fallend);

point_light * newlight(void *, vector, flt);
point_light * newspotlight(void * tex, vector ctr, flt rad, vector dir,
                           flt fallstart, flt fallend);

void light_set_attenuation(point_light * li, flt Kc, flt Kl, flt Kq);


#ifdef LIGHT_PRIVATE
static int light_bbox(void * obj, vector * min, vector * max);
static void light_intersect(const point_light *, ray *);
static void light_normal(const point_light *, const vector *, const ray *, vector *);
static flt light_no_attenuation(void * vli, flt Llen);
static flt light_complex_attenuation(void * vli, flt Llen);
static flt light_no_falloff(void * vli, vector * L);
static flt light_spotlight_falloff(void * vli, vector * L);
static flt point_light_shade_diffuse(point_light * li, shadedata *);
static flt simple_point_light_shade_diffuse(point_light * li, shadedata *);
static flt directional_light_shade_diffuse(directional_light * li, shadedata *);
#endif

/* 
 * machine.h - This is the machine specific include file
 *
 *  $Id: machine.h,v 1.23 1998/07/13 17:54:54 johns Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* 
 * macros.h - This file contains macro versions of functions that would be best 
 * used as inlined code rather than function calls.
 *
 *  $Id: macros.h,v 1.6 1995/07/04 00:47:32 johns Exp $
 */

#define MYMAX(a , b) ((a) > (b) ? (a) : (b))
#define MYMIN(a , b) ((a) < (b) ? (a) : (b))

#define VDOT(return, a, b) 				\
 return=(a.x * b.x  +  a.y * b.y  +  a.z * b.z); 	\

#define RAYPNT(c, a, b)		\
c.x = a.o.x + ( a.d.x * b );	\
c.y = a.o.y + ( a.d.y * b );	\
c.z = a.o.z + ( a.d.z * b );	\


#define VSUB(a, b, c)		\
c.x = (a.x - b.x);		\
c.y = (a.y - b.y);		\
c.z = (a.z - b.z);		\


#define VCROSS(a, b, c) 				\
 c->x = (a->y * b->z) - (a->z * b->y);			\
 c->y = (a->z * b->x) - (a->x * b->z);			\
 c->z = (a->x * b->y) - (a->y * b->x);			\

/* 
 * mainanim.c - This file contains an animation driver for the raytracer.
 *
 *  $Id: mainanim.c,v 1.14 2000/12/20 00:09:36 johns Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "tachyon.h"

int rt_mynode(void); /* proto */

#define MAXFRAMES 100
#define LOOP 100.0
#define LOOP2 50.0
#define RAD 6.28

#ifdef cube
#define RFILE "/cfs/johns/anim/frame"
#else
#define RFILE "outfile"
#endif

int main(int argc, char **argv) {
  SceneHandle scene;
  int i,j;
  apivector ctr, ctr1, vect2;
  apitexture tex1, tex2;
  apiflt f1, f2;
  char fname[200];
  char fname2[200];

  rt_initialize(&argc, &argv); 

  tex1.col.r=1.0;
  tex1.col.g=1.0;
  tex1.col.b=1.0;
  ctr1.x=5.0;
  ctr1.y=5.0;
  ctr1.z=1.0;
  f1=0.5;

  tex2.col.r=1.0;
  tex2.col.g=1.0;
  tex2.col.b=1.0;
  tex2.ambient=0.1;
  tex2.diffuse=0.7;
  tex2.specular=0.2;
  tex2.opacity=1.0;
  tex2.texturefunc=0;
  f2=1.5;

  vect2.x=0.0;
  vect2.y=1.0;
  vect2.z=0.0;

  for (i=0; i<MAXFRAMES; i++) {
    void * txarray[20];

    scene = rt_newscene();
    rt_resolution(scene, 320, 240);

#ifdef cube
    if (rt_mynode()==0) printf("Rendering frame %d \n",i);
#endif
#ifndef cube
    printf("Rendering frame %d \n",i);
#endif
    ctr1.x= i / 20.0 - 5.0;
    ctr1.y=5.0;
    ctr1.z= i / 20.0 + 5.0; 
    tex1.col.r=1.0;
    tex1.col.g=1.0;
    tex1.col.b=1.0;
    txarray[0] = rt_texture(scene, &tex1);
    rt_light(scene, txarray[0], ctr1, f1);

    ctr1.x= i / 15.0 - 5.0; 
    ctr1.y=0.0;
    ctr1.z=15.0;
    tex1.col.r=0.0;
    tex1.col.g=0.0;
    tex1.col.b=1.0;
    txarray[1] = rt_texture(scene, &tex1);
    rt_light(scene, txarray[1], ctr1, f1 / 3.0 );

    j=i;
    tex2.col.r=1.0;
    tex2.texturefunc=0;
    ctr.x=2.0*sin((j*RAD) / LOOP);
    ctr.z=10.0 + 2.0*cos((j*RAD) / LOOP);
    ctr.y=-2.0;

    txarray[2] = rt_texture(scene, &tex2);
    rt_sphere(scene, txarray[2], ctr, f2);

    tex2.texturefunc=0;
    j=i+(MAXFRAMES/3);
    tex2.col.r=0.5 + 0.5*sin((j*RAD)/ LOOP2);
    ctr.x=2.0*sin((j*RAD) / LOOP);
    ctr.z=10.0 + 2.0*cos((j*RAD) / LOOP);
    ctr.y=-2.0;

    txarray[3] = rt_texture(scene, &tex2);
    rt_sphere(scene, txarray[3], ctr, f2); 

    j=i+((MAXFRAMES * 2)/3);
    tex2.col.r=1.0;
    tex2.col.b=0.5 + 0.5*sin((j*RAD)/ LOOP2);
    ctr.x=2.0*sin((j*RAD) / LOOP);
    ctr.z=10.0 + 2.0*cos((j*RAD) / LOOP);
    ctr.y=-2.0;

    txarray[4] = rt_texture(scene, &tex2);
    rt_sphere(scene, txarray[4], ctr, f2);

    tex2.col.r=0.0;
    tex2.col.b=1.0;
    tex2.ambient=0.0;
    tex2.diffuse=0.0;
    tex2.specular=0.99;

    ctr.x=0.0;
    ctr.y=-2.0;
    ctr.z=10.0;

    txarray[5] = rt_texture(scene, &tex2);
    rt_sphere(scene, txarray[5], ctr, f2); 


    tex2.diffuse=0.8;
    tex2.ambient=0.1;
    tex2.specular=0.2;
    tex2.col.r=1.0;
    ctr.y=-7.0;  

    txarray[6] = rt_texture(scene, &tex2);
    rt_plane(scene, txarray[6], ctr, vect2); 


    sprintf(fname,".%4.4d.tga",i);
    strcpy(fname2, RFILE);
    strcat(fname2, fname);

    rt_outputfile(scene, fname2);

    rt_renderscene(scene);

    rt_deletescene(scene);

    for (j=0; j<7; j++)
      free(txarray[j]);
  }

  rt_finalize();

  return 0;
}
   
/* 
 * main.c - This file contains the main program and driver for the raytracer.
 *
 *  $Id: main.c,v 1.66 2004/02/03 03:49:02 johns Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "tachyon.h"    /* The Tachyon ray tracing library API */
#include "getargs.h"    /* command line argument/option parsing */
#include "parse.h"      /* Support for my own scene file format */
#include "nffparse.h"   /* Support for NFF files, as in SPD */
#include "ac3dparse.h"  /* Support for AC3D files */
#include "mgfparse.h"   /* Support for MGF files */

#ifdef USEOPENGL
#include "glwin.h"      /* OpenGL run-time display code */
#endif

#ifdef USERTVI
#include "rtvi_iface.h" /* Synergy RTVI/ETVI Attached Framebuffers */
#endif

#ifdef USESPACEBALL
#include "spaceball.h"  /* Spaceball fly-through code */
#endif

typedef struct {
  float x;
  float y;
  float z;
} floatvec; 


typedef struct {
  int xsize, ysize;

#if defined(USEOPENGL) || defined(USERTVI)
    unsigned char * img;
#endif
#ifdef USEOPENGL
    void * glwin;
#endif
#ifdef USERTVI
    void * rtviwin;
#endif
} dispHandle;


static void my_ui_message(int a, char * msg) {
  printf("%s\n", msg);
}

static void my_ui_progress(int percent) {
  printf("\rRendering Progress:       %3d%% complete            \r", percent);
  fflush(stdout);
}


/*
 * routines for managing runtime display of ray traced scene
 */
static dispHandle * tachyon_display_create(SceneHandle scene) {
  dispHandle * dh;

  dh = (dispHandle *) malloc(sizeof(dispHandle));

  if (dh != NULL) {
    memset(dh, 0, sizeof(dispHandle));

    rt_get_resolution(scene, &dh->xsize, &dh->ysize);

#if defined(USEOPENGL) || defined(USERTVI)
      dh->img = malloc((dh->xsize)*(dh->ysize)*3);
      if (dh->img != NULL) {

#if defined(USEOPENGL)
        dh->glwin = glwin_create("Tachyon Parallel/Multiprocessor Ray Tracer", dh->xsize, dh->ysize);
#elif defined(USERTVI)
        dh->rtviwin = rt_rtvi_init(dh->xsize, dh->ysize);
#endif

        rt_rawimage(scene, dh->img);
      }
      else {
        printf("Couldn't allocate image buffer for framebuffer display!!\n");
        free(dh);
        return NULL;
      } 
#endif
  }

  return dh;
}

static void tachyon_display_draw(dispHandle *dh) {
#if defined(USEOPENGL)
      if (dh->img != NULL)
        glwin_draw_image(dh->glwin, dh->xsize, dh->ysize, dh->img);
#elif defined(USERTVI)
      if (dh->img != NULL)
        rt_rtvi_displayimage(dh->img, rtviwin);
#endif
}

static void tachyon_display_delete(dispHandle *dh) {
#if defined(USEOPENGL) || defined(USERTVI)
    if (dh->img != NULL) {
#if defined(USEOPENGL)
      glwin_destroy(dh->glwin);
#endif
      free(dh->img);
    }
#endif
}


/* 
 * main loop for creating animations by flying using a spaceball
 * or other 3-D input mechanism. 
 */
static int fly_scene(argoptions opt, SceneHandle scene, int node) {
  dispHandle * dh = NULL;
  int done = 0;
  int frameno = 0;
  float fps;
  rt_timerhandle fpstimer;
  rt_timerhandle animationtimer;
  char outfilename[1];

#if defined(USESPACEBALL)
  sbHandle * bh = NULL;
#endif

  if (node == 0)
    dh = tachyon_display_create(scene);

  rt_set_ui_message(NULL);
  rt_set_ui_progress(NULL);

  if (node == 0)
    printf("Interactive Camera Flight\n");

  outfilename[0] = '\0';
  rt_outputfile(scene, outfilename);

  fpstimer=rt_timer_create();
  animationtimer=rt_timer_create();

#if defined(USESPACEBALL)
  if (node == 0) {
#if 1
    bh = tachyon_init_spaceball(scene, opt.spaceball);
#else
    if (rt_numnodes() < 2) {
      bh = tachyon_init_spaceball(scene, opt.spaceball);
    } else {
      printf("WARNING: Spaceball mode disabled when running with distributed memory");
    }
#endif
  }
#endif

  rt_timer_start(animationtimer);
  while (!done) {
    if (frameno != 0) {
      rt_timer_stop(fpstimer);
      fps = 1.0f / rt_timer_time(fpstimer);
    } else {
      fps = 0.0;
    }

    rt_timer_start(fpstimer);
    if (node == 0) {
      printf("\rRendering Frame: %9d   %10.4f FPS       ", frameno, fps);
      fflush(stdout);
    } 

#if defined(USESPACEBALL)
    if (bh != NULL)
      done = tachyon_spaceball_update(bh, scene);
#endif


#ifdef RSIM
  endphase();
  newphase(1+frameno);
#endif


    rt_renderscene(scene);


    if (dh != NULL)
      tachyon_display_draw(dh); 

    frameno++;

#ifdef RSIM
  endphase();
  newphase(1+frameno);
#endif

  }




  rt_timer_stop(animationtimer);
  fps = frameno / rt_timer_time(animationtimer);

  if (node == 0) {
    printf("\rCompleted animation of %d frames                            \n",
	   frameno);
    printf("Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n", 
         rt_timer_time(animationtimer), fps); 
  }
  rt_timer_destroy(fpstimer);

  if (node == 0) {
    printf("\nFinished Running Camera.\n");

    if (dh !=NULL)
      tachyon_display_delete(dh);
  }

  rt_deletescene(scene); /* free the scene */
  rt_finalize(); /* close down the rendering library and MPI */

  return 0;
}



/* 
 * main loop for creating animations by playing recorded camera fly-throughs
 */
static int animate_scene(argoptions opt, SceneHandle scene, int node) {
  char outfilename[1000];
  FILE * camfp;
  dispHandle * dh = NULL;

  if (node == 0)
    dh = tachyon_display_create(scene);

  /* if we have a camera file, then animate.. */
  if ((camfp = fopen(opt.camfilename, "r")) != NULL) {
    floatvec cv, cu, cc;
    apivector cmv, cmu, cmc;
    int frameno = 0;
    float fps;
    rt_timerhandle fpstimer;
    rt_timerhandle animationtimer;

    rt_set_ui_message(NULL);
    rt_set_ui_progress(NULL);

    if (node == 0)
      printf("Running Camera File: %s\n", opt.camfilename);

    fpstimer=rt_timer_create();
    animationtimer=rt_timer_create();

    rt_timer_start(animationtimer);

    while (!feof(camfp)) {
      fscanf(camfp, "%f %f %f  %f %f %f  %f %f %f",
        &cv.x, &cv.y, &cv.z, &cu.x, &cu.y, &cu.z, &cc.x, &cc.y, &cc.z);

      cmv.x = cv.x; cmv.y = cv.y; cmv.z = cv.z;
      cmu.x = cu.x; cmu.y = cu.y; cmu.z = cu.z;
      cmc.x = cc.x; cmc.y = cc.y; cmc.z = cc.z;

      if (frameno != 0) {
        rt_timer_stop(fpstimer);
        fps = 1.0f / rt_timer_time(fpstimer);
      } else {
        fps = 0.0;
      }

      rt_timer_start(fpstimer);
      outfilename[0] = '\0';
      if (opt.nosave == 1) {
        if (node == 0) {
          printf("\rRendering Frame: %9d   %10.4f FPS       ", frameno, fps);
          fflush(stdout);
        } 
      }
      else {
        sprintf(outfilename, opt.outfilename, frameno);
        if (node == 0) {
          printf("\rRendering Frame to %s   (%10.4f FPS)       ", outfilename, fps);
          fflush(stdout);
        }
      }
 
      rt_outputfile(scene, outfilename);
      rt_camera_position(scene, cmc, cmv, cmu);


#ifdef RSIM
  endphase();
  newphase(1+frameno);
#endif

      rt_renderscene(scene);

      if (dh != NULL)
        tachyon_display_draw(dh); 

      frameno++;

#ifdef RSIM
  endphase();
  newphase(1+frameno);
#endif

    } 
    rt_timer_stop(animationtimer);
    fps = frameno / rt_timer_time(animationtimer);
    if (node == 0) {
      printf("\rCompleted animation of %d frames                            \n", frameno);
      printf("Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n", 
           rt_timer_time(animationtimer), fps); 
    }
    rt_timer_destroy(fpstimer);
    fclose(camfp);
  } else {
    if (node == 0) {
      printf("Couldn't open camera file: %s\n", opt.camfilename);
      printf("Aborting Render...\n");
    }
    rt_deletescene(scene); /* free the scene */
    rt_finalize(); /* close down the rendering library and MPI */
    return -1;
  }

  if (node == 0) {
    printf("\nFinished Running Camera.\n");

    if (dh !=NULL)
      tachyon_display_delete(dh);
  }

  rt_deletescene(scene); /* free the scene */
  rt_finalize(); /* close down the rendering library and MPI */

  return 0;
}




#ifdef VXWORKS
int ray(int argc, char **argv) {
#else
int main(int argc, char **argv) {
#endif
  SceneHandle scene;
  unsigned int rc;
  argoptions opt;
  char * filename;
  int node, fileindex;
  rt_timerhandle parsetimer;
  
  node = rt_initialize(&argc, &argv);

  rt_set_ui_message(my_ui_message);
  rt_set_ui_progress(my_ui_progress);

  if (node == 0) {
    printf("Tachyon Parallel/Multiprocessor Ray Tracer   Version %s   \n",
           TACHYON_VERSION_STRING);
    printf("Copyright 1994-2004,    John E. Stone <johns@megapixel.com> \n");
    printf("----------------------------------------------------------- \n"); 
  }

  if ((rc = getargs(argc, argv, &opt, node)) != 0) {
    rt_finalize();
    exit(rc);
  }

  if (opt.numfiles > 1) {
    printf("Rendering %d scene files.\n", opt.numfiles);
  }

  for (fileindex=0; fileindex<opt.numfiles; fileindex++) { 
    scene = rt_newscene();

    filename = opt.filenames[fileindex];

    if (opt.numfiles > 1) {
      printf("\nRendering scene file %d of %d, %s\n", fileindex+1, opt.numfiles, filename);
    }

    parsetimer=rt_timer_create();
    rt_timer_start(parsetimer);

    if (strstr(filename, ".nff") || strstr(filename, ".NFF")) {
      rc = ParseNFF(filename, scene); /* must be an NFF file */
    }
    else if (strstr(filename, ".ac") || strstr(filename, ".AC")) {
      rc = ParseAC3D(filename, scene); /* Must be an AC3D file */
    }
#ifdef USELIBMGF
    else if (strstr(filename, ".mgf") || strstr(filename, ".MGF")) {
      rc = ParseMGF(filename, scene, 1); /* Must be an MGF file */
    }
#endif
    else {  
      rc = readmodel(filename, scene); /* Assume its a Tachyon scene file */
    }

    rt_timer_stop(parsetimer);
    if (rc == PARSENOERR && node == 0) 
      printf("Scene Parsing Time: %10.4f seconds\n", rt_timer_time(parsetimer));
    rt_timer_destroy(parsetimer);
   
    if (rc != PARSENOERR && node == 0) {
      switch(rc) {
        case PARSEBADFILE:
          printf("Parser failed due to nonexistent input file: %s\n", filename);
          break;
        case PARSEBADSUBFILE:
          printf("Parser failed due to nonexistent included file.\n");
          break;
        case PARSEBADSYNTAX:
          printf("Parser failed due to an input file syntax error.\n");
          break;
        case PARSEEOF:
          printf("Parser unexpectedly hit an end of file.\n");
          break;
        case PARSEALLOCERR:
          printf("Parser ran out of memory.\n");
          break; 
      }
      printf("Aborting Render...\n");
      rt_finalize();
      return -1;
    }

    /* process command line overrides */
    useoptions(&opt, scene);

    /* choose which rendering mode to use */
    if (opt.usecamfile == 1) {
      return animate_scene(opt, scene, node); /* fly using prerecorded data */
    }
    else if (strlen(opt.spaceball) > 0) {
      return fly_scene(opt, scene, node);     /* fly with spaceball etc */
    } 
    else {
      if (opt.numfiles > 1 && opt.nosave != 1) {
        char multioutfilename[FILENAME_MAX];
        sprintf(multioutfilename, opt.outfilename, fileindex);
        rt_outputfile(scene, multioutfilename);
      }

#ifdef RSIM
  endphase();
  newphase(1);
#endif

      rt_renderscene(scene); /* Render a single frame */
    }

    rt_deletescene(scene); /* free the scene, get ready for next one */
  }

#ifdef RSIM
  endphase();
  newphase(2);
#endif

  rt_finalize(); /* close down the rendering library and MPI */
  
  return 0;
}



#ifdef USELIBMGF

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "tachyon.h"  /* Ray Tracer API */
#include "parser.h"   /* MGF parser library */
#include "mgfparse.h" /* self proto */

static void * globtex = NULL;
static SceneHandle globscene = NULL;

int put_material(void);
int mgf2rgb(C_COLOR *cin, double intensity, float cout[3]);

char tabs[] = " ";

#define curmatname      (c_cmname == NULL ? "mat" : c_cmname)

/*
 * Convert MGF color to RGB representation defined below.
 */
			/* Change the following to suit your standard */
#define  CIE_x_r		0.640		/* nominal CRT primaries */
#define  CIE_y_r		0.330
#define  CIE_x_g		0.290
#define  CIE_y_g		0.600
#define  CIE_x_b		0.150
#define  CIE_y_b		0.060
#define  CIE_x_w		0.3333		/* use true white */
#define  CIE_y_w		0.3333

#define CIE_C_rD	( (1./CIE_y_w) * \
				( CIE_x_w*(CIE_y_g - CIE_y_b) - \
				  CIE_y_w*(CIE_x_g - CIE_x_b) + \
				  CIE_x_g*CIE_y_b - CIE_x_b*CIE_y_g	) )
#define CIE_C_gD	( (1./CIE_y_w) * \
				( CIE_x_w*(CIE_y_b - CIE_y_r) - \
				  CIE_y_w*(CIE_x_b - CIE_x_r) - \
				  CIE_x_r*CIE_y_b + CIE_x_b*CIE_y_r	) )
#define CIE_C_bD	( (1./CIE_y_w) * \
				( CIE_x_w*(CIE_y_r - CIE_y_g) - \
				  CIE_y_w*(CIE_x_r - CIE_x_g) + \
				  CIE_x_r*CIE_y_g - CIE_x_g*CIE_y_r	) )


static float xyz2rgbmat[3][3] = {	/* XYZ to RGB conversion matrix */
	{(CIE_y_g - CIE_y_b - CIE_x_b*CIE_y_g + CIE_y_b*CIE_x_g)/CIE_C_rD,
	 (CIE_x_b - CIE_x_g - CIE_x_b*CIE_y_g + CIE_x_g*CIE_y_b)/CIE_C_rD,
	 (CIE_x_g*CIE_y_b - CIE_x_b*CIE_y_g)/CIE_C_rD},
	{(CIE_y_b - CIE_y_r - CIE_y_b*CIE_x_r + CIE_y_r*CIE_x_b)/CIE_C_gD,
	 (CIE_x_r - CIE_x_b - CIE_x_r*CIE_y_b + CIE_x_b*CIE_y_r)/CIE_C_gD,
	 (CIE_x_b*CIE_y_r - CIE_x_r*CIE_y_b)/CIE_C_gD},
	{(CIE_y_r - CIE_y_g - CIE_y_r*CIE_x_g + CIE_y_g*CIE_x_r)/CIE_C_bD,
	 (CIE_x_g - CIE_x_r - CIE_x_g*CIE_y_r + CIE_x_r*CIE_y_g)/CIE_C_bD,
	 (CIE_x_r*CIE_y_g - CIE_x_g*CIE_y_r)/CIE_C_bD}
};


/* mgf2rgb() - convert MGF color to RGB       */
/* cin       - input MGF chrominance          */
/* intensity - input luminance or reflectance */
/* cout      - output RGB color               */
int mgf2rgb(C_COLOR *cin, double intensity, float cout[3]) {
	static double	cie[3]; /* get CIE XYZ representation */
	c_ccvt(cin, C_CSXY);
	cie[0] = intensity*cin->cx/cin->cy;
	cie[1] = intensity;
	cie[2] = intensity*(1./cin->cy - 1.) - cie[0];
					/* convert to RGB */
	cout[0] = xyz2rgbmat[0][0]*cie[0] + xyz2rgbmat[0][1]*cie[1]
			+ xyz2rgbmat[0][2]*cie[2];
	if(cout[0] < 0.) cout[0] = 0.;
	cout[1] = xyz2rgbmat[1][0]*cie[0] + xyz2rgbmat[1][1]*cie[1]
			+ xyz2rgbmat[1][2]*cie[2];
	if(cout[1] < 0.) cout[1] = 0.;
	cout[2] = xyz2rgbmat[2][0]*cie[0] + xyz2rgbmat[2][1]*cie[1]
			+ xyz2rgbmat[2][2]*cie[2];
	if(cout[2] < 0.) cout[2] = 0.;

  return MG_OK;
}

int put_material(void) {
  float   rgbval[3];
  apitexture tex;  
#if 0
  char    *mname = curmatname;

  if (!c_cmaterial->clock) {      /* current, just use it */
    printf("USE %s\n", mname);
  }
  else {
    printf("%sDEF %s Group {\n", tabs, mname);
  }
  printf("%sMaterial {\n", tabs);
#endif

  memset(&tex, 0, sizeof(tex));

  mgf2rgb(&c_cmaterial->rd_c, 1.0, rgbval);
  tex.col = rt_color(rgbval[0], rgbval[1], rgbval[2]);
  tex.ambient = 0.1;
  tex.diffuse = c_cmaterial->rd;
  tex.opacity = 1.0 - (c_cmaterial->td + c_cmaterial->ts);
  tex.texturefunc = 0;

  if (c_cmaterial->ed > FTINY) {
    mgf2rgb(&c_cmaterial->ed_c, 1.0, rgbval);
    tex.col = rt_color(rgbval[0], rgbval[1], rgbval[2]);
    tex.ambient = c_cmaterial->ed;

    if (tex.ambient > 1.0) 
      tex.ambient = 1.0;
    if (tex.ambient < 0.1)
      tex.ambient = 0.1; 
  }

  globtex = rt_texture(globscene, &tex); /* XXX memory leak city, */
                              /* we aren't keeping track of these... */

  if (c_cmaterial->rs > 0.0) {
    tex.specular = c_cmaterial->rs - (c_cmaterial->rs_a / 2.0);
    if (tex.specular < 0.0) tex.specular = 0.0;

    if (c_cmaterial->rs_a > 0.09) {
      flt pexp, pval ;
      pval = c_cmaterial->rs * 4;
      pval = 0.8;  /* XXX hack */
      pexp = 12.0 / c_cmaterial->rs_a;
      rt_tex_phong(globtex, pval, pexp, RT_PHONG_PLASTIC);
    } 
  }

  c_cmaterial->clock = 0;

  return MG_OK;
}
  

static int myfaceh(int ac, char **av) {  /* face handling routine */
  static char lastmat[256];
  C_VERTEX *vp;    /* vertex structure pointer */
  FVECT vert;      /* vertex point location */
  FVECT normal;      /* vertex point location */
  int i;
  apivector v0, v1, v2;
  apivector n0, n1, n2;
  if (ac < 4)                     /* check # arguments */
    return(MG_EARGC);

  if (strcmp(lastmat, curmatname) || c_cmaterial->clock) {
    put_material();
    strcpy(lastmat, curmatname);
  }

  if ((vp = c_getvert(av[1])) == NULL)    /* vertex from name */
      return(MG_EUNDEF);
  xf_xfmpoint(vert, vp->p);               /* transform vertex */
  v0 = rt_vector(vert[0], vert[1], vert[2]);
  xf_rotvect(normal, vp->n);              /* transform normal */
  n0 = rt_vector(normal[0], normal[1], normal[2]);

  if ((vp = c_getvert(av[2])) == NULL)    /* vertex from name */
      return(MG_EUNDEF);
  xf_xfmpoint(vert, vp->p);               /* transform vertex */
  v1 = rt_vector(vert[0], vert[1], vert[2]);
  xf_rotvect(normal, vp->n);              /* transform normal */
  n1 = rt_vector(normal[0], normal[1], normal[2]);

  for (i = 3; i < ac; i++) {
    if ((vp = c_getvert(av[i])) == NULL)   /* vertex from name */
      return(MG_EUNDEF);
    xf_xfmpoint(vert, vp->p);              /* transform vertex */
    v2 = rt_vector(vert[0], vert[1], vert[2]);
    xf_rotvect(normal, vp->n);             /* transform normal */
    n2 = rt_vector(normal[0], normal[1], normal[2]);

    if (((n0.x*n0.x + n0.y*n0.y + n0.z*n0.z) < 0.9) ||
        ((n1.x*n1.x + n1.y*n1.y + n1.z*n1.z) < 0.9) ||
        ((n2.x*n2.x + n2.y*n2.y + n2.z*n2.z) < 0.9)) {
      rt_tri(globscene, globtex, v0, v1, v2);
    } else { 
      rt_stri(globscene, globtex, v0, v1, v2, n0, n1, n2);
    }

    v1 = v2;
    n1 = n2;
  }

  return(MG_OK);                  /* normal exit */
}

static void DefaultTex(SceneHandle scene) {
  apitexture apitex;

  apitex.col.r=1.0;
  apitex.col.g=1.0;
  apitex.col.b=1.0;
  apitex.ambient=0.1;
  apitex.diffuse=0.9;
  apitex.specular=0.0;
  apitex.opacity=1.0;
  apitex.texturefunc=0;

  globtex = rt_texture(globscene, &apitex);
}


static void DefaultLight(SceneHandle scene) {
  /* lighting hack */
  apivector ctr;
  apitexture tex;

  memset(&tex, 0, sizeof(apitexture));

  tex.col.r = 1.0;
  tex.col.g = 1.0;
  tex.col.b = 1.0;
  ctr.x = 1000.0;
  ctr.y = 1000.0;
  ctr.z = -1000.0;

  rt_light(scene, rt_texture(globscene, &tex), ctr, 1.0);
}

static void DefaultScene(char *mgfname, SceneHandle scene) {
  FILE * ifp;
  char fname[1024];
  float x, y, z, zoom, len;
  apivector vp, vd, vup;

  strcpy(fname, mgfname);
  strcat(fname, ".scn");
  if ((ifp = fopen(fname, "r")) == NULL) {
    printf("No scene settings file found, using defaults\n");
    return;
  }
  printf("Reading default scene parameters from %s\n", fname);

  zoom = 1.0;
  fscanf(ifp, "%f", &zoom);

  fscanf(ifp, "%f %f %f", &x, &y, &z);
  vp = rt_vector(x, y, z);

  fscanf(ifp, "%f %f %f", &x, &y, &z);
  len = sqrt(x*x + y*y + z*z);
  vd = rt_vector(x/len, y/len, z/len);

  fscanf(ifp, "%f %f %f", &x, &y, &z);
  vup = rt_vector(x, y, z);

  rt_camera_setup(scene, zoom, 1.0, 0, 6, vp, vd, vup);
  
  fclose(ifp);
}

unsigned int ParseMGF(char *mgfname, SceneHandle scene, int defaultflag) {
  DefaultTex(scene);   /* hack, paranoia */

  globscene = scene;

  if (defaultflag == 1) {
    DefaultLight(scene); /* hack */
    DefaultScene(mgfname, scene); /* hack */
  }

  printf("MGF: loading %s\n", mgfname);

  /* initialize dispatch table */
  mg_ehand[MG_E_FACE] = myfaceh;          /* we do faces */
  mg_ehand[MG_E_VERTEX] = c_hvertex;      /* parser lib */
  mg_ehand[MG_E_POINT] = c_hvertex;       /* parser lib */
  mg_ehand[MG_E_NORMAL] = c_hvertex;      /* parser lib */
  mg_ehand[MG_E_XF] = xf_handler;         /* parser lib */

  /* lighting and coloring handling */
  mg_ehand[MG_E_COLOR] = c_hcolor;        /* they get color */
  mg_ehand[MG_E_CMIX] = c_hcolor;         /* they mix colors */
  mg_ehand[MG_E_CSPEC] = c_hcolor;        /* they get spectra */
  mg_ehand[MG_E_CXY] = c_hcolor;          /* they get chromaticities */
  mg_ehand[MG_E_CCT] = c_hcolor;          /* they get color temp's */
  mg_ehand[MG_E_ED] = c_hmaterial;        /* they get emission */
  mg_ehand[MG_E_MATERIAL] = c_hmaterial;  /* they get materials */
  mg_ehand[MG_E_RD] = c_hmaterial;        /* they get diffuse refl. */
  mg_ehand[MG_E_RS] = c_hmaterial;        /* they get specular refl. */
  mg_ehand[MG_E_SIDES] = c_hmaterial;     /* they get # sides */
  mg_ehand[MG_E_TD] = c_hmaterial;        /* they get diffuse trans. */
  mg_ehand[MG_E_TS] = c_hmaterial;        /* they get specular trans. */

  mg_init();                              /* initialize parser */
  if (mg_load(mgfname) != MG_OK)          /* and check for error */
    return MGF_BADSYNTAX;

  return MGF_NOERR;
}

#endif
/*
 * definitions for parsing MGF model files
 * 
 *  
 */

#define MGF_NOERR     0
#define MGF_BADFILE   1
#define MGF_BADSYNTAX 2
#define MGF_EOF       3

unsigned int ParseMGF(char *mgfname, SceneHandle scene, int defaultflag);

/*
 * Code for parsing NFF model files.
 *
 * See the NFF.DOC file in the SPD Distribution by Eric Haines 
 * for more information on NFF.
 */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h> /* needed for toupper(), macro.. */

#include "tachyon.h"  /* ray tracer api */
#include "nffparse.h" /* nff protos */

static void * curtexture;
static apicolor backgr;

/* protos */
int NFFGetObject(FILE * dfile, SceneHandle scene);


int NFFstringcmp(char * a, char * b) {
  int i, s, l;

  s=strlen(a);
  l=strlen(b);

  if (s != l)
    return 1;

  for (i=0; i<s; i++) {
    if (toupper(a[i]) != toupper(b[i])) {
      return 1;
    }
  }
  return 0;
}


void NFFGetString(FILE * dfile, char * string) {
  char data[100];

  fscanf(dfile,"%s",data);

  if (NFFstringcmp(data, string) != 0) {
    printf("parse: Expected %s, got %s \n",string, data);
    printf("Rendering terminated. \n");
    exit(1);
  }
}

void NFFGetVector(FILE * dfile, apivector * v1) {
  float a, b, c;

  fscanf(dfile, "%f %f %f", &a, &b, &c);
  v1->x=a;
  v1->y=b;
  v1->z=c;
}

unsigned int ParseNFF(char *nffname, SceneHandle scene) {
  FILE * dfile;
  backgr.r = 0.0;
  backgr.g = 0.0;
  backgr.b = 0.0;

  if (nffname == NULL) {
    return NFFBADFILE;
  }
  else {
    dfile=fopen(nffname,"r");
    if (dfile==NULL) {
      return NFFBADFILE;
    }
  }

  while (NFFGetObject(dfile, scene) == NFFNOERR); 

  rt_background(scene, backgr); 
  
  return NFFNOERR;
}

int NFFGetScenedefs(FILE * dfile, SceneHandle scene) {
  apivector Ccenter, Cview, Cup;
  apiflt zoom, aspectratio;
  int raydepth, antialiasing;
  int xres, yres, verbose;
  apivector lookat;
  float vangle, hither;
 
  NFFGetString(dfile, "from");
  NFFGetVector(dfile, &Ccenter);

  NFFGetString(dfile, "at");
  NFFGetVector(dfile, &lookat);
  Cview.x = lookat.x - Ccenter.x;
  Cview.y = lookat.y - Ccenter.y;
  Cview.z = lookat.z - Ccenter.z;

  NFFGetString(dfile, "up");
  NFFGetVector(dfile, &Cup);

  NFFGetString(dfile, "angle");
  fscanf(dfile, "%f", &vangle);
  zoom = 1.0; /* XXX fix me later */
  aspectratio = 1.0;
 
  NFFGetString(dfile, "hither");
  fscanf(dfile, "%f", &hither);
 
  NFFGetString(dfile, "resolution");
  fscanf(dfile, "%d %d", &xres, &yres);

  antialiasing = 0;
  raydepth = 6;
  verbose = 0;

  rt_outputfile(scene, "outfile.tga");
  rt_resolution(scene, xres, yres);
  rt_verbose(scene, verbose);

  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth,
              Ccenter, Cview, Cup);

  rt_background(scene, backgr); 

  return NFFNOERR; 
}


int NFFGetBackground(FILE *dfile, SceneHandle scene) {
  float r, g, b; 
  fscanf(dfile, "%f %f %f", &r, &g, &b);
  backgr.r = r;
  backgr.g = g;
  backgr.b = b;

  return NFFNOERR; 
}

int NFFGetLight(FILE *dfile, SceneHandle scene) {
  apiflt rad;
  apivector ctr;
  apitexture tex;
  float r, g, b;

  NFFGetVector(dfile, &ctr);
  rad = 1.0; /* XXX hack for now */

  r = g = b = 1.0; 

  fscanf(dfile, "%f %f %f", &r, &g, &b);
  tex.col.r = r;
  tex.col.g = g;
  tex.col.b = b;
 
  rt_light(scene, rt_texture(scene, &tex), ctr, rad);

  return NFFNOERR;
}

int NFFGetTexture(FILE *dfile, SceneHandle scene) {
  apitexture tex;
  float r, g, b, Kd, Ks, Shine, T, IOR;

  fscanf(dfile, "%f %f %f %f %f %f %f %f", 
         &r, &g, &b, &Kd, &Ks, &Shine, &T, &IOR);
  tex.col.r = r;
  tex.col.g = g;
  tex.col.b = b;
  tex.ambient = 0.1;
  tex.diffuse = Kd;
  tex.specular = Ks;
  tex.opacity = (T > 0.99) ? 0.0 : (1.0 - T);
  tex.texturefunc = 0;

  curtexture = rt_texture(scene, &tex); /* XXX memory leak city, */
                                /* we aren't keeping track of these... */
  return NFFNOERR;
}

int NFFGetCylCone(FILE *dfile, SceneHandle scene) {
  apivector pnt1, pnt2;
  apivector ctr, axis;
  float baserad, apexrad;
 
  NFFGetVector(dfile, &pnt1);
  fscanf(dfile, "%f", &baserad);

  NFFGetVector(dfile, &pnt2);
  fscanf(dfile, "%f", &apexrad);

  ctr=pnt1;
  axis.x=pnt2.x - pnt1.x;
  axis.y=pnt2.y - pnt1.y;
  axis.z=pnt2.z - pnt1.z;

  /* XXX should really be cone */
  rt_fcylinder(scene, curtexture, ctr, axis, baserad); 

  return NFFNOERR;
}

int NFFGetSphere(FILE *dfile, SceneHandle scene) {
  apiflt rad;
  apivector ctr;
  float a;  

  NFFGetVector(dfile, &ctr);
  fscanf(dfile, "%f", &a);
  rad = a;

  rt_sphere(scene, curtexture, ctr, rad);

  return NFFNOERR;
}

int NFFGetPolygon(FILE *dfile, SceneHandle scene) {
  int numverts, i;
  apivector v0, vold, vnew;

  fscanf(dfile, "%d", &numverts); 
  NFFGetVector(dfile, &v0);
  NFFGetVector(dfile, &vold);

  for (i=2; i<numverts; i++) {
    NFFGetVector(dfile, &vnew);
    rt_tri(scene, curtexture, v0, vold, vnew);
    vold = vnew;
  } 

  return NFFNOERR;
}

int NFFGetPatch(FILE *dfile, SceneHandle scene) {
  int numverts, i;
  apivector v0, n0;
  apivector vold, nold;
  apivector vnew, nnew;

  fscanf(dfile, "%d", &numverts); 
  NFFGetVector(dfile, &v0);
  NFFGetVector(dfile, &n0);
  NFFGetVector(dfile, &vold);
  NFFGetVector(dfile, &nold);

  for (i=2; i<numverts; i++) {
    NFFGetVector(dfile, &vnew);
    NFFGetVector(dfile, &nnew);
    rt_stri(scene, curtexture, v0, vold, vnew, n0, nold, nnew) ;
    vold = vnew;
    nold = nnew;
  } 

  return NFFNOERR;
}

int NFFGetObject(FILE * dfile, SceneHandle scene) {
  char objtype[80];
  if (fscanf(dfile, "%s", objtype) != 1) 
    return NFFEOF; /* end parsing */

  if (!NFFstringcmp(objtype, "v")) {
    return NFFGetScenedefs(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "b")) {
    return NFFGetBackground(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "l")) {
    return NFFGetLight(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "f")) {
    return NFFGetTexture(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "s")) {
    return NFFGetSphere(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "c")) {
    return NFFGetCylCone(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "p")) {
    return NFFGetPolygon(dfile, scene);
  }
  if (!NFFstringcmp(objtype, "pp")) {
    return NFFGetPatch(dfile, scene);
  }

  return NFFEOF;
}


/*
 * definitions for parsing NFF model files
 * 
 *  
 */

#define NFFNOERR     0
#define NFFBADFILE   1
#define NFFBADSYNTAX 2
#define NFFEOF       3

unsigned int ParseNFF(char *nffname, SceneHandle scene);


/*
 *  parallel.c - This file contains all of the code for doing parallel
 *               message passing and such.
 *
 *  $Id: parallel.c,v 1.40 2001/07/26 23:47:00 johns Exp $
 *
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "parallel.h"
#include "tgafile.h"
#include "util.h"
#include "threads.h"

#if !defined(_MSC_VER)
#include <unistd.h>
#endif

#ifdef MPI
#include <mpi.h>
#endif

int rt_par_init(int * argc, char ***argv) {
  int a=0;  /* if sequential, do nothing */

#ifdef MPI
  MPI_Init(argc, argv);
#endif

  a = rt_mynode();

  return a;
}

int rt_par_finish(void) {
  int a=0; /* if sequential, do nothing */ 

#ifdef MPI
  MPI_Finalize();
#endif  

  return a;
}

int rt_mynode(void) {
  int a=0;   /* for non-parallel machines */

#ifdef MPI
  MPI_Comm_rank(MPI_COMM_WORLD, &a);
#endif

  return a;
}

int rt_numnodes(void) {
  int a=1;  /* for non-parallel machines */

#ifdef MPI
  MPI_Comm_size(MPI_COMM_WORLD, &a);
#endif

  return a;
}

void rt_barrier_sync(void) {
  /* if sequential, do nothing */
#ifdef MPI
  MPI_Barrier(MPI_COMM_WORLD);
#endif
}

int rt_getcpuinfo(nodeinfo **nodes) {
  int numnodes = rt_numnodes();
  int mynode = rt_mynode();
 
  *nodes = (nodeinfo *) malloc(numnodes * sizeof(nodeinfo));
  (*nodes)[mynode].numcpus = 1; /*rt_thread_numprocessors(); */
  (*nodes)[mynode].cpuspeed = 1.0; 
  (*nodes)[mynode].nodespeed = (*nodes)[mynode].numcpus * 
                                  (*nodes)[mynode].cpuspeed; 


  /*gethostname((*nodes)[mynode].machname, 511);*/

  return numnodes;
}



/* 
 * Communications implementation based on MPI persistent send/recv operations.
 *
 * MPI Request buffers are allocated
 *
 * Persistent Send/Recv channels are initialized for the scanlines in 
 *   the image(s) to be rendered.
 *
 * For each frame, the persistent communications are used once.
 *
 * After all frames are rendered, the persistent channels are closed down
 *   and the MPI Request buffers are freed.
 */

#ifdef MPI

typedef struct {
  int mynode;
  int nodes;
  int count;
  int curmsg;
  int haveinited;
  int havestarted;
  MPI_Request * requests;
  MPI_Status * statuses;
  int * indices;
} pardata;  

#endif

void * rt_allocate_reqbuf(int count) {
#ifdef MPI
  pardata * p;
  p = malloc(sizeof(pardata));
  p->mynode = rt_mynode();
  p->nodes = rt_numnodes();
  p->count = 0;
  p->curmsg = 0;
  p->haveinited = 0;
  p->havestarted = 0;
  p->requests = malloc(sizeof(MPI_Request)*count);
  p->statuses = malloc(sizeof(MPI_Status)*count);
  p->indices  = malloc(sizeof(int)*count);
  return p;
#else 
  return NULL;
#endif
}

void rt_free_reqbuf(void * voidhandle) {
#ifdef MPI
  pardata * p = (pardata *) voidhandle;

  if (p->requests != NULL)
    free(p->requests);

  if (p->statuses != NULL)
    free(p->statuses);

  if (p->indices != NULL)
    free(p->indices);

  if (p != NULL)
    free(p);
#endif
}


void * rt_init_scanlinereceives(scenedef * scene) {
#ifdef MPI
  int i, addr;
  pardata * p;

  p = (pardata *) rt_allocate_reqbuf(scene->vres);

  p->curmsg = 0;
  p->count = 0;
  p->haveinited = 1;
  if (p->mynode == 0) {
    for (i=0; i<scene->vres; i++) {
      if (i % p->nodes != p->mynode) {
        addr = i * scene->hres * 3;
        MPI_Recv_init(&scene->img[addr], scene->hres * 3, MPI_BYTE, 
                    i % p->nodes, i+1, MPI_COMM_WORLD, &p->requests[p->count]);
        p->count++;
      }
    }
  }
  else {
    for (i=0; i<scene->vres; i++) {
      if (i % p->nodes == p->mynode) {
        addr = i * scene->hres * 3;
        MPI_Send_init(&scene->img[addr], scene->hres * 3, MPI_BYTE, 
                    0, i+1, MPI_COMM_WORLD, &p->requests[p->count]);
        p->count++;
      }
    }
  }
  
  return p;
#else
  return NULL;
#endif
}


void rt_start_scanlinereceives(void * voidhandle) {
#ifdef MPI
  pardata * p = (pardata *) voidhandle;

  p->havestarted = 1;
  if (p->mynode == 0)
    MPI_Startall(p->count, p->requests);

  p->curmsg = 0;
#endif
}

void rt_waitscanlines(void * voidhandle) {
#ifdef MPI
  pardata * p = (pardata *) voidhandle;
  
  MPI_Waitall(p->count, p->requests, p->statuses);

  p->havestarted=0;
#endif
}  

void rt_delete_scanlinereceives(void * voidhandle) {
#ifdef MPI
  int i;
  pardata * p = (pardata *) voidhandle;

  if (p == NULL)
    return; /* don't bomb if no valid handle */

  if (p->haveinited != 0 || p->havestarted != 0) {
    for (i=0; i<p->count; i++) {
      MPI_Request_free(&p->requests[i]);  
    }
  }

  rt_free_reqbuf(voidhandle);
#endif
}

void rt_sendrecvscanline(void * voidhandle) {
#ifdef MPI
  pardata * p = (pardata *) voidhandle;

  if (p->mynode == 0) {
#if   MPI_TUNE == 0  || !defined(MPI_TUNE)
    /* 
     * Default Technique 
     */
    int outcount;
    int numtotest;
    
    numtotest = ((p->nodes - 1) < (p->count - p->curmsg)) ?
                 (p->nodes - 1) : (p->count - p->curmsg);

    MPI_Testsome(numtotest, &p->requests[p->curmsg], &outcount,
                 &p->indices[p->curmsg], &p->statuses[p->curmsg]);
    p->curmsg += p->nodes - 1;
#elif MPI_TUNE == 1
    /* 
     * Technique number 1
     */
    int index, flag;
    MPI_Testany(p->count, p->requests, &index, &flag, p->statuses);
#elif MPI_TUNE == 2
    /* 
     * Technique number 2 
     */
    int flag;
    MPI_Testall(p->count, p->requests, &flag, p->statuses);
#elif MPI_TUNE == 3
    /* 
     * Technique number 3 
     */
    int i, index, flag;
    for (i=1; i<p->nodes; i++)
      MPI_Testany(p->count, p->requests, &index, &flag, p->statuses);
#endif
  }
  else {
    MPI_Start(&p->requests[p->curmsg]);
    p->curmsg++;
  }
#endif
}


/*
 *  parallel.h - This file contains all of the defines for doing parallel
 *               message passing and such.
 *
 *  $Id: parallel.h,v 1.13 1998/07/20 04:31:57 johns Exp $
 *
 */

int rt_par_init(int *, char ***);
int rt_par_finish(void);
int rt_mynode(void);
int rt_numnodes(void);
int rt_getcpuinfo(nodeinfo **);
void rt_barrier_sync(void);

void * rt_allocate_reqbuf(int count);
void rt_free_reqbuf(void * voidhandle);

void * rt_init_scanlinereceives(scenedef * scene);
void rt_start_scanlinereceives(void * voidhandle);
void rt_waitscanlines(void * voidhandle);
void rt_delete_scanlinereceives(void * voidhandle);
void rt_sendrecvscanline(void * voidhandle);
/* 
 * parse.c - an UltraLame (tm) parser for simple data files...
 *
 *  $Id: parse.c,v 1.58 2004/02/03 05:48:12 johns Exp $
 */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h> /* needed for toupper(), macro.. */

#include "tachyon.h"  /* Tachyon ray tracer API */

#ifdef USELIBMGF
#include "mgfparse.h" /* MGF parser code */
#endif

#define PARSE_INTERNAL
#include "parse.h" /* self protos */
#undef PARSE_INTERNAL

#define ERROR_READBUF_SIZE 65536

/*
 * a is unknown compared string, b must be upper case already...)
 */
static int stringcmp(const char * a, const char * b) {
  int i, s, l;

  s=strlen(a);
  l=strlen(b);

  if (s != l) 
    return 1;

  for (i=0; i<s; i++) {
    if (toupper(a[i]) != b[i]) {
      return 1;
    }
  }
  return 0;
}

static void reset_tex_table(parsehandle * ph, SceneHandle scene) {
  apitexture apitex;
  
  ph->maxtextures=512; 
  ph->numtextures=0; 
  ph->textable = (texentry *) malloc(ph->maxtextures * sizeof(texentry));
  memset(ph->textable, 0, ph->maxtextures * sizeof(texentry));

  apitex.col.r=1.0;
  apitex.col.g=1.0; 
  apitex.col.b=1.0; 
  apitex.ambient=0.1;
  apitex.diffuse=0.9;
  apitex.specular=0.0;
  apitex.opacity=1.0;
  apitex.texturefunc=0;

  ph->defaulttex.tex=rt_texture(scene, &apitex);
  rt_hash_init(&ph->texhash, 1024);
}

static void free_tex_table(parsehandle * ph, SceneHandle scene) {
  int i;

  rt_hash_destroy(&ph->texhash);

  for (i=0; i<ph->numtextures; i++) {
    free(ph->textable[i].name);
  }
  
  free(ph->textable);
  ph->textable = NULL; 

  ph->numtextures = 0;
}

static errcode add_texture(parsehandle * ph, void * tex, const char * name) {
  ph->textable[ph->numtextures].tex=tex;
  ph->textable[ph->numtextures].name = malloc(strlen(name) + 1);
  strcpy(ph->textable[ph->numtextures].name, name); 
  rt_hash_insert(&ph->texhash, ph->textable[ph->numtextures].name, ph->numtextures);

  ph->numtextures++;
  if (ph->numtextures >= ph->maxtextures) {
    texentry * newblock;
    int newsize;

    newsize = 2 * ph->maxtextures;
    newblock = realloc(ph->textable, newsize * sizeof(texentry)); 
    if (newblock != NULL) {
      ph->maxtextures = newsize;
      ph->textable = newblock;
      return PARSENOERR;
    } else {
      printf("Parse: %d textures allocated, texture slots full!\n", ph->numtextures);
      ph->numtextures--; /* keep writing over last texture if we've run out.. */
      return PARSEALLOCERR;
    }
  }

  return PARSENOERR;
}

static void * find_texture(parsehandle * ph, const char * name) {
  int i;

  i=rt_hash_lookup(&ph->texhash, name);
  if (i != HASH_FAIL) {
    return ph->textable[i].tex;
  }

  printf("Undefined texture '%s', using default. \n", name);
  return(ph->defaulttex.tex); 
}

apiflt degtorad(apiflt deg) {
  apiflt tmp;
  tmp=deg * 3.1415926 / 180.0;
  return tmp;
}

static void degvectoradvec(apivector * degvec) {
  apivector tmp;

  tmp.x=degtorad(degvec->x);
  tmp.y=degtorad(degvec->y);
  tmp.z=degtorad(degvec->z);
  *degvec=tmp;
}

static void InitRot3d(RotMat * rot, apiflt x, apiflt y, apiflt z) {
  rot->rx1=cos(y)*cos(z);
  rot->rx2=sin(x)*sin(y)*cos(z) - cos(x)*sin(z);
  rot->rx3=sin(x)*sin(z) + cos(x)*cos(z)*sin(y);
  
  rot->ry1=cos(y)*sin(z);
  rot->ry2=cos(x)*cos(z) + sin(x)*sin(y)*sin(z);
  rot->ry3=cos(x)*sin(y)*sin(z) - sin(x)*cos(z);

  rot->rz1=sin(y);
  rot->rz2=sin(x)*cos(y);
  rot->rz3=cos(x)*cos(y);
}

static void Rotate3d(RotMat * rot, apivector * vec) {
  apivector tmp;
  tmp.x=(vec->x*(rot->rx1) + vec->y*(rot->rx2) + vec->z*(rot->rx3));
  tmp.y=(vec->x*(rot->ry1) + vec->y*(rot->ry2) + vec->z*(rot->ry3));
  tmp.z=(vec->x*(rot->rz1) + vec->y*(rot->rz2) + vec->z*(rot->rz3));
  *vec=tmp; 
}

static void Scale3d(apivector * scale, apivector * vec) {
  vec->x=vec->x * scale->x;
  vec->y=vec->y * scale->y;
  vec->z=vec->z * scale->z;
}

static void Trans3d(apivector * trans, apivector * vec) {
  vec->x+=trans->x;
  vec->y+=trans->y;
  vec->z+=trans->z;
}

static void PrintSyntaxError(parsehandle * ph, 
                             const char * string, const char * found) {
  long streampos, readsize;
  long i, j, linecount;
  char cbuf[ERROR_READBUF_SIZE];

  streampos = ftell(ph->ifp);

  /* count lines up to approximate position where error occured */ 
  fseek(ph->ifp, 0, SEEK_SET); 

  i=0;
  linecount=0;
  while (i < streampos) {
    if ((streampos - i) > ERROR_READBUF_SIZE) {
      readsize = ERROR_READBUF_SIZE;
    } else {
      readsize = streampos - i;
    }

    fread(cbuf, readsize, 1, ph->ifp);
    i+=readsize;
    for (j=0; j<readsize; j++) {
      if (cbuf[j] == '\n') {
        linecount++;
      }
    } 
  }

  printf("Parse Error:\n");
  printf("   Encountered a syntax error in file %s\n", ph->filename); 
  printf("   Expected to find %s\n", string);
  printf("   Actually found: %s\n", found);
  printf("   Error occured at or prior to file offset %ld, line %ld\n",
         streampos, linecount);
  printf("   Error position is only approximate, but should be close\n\n");

  fseek(ph->ifp, streampos, SEEK_SET); /* return to previous offset */
}

static errcode GetString(parsehandle * ph, const char * string) {
  char data[255];

  fscanf(ph->ifp, "%s", data);
  if (stringcmp(data, string) != 0) {
    PrintSyntaxError(ph, string, data);
    return PARSEBADSYNTAX;
  }

  return PARSENOERR;
}

unsigned int readmodel(const char * modelfile, SceneHandle scene) {
  parsehandle ph;
  errcode rc;

  memset(&ph, 0, sizeof(ph));
  ph.filename = modelfile;
  ph.ifp=fopen(modelfile, "r");
  if (ph.ifp == NULL) {
    return PARSEBADFILE;
  }

  reset_tex_table(&ph, scene); 

  rc = GetScenedefs(&ph, scene); 
  if (rc == PARSENOERR) {
    ph.numobjectsparsed=0;
    while ((rc = GetObject(&ph, scene)) == PARSENOERR) {
      ph.numobjectsparsed++;
    } 
    fclose(ph.ifp);
  
    if (rc == PARSEEOF)
      rc = PARSENOERR;
  }

  free_tex_table(&ph, scene);

  return rc;
}

static errcode ReadIncludeFile(parsehandle * ph, const char * includefile, SceneHandle scene) {
  errcode rc;
  const char * oldfilename = ph->filename;
  FILE * oldfp = ph->ifp;

  if (strcmp(includefile, ph->filename) == 0) {
    printf("Warning: possible self-recursive include of file %s\n", 
           includefile);
  }

  ph->filename=includefile;
  ph->ifp=fopen(includefile, "r");
  if (ph->ifp == NULL) {
    printf("Parser failed trying to open file: %s\n", includefile);

    /* restore old file pointers etc */
    ph->filename=oldfilename;
    ph->ifp = oldfp;

    return PARSEBADSUBFILE;
  }

  while ((rc = GetObject(ph, scene)) == PARSENOERR) {
    ph->numobjectsparsed++;
  } 
  fclose(ph->ifp);

  /* restore old file pointers etc */
  ph->filename=oldfilename;
  ph->ifp = oldfp;
  
  if (rc == PARSEEOF){
    rc = PARSENOERR;
  }

  return rc;
}

static errcode GetScenedefs(parsehandle * ph, SceneHandle scene) {
  int xres, yres;
  errcode rc = PARSENOERR;

  rc |= GetString(ph, "BEGIN_SCENE"); 
  
  rc |= GetString(ph, "RESOLUTION");
  fscanf(ph->ifp, "%d %d", &xres, &yres);

  rt_outputfile(scene, "outfile.tga");
  rt_resolution(scene, xres, yres);
  rt_verbose(scene, 0);

  return rc;
}

static errcode GetCamera(parsehandle * ph, SceneHandle scene) {
  apivector Ccenter, Cview, Cup;
  apiflt zoom, aspectratio;
  int raydepth, antialiasing;
  float a, b, c, d;
  errcode rc = PARSENOERR;
  char data[255];

  fscanf(ph->ifp, "%s", data);
  if (stringcmp(data, "PROJECTION") == 0) {
    fscanf(ph->ifp, "%s", data);
    if (stringcmp(data, "FISHEYE") ==0) {
      rt_camera_projection(scene, RT_PROJECTION_FISHEYE);
    } else if (stringcmp(data, "PERSPECTIVE") ==0) {
      rt_camera_projection(scene, RT_PROJECTION_PERSPECTIVE);
    } else if (stringcmp(data, "PERSPECTIVE_DOF") ==0) {
      rt_camera_projection(scene, RT_PROJECTION_PERSPECTIVE_DOF);

      rc |= GetString(ph, "FOCALLENGTH");
      fscanf(ph->ifp, "%f", &a);  

      rc |= GetString(ph, "APERTURE");
      fscanf(ph->ifp, "%f", &b);  

      rt_camera_dof(scene, a, b);
    } else if (stringcmp(data, "ORTHOGRAPHIC") ==0) {
      rt_camera_projection(scene, RT_PROJECTION_ORTHOGRAPHIC);
    }

    rc |= GetString(ph, "ZOOM");
    fscanf(ph->ifp, "%f", &a);  
    zoom=a;
  } else if (stringcmp(data, "ZOOM") == 0) {
    fscanf(ph->ifp, "%f", &a);
    zoom=a;
  } else {
    rc = PARSEBADSYNTAX;
    return rc;
  }

  rc |= GetString(ph, "ASPECTRATIO");
  fscanf(ph->ifp, "%f", &b);  
  aspectratio=b;

  rc |= GetString(ph, "ANTIALIASING");
  fscanf(ph->ifp, "%d", &antialiasing);

  rc |= GetString(ph, "RAYDEPTH");
  fscanf(ph->ifp, "%d", &raydepth);

  rc |= GetString(ph, "CENTER");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Ccenter.x = a;
  Ccenter.y = b;
  Ccenter.z = c;

  rc |= GetString(ph, "VIEWDIR");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Cview.x = a;
  Cview.y = b;
  Cview.z = c;

  rc |= GetString(ph, "UPDIR");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Cup.x = a;
  Cup.y = b;
  Cup.z = c;

  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth,
                  Ccenter, Cview, Cup);

  fscanf(ph->ifp, "%s", data);
  if (stringcmp(data, "FRUSTUM") == 0) {
    fscanf(ph->ifp, "%f %f %f %f", &a, &b, &c, &d);
    rt_camera_frustum(scene, a, b, c, d);
    fscanf(ph->ifp, "%s", data);
    if (stringcmp(data, "END_CAMERA") != 0) {
      rc |= PARSEBADSYNTAX;
      return rc;
    }
  } else if (stringcmp(data, "END_CAMERA") != 0) {
    rc |= PARSEBADSYNTAX;
    return rc;
  }


  return rc;
}

static errcode GetObject(parsehandle * ph, SceneHandle scene) {
  char objtype[256];
 
  if (fscanf(ph->ifp, "%s", objtype) == EOF) {
    return PARSEEOF;
  }
  if (!stringcmp(objtype, "TRI")) {
    return GetTri(ph, scene);
  }
  if (!stringcmp(objtype, "STRI")) {
    return GetSTri(ph, scene);
  }
  if (!stringcmp(objtype, "VCSTRI")) {
    return GetVCSTri(ph, scene);
  }
  if (!stringcmp(objtype, "SPHERE")) {
    return GetSphere(ph, scene);
  }
  if (!stringcmp(objtype, "FCYLINDER")) {
    return GetFCylinder(ph, scene);
  }
  if (!stringcmp(objtype, "RING")) {
    return GetRing(ph, scene);
  }
  if (!stringcmp(objtype, "POLYCYLINDER")) {
    return GetPolyCylinder(ph, scene);
  }
  if (!stringcmp(objtype, "CYLINDER")) {
    return GetCylinder(ph, scene);
  }
  if (!stringcmp(objtype, "PLANE")) {
    return GetPlane(ph, scene);
  }
  if (!stringcmp(objtype, "BOX")) {
    return GetBox(ph, scene);
  }
  if (!stringcmp(objtype, "SCALARVOL")) {
    return GetVol(ph, scene);
  }
  if (!stringcmp(objtype, "TEXDEF")) {
    return GetTexDef(ph, scene);
  }	
  if (!stringcmp(objtype, "TEXALIAS")) {
    return GetTexAlias(ph);
  }
  if (!stringcmp(objtype, "LIGHT")) {
    return GetLight(ph, scene);
  }
  if (!stringcmp(objtype, "DIRECTIONAL_LIGHT")) {
    return GetDirLight(ph, scene);
  }
  if (!stringcmp(objtype, "SPOTLIGHT")) {
    return GetSpotLight(ph, scene);
  }
  if (!stringcmp(objtype, "SCAPE")) {
    return GetLandScape(ph, scene);
  }
  if (!stringcmp(objtype, "CAMERA")) {
    return GetCamera(ph, scene);
  }
  if (!stringcmp(objtype, "TPOLYFILE")) {
    return GetTPolyFile(ph, scene);
  }
  if (!stringcmp(objtype, "MGFFILE")) {
#ifdef USELIBMGF
    return GetMGFFile(ph, scene);
#else
    printf("MGF File Parsing is not available in this build.\n");
    return PARSEBADSYNTAX;
#endif
  }
  if (!stringcmp(objtype, "#")) {
    int c;
    while (1) {
      c=fgetc(ph->ifp);
      if (c == EOF || c == '\n')    /* eat comment text */
        return PARSENOERR;
    } 
  }
  if (!stringcmp(objtype, "BACKGROUND")) {
    return GetBackGnd(ph, scene);
  }
  if (!stringcmp(objtype, "FOG")) {
    return GetFog(ph, scene);
  }
  if (!stringcmp(objtype, "INCLUDE")) {
    char includefile[FILENAME_MAX];
    fscanf(ph->ifp, "%s", includefile);
    return ReadIncludeFile(ph, includefile, scene);
  }
  if (!stringcmp(objtype, "END_SCENE")) {
    return PARSEEOF; /* end parsing */
  }

  PrintSyntaxError(ph, "an object or other declaration", objtype);

  return PARSEBADSYNTAX;
}

static errcode GetVector(parsehandle * ph, apivector * v1) {
  float a, b, c;
 
  if (fscanf(ph->ifp, "%f %f %f", &a, &b, &c) != 3) 
    return PARSEBADSYNTAX;

  v1->x=a;
  v1->y=b;
  v1->z=c;

  return PARSENOERR;
}

static errcode GetFloat(parsehandle * ph, apiflt * f) {
  float a;
  if (fscanf(ph->ifp, "%f", &a) != 1) 
    return PARSEBADSYNTAX;

  *f = a;

  return PARSENOERR;
}

static errcode GetColor(parsehandle * ph, apicolor * c1) {
  float r, g, b;
  int rc; 

  rc = GetString(ph, "COLOR"); 
  fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
  c1->r=r;
  c1->g=g;
  c1->b=b;

  return rc;
}

static errcode GetTexDef(parsehandle * ph, SceneHandle scene) {
  char texname[TEXNAMELEN];

  fscanf(ph->ifp, "%s", texname);
  add_texture(ph, GetTexBody(ph, scene, 0), texname); 

  return PARSENOERR;
}

static errcode GetTexAlias(parsehandle * ph) {
  char texname[TEXNAMELEN];
  char aliasname[TEXNAMELEN];

  fscanf(ph->ifp, "%s", texname);
  fscanf(ph->ifp, "%s", aliasname);
  add_texture(ph, find_texture(ph, aliasname), texname); 

  return PARSENOERR;
}


static errcode GetTexture(parsehandle * ph, SceneHandle scene, void ** tex) {
  char tmp[255];
  errcode rc = PARSENOERR;

  fscanf(ph->ifp, "%s", tmp);
  if (!stringcmp(tmp, "TEXTURE")) {	
    *tex = GetTexBody(ph, scene, 0);
  }
  else
    *tex = find_texture(ph, tmp);

  return rc;
}

void * GetTexBody(parsehandle * ph, SceneHandle scene, int modeflag) {
  char tmp[255];
  float a,b,c,d, phong, phongexp;
  int phongtype;
  apitexture tex;
  void * voidtex; 
  errcode rc;

  rc = GetString(ph, "AMBIENT");
  fscanf(ph->ifp, "%f", &a); 
  tex.ambient=a;

  rc |= GetString(ph, "DIFFUSE");
  fscanf(ph->ifp, "%f", &b);
  tex.diffuse=b;

  rc |= GetString(ph, "SPECULAR");
  fscanf(ph->ifp, "%f", &c);
  tex.specular=c;

  rc |= GetString(ph, "OPACITY");
  fscanf(ph->ifp, "%f", &d);  
  tex.opacity=d;

  fscanf(ph->ifp, "%s", tmp);
  if (!stringcmp(tmp, "PHONG")) {
    fscanf(ph->ifp, "%s", tmp);
    if (!stringcmp(tmp, "METAL")) {
      phongtype = RT_PHONG_METAL;
    }
    else if (!stringcmp(tmp, "PLASTIC")) {
      phongtype = RT_PHONG_PLASTIC;
    }
    else {
      phongtype = RT_PHONG_PLASTIC;
    } 

    fscanf(ph->ifp, "%f", &phong);
    GetString(ph, "PHONG_SIZE");
    fscanf(ph->ifp, "%f", &phongexp);
    fscanf(ph->ifp, "%s", tmp);
  } else { 
    /* assume we found "COLOR" otherwise */
    phong = 0.0;
    phongexp = 100.0;
    phongtype = RT_PHONG_PLASTIC;
  }

  /* if we're processing normal objects, use the regular */
  /* texture definition pattern.                         */
  /* VCSTri objects skip the normal color and texture    */
  /* function definition since they are unused.          */ 
  if (modeflag == 0) { 
    if (stringcmp(tmp, "COLOR")) {
      rc |= PARSEBADSYNTAX;
    }

    fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
    tex.col.r = a;
    tex.col.g = b;
    tex.col.b = c;
 
    rc |= GetString(ph, "TEXFUNC");

    /* this really ought to be a string, not a number... */
    fscanf(ph->ifp, "%d", &tex.texturefunc);

    switch (tex.texturefunc) {
      case RT_TEXTURE_CONSTANT:
      default: 
        break;

      case RT_TEXTURE_3D_CHECKER:
      case RT_TEXTURE_GRIT:
      case RT_TEXTURE_MARBLE:
      case RT_TEXTURE_WOOD:
      case RT_TEXTURE_GRADIENT:
      case RT_TEXTURE_CYLINDRICAL_CHECKER:
        rc |= GetString(ph, "CENTER");
        rc |= GetVector(ph, &tex.ctr);
        rc |= GetString(ph, "ROTATE");
        rc |= GetVector(ph, &tex.rot);
        rc |= GetString(ph, "SCALE");
        rc |= GetVector(ph, &tex.scale);
        break;

      case RT_TEXTURE_CYLINDRICAL_IMAGE:
      case RT_TEXTURE_SPHERICAL_IMAGE:
        fscanf(ph->ifp, "%s", tex.imap);
        rc |= GetString(ph, "CENTER");
        rc |= GetVector(ph, &tex.ctr);
        rc |= GetString(ph, "ROTATE");
        rc |= GetVector(ph, &tex.rot);
        rc |= GetString(ph, "SCALE");
        rc |= GetVector(ph, &tex.scale);
        break;
     
      case RT_TEXTURE_PLANAR_IMAGE:
        fscanf(ph->ifp, "%s", tex.imap);
        rc |= GetString(ph, "CENTER");
        rc |= GetVector(ph, &tex.ctr);
        rc |= GetString(ph, "ROTATE");
        rc |= GetVector(ph, &tex.rot);
        rc |= GetString(ph, "SCALE");
        rc |= GetVector(ph, &tex.scale);
        rc |= GetString(ph, "UAXIS");
        rc |= GetVector(ph, &tex.uaxs);
        rc |= GetString(ph, "VAXIS");
        rc |= GetVector(ph, &tex.vaxs);
        break;
    }
  } else {
    if (stringcmp(tmp, "VCST")) {
      rc |= PARSEBADSYNTAX;
    }

    /* if we're processing VCSTri objects, set some defaults */
    tex.col.r = 1.0;
    tex.col.g = 1.0;
    tex.col.b = 1.0;
    tex.texturefunc = 0; /* set to none by default, gets reset anyway */
  }

  voidtex = rt_texture(scene, &tex);
  rt_tex_phong(voidtex, phong, phongexp, phongtype);

  return voidtex;
}

static errcode GetDirLight(parsehandle * ph, SceneHandle scene) {
  char tmp[255];
  apivector dir;
  apitexture tex;
  float r, g, b;
  errcode rc;

  memset(&tex, 0, sizeof(apitexture)); 

  rc = GetString(ph, "DIRECTION"); 
  rc |= GetVector(ph, &dir); 

  fscanf(ph->ifp, "%s", tmp);
  if (!stringcmp(tmp, "COLOR")) {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r=r;
    tex.col.g=g;
    tex.col.b=b;

    rt_directional_light(scene, rt_texture(scene, &tex), dir);
  }

  return rc;
}

static errcode GetLight(parsehandle * ph, SceneHandle scene) {
  char tmp[255];
  apiflt rad, Kc, Kl, Kq;
  apivector ctr;
  apitexture tex;
  float r, g, b, a;
  errcode rc;
  void * li;

  memset(&tex, 0, sizeof(apitexture)); 

  rc = GetString(ph, "CENTER"); 
  rc |= GetVector(ph, &ctr); 
  rc |= GetString(ph, "RAD");
  fscanf(ph->ifp, "%f", &a);  /* read in radius */ 
  rad=a;

  fscanf(ph->ifp, "%s", tmp);
  if (!stringcmp(tmp, "COLOR")) {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r=r;
    tex.col.g=g;
    tex.col.b=b;

    li = rt_light(scene, rt_texture(scene, &tex), ctr, rad);
  }
  else { 
    if (stringcmp(tmp, "ATTENUATION"))
      return -1;

    rc |= GetString(ph, "CONSTANT");
    fscanf(ph->ifp, "%f", &a); 
    Kc=a;
    rc |= GetString(ph, "LINEAR");
    fscanf(ph->ifp, "%f", &a); 
    Kl=a;
    rc |= GetString(ph, "QUADRATIC");
    fscanf(ph->ifp, "%f", &a); 
    Kq=a;
    rc |= GetColor(ph, &tex.col);

    li = rt_light(scene, rt_texture(scene, &tex), ctr, rad);

    rt_light_attenuation(li, Kc, Kl, Kq);
  } 

  return rc;
}

static errcode GetSpotLight(parsehandle * ph, SceneHandle scene) {
  char tmp[255];
  apiflt rad, Kc, Kl, Kq;
  apivector ctr;
  apitexture tex;
  apivector direction;
  apiflt start, end;
  float r, g, b, a;
  errcode rc;
  void * li;

  memset(&tex, 0, sizeof(apitexture)); 

  rc = GetString(ph, "CENTER"); 
  rc |= GetVector(ph, &ctr); 
  rc |= GetString(ph,"RAD");
  fscanf(ph->ifp, "%f", &a);  /* read in radius */ 
  rad=a;
 
  rc |= GetString(ph, "DIRECTION"); 
  rc |= GetVector(ph, &direction); 
  rc |= GetString(ph, "FALLOFF_START");
  fscanf(ph->ifp, "%f",&a);
  start=a;
  rc |= GetString(ph, "FALLOFF_END");
  fscanf(ph->ifp, "%f", &a);
  end=a;
   
  fscanf(ph->ifp, "%s", tmp);
  if (!stringcmp(tmp, "COLOR")) {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r=r;
    tex.col.g=g;
    tex.col.b=b;

    li = rt_spotlight(scene, rt_texture(scene, &tex), ctr, rad, direction, start, end);
  } 
  else {
    if (stringcmp(tmp, "ATTENUATION"))
      return -1;
    rc |= GetString(ph, "CONSTANT");
    fscanf(ph->ifp, "%f", &a);
    Kc=a;
    rc |= GetString(ph, "LINEAR");
    fscanf(ph->ifp, "%f", &a);
    Kl=a;
    rc |= GetString(ph, "QUADRATIC");
    fscanf(ph->ifp, "%f", &a);
    Kq=a;
    rc |= GetColor(ph, &tex.col);

    li = rt_spotlight(scene, rt_texture(scene, &tex), ctr, rad, direction, start, end);
    rt_light_attenuation(li, Kc, Kl, Kq);
  }

  return rc;
}


static errcode GetFog(parsehandle * ph, SceneHandle scene) {
  char tmp[255];
  apicolor fogcol; 
  float start, end, density;
  errcode rc = PARSENOERR;
 
  fscanf(ph->ifp, "%s", tmp); 
  if (!stringcmp(tmp, "LINEAR")) {
    rt_fog_mode(scene, RT_FOG_LINEAR);
  } else if (!stringcmp(tmp, "EXP")) {
    rt_fog_mode(scene, RT_FOG_EXP);
  } else if (!stringcmp(tmp, "EXP2")) {
    rt_fog_mode(scene, RT_FOG_EXP2);
  } else if (!stringcmp(tmp, "OFF")) {
    rt_fog_mode(scene, RT_FOG_NONE);
  }

  rc |= GetString(ph, "START");
  fscanf(ph->ifp, "%f", &start);

  rc |= GetString(ph, "END");
  fscanf(ph->ifp, "%f", &end);

  rc |= GetString(ph, "DENSITY");
  fscanf(ph->ifp, "%f", &density);

  rc |= GetColor(ph, &fogcol);

  rt_fog_parms(scene, fogcol, start, end, density);

  return PARSENOERR;
}


static errcode GetBackGnd(parsehandle * ph, SceneHandle scene) {
  float r,g,b;
  apicolor scenebackcol; 
  
  fscanf(ph->ifp, "%f %f %f", &r, &g, &b);

  scenebackcol.r=r;
  scenebackcol.g=g;
  scenebackcol.b=b;
  rt_background(scene, scenebackcol);

  return PARSENOERR;
}


static errcode GetCylinder(parsehandle * ph, SceneHandle scene) {
  apiflt rad;
  apivector ctr, axis;
  void * tex;
  float a;
  errcode rc;

  rc = GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr);
  rc |= GetString(ph, "AXIS");
  rc |= GetVector(ph, &axis);
  rc |= GetString(ph, "RAD");
  fscanf(ph->ifp, "%f", &a);
  rad=a;

  rc |= GetTexture(ph, scene, &tex);
  rt_cylinder(scene, tex, ctr, axis, rad); 

  return rc;
}

static errcode GetFCylinder(parsehandle * ph, SceneHandle scene) {
  apiflt rad;
  apivector ctr, axis;
  apivector pnt1, pnt2;
  void * tex;
  float a;
  errcode rc;

  rc = GetString(ph, "BASE");
  rc |= GetVector(ph, &pnt1);
  rc |= GetString(ph, "APEX");
  rc |= GetVector(ph, &pnt2);

  ctr=pnt1;
  axis.x=pnt2.x - pnt1.x; 
  axis.y=pnt2.y - pnt1.y;
  axis.z=pnt2.z - pnt1.z;

  rc |= GetString(ph, "RAD");
  fscanf(ph->ifp, "%f", &a);
  rad=a;

  rc |= GetTexture(ph, scene, &tex);
  rt_fcylinder(scene, tex, ctr, axis, rad); 

  return rc;
}
 
static errcode GetPolyCylinder(parsehandle * ph, SceneHandle scene) {
  apiflt rad;
  apivector * temp;
  void * tex;
  float a;
  int numpts, i;
  errcode rc;

  rc = GetString(ph, "POINTS");
  fscanf(ph->ifp, "%d", &numpts);

  temp = (apivector *) malloc(numpts * sizeof(apivector));

  for (i=0; i<numpts; i++) {
    rc |= GetVector(ph, &temp[i]);
  }         

  rc |= GetString(ph, "RAD");
  fscanf(ph->ifp, "%f", &a);
  rad=a;

  rc |= GetTexture(ph, scene, &tex);
  rt_polycylinder(scene, tex, temp, numpts, rad); 

  free(temp);

  return rc;
}
 

static errcode GetSphere(parsehandle * ph, SceneHandle scene) {
  apiflt rad;
  apivector ctr;
  void * tex;
  float a;
  errcode rc;
 
  rc = GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr); 
  rc |= GetString(ph, "RAD");
  fscanf(ph->ifp, "%f", &a); 
  rad=a;

  rc |= GetTexture(ph, scene, &tex); 
 
  rt_sphere(scene, tex, ctr, rad);

  return rc;
}

static errcode GetPlane(parsehandle * ph, SceneHandle scene) {
  apivector normal;
  apivector ctr;
  void * tex;
  errcode rc;

  rc = GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr);
  rc |= GetString(ph, "NORMAL");
  rc |= GetVector(ph, &normal);
  rc |= GetTexture(ph, scene, &tex);

  rt_plane(scene, tex, ctr, normal);

  return rc;
}

static errcode GetVol(parsehandle * ph, SceneHandle scene) {
  apivector min, max;
  int x,y,z;  
  char fname[255];
  void * tex;
  errcode rc;
 
  rc = GetString(ph, "MIN");
  rc |= GetVector(ph, &min);
  rc |= GetString(ph, "MAX");
  rc |= GetVector(ph, &max);
  rc |= GetString(ph, "DIM");
  fscanf(ph->ifp, "%d %d %d ", &x, &y, &z);
  rc |= GetString(ph, "FILE");
  fscanf(ph->ifp, "%s", fname);  
  rc |= GetTexture(ph, scene, &tex);
 
  rt_scalarvol(scene, tex, min, max, x, y, z, fname, NULL); 

  return rc;
}

static errcode GetBox(parsehandle * ph, SceneHandle scene) {
  apivector min, max;
  void * tex;
  errcode rc;

  rc = GetString(ph, "MIN");
  rc |= GetVector(ph, &min);
  rc |= GetString(ph, "MAX");
  rc |= GetVector(ph, &max);
  rc |= GetTexture(ph, scene, &tex);

  rt_box(scene, tex, min, max);

  return rc;
}

static errcode GetRing(parsehandle * ph, SceneHandle scene) {
  apivector normal;
  apivector ctr;
  void * tex;
  float a,b;
  errcode rc;
 
  rc = GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr);
  rc |= GetString(ph, "NORMAL");
  rc |= GetVector(ph, &normal);
  rc |= GetString(ph, "INNER");
  fscanf(ph->ifp, " %f ", &a);
  rc |= GetString(ph, "OUTER");
  fscanf(ph->ifp, " %f ", &b);
  rc |= GetTexture(ph, scene, &tex);
 
  rt_ring(scene, tex, ctr, normal, a, b);

  return rc;
}

static errcode GetTri(parsehandle * ph, SceneHandle scene) {
  apivector v0,v1,v2;
  void * tex;
  errcode rc;

  rc = GetString(ph, "V0");
  rc |= GetVector(ph, &v0);

  rc |= GetString(ph, "V1");
  rc |= GetVector(ph, &v1);

  rc |= GetString(ph, "V2");
  rc |= GetVector(ph, &v2);

  rc |= GetTexture(ph, scene, &tex);

  rt_tri(scene, tex, v0, v1, v2);

  return rc;
}

static errcode GetSTri(parsehandle * ph, SceneHandle scene) {
  apivector v0,v1,v2,n0,n1,n2;
  void * tex;
  errcode rc;

  rc = GetString(ph, "V0");
  rc |= GetVector(ph, &v0);

  rc |= GetString(ph, "V1");
  rc |= GetVector(ph, &v1);

  rc |= GetString(ph, "V2");
  rc |= GetVector(ph, &v2);
  
  rc |= GetString(ph, "N0");
  rc |= GetVector(ph, &n0);

  rc |= GetString(ph, "N1");
  rc |= GetVector(ph, &n1);

  rc |= GetString(ph, "N2");
  rc |= GetVector(ph, &n2);

  rc |= GetTexture(ph, scene, &tex);
  
  rt_stri(scene, tex, v0, v1, v2, n0, n1, n2);

  return rc;
}

static errcode GetVCSTri(parsehandle * ph, SceneHandle scene) {
  apivector v0,v1,v2,n0,n1,n2;
  apicolor  c0,c1,c2;
  float a, b, c;

  void * tex;
  errcode rc;

  rc = GetString(ph, "V0");
  rc |= GetVector(ph, &v0);

  rc |= GetString(ph, "V1");
  rc |= GetVector(ph, &v1);

  rc |= GetString(ph, "V2");
  rc |= GetVector(ph, &v2);
  
  rc |= GetString(ph, "N0");
  rc |= GetVector(ph, &n0);

  rc |= GetString(ph, "N1");
  rc |= GetVector(ph, &n1);

  rc |= GetString(ph, "N2");
  rc |= GetVector(ph, &n2);

  rc |= GetString(ph, "C0");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c0.r = a;
  c0.g = b;
  c0.b = c;

  rc |= GetString(ph, "C1");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c1.r = a;
  c1.g = b;
  c1.b = c;

  rc |= GetString(ph, "C2");
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c2.r = a;
  c2.g = b;
  c2.b = c;

  tex = GetTexBody(ph, scene, 1);
  
  rt_vcstri(scene, tex, v0, v1, v2, n0, n1, n2, c0, c1, c2);

  return rc;
}


static errcode GetLandScape(parsehandle * ph, SceneHandle scene) {
  void * tex;
  apivector ctr;
  apiflt wx, wy;
  int m, n;
  float a,b;
  errcode rc;

  rc = GetString(ph, "RES");
  fscanf(ph->ifp, "%d %d", &m, &n);

  rc |= GetString(ph, "SCALE");
  fscanf(ph->ifp, "%f %f", &a, &b);   
  wx=a;
  wy=b;

  rc |= GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr);

  rc |= GetTexture(ph, scene, &tex);

  rt_landscape(scene, tex, m, n, ctr, wx, wy);

  return rc;
}

static errcode GetTPolyFile(parsehandle * ph, SceneHandle scene) {
  void * tex;
  apivector ctr, rot, scale;
  apivector v1, v2, v0;
  char ifname[255];
  FILE *ifp;
  int v, totalpolys;
  RotMat RotA;
  errcode rc;

  totalpolys=0;

  rc = GetString(ph, "SCALE"); 
  rc |= GetVector(ph, &scale);

  rc |= GetString(ph, "ROT");
  rc |= GetVector(ph, &rot);

  degvectoradvec(&rot); 
  InitRot3d(&RotA, rot.x, rot.y, rot.z);

  rc |= GetString(ph, "CENTER");
  rc |= GetVector(ph, &ctr);

  rc |= GetString(ph, "FILE");
  fscanf(ph->ifp, "%s", ifname);

  rc |= GetTexture(ph, scene, &tex);

  if ((ifp=fopen(ifname, "r")) == NULL) {
    printf("Can't open data file %s for input!! Aborting...\n", ifname);
    return PARSEBADSUBFILE;
  }

  while (!feof(ifp)) {
    fscanf(ifp, "%d", &v);
    if (v != 3) { break; }

    totalpolys++;
    v=0; 
     
    rc |= GetVector(ph, &v0);
    rc |= GetVector(ph, &v1);
    rc |= GetVector(ph, &v2);

    Scale3d(&scale, &v0);
    Scale3d(&scale, &v1);
    Scale3d(&scale, &v2);

    Rotate3d(&RotA, &v0); 
    Rotate3d(&RotA, &v1); 
    Rotate3d(&RotA, &v2); 

    Trans3d(&ctr, &v0);
    Trans3d(&ctr, &v1);
    Trans3d(&ctr, &v2);

    rt_tri(scene, tex, v1, v0, v2);
  }

  fclose(ifp);

  return rc;
}

#ifdef USELIBMGF
static errcode GetMGFFile(parsehandle * ph, SceneHandle scene) {
  char ifname[255];

  fscanf(ph->ifp, "%s", ifname); /* get MGF filename */
  if (ParseMGF(ifname, scene, 0) == MGF_NOERR)
    return PARSENOERR;
  
  return PARSENOERR; /* XXX hack */ 
}
#endif



 
/*
 * parse.h - this file contains defines for model file reading.
 *
 *  $Id: parse.h,v 1.23 2004/02/03 05:48:12 johns Exp $
 */

#define PARSENOERR       0
#define PARSEBADFILE     1
#define PARSEBADSUBFILE  2
#define PARSEBADSYNTAX   4
#define PARSEEOF         8
#define PARSEALLOCERR    16
 
unsigned int readmodel(const char *, SceneHandle);

#ifdef PARSE_INTERNAL
#define TEXNAMELEN 255

typedef struct {
        char * name;
        void * tex;
} texentry;

typedef struct {
  FILE * ifp;            /* current input file pointer */
  const char * filename; /* filename of current input file */
  texentry *textable;    /* texture lookup table */
  texentry defaulttex;   /* The default texture when a lookup fails */
  int numtextures;       /* number of TEXDEF textures               */
  int maxtextures;       /* number of TEXDEF textures               */
  int numobjectsparsed;  /* total number of objects parsed so far   */
  rt_hash_t texhash;     /* hash table for texture name lookup      */
} parsehandle;  

typedef struct {
   double rx1; double rx2; double rx3;
   double ry1; double ry2; double ry3;
   double rz1; double rz2; double rz3;
} RotMat;

typedef unsigned int errcode;

/* texture lookup table code */
static void reset_tex_table(parsehandle *, SceneHandle);
static void free_tex_table(parsehandle *, SceneHandle);
static errcode add_texture(parsehandle *, void * tex, const char *);
static void * find_texture(parsehandle *, const char *);

/* scene file parsing code */
static errcode GetString(parsehandle *, const char *);
static errcode GetScenedefs(parsehandle *, SceneHandle);
static errcode GetCamera(parsehandle *, SceneHandle);
static errcode GetColor(parsehandle *, apicolor *);
static errcode GetFloat(parsehandle *, apiflt *);
static errcode GetVector(parsehandle *, apivector *);
static errcode GetTexDef(parsehandle *, SceneHandle);
static errcode GetTexAlias(parsehandle *);
static errcode GetTexture(parsehandle *, SceneHandle, void **);
void * GetTexBody(parsehandle *, SceneHandle, int);
static errcode GetBackGnd(parsehandle *, SceneHandle);
static errcode GetFog(parsehandle *, SceneHandle);
static errcode GetCylinder(parsehandle *, SceneHandle);
static errcode GetFCylinder(parsehandle *, SceneHandle);
static errcode GetPolyCylinder(parsehandle *, SceneHandle);
static errcode GetSphere(parsehandle *, SceneHandle);
static errcode GetPlane(parsehandle *, SceneHandle);
static errcode GetRing(parsehandle *, SceneHandle);
static errcode GetBox(parsehandle *, SceneHandle);
static errcode GetVol(parsehandle *, SceneHandle);
static errcode GetTri(parsehandle *, SceneHandle);
static errcode GetSTri(parsehandle *, SceneHandle);
static errcode GetVCSTri(parsehandle *, SceneHandle);
static errcode GetDirLight(parsehandle *, SceneHandle);
static errcode GetLight(parsehandle *, SceneHandle);
static errcode GetSpotLight(parsehandle *, SceneHandle);
static errcode GetLandScape(parsehandle *, SceneHandle);
static errcode GetTPolyFile(parsehandle *, SceneHandle);
static errcode GetObject(parsehandle *, SceneHandle);
static errcode ReadIncludeFile(parsehandle *, const char *, SceneHandle);

#ifdef USELIBMGF
static errcode GetMGFFile(parsehandle *, SceneHandle);
#endif

#endif

/*
 * parvol.c - Volume rendering helper routines etc.
 *
 *  $Id: parvol.c,v 1.9 1997/10/30 08:10:22 johns Exp $
 */

#include<stdio.h>

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "util.h"
#include "parallel.h"
#include "box.h"
#include "parvol.h"
#include "trace.h"
#include "sphere.h"
#include "light.h"
#include "shade.h"
#include "global.h"

parvol * newparvol() {
  parvol * xvol;

  xvol = (parvol *) rt_getmem(sizeof(parvol));
  memset(xvol, 0, sizeof(parvol));
  xvol->intersect = (void (*)(void *, void *))(box_intersect);
  xvol->normal = (void (*)(void *, void *, void *, void *))(box_normal);

  return xvol;
}

color ParVoxelColor(flt scalar) {
  color col;
 
  if (scalar > 1.0)
    scalar = 1.0;
 
  if (scalar < 0.0)
    scalar = 0.0;
 
  if (scalar < 0.5) {
    col.g = 0.0;
  }
  else {
    col.g = (scalar - 0.5) * 2.0;
  }
 
  col.r = scalar;
  col.b = 1.0 - (scalar / 2.0);
 
  return col;
} 

color par_volume_texture(vector * hit, texture * tex, ray * ry) {
  color col, col2;
  box * bx;
  parvol * xvol;
  flt a, tx1, tx2, ty1, ty2, tz1, tz2;
  flt tnear, tfar;
  flt t, tdist, dt, ddt, sum, tt; 
  vector pnt, bln;
  flt scalar, transval; 
  int i;
  point_light * li;
  color diffint;
  vector N, L;
  flt inten;

    bx = (box *)    tex->obj;
  xvol = (parvol *) tex->obj;
 
  tnear= -FHUGE;
  tfar= FHUGE;
 
  if (ry->d.x == 0.0) {
    if ((ry->o.x < bx->min.x) || (ry->o.x > bx->max.x)) return col;
  }
  else {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if (tx1 > tx2) { a=tx1; tx1=tx2; tx2=a; }
    if (tx1 > tnear) tnear=tx1;
    if (tx2 < tfar)   tfar=tx2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
 if (ry->d.y == 0.0) {
    if ((ry->o.y < bx->min.y) || (ry->o.y > bx->max.y)) return col;
  }
  else {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if (ty1 > ty2) { a=ty1; ty1=ty2; ty2=a; }
    if (ty1 > tnear) tnear=ty1;
    if (ty2 < tfar)   tfar=ty2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (ry->d.z == 0.0) {
    if ((ry->o.z < bx->min.z) || (ry->o.z > bx->max.z)) return col;
  }
  else {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if (tz1 > tz2) { a=tz1; tz1=tz2; tz2=a; }
    if (tz1 > tnear) tnear=tz1;
    if (tz2 < tfar)   tfar=tz2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (tnear < 0.0) tnear=0.0;
 
  tdist = xvol->samples;

  tt = (xvol->opacity / tdist); 

  bln.x=fabs(bx->min.x - bx->max.x);
  bln.y=fabs(bx->min.y - bx->max.y);
  bln.z=fabs(bx->min.z - bx->max.z);
  
     dt = 1.0 / tdist; 
    sum = 0.0;
  col.r = 0.0;
  col.g = 0.0;
  col.b = 0.0;

/* Accumulate color as the ray passes through the voxels */
  for (t=tnear; t<=tfar; t+=dt) {
    if (sum < 1.0) {
      pnt.x=((ry->o.x + (ry->d.x * t)) - bx->min.x) / bln.x;
      pnt.y=((ry->o.y + (ry->d.y * t)) - bx->min.y) / bln.y;
      pnt.z=((ry->o.z + (ry->d.z * t)) - bx->min.z) / bln.z;

      /* call external evaluator assume 0.0 -> 1.0 range.. */
      scalar = xvol->evaluator(pnt.x, pnt.y, pnt.z);  

      transval = tt * scalar; 
      sum += transval; 

      col2 = ParVoxelColor(scalar);

      col.r += transval * col2.r * xvol->ambient;
      col.g += transval * col2.g * xvol->ambient;
      col.b += transval * col2.b * xvol->ambient;

      ddt = dt;

      /* Add in diffuse shaded light sources (no shadows) */
      if (xvol->diffuse > 0.0) {
 
        /* Calculate the Volume gradient at the voxel */
        N.x = (xvol->evaluator(pnt.x - ddt, pnt.y, pnt.z)  -
              xvol->evaluator(pnt.x + ddt, pnt.y, pnt.z)) *  8.0 * tt;
 
        N.y = (xvol->evaluator(pnt.x, pnt.y - ddt, pnt.z)  -
              xvol->evaluator(pnt.x, pnt.y + ddt, pnt.z)) *  8.0 * tt;
 
        N.z = (xvol->evaluator(pnt.x, pnt.y, pnt.z - ddt)  -
              xvol->evaluator(pnt.x, pnt.y, pnt.z + ddt)) *  8.0 * tt;
 
        /* only light surfaces with enough of a normal.. */
        if ((N.x*N.x + N.y*N.y + N.z*N.z) > 0.0) {
          diffint.r = 0.0;
          diffint.g = 0.0;
          diffint.b = 0.0;
 
          /* add the contribution of each of the lights.. */
          for (i=0; i<numlights; i++) {
            li=lightlist[i];
            VSUB(li->ctr, (*hit), L)
            VNorm(&L);
            VDOT(inten, N, L)
 
            /* only add light if its from the front of the surface */
            /* could add back-lighting if we wanted to later.. */
            if (inten > 0.0) {
              diffint.r += inten*li->tex->col.r;
              diffint.g += inten*li->tex->col.g;
              diffint.b += inten*li->tex->col.b;
            }
          }
          col.r += col2.r * diffint.r * xvol->diffuse;
          col.g += col2.g * diffint.g * xvol->diffuse;
          col.b += col2.b * diffint.b * xvol->diffuse;
        }
      }
    }
    else { 
      sum=1.0;
    }  
  }

  /* Add in transmitted ray from outside environment */
  if (sum < 1.0) {      /* spawn transmission rays / refraction */
    color transcol;

    transcol = shade_transmission(ry, hit, 1.0 - sum);

    col.r += transcol.r; /* add the transmitted ray  */
    col.g += transcol.g; /* to the diffuse and       */
    col.b += transcol.b; /* transmission total..     */
  }

  return col;
}



/*
 * parvol.h - Volume rendering definitions etc.
 *
 *
 *  $Id: parvol.h,v 1.4 2002/08/04 21:43:34 johns Exp $
 */

typedef struct {
  RT_OBJECT_HEAD
  vector min;
  vector max;
  flt ambient;
  flt diffuse;
  flt opacity;
  int samples;
  flt (* evaluator)(flt, flt, flt);
} parvol;

parvol * newparvol();
color par_volume_texture(vector *, texture *, ray *);


/* 
 * plane.c - This file contains the functions for dealing with planes.
 *
 *  $Id: plane.c,v 1.22 2002/07/09 16:14:31 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

#define PLANE_PRIVATE
#include "plane.h"

static object_methods plane_methods = {
  (void (*)(const void *, void *))(plane_intersect),
  (void (*)(const void *, const void *, const void *, void *))(plane_normal),
  plane_bbox, 
  free 
};

object * newplane(void * tex, vector ctr, vector norm) {
  plane * p;
  
  p=(plane *) malloc(sizeof(plane));
  memset(p, 0, sizeof(plane));
  p->methods = &plane_methods;

  p->tex = tex;
  p->norm = norm;
  VNorm(&p->norm);
  p->d = -VDot(&ctr, &p->norm);

  return (object *) p;
}

static int plane_bbox(void * obj, vector * min, vector * max) {
  return 0;
}

static void plane_intersect(const plane * pln, ray * ry) {
  flt t,td, tmp;

  /*
    BEGIN_VEC3Arg(SIMD_PLANE_INTERSECT, &(pln->norm), &(ry->o));

    sld4   r9, r0, s4     ; pln->norm -> s4
    sld4   r10, r0, s8    ; ry->o --> s8
    sld4   r10, i12, s12  ; ry->d --> s12 (note ry.d is 12 bytes after ry->o)
    smulf4  s4, s8, s16   ; s16 = pln->norm * ry->o
    sredf4  s16, r0, f0   ; f0 (say) = tmp
    
    smulf4  s4, s12, s24  ; s24 =  pln->norm * ry->d
    sredf4  s24, r0, f4   ; f4 (say) = td
    
    tmp += END_VEC();
 */
  
  tmp = (pln->norm.x * ry->o.x + 
	 pln->norm.y * ry->o.y + 
	 pln->norm.z * ry->o.z);


  t = -(pln->d + tmp);

  /* may wish to reorder these computations... */
 

  td = pln->norm.x * ry->d.x + pln->norm.y * ry->d.y + pln->norm.z * ry->d.z;



  if (td != 0.0) {
    t /= td;
    if (t > 0.0)
      ry->add_intersection(t,(object *) pln, ry);
  }
}

static void plane_normal(const plane * pln, const vector * pnt, const ray * incident, vector * N) {
  *N=pln->norm;
}

/* 
 * plane.h - This file contains the defines for planes etc.
 *
 *  $Id: plane.h,v 1.12 2002/08/04 21:43:34 johns Exp $
 */

 
object * newplane(void * tex, vector ctr, vector norm);

#ifdef PLANE_PRIVATE
typedef struct {
  RT_OBJECT_HEAD
  flt d;
  vector norm;
} plane; 

static void plane_intersect(const plane *, ray *);
static int plane_bbox(void * obj, vector * min, vector * max);
static void plane_normal(const plane *, const vector *, const ray * incident, vector *);
#endif

/*
 *  pngfile.c - This file deals with PNG format image files (reading/writing)
 *
 *  $Id: pngfile.c,v 1.7 2001/02/26 22:50:43 johns Exp $
 */ 

/*
 * This code requires support from libpng, and libz.
 * For our purposes, we're interested only in the 3 byte per pixel 24 bit
 * RGB input/output.  Probably won't implement any decent checking at this 
 * point.
 */ 

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h" /* error codes etc */
#include "pngfile.h" /* the protos for this file */

#if !defined(USEPNG)

int readpng(char * name, int * xres, int * yres, unsigned char **imgdata) {
  return IMAGEUNSUP;
}

int writepng(char * name, int xres, int yres, unsigned char *imgdata) {
  return IMAGEUNSUP;
}

#else

#include "png.h" /* the libpng library headers */

/* The png_jmpbuf() macro, used in error handling, became available in
 * libpng version 1.0.6.  If you want to be able to run your code with older
 * versions of libpng, you must define the macro yourself (but only if it
 * is not already defined by libpng!).
 */
#ifndef png_jmpbuf
#  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
#endif

int readpng(char * name, int * xres, int * yres, unsigned char **imgdata) {
  FILE * ifp;
  png_structp png_ptr;
  png_infop info_ptr;
  png_bytep *row_pointers;
  int x, y;

  /* Create and initialize the png_struct with the default error handlers */
  png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
  if (png_ptr == NULL) {
    return IMAGEALLOCERR; /* Could not initialize PNG library, return error */
  }

  /* Allocate/initialize the memory for image information.  REQUIRED. */
  info_ptr = png_create_info_struct(png_ptr);
  if (info_ptr == NULL) {
    png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
    return IMAGEALLOCERR; /* Could not initialize PNG library, return error */
  }

  /* open input file before doing any more PNG decompression setup */
  if ((ifp = fopen(name, "rb")) == NULL) 
    return IMAGEBADFILE; /* Could not open image, return error */

  /* Set error handling for setjmp/longjmp method of libpng error handling */
  if (setjmp(png_jmpbuf(png_ptr))) {
    /* Free all of the memory associated with the png_ptr and info_ptr */
    png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
    /* If we get here, we had a problem reading the file */
    fclose(ifp);
    return IMAGEBADFILE; /* Could not open image, return error */
  }

  /* Set up the input control if you are using standard C streams */
  png_init_io(png_ptr, ifp);

  /* one-shot call to read the whole PNG file into memory */
  png_read_png(png_ptr, info_ptr,
    PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_PACKING | PNG_TRANSFORM_STRIP_ALPHA,
    NULL);
  *xres = png_get_image_width(png_ptr, info_ptr);
  *yres = png_get_image_height(png_ptr, info_ptr);

  /* copy pixel data into our own data structures */
  row_pointers = png_get_rows(png_ptr, info_ptr); 
 
  *imgdata = (unsigned char *) malloc(3 * (*xres) * (*yres));
  if ((*imgdata) == NULL) {
    return IMAGEALLOCERR;
  }

  for (y=0; y<(*yres); y++) { 
    unsigned char *img = &(*imgdata)[(y * (*xres) * 3)];
    for (x=0; x<(*xres); x++) { 
      img[(x*3)    ] = row_pointers[(*yres) - y - 1][x    ]; 
      img[(x*3) + 1] = row_pointers[(*yres) - y - 1][x + 1]; 
      img[(x*3) + 2] = row_pointers[(*yres) - y - 1][x + 2]; 
    }
  }

  /* clean up after the read, and free any memory allocated - REQUIRED */
  png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);

  fclose(ifp); /* Close the input file */

  return IMAGENOERR;  /* No fatal errors */
}


int writepng(char * name, int xres, int yres, unsigned char *imgdata) {
  FILE *ofp;
  png_structp png_ptr;
  png_infop info_ptr;
  png_bytep *row_pointers;
  png_textp text_ptr;
  int y;

  /* Create and initialize the png_struct with the default error handlers */
  png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
  if (png_ptr == NULL) {
    return IMAGEALLOCERR; /* Could not initialize PNG library, return error */
  }

  /* Allocate/initialize the memory for image information.  REQUIRED. */
  info_ptr = png_create_info_struct(png_ptr);
  if (info_ptr == NULL) {
    png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
    return IMAGEALLOCERR; /* Could not initialize PNG library, return error */
  }

  /* open output file before doing any more PNG compression setup */
  if ((ofp = fopen(name, "wb")) == NULL) {
    return IMAGEBADFILE;
  }

  /* Set error handling for setjmp/longjmp method of libpng error handling */
  if (setjmp(png_jmpbuf(png_ptr))) {
    /* Free all of the memory associated with the png_ptr and info_ptr */
    png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
    /* If we get here, we had a problem writing the file */
    fclose(ofp);
    return IMAGEBADFILE; /* Could not open image, return error */
  }

  /* Set up the input control if you are using standard C streams */
  png_init_io(png_ptr, ofp);

  png_set_IHDR(png_ptr, info_ptr, xres, yres, 
               8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, 
               PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);

  png_set_gAMA(png_ptr, info_ptr, 1.0);

  text_ptr = (png_textp) png_malloc(png_ptr, (png_uint_32)sizeof(png_text) * 2);
   
  text_ptr[0].key = "Description";
  text_ptr[0].text = "A scene rendered by the Tachyon ray tracer";
  text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE; 
#ifdef PNG_iTXt_SUPPORTED
  text_ptr[0].lang = NULL;
#endif

  text_ptr[1].key = "Software";
  text_ptr[1].text = "Tachyon Parallel/Multiprocessor Ray Tracer";
  text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE; 
#ifdef PNG_iTXt_SUPPORTED
  text_ptr[1].lang = NULL;
#endif
  png_set_text(png_ptr, info_ptr, text_ptr, 1);

  row_pointers = png_malloc(png_ptr, yres*sizeof(png_bytep));
  for (y=0; y<yres; y++) {
    row_pointers[yres - y - 1] = &imgdata[y * xres * 3];
  }

  png_set_rows(png_ptr, info_ptr, row_pointers); 

  /* one-shot call to write the whole PNG file into memory */
  png_write_png(png_ptr, info_ptr, PNG_TRANSFORM_IDENTITY, NULL);

  png_free(png_ptr, row_pointers);
  png_free(png_ptr, text_ptr);
 
  /* clean up after the write and free any memory allocated - REQUIRED */
  png_destroy_write_struct(&png_ptr, (png_infopp)NULL);

  fclose(ofp); /* close the output file */

  return IMAGENOERR; /* No fatal errors */
}

#endif
/*
 *  pngfile.h - This file deals with PNG format image files (reading/writing)
 *
 *  $Id: pngfile.h,v 1.1 2001/02/26 18:26:00 johns Exp $
 */ 

int readpng(char * name, int * xres, int * yres, unsigned char **imgdata);
int writepng(char * name, int xres, int yres, unsigned char *imgdata);
/*
 *  ppm.c - This file deals with PPM format image files (reading/writing)
 *
 *  $Id: ppm.c,v 1.14 1999/09/01 20:16:08 johns Exp $
 */ 

/* For our puposes, we're interested only in the 3 byte per pixel 24 bit
   truecolor sort of file..  Probably won't implement any decent checking
   at this point, probably choke on things like the # comments.. */

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h" /* error codes etc */
#include "ppm.h"

static int getint(FILE * dfile) {
  char ch[200];
  int i;
  int num;

  num=0; 
  while (num==0) {
    fscanf(dfile, "%s", ch);
      while (ch[0]=='#') {
        fgets(ch, 200, dfile);
      }
    num=sscanf(ch, "%d", &i);
  }
  return i;
}

int readppm(char * name, int * xres, int * yres, unsigned char **imgdata) {
  char data[200];  
  FILE * ifp;
  int i, bytesread;
  int datasize;
 
  ifp=fopen(name, "r");  
  if (ifp==NULL) {
    return IMAGEBADFILE; /* couldn't open the file */
  }
  fscanf(ifp, "%s", data);
 
  if (strcmp(data, "P6")) {
     fclose(ifp);
     return IMAGEUNSUP; /* not a format we support */
  }

  *xres=getint(ifp);
  *yres=getint(ifp);
      i=getint(ifp); /* eat the maxval number */
  fread(&i, 1, 1, ifp); /* eat the newline */ 
  datasize = 3 * (*xres) * (*yres);

  *imgdata=malloc(datasize); 

  bytesread=fread(*imgdata, 1, datasize, ifp);   

  fclose(ifp);

  if (bytesread != datasize) 
    return IMAGEREADERR;
  
  return IMAGENOERR;
}

int writeppm(char *name, int xres, int yres, unsigned char *imgdata) {
  FILE * ofp;
  int i;
 
  ofp=fopen(name, "wb");
  if (ofp==NULL) {
    return IMAGEBADFILE;
  }

  fprintf(ofp, "P6\n");
  fprintf(ofp, "%d %d\n", xres, yres);
  fprintf(ofp, "255\n"); /* maxval */

  for (i=0; i<yres; i++) {
    fwrite(&imgdata[(yres - i - 1)*3*xres], 1, (3*xres), ofp);
  }

  fclose(ofp);

  return IMAGENOERR;
}

/*
 *  ppm.h - This file deals with PPM format image files (reading/writing)
 *
 *  $Id: ppm.h,v 1.4 1999/09/01 16:20:47 johns Exp $
 */ 

/* For our puposes, we're interested only in the 3 byte per pixel 24 bit
   truecolor sort of file..  Probably won't implement any decent checking
   at this point, probably choke on things like the # comments.. */

int readppm(char * name, int * xres, int * yres, unsigned char **imgdata);
int writeppm(char *name, int xres, int yres, unsigned char *imgdata);
/* 
 * quadric.c - This file contains the functions for dealing with quadrics.
 *
 *  $Id: quadric.c,v 1.21 2002/07/09 16:14:31 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "quadric.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

int quadric_bbox(void * obj, vector * min, vector * max) {
  return 0;
}

static object_methods quadric_methods = {
  (void (*)(const void *, void *))(quadric_intersect),
  (void (*)(const void *, const void *, const void *, void *))(quadric_normal),
  quadric_bbox, 
  free 
};
 
quadric * newquadric(void) {
  quadric * q;
 
  q=(quadric *) malloc(sizeof(quadric));
  memset(q, 0, sizeof(quadric));
  q->ctr.x=0.0;
  q->ctr.y=0.0;
  q->ctr.z=0.0;
  q->methods = &quadric_methods;
 
  return q;
}

void quadric_intersect(const quadric * q, ray * ry) {
  flt Aq, Bq, Cq;
  flt t1, t2;
  flt disc;
  vector rd;
  vector ro;
 
  rd=ry->d;
  VNorm(&rd);

  ro.x =  ry->o.x - q->ctr.x;
  ro.y =  ry->o.y - q->ctr.y;
  ro.z =  ry->o.z - q->ctr.z;


  Aq = (q->mat.a*(rd.x * rd.x)) +
        (2.0 * q->mat.b * rd.x * rd.y) +
        (2.0 * q->mat.c * rd.x * rd.z) +
        (q->mat.e * (rd.y * rd.y)) +
        (2.0 * q->mat.f * rd.y * rd.z) +
        (q->mat.h * (rd.z * rd.z));

  Bq = 2.0 * (
        (q->mat.a * ro.x * rd.x) +
        (q->mat.b * ((ro.x * rd.y) + (rd.x * ro.y))) +
        (q->mat.c * ((ro.x * rd.z) + (rd.x * ro.z))) +
        (q->mat.d * rd.x) +
        (q->mat.e * ro.y * rd.y) +
        (q->mat.f * ((ro.y * rd.z) + (rd.y * ro.z))) +
        (q->mat.g * rd.y) +
        (q->mat.h * ro.z * rd.z) +
        (q->mat.i * rd.z)
        );

  Cq = (q->mat.a * (ro.x * ro.x)) +
        (2.0 * q->mat.b * ro.x * ro.y) +
        (2.0 * q->mat.c * ro.x * ro.z) +
        (2.0 * q->mat.d * ro.x) +
        (q->mat.e * (ro.y * ro.y)) +
        (2.0 * q->mat.f * ro.y * ro.z) +
        (2.0 * q->mat.g * ro.y) +
        (q->mat.h * (ro.z * ro.z)) +
        (2.0 * q->mat.i * ro.z) +
        q->mat.j;

  if (Aq == 0.0) {
          t1 = - Cq / Bq;
          ry->add_intersection(t1, (object *) q, ry);
          }
  else {
    disc=(Bq*Bq - 4.0 * Aq * Cq);
    if (disc > 0.0) {
          disc=sqrt(disc);
          t1 = (-Bq + disc) / (2.0 * Aq);
          t2 = (-Bq - disc) / (2.0 * Aq);
          ry->add_intersection(t1, (object *) q, ry);
          ry->add_intersection(t2, (object *) q, ry); 
          }
  }
}

void quadric_normal(const quadric * q, const vector * pnt, const ray * incident, vector * N) {
  flt len;

  N->x = (q->mat.a*(pnt->x - q->ctr.x) + 
	  q->mat.b*(pnt->y - q->ctr.y) + 
	  q->mat.c*(pnt->z - q->ctr.z) + q->mat.d);

  N->y = (q->mat.b*(pnt->x - q->ctr.x) + 
	  q->mat.e*(pnt->y - q->ctr.y) + 
	  q->mat.f*(pnt->z - q->ctr.z) + q->mat.g);

  N->z = (q->mat.c*(pnt->x - q->ctr.x) + 
	  q->mat.f*(pnt->y - q->ctr.y) + 
	  q->mat.h*(pnt->z - q->ctr.z) + q->mat.i);

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}
 

/* 
 * quadric.h - This file contains the defines for quadrics.
 *
 *  $Id: quadric.h,v 1.11 2002/08/04 21:43:34 johns Exp $
 */

typedef struct {
  flt a; flt b; flt c;
  flt d; flt e; flt f;
  flt g; flt h; flt i; flt j;
} quadmatrix;

 
typedef struct {
  RT_OBJECT_HEAD
  vector ctr;
  quadmatrix mat;
} quadric; 


quadric * newquadric(void);
void quadric_intersect(const quadric *, ray *);
void quadric_normal(const quadric *, const vector *, const ray *, vector *);



/* 
 * render.c - This file contains the main program and driver for the raytracer.
 *
 *  $Id: render.c,v 1.98 2002/08/05 05:27:46 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "threads.h"
#include "parallel.h"
#include "imageio.h"
#include "trace.h"
#include "render.h"
#include "util.h"
#include "shade.h"
#include "ui.h"
#include "grid.h"
#include "camera.h"
#include "intersect.h"

/*
 * Determine which shader to use based on the list of capabilities
 * needed to render the scene at full quality.  Ideally we'll avoid
 * using anything more sophisticated than is actually needed to render
 * a scene.
 */
static void rt_autoshader(scenedef * scene) {
  /* 
   * If the user has already specified a particular shader
   * then we use what they asked for, otherwise we determine
   * which shader to use ourselves.
   */
  if (scene->shader == NULL) {
    /* No logic yet, just use max quality */
    scene->shader = (color (*)(void *)) full_shader;
  }
}


void * thread_slave(void * voidparms) {
  thr_parms * parms = (thr_parms *) voidparms;

  /*  while (rt_thread_barrier(parms->runbar, 0)) {*/
    thread_trace(parms);
    /*}*/
  return NULL;
}


void create_render_threads(scenedef * scene) {
  thr_parms * parms;
  rt_thread_t * threads;
  rt_barrier_t * bar;
  int thr;

  /* allocate and initialize thread parameter buffers */
  threads = (rt_thread_t *) malloc(scene->numthreads * sizeof(rt_thread_t));
  parms = (thr_parms *) malloc(scene->numthreads * sizeof(thr_parms));

  bar = NULL; /*rt_thread_barrier_init(scene->numthreads);*/

  for (thr=0; thr<scene->numthreads; thr++) {
    parms[thr].tid=thr;
    parms[thr].nthr=scene->numthreads;
    parms[thr].scene=scene;

    /* the sizes of these arrays are padded to avoid cache aliasing */
    /* and false sharing between threads.                           */
    parms[thr].local_mbox = 
#if !defined(DISABLEMBOX)
      (unsigned long *) calloc(sizeof(unsigned long)*scene->objgroup.numobjects + 32, 1);
#else
      NULL;
#endif

    parms[thr].serialno = 1;
    parms[thr].runbar = bar;

    if (scene->nodes == 1) {
      parms[thr].startx = 1;
      parms[thr].stopx  = scene->hres;
      parms[thr].xinc   = 1;
      parms[thr].starty = thr + 1;
      parms[thr].stopy=scene->vres;
      parms[thr].yinc = scene->numthreads;
    }
    else {
      parms[thr].startx = thr + 1;
      parms[thr].stopx  = scene->hres;
      parms[thr].xinc   = scene->numthreads;
      parms[thr].starty = scene->mynode + 1;
      parms[thr].stopy  = scene->vres;
      parms[thr].yinc   = scene->nodes;
    }
  }

  scene->threadparms = (void *) parms;
  scene->threads = (void *) threads;

  /*  for (thr=1; thr < scene->numthreads; thr++) {
    thr_parms * dummy_parms;
    rt_thread_t * dummy_threads;*/
    /*    rt_thread_create(&threads[thr], thread_slave, (void *) (&parms[thr]));*/
  /*    dummy_parms = (thr_parms *) scene->threadparms;
    dummy_threads = (rt_thread_t *) scene->threads;
    rt_thread_create(&dummy_threads[thr], thread_slave, (void *) (&dummy_parms[thr]));
    }*/

}



void destroy_render_threads(scenedef * scene) {
  thr_parms * parms = (thr_parms *) scene->threadparms;
  rt_thread_t * threads = (rt_thread_t *) scene->threads;
  int thr;

  if (scene->threads != NULL) {
    /* wake up sleepers and tell them to exit */
    /*rt_thread_barrier(parms[0].runbar, 0); */

    /* wait for all sleepers to exit */
    for (thr=1; thr<parms[0].nthr; thr++) 
      rt_thread_join(threads[thr], NULL);
  
    /* destroy the thread barrier */
    /*rt_thread_barrier_destroy(parms[0].runbar);*/

    free(scene->threads);
  }

  if (scene->threadparms != NULL) {
    /* deallocate thread parameter buffers 
     * NOTE: This has to use the remembered number of threads stored in the
     *       thread parameter area for thread 0, since the one in the scene
     *       may have changed on us.
     */
    for (thr=0; thr < parms[0].nthr; thr++) {
      if (parms[thr].local_mbox != NULL) 
        free(parms[thr].local_mbox);
    }

    free(scene->threadparms);
  }

  scene->threads = NULL;
  scene->threadparms = NULL;
}



static void rendercheck(scenedef * scene) {
  flt runtime;
  rt_timerhandle stth; /* setup time timer handle */

  if (scene->verbosemode && scene->mynode == 0) {
    char msgtxt[1024];
    int i, totalcpus;
    flt totalspeed;

    rt_ui_message(MSG_0, "CPU Information:");

    totalspeed = 0.0;
    totalcpus = 0;
    for (i=0; i<scene->nodes; i++) {
      sprintf(msgtxt,
            "  Node %4d: %2d CPUs, CPU Speed %4.2f, Node Speed %6.2f Name: %s",
            i, scene->cpuinfo[i].numcpus, scene->cpuinfo[i].cpuspeed,
            scene->cpuinfo[i].nodespeed, scene->cpuinfo[i].machname);
      rt_ui_message(MSG_0, msgtxt);

      totalcpus += scene->cpuinfo[i].numcpus;
      totalspeed += scene->cpuinfo[i].nodespeed;
    }

    sprintf(msgtxt, "  Total CPUs: %d", totalcpus);
    rt_ui_message(MSG_0, msgtxt);
    sprintf(msgtxt, "  Total Speed: %f\n", totalspeed);
    rt_ui_message(MSG_0, msgtxt);
  }

  rt_barrier_sync();     /* synchronize all nodes at this point             */
  stth=rt_timer_create();
  rt_timer_start(stth);  /* Time the preprocessing of the scene database    */
  rt_autoshader(scene);  /* Adapt to the shading features needed at runtime */

  /* Hierarchical grid ray tracing acceleration scheme */
  if (scene->boundmode == RT_BOUNDING_ENABLED) 
    engrid_scene(scene, scene->boundthresh); 

  /* if there was a preexisting image, free it before continuing */
  if (scene->imginternal && (scene->img != NULL)) {
    free(scene->img);
    scene->img = NULL;
  }

  /* Allocate a new image buffer if necessary */
  if (scene->img == NULL) {
    scene->imginternal = 1;
    if (scene->verbosemode && scene->mynode == 0) { 
      rt_ui_message(MSG_0, "Allocating Image Buffer."); 
    }
    scene->img = (unsigned char *) malloc(scene->hres * scene->vres * 3);
    if (scene->img == NULL) {
      scene->imginternal = 0;
      rt_ui_message(MSG_0, "Warning: Failed To Allocate Image Buffer!"); 
    } 
  }

  /* if any threads are leftover from a previous scene, and the  */
  /* scene has changed significantly, we have to collect, and    */
  /* respawn the worker threads, since lots of things may have   */
  /* changed which would affect them.                            */
  destroy_render_threads(scene);
  create_render_threads(scene);

  /* allocate and initialize persistent scanline receive buffers */
  /* which are used by the parallel message passing code.        */
  scene->parbuf = rt_init_scanlinereceives(scene);

  /* the scene has been successfully prepared for rendering      */
  /* unless it gets modified in certain ways, we don't need to   */
  /* pre-process it ever again.                                  */
  scene->scenecheck = 0;

  rt_timer_stop(stth); /* Preprocessing is finished, stop timing */
  runtime=rt_timer_time(stth);   
  rt_timer_destroy(stth);

  /* Print out relevent timing info */
  if (scene->mynode == 0) {
    char msgtxt[256];
    sprintf(msgtxt, "Preprocessing Time: %10.4f seconds",runtime);
    rt_ui_message(MSG_0, msgtxt);
  }
}


static void renderio(scenedef * scene) {
  flt iotime;
  char msgtxt[256];
  rt_timerhandle ioth; /* I/O timer handle */

  ioth=rt_timer_create();
  rt_timer_start(ioth);
 
  writeimage(scene->outfilename, scene->hres, scene->vres, 
             scene->img, scene->imgformat);

  rt_timer_stop(ioth);
  iotime = rt_timer_time(ioth);
  rt_timer_destroy(ioth);

  sprintf(msgtxt, "    Image I/O Time: %10.4f seconds", iotime);
  rt_ui_message(MSG_0, msgtxt);
}


void renderscene(scenedef * scene) {
  flt runtime;
  rt_timerhandle rtth; /* render time timer handle */
  int thr;
  thr_parms * dummy_parms;
  rt_thread_t * dummy_threads;
  int status;

  /* if certain key aspects of the scene parameters have been changed */
  /* since the last frame rendered, or when rendering the scene the   */
  /* first time, various setup, initialization and memory allocation  */
  /* routines need to be run in order to prepare for rendering.       */
  if (scene->scenecheck)
    rendercheck(scene);

  if (scene->mynode == 0) 
    rt_ui_progress(0);     /* print 0% progress at start of rendering */


  /* 
   * Core Ray Tracing Code
   *
   * Ideally, as little as possible other than this code should be
   * executed for rendering a frame.  Most if not all memory allocations
   * should be done outside of the core code, and all setup should be
   * done outside of here.  This will give the best speed when rendering
   * walk-throughs and similar things.  
   */

  rtth=rt_timer_create();  /* create/init rendering timer              */
  rt_timer_start(rtth);    /* start ray tracing timer                  */

  camera_init(scene);      /* Initialize all aspects of camera system  */

#ifdef THR
  /* if using threads, wake up the child threads...  */
  /*rt_thread_barrier(((thr_parms *) scene->threadparms)[0].runbar, 1);*/
#endif

#ifdef MPI
  /* if using message passing, start persistent receives */
  rt_start_scanlinereceives(scene->parbuf); /* start scanline receives */
#endif
  

  /*** FORK_CODE ****/
  
  dummy_parms= (thr_parms *) scene->threadparms;
  dummy_threads= (rt_thread_t *) scene->threads;
  
  for (thr=1; thr < scene->numthreads; thr++) {
/*    rt_thread_create(&dummy_threads[thr], thread_slave, (void *) (&dummy_parms[thr])); */
  /*******************/


    int pid = fork();

    if (pid ==0) { /* a child */
	  thread_trace(&((thr_parms *) scene->threadparms)[thr]);
      		exit(0);
    }


  }


  /* Actually Ray Trace The Image */
  thread_trace(&((thr_parms *) scene->threadparms)[0]);

#ifdef MPI
  rt_waitscanlines(scene->parbuf);  /* wait for all scanlines to recv/send  */
#endif

#ifndef RSIM
  /****** JOIN_CODE *****/
  for (thr=1; thr < scene->numthreads; thr++) {
    status = rt_thread_join(dummy_threads[thr], NULL);
    if (status)
      printf("bad thread join %d\n",thr);
  }
  /***********************/
#else
    ThreadJoin();
#endif
  
  rt_timer_stop(rtth);              /* stop timer for ray tracing runtime   */
  runtime=rt_timer_time(rtth);
  rt_timer_destroy(rtth);

  /*
   * End of Core Ray Tracing Code
   *
   * Anything after here should be UI, tear-down, or reset code 
   *
   */

  if (scene->mynode == 0) {
    char msgtxt[256];

    rt_ui_progress(100); /* print 100% progress when finished rendering */

    sprintf(msgtxt, "\n  Ray Tracing Time: %10.4f seconds", runtime);
    rt_ui_message(MSG_0, msgtxt);
 
    if (scene->writeimagefile) 
      renderio(scene);
  }
} /* end of renderscene() */

/*
 * render.h - This file contains the defines for the top level functions 
 *
 *  $Id: render.h,v 1.4 1998/07/26 06:43:09 johns Exp $
 */

void create_render_threads(scenedef * scene);
void destroy_render_threads(scenedef * scene);
void renderscene(scenedef *); 

/* 
 * ring.c - This file contains the functions for dealing with rings.
 *
 *  $Id: ring.c,v 1.18 2002/07/09 16:14:31 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

#define RING_PRIVATE
#include "ring.h"

static object_methods ring_methods = {
  (void (*)(const void *, void *))(ring_intersect),
  (void (*)(const void *, const void *, const void *, void *))(ring_normal),
  ring_bbox, 
  free 
};

object * newring(void * tex, vector ctr, vector norm, flt inrad, flt outrad) {
  ring * r;
  
  r=(ring *) malloc(sizeof(ring));
  memset(r, 0, sizeof(ring));
  r->methods = &ring_methods;

  r->tex = tex;
  r->ctr = ctr;
  r->norm = norm;
  VNorm(&r->norm);
  r->inrad = inrad;
  r->outrad= outrad;

  return (object *) r;
}

static int ring_bbox(void * obj, vector * min, vector * max) {
  ring * r = (ring *) obj;

  min->x = r->ctr.x - r->outrad;
  min->y = r->ctr.y - r->outrad;
  min->z = r->ctr.z - r->outrad;
  max->x = r->ctr.x + r->outrad;
  max->y = r->ctr.y + r->outrad;
  max->z = r->ctr.z + r->outrad;

  return 1;
}

static void ring_intersect(const ring * rng, ray * ry) {
  flt d;
  flt t,td;
  vector hit, pnt;
  
  d = -VDot(&(rng->ctr), &(rng->norm));
   
  t=-(d+VDot(&(rng->norm), &(ry->o)));
  td=VDot(&(rng->norm),&(ry->d)); 
  if (td != 0.0) {
    t= t / td;
    if (t>=0.0) {
      hit=Raypnt(ry, t);
      VSUB(hit, rng->ctr, pnt);
      VDOT(td, pnt, pnt);
      td=sqrt(td);
      if ((td > rng->inrad) && (td < rng->outrad)) 
        ry->add_intersection(t,(object *) rng, ry);
    }
  }
}

static void ring_normal(const ring * rng, const vector * pnt, const ray * incident, vector * N) {
  *N=rng->norm;
}

/* 
 * ring.h - This file contains the defines for rings etc.
 *
 *  $Id: ring.h,v 1.10 2002/08/04 21:43:34 johns Exp $
 */

object * newring(void * tex, vector ctr, vector norm, flt in, flt out);

#ifdef RING_PRIVATE 
typedef struct {
  RT_OBJECT_HEAD
  vector ctr;
  vector norm;
  flt inrad;
  flt outrad;
} ring; 

static int ring_bbox(void * obj, vector * min, vector * max);
static void ring_intersect(const ring *, ray *);
static void ring_normal(const ring *, const vector *, const ray * incident, vector *);
#endif

/*
 * rtcommon.h - This file contains common defines typedefs used by various
 *   parts of the raytracer and it interfaces
 *
 * $Id: rtcommon.h,v 1.12 2004/02/03 03:01:40 johns Exp $
 *
 */ 

#include "util.h"    /* rt_timer_xxx() and rt_rand() */
#include "hash.h"    /* rt_hash_xxx() */

/*
 * Tachyon version strings for feature detection and compatibility testing.
 */
#define TACHYON_VERSION_STRING      "0.96"
#define TACHYON_MAJOR_VERSION       0
#define TACHYON_MINOR_VERSION       96
#define TACHYON_PATCH_VERSION       0

/* 
 * Build the ray tracer and its interfaces using either doubles or floats
 * based on compile time defition of USESINGLEFLT
 */
#ifdef USESINGLEFLT
typedef float flt;   /* generic floating point number, using float  */
typedef flt apiflt;  /* generic floating point number, using float  */
#else
typedef double flt;  /* generic floating point number, using double */
typedef flt apiflt;  /* generic floating point number, using double */
#endif


/*
 * Parameter values for rt_boundmode()
 */
#define RT_BOUNDING_DISABLED 0  /* spatial subdivision/bounding disabled */
#define RT_BOUNDING_ENABLED  1  /* spatial subdivision/bounding enabled  */


/*
 * Parameter values for rt_camera_projection()
 */
#define RT_PROJECTION_PERSPECTIVE      0
#define RT_PROJECTION_ORTHOGRAPHIC     1
#define RT_PROJECTION_PERSPECTIVE_DOF  2
#define RT_PROJECTION_FISHEYE          3

/* 
 * Fog modes
 */
#define RT_FOG_NONE       0 /* no fog                                 */ 
#define RT_FOG_LINEAR     1 /* linear fog                             */
#define RT_FOG_EXP        2 /* exponential fog                        */
#define RT_FOG_EXP2       3 /* exponential-squared fog                */

/* 
 * Transparency modes
 */
#define RT_TRANS_ORIG     0 /* original transparency mode               */
#define RT_TRANS_VMD      1 /* mult shaded color by opacity, for VMD    */

/*
 * Shader Modes for rt_shadermode()
 *
 * These are sorted from lowest quality (and fastest execution)
 * to highest quality (and slowest execution)
 */
#define RT_SHADER_AUTO    0  /* Automatically determine shader needed */
#define RT_SHADER_LOWEST  1  /* lowest quality shading available      */
#define RT_SHADER_LOW     2  /* low quality shading                   */
#define RT_SHADER_MEDIUM  3  /* Medium quality shading                */
#define RT_SHADER_HIGH    4  /* High quality shading                  */
#define RT_SHADER_FULL    5  /* Highest quality shading available     */

/*
 * Shader modes for rt_phong_shader()
 */
#define RT_SHADER_NULL_PHONG 0 /* Disable phong contributions               */
#define RT_SHADER_BLINN_FAST 1 /* Fast version of Blinn's equation          */
#define RT_SHADER_BLINN      2 /* Blinn's specular highlights, as in OpenGL */
#define RT_SHADER_PHONG      3 /* Phong specular highlights                 */

/*
 * Shader capability flags - sorted by relative execution cost.
 *
 * Used to automatically setup the fastest shader that supports
 * all of the capabilities used in a given scene.
 * Ideally, we use the shader that just has the features we need,
 * and nothing more, but its impractical to have that many seperate
 * shaders, each optimized for an exact set of features, but we
 * do the best we can with a reasonable amount of code.
 */
#define RT_SHADE_LIGHTING               1  /* need lighting                */
#define RT_SHADE_PHONG                  2  /* need phong shading           */
#define RT_SHADE_TEXTURE_MAPS           4  /* need texture mapping         */
#define RT_SHADE_MIPMAP                 8  /* need mip-maps                */
#define RT_SHADE_REFLECTION            16  /* need reflections             */
#define RT_SHADE_REFRACTION            32  /* need refraction              */
#define RT_SHADE_SHADOWS               64  /* need shadows                 */
#define RT_SHADE_VOLUMETRIC           128  /* need volume rendering        */
#define RT_SHADE_ANTIALIASING         256  /* need antialiasing            */
#define RT_SHADE_DEPTH_OF_FIELD       512  /* need depth of field          */
#define RT_SHADE_SOFT_SHADOW         1024  /* need soft-shadows/penumbra   */
#define RT_SHADE_VOLUMETRIC_SHADOW   2048  /* need volumetric shadows      */



/* 
 * Texture mapping types
 */
#define RT_TEXTURE_CONSTANT             0
#define RT_TEXTURE_3D_CHECKER           1
#define RT_TEXTURE_GRIT                 2
#define RT_TEXTURE_MARBLE               3
#define RT_TEXTURE_WOOD                 4
#define RT_TEXTURE_GRADIENT             5
#define RT_TEXTURE_CYLINDRICAL_CHECKER  6
#define RT_TEXTURE_CYLINDRICAL_IMAGE    7
#define RT_TEXTURE_SPHERICAL_IMAGE      8
#define RT_TEXTURE_PLANAR_IMAGE         9


/*
 * Phong types
 */
#define RT_PHONG_PLASTIC                0
#define RT_PHONG_METAL                  1


/*
 * Supported output file formats list.
 */
#define RT_FORMAT_TARGA                 0
#define RT_FORMAT_PPM                   1
#define RT_FORMAT_SGIRGB                2
#define RT_FORMAT_JPEG                  3
#define RT_FORMAT_WINBMP                4
#define RT_FORMAT_PNG                   5



/*
 *  sgirgb.h - This file deals with SGI RGB format image files (reading/writing)
 *
 *  $Id: sgirgb.c,v 1.3 2000/08/16 19:01:15 johns Exp $
 */ 

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h" /* error codes etc */
#include "sgirgb.h"

static void putbyte(FILE * outf, unsigned char val) {
  unsigned char buf[1];
  buf[0] = val;
  fwrite(buf, 1, 1, outf);
}

static void putshort(FILE * outf, unsigned short val) {
  unsigned char buf[2];
  buf[0] = val >> 8;
  buf[1] = val & 0xff;
  fwrite(buf, 2, 1, outf);
}

static void putint(FILE * outf, unsigned int val) {
  unsigned char buf[4];
  buf[0] = (unsigned char) (val >> 24);
  buf[1] = (unsigned char) (val >> 16);
  buf[2] = (unsigned char) (val >>  8);
  buf[3] = (unsigned char) (val & 0xff);
  fwrite(buf, 4, 1, outf);
}

int writergb(char *name, int xres, int yres, unsigned char *imgdata) {
  FILE * ofp;
  char iname[80];               /* Image name */
  int x, y, i;

  if ((ofp = fopen(name, "wb")) != NULL) {
    putshort(ofp, 474);         /* Magic                       */
    putbyte(ofp, 0);            /* STORAGE is VERBATIM         */
    putbyte(ofp, 1);            /* BPC is 1                    */
    putshort(ofp, 3);           /* DIMENSION is 3              */
    putshort(ofp, (unsigned short) xres);        /* XSIZE      */
    putshort(ofp, (unsigned short) yres);        /* YSIZE      */
    putshort(ofp, 3);           /* ZSIZE                       */
    putint(ofp, 0);             /* PIXMIN is 0                 */
    putint(ofp, 255);           /* PIXMAX is 255               */

    for(i=0; i<4; i++)          /* DUMMY 4 bytes               */
      putbyte(ofp, 0);

    strcpy(iname, "Tachyon Ray Tracer Image");
    fwrite(iname, 80, 1, ofp);  /* IMAGENAME                   */
    putint(ofp, 0);             /* COLORMAP is 0               */

    for(i=0; i<404; i++)        /* DUMMY 404 bytes             */
      putbyte(ofp,0);

    for(i=0; i<3; i++)
      for(y=0; y<yres; y++)
        for(x=0; x<xres; x++)
          fwrite(&imgdata[(y*xres + x)*3 + i], 1, 1, ofp);

    fclose(ofp);
  }

  return IMAGENOERR;
}

/*
 *  sgirgb.h - This file deals with SGI RGB format image files (reading/writing)
 *
 *  $Id: sgirgb.h,v 1.1 1999/09/01 16:26:14 johns Exp $
 */ 

int writergb(char *name, int xres, int yres, unsigned char *imgdata);
/* 
 * shade.c - This file contains the functions that perform surface shading.
 *
 *  $Id: shade.c,v 1.82 2004/02/03 06:00:39 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "threads.h"
#include "light.h"
#include "intersect.h"
#include "vector.h"
#include "trace.h"
#include "shade.h"


/*
 * Lowest Quality Shader - Returns the raw color of an object.
 *
 */

color lowest_shader(ray * incident) {
  int numints;
  object const * obj;
  flt t = FHUGE;
  color col;

  numints=closest_intersection(&t, &obj, incident);
                /* find the number of intersections */
                /* and return the closest one.      */

  if (numints < 1) {
    /* if there weren't any object intersections then return the */
    /* background color for the pixel color.                     */
    return incident->scene->background;
  }

  col.r = 1.0;
  col.g = 1.0;
  col.b = 1.0;

  return col;
}


/*
 * Low Quality Shader - Returns raw texture color of objects hit, nothing else.
 *
 */

color low_shader(ray * incident) {
  int numints;
  object const * obj;
  vector hit;
  flt t = FHUGE;

  numints=closest_intersection(&t, &obj, incident);
                /* find the number of intersections */
                /* and return the closest one.      */

  if (numints < 1) {
    /* if there weren't any object intersections then return the */
    /* background color for the pixel color.                     */
    return incident->scene->background;
  }

  RAYPNT(hit, (*incident), t) /* find the point of intersection from t */
  incident->opticdist = FHUGE; 
  return obj->tex->texfunc(&hit, obj->tex, incident);
}



/*
 * Medium Quality Shader - Includes a subset of the rendering features
 *
 */

color medium_shader(ray * incident) {
  color col, diffuse, phongcol; 
  shadedata shadevars;
  flt inten;
  flt t = FHUGE;
  object const * obj;
  int numints;
  list * cur;

  numints=closest_intersection(&t, &obj, incident);  
		/* find the number of intersections */
                /* and return the closest one.      */

  if (numints < 1) {         
    /* if there weren't any object intersections then return the */
    /* background color for the pixel color.                     */
    col = incident->scene->background;

    /* calculate fog effects */
    if (incident->scene->fog.fog_fctn != NULL) {
      col = incident->scene->fog.fog_fctn(&incident->scene->fog, col, t);
    }

    return col;
  }

  RAYPNT(shadevars.hit, (*incident), t) /* find point of intersection from t */ 
  incident->opticdist += t;
  obj->methods->normal(obj, &shadevars.hit, incident, &shadevars.N);  /* find the surface normal */

  /* Flip surface normal to point toward the viewer if necessary */
  if (VDot(&shadevars.N, &(incident->d)) > 0.0) {
    shadevars.N.x=-shadevars.N.x;
    shadevars.N.y=-shadevars.N.y;
    shadevars.N.z=-shadevars.N.z;
  }

  /* execute the object's texture function */
  col = obj->tex->texfunc(&shadevars.hit, obj->tex, incident); 

  if (obj->tex->flags & RT_TEXTURE_ISLIGHT) {  
                  /* if the current object is a light, then we  */
    return col;   /* will only use the object's base color      */
  }

  diffuse.r = 0.0; 
  diffuse.g = 0.0; 
  diffuse.b = 0.0; 
  phongcol = diffuse;

  if ((obj->tex->diffuse > MINCONTRIB) || (obj->tex->phong > MINCONTRIB)) {  
    cur = incident->scene->lightlist;
    while (cur != NULL) {              /* loop for light contributions */
      light * li=(light *) cur->item;  /* set li=to the current light  */
      inten = li->shade_diffuse(li, &shadevars);

      /* add in diffuse lighting for this light if we're facing it */ 
      if (inten > MINCONTRIB) {            
        /* XXX now that opacity is in the code, have to be more careful */
        ColorAddS(&diffuse, &((standard_texture *)li->tex)->col, inten);

        /* phong type specular highlights */
        if (obj->tex->phong > MINCONTRIB) {
          flt phongval;
          phongval = incident->scene->phongfunc(incident, &shadevars, obj->tex->phongexp); 
          if (obj->tex->phongtype == RT_PHONG_METAL) 
            ColorAddS(&phongcol, &col, phongval * obj->tex->phong);
          else
            ColorAddS(&phongcol, &((standard_texture *)li->tex)->col, phongval * obj->tex->phong);
        }
      }  

      cur = cur->next;
    } 
  }

  ColorScale(&diffuse, obj->tex->diffuse);

  col.r *= (diffuse.r + obj->tex->ambient); /* do a product of the */
  col.g *= (diffuse.g + obj->tex->ambient); /* diffuse intensity with  */
  col.b *= (diffuse.b + obj->tex->ambient); /* object color + ambient  */

  if (obj->tex->phong > MINCONTRIB) {
    ColorAccum(&col, &phongcol);
  }

  /* spawn reflection rays if necessary */
  /* note: this will overwrite the old intersection list */
  if (obj->tex->specular > MINCONTRIB) {    
    color specol;
    specol = shade_reflection(incident, &shadevars, obj->tex->specular);
    ColorAccum(&col, &specol);
  }

  /* spawn transmission rays / refraction */
  /* note: this will overwrite the old intersection list */
  if (obj->tex->opacity < (1.0 - MINCONTRIB)) {      
    color transcol;
    transcol = shade_transmission(incident, &shadevars, 1.0 - obj->tex->opacity);
    if (incident->scene->transmode == RT_TRANS_VMD) 
      ColorScale(&col, obj->tex->opacity);

    ColorAccum(&col, &transcol);
  }

  /* calculate fog effects */
  if (incident->scene->fog.fog_fctn != NULL) {
    col = incident->scene->fog.fog_fctn(&incident->scene->fog, col, t);
  }

  return col;    /* return the color of the shaded pixel... */
}



/*
 * Full Quality Shader - Includes all possible rendering features
 *
 */

color full_shader(ray * incident) {
  color col, diffuse, phongcol; 
  shadedata shadevars;
  ray shadowray;
  flt inten;
  flt t = FHUGE;
  object const * obj;
  int numints;
  list * cur;

  numints=closest_intersection(&t, &obj, incident);  
		/* find the number of intersections */
                /* and return the closest one.      */

  if (numints < 1) {         
    /* if there weren't any object intersections then return the */
    /* background color for the pixel color.                     */
    col = incident->scene->background;

    /* calculate fog effects */
    if (incident->scene->fog.fog_fctn != NULL) {
      col = incident->scene->fog.fog_fctn(&incident->scene->fog, col, t);
    }

    return col;
  }

  RAYPNT(shadevars.hit, (*incident), t) /* find point of intersection from t */ 
  incident->opticdist += t;
  obj->methods->normal(obj, &shadevars.hit, incident, &shadevars.N);  /* find the surface normal */

  /* Flip surface normal to point toward the viewer if necessary */
  if (VDot(&shadevars.N, &(incident->d)) > 0.0) { 
    shadevars.N.x=-shadevars.N.x;
    shadevars.N.y=-shadevars.N.y;
    shadevars.N.z=-shadevars.N.z;
  }

  /* execute the object's texture function */
  col = obj->tex->texfunc(&shadevars.hit, obj->tex, incident); 

  if (obj->tex->flags & RT_TEXTURE_ISLIGHT) {  
                  /* if the current object is a light, then we  */
    return col;   /* will only use the object's base color      */
  }

  diffuse.r = 0.0; 
  diffuse.g = 0.0; 
  diffuse.b = 0.0; 
  phongcol = diffuse;

  if ((obj->tex->diffuse > MINCONTRIB) || (obj->tex->phong > MINCONTRIB)) {  
    cur = incident->scene->lightlist;
    while (cur != NULL) {              /* loop for light contributions */
      light * li=(light *) cur->item;  /* set li=to the current light  */
      inten = li->shade_diffuse(li, &shadevars);

      /* add in diffuse lighting for this light if we're facing it */ 
      if (inten > MINCONTRIB) {            
        /* test for a shadow */
        shadowray.o   = shadevars.hit;
        shadowray.d   = shadevars.L;      
        shadowray.maxdist = shadevars.Llen;
        shadowray.add_intersection = add_shadow_intersection;
        shadowray.flags = RT_RAY_SHADOW;
        incident->serial++;
        shadowray.serial = incident->serial;
        shadowray.mbox = incident->mbox;
        shadowray.scene = incident->scene;
        reset_intersection(&shadowray);
        intersect_objects(&shadowray);

        if (!shadow_intersection(&shadowray)) {
          /* XXX now that opacity is in the code, have to be more careful */
          ColorAddS(&diffuse, &((standard_texture *)li->tex)->col, inten);

          /* phong type specular highlights */
          if (obj->tex->phong > MINCONTRIB) {
            flt phongval;
            phongval = incident->scene->phongfunc(incident, &shadevars, obj->tex->phongexp); 
            if (obj->tex->phongtype == RT_PHONG_METAL) 
              ColorAddS(&phongcol, &col, phongval * obj->tex->phong);
            else
              ColorAddS(&phongcol, &((standard_texture *)li->tex)->col, phongval * obj->tex->phong);
          }
        }
      }  

      cur = cur->next;
    } 
  }

  ColorScale(&diffuse, obj->tex->diffuse);

  col.r *= (diffuse.r + obj->tex->ambient); /* do a product of the */
  col.g *= (diffuse.g + obj->tex->ambient); /* diffuse intensity with  */
  col.b *= (diffuse.b + obj->tex->ambient); /* object color + ambient  */

  if (obj->tex->phong > MINCONTRIB) {
    ColorAccum(&col, &phongcol);
  }

  /* spawn reflection rays if necessary */
  /* note: this will overwrite the old intersection list */
  if (obj->tex->specular > MINCONTRIB) {    
    color specol;
    specol = shade_reflection(incident, &shadevars, obj->tex->specular);
    ColorAccum(&col, &specol);
  }

  /* spawn transmission rays / refraction */
  /* note: this will overwrite the old intersection list */
  if (obj->tex->opacity < (1.0 - MINCONTRIB)) {      
    color transcol;
    transcol = shade_transmission(incident, &shadevars, 1.0 - obj->tex->opacity);
    if (incident->scene->transmode == RT_TRANS_VMD) 
      ColorScale(&col, obj->tex->opacity);

    ColorAccum(&col, &transcol);
  }

  /* calculate fog effects */
  if (incident->scene->fog.fog_fctn != NULL) {
    col = incident->scene->fog.fog_fctn(&incident->scene->fog, col, t);
  }

  return col;    /* return the color of the shaded pixel... */
}


color shade_reflection(ray * incident, const shadedata * shadevars, flt specular) {
  ray specray;
  color col;
  vector R;
 
  VAddS(-2.0 * (incident->d.x * shadevars->N.x + 
                incident->d.y * shadevars->N.y + 
                incident->d.z * shadevars->N.z), &shadevars->N, &incident->d, &R);

  specray.o=shadevars->hit; 
  specray.d=R;			       /* reflect incident ray about normal */
  specray.o=Raypnt(&specray, EPSILON); /* avoid numerical precision bugs */
  specray.maxdist = FHUGE;             /* take any intersection */
  specray.opticdist = incident->opticdist;
  specray.add_intersection=add_regular_intersection; /* ray type  */
  specray.depth=incident->depth - 1;   /* go up a level in recursion depth */
  specray.flags = RT_RAY_REGULAR;      /* infinite ray, to start with */
  specray.serial = incident->serial + 1; /* next serial number */
  specray.mbox = incident->mbox; 
  specray.scene=incident->scene;       /* global scenedef info */
  specray.randval=incident->randval;   /* random number seed */
  col=trace(&specray);                 /* trace specular reflection ray */ 

  incident->serial = specray.serial;    /* update the serial number */

  ColorScale(&col, specular);

  return col;
}


color shade_transmission(ray * incident, const shadedata * shadevars, flt trans) {
  ray transray;
  color col;

  transray.o=shadevars->hit; 
  transray.d=incident->d;                /* ray continues along incident path */
  transray.o=Raypnt(&transray, EPSILON); /* avoid numerical precision bugs */
  transray.maxdist = FHUGE;              /* take any intersection */
  transray.opticdist = incident->opticdist;
  transray.add_intersection=add_regular_intersection; /* ray type  */
  transray.depth=incident->depth - 1;    /* go up a level in recursion depth */
  transray.flags = RT_RAY_REGULAR;       /* infinite ray, to start with */
  transray.serial = incident->serial + 1; /* update serial number */
  transray.mbox = incident->mbox;
  transray.scene=incident->scene;        /* global scenedef info */
  transray.randval=incident->randval;    /* random number seed */
  col=trace(&transray);                  /* trace transmission ray */  

  incident->serial = transray.serial;

  ColorScale(&col, trans);

  return col;
}


/*
 * Phong shader, always returns 0.0, used for testing
 */
flt shade_nullphong(const ray * incident, const shadedata * shadevars, flt specpower) {
  return 0.0;
}

/*
 * Phong shader, implements specular highlight model
 * using Blinn's halfway vector dotted with the surface normal.
 * This is also the shading model used by OpenGL and Direct3D.
 */
flt shade_blinn(const ray * incident, const shadedata * shadevars, flt specpower) {
  vector H;   /* Blinn's halfway vector */
  flt inten;  /* calculated intensity   */

  /* since incident ray is negated direction to viewer, we subtract... */
  /* sub. incoming ray dir. from light direction */
  H.x = shadevars->L.x - incident->d.x; 
  H.y = shadevars->L.y - incident->d.y;
  H.z = shadevars->L.z - incident->d.z;

  inten = shadevars->N.x * H.x + shadevars->N.y * H.y + shadevars->N.z * H.z;
  if (inten > MINCONTRIB) {
    /* normalize the previous dot product */
    inten /= sqrt(H.x * H.x + H.y * H.y + H.z * H.z);

    /* calculate specular exponent */
    inten = pow(inten, specpower);
  } else {
    inten = 0.0;
  }

  return inten;
}



/*
 * Phong shader, implements specular highlight model
 * using Blinn's halfway vector dotted with the surface normal.
 * This is also the shading model used by OpenGL and Direct3D.
 * Uses Graphics Gems IV chapter VI.1 algorithm for phong exponent
 * instead of the usual call to pow(). 
 */
flt shade_blinn_fast(const ray * incident, const shadedata * shadevars, flt specpower) {
  vector H;   /* Blinn's halfway vector */
  flt inten;  /* calculated intensity   */

  /* since incident ray is negated direction to viewer, we subtract... */
  /* sub. incoming ray dir. from light direction */
  H.x = shadevars->L.x - incident->d.x; 
  H.y = shadevars->L.y - incident->d.y;
  H.z = shadevars->L.z - incident->d.z;

  inten = shadevars->N.x * H.x + shadevars->N.y * H.y + shadevars->N.z * H.z;
  if (inten > 0.0) {
    /* normalize the previous dot product */
    inten /= sqrt(H.x * H.x + H.y * H.y + H.z * H.z);

    /* replace specular exponent with a simple approximation */
    inten = inten / (specpower - (specpower * inten) + inten);
  } else {
    inten = 0.0;
  }

  return inten;
} 

/*
 * Phong shader, implements a Phong specular highlight model
 * using the reflection vector about the surface normal, dotted
 * with the direction to the viewer.  This is the "classic" phong
 */
flt shade_phong(const ray * incident, const shadedata * shadevars, flt specpower) {
  vector R;   /* reflection vector      */
  vector V;   /* direction to viewpoint */
  vector LL;  /* reverse direction to light     */
  flt inten;  /* calculated intensity   */

  LL = shadevars->L;
  VScale(&LL, -1.0);
  VAddS(-2.0 * (LL.x * shadevars->N.x + 
                LL.y * shadevars->N.y + 
                LL.z * shadevars->N.z), &shadevars->N, &LL, &R);

  V = incident->d;
  VScale(&V, -1.0);
  VNorm(&R);            /* normalize reflection vector */
  inten = VDot(&V, &R); /* dot product of halfway vector and surface normal */
  if (inten > 0.0)     
    inten = pow(inten, specpower);
  else 
    inten = 0.0;

  return inten;
} 


/*
 * Fog functions
 */
color fog_color_linear(struct fogdata_t * fog, color col, flt z) {
  color c; 
  flt f;

  f = (fog->end - z) / (fog->end - fog->start) * fog->density;
  if (f > 1.0) {
    f = 1.0;
  } else if (f < 0.0) {
    f = 0.0;
  } 

  c.r = (f * col.r) + ((1 - f) * fog->col.r);
  c.g = (f * col.g) + ((1 - f) * fog->col.g);
  c.b = (f * col.b) + ((1 - f) * fog->col.b);

  return c;
}

color fog_color_exp(struct fogdata_t * fog, color col, flt z) {
  color c; 
  flt f, v;

  v = fog->density * (z - fog->start);
  f = exp(-v);
  if (f > 1.0) {
    f = 1.0;
  } else if (f < 0.0) {
    f = 0.0;
  } 

  c.r = (f * col.r) + ((1 - f) * fog->col.r);
  c.g = (f * col.g) + ((1 - f) * fog->col.g);
  c.b = (f * col.b) + ((1 - f) * fog->col.b);

  return c;
}

color fog_color_exp2(struct fogdata_t * fog, color col, flt z) {
  color c; 
  flt f, v;
  
  v = fog->density * (z - fog->start);
  f = exp(-v*v);
  if (f > 1.0) {
    f = 1.0;
  } else if (f < 0.0) {
    f = 0.0;
  } 

  c.r = (f * col.r) + ((1 - f) * fog->col.r);
  c.g = (f * col.g) + ((1 - f) * fog->col.g);
  c.b = (f * col.b) + ((1 - f) * fog->col.b);

  return c;
}

/* 
 * shade.h - This file contains declarations and definitions for the shader.
 *
 *  $Id: shade.h,v 1.17 2003/02/16 06:24:21 johns Exp $
 */

#ifndef SHADE_H
#define SHADE_H

color lowest_shader(ray *);
color low_shader(ray *);
color medium_shader(ray *);
color full_shader(ray *);
color shade_reflection(ray *, const shadedata *, flt);
color shade_transmission(ray *, const shadedata *, flt);



flt shade_phong(const ray * incident, const shadedata * shadevars, flt specpower);
flt shade_nullphong(const ray * incident, const shadedata * shadevars, flt specpower);
flt shade_blinn(const ray * incident, const shadedata * shadevars, flt specpower);
flt shade_blinn_fast(const ray * incident, const shadedata * shadevars, flt specpower);


color fog_color_linear(struct fogdata_t *, color col, flt z);
color fog_color_exp(struct fogdata_t *, color col, flt z);
color fog_color_exp2(struct fogdata_t *, color col, flt z);

#endif
/*
 * spaceball.c - code to perform camera fly-throughs using a spaceball
 * 
 *  $Id: spaceball.c,v 1.2 2001/08/19 06:57:06 johns Exp $
 */

#ifdef USESPACEBALL

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <unistd.h>

#include "trackball.h"   /* quaternion code */
#include "tachyon.h"     /* main ray tracer api headers */
#include "sball.h"       /* spaceball code */
#include "spaceball.h"   /* protos for this file */

void * tachyon_init_spaceball(SceneHandle scene, char * port) {
  sbHandle * bh;

  bh = (sbHandle *) malloc(sizeof(sbHandle));

  if (bh != NULL) {
    memset(bh, 0, sizeof(sbHandle));

    bh->sball = sball_open(port);
    if (bh->sball == NULL) {
      free(bh);
      return NULL;
    } 
  }

  rt_get_camera_position(scene, &bh->orig_camcent, &bh->orig_camviewvec, &bh->orig_camupvec, &bh->orig_camrightvec);

  bh->camcent = bh->orig_camcent;
  bh->camviewvec = bh->orig_camviewvec;
  bh->camupvec = bh->orig_camupvec;

  trackball(bh->curquat, 0.0, 0.0, 0.0, 0.0);

  return bh;
}


int tachyon_spaceball_update(sbHandle * bh, SceneHandle scene) {
  int tx, ty, tz, rx, ry, rz, buttons;
  float qq[4];
  float xx[3]={1.0, 0.0, 0.0};
  float yy[3]={0.0, 1.0, 0.0};
  float zz[3]={0.0, 0.0, 1.0};

  float m[4][4];
  float t[3];

  static float transdivisor = 5000.0;
  static float angdivisor = 20000.0;

  if (bh->sball == NULL)
    return -1;
 
  if (sball_getstatus(bh->sball, &tx, &ty, &tz, &rx, &ry, &rz, &buttons)) {
    /* negate rotations given by spaceball */
    rx = -rx;
    ry = -ry;
    rz = -rz;

    if (buttons) {
      if (buttons & SBALL_BUTTON_PICK) {
        bh->curtrans[0] = 0.0;
        bh->curtrans[1] = 0.0;
        bh->curtrans[2] = 0.0;
        trackball(bh->curquat, 0.0, 0.0, 0.0, 0.0);
        transdivisor = 5000.0;
        angdivisor = 20000.0; 
  
        bh->camviewvec = bh->orig_camviewvec;
        bh->camupvec = bh->orig_camupvec;
        bh->camcent = bh->orig_camcent;
      }

      if (buttons & SBALL_BUTTON_1) {
        transdivisor /= 1.2;
        angdivisor /= 1.2;
      }
      else if (buttons & SBALL_BUTTON_2) {
        transdivisor *= 1.2; 
        angdivisor *= 1.2;
      }

      if (buttons & SBALL_BUTTON_3)
        transdivisor /= 1.2;
      else if (buttons & SBALL_BUTTON_4)
        transdivisor *= 1.2; 

      if (buttons & SBALL_BUTTON_5) 
        angdivisor *= 1.2;
      else if (buttons & SBALL_BUTTON_6)
        angdivisor /= 1.2;


      if (buttons & SBALL_BUTTON_7) {
        return 1;  /* quit the fly through */
      }
    } /* end of button handling */
      
    t[0] = tx / transdivisor; 
    t[1] = ty / transdivisor;
    t[2] = tz / transdivisor;

    /* 
     * convert rotations and translations from the
     * spaceball's coordinate frame into the camera's frame.
     */
    bh->newtrans[0] = 
      t[0] * bh->orig_camrightvec.x +
      t[1] * bh->orig_camupvec.x +
      t[2] * bh->orig_camviewvec.x;

    bh->newtrans[1] = 
      t[0] * bh->orig_camrightvec.y +
      t[1] * bh->orig_camupvec.y +
      t[2] * bh->orig_camviewvec.y;

    bh->newtrans[2] = 
      t[0] * bh->orig_camrightvec.z +
      t[1] * bh->orig_camupvec.z +
      t[2] * bh->orig_camviewvec.z;

    /* 
     * rotate around camera's coordinate frame
     */ 
    xx[0] = bh->orig_camrightvec.x;
    xx[1] = bh->orig_camrightvec.y;
    xx[2] = bh->orig_camrightvec.z;

    yy[0] = bh->orig_camupvec.x;
    yy[1] = bh->orig_camupvec.y;
    yy[2] = bh->orig_camupvec.z;

    zz[0] = bh->orig_camviewvec.x;
    zz[1] = bh->orig_camviewvec.y;
    zz[2] = bh->orig_camviewvec.z;
 
    /* do rotations */ 
    axis_to_quat(xx, rx / angdivisor, bh->lastquat);

    axis_to_quat(yy, ry / angdivisor, qq);
    add_quats(qq, bh->lastquat, bh->lastquat);

    axis_to_quat(zz, rz / angdivisor, qq);
    add_quats(qq, bh->lastquat, bh->lastquat);

    add_quats(bh->lastquat, bh->curquat, bh->curquat);
  }
  else {
    usleep(5); /* if no movement then sleep for a tiny bit.. */
  }

  build_rotmatrix(m, bh->curquat);

  /*
   * translate along the new axes
   */
  t[0] = m[0][0] * bh->newtrans[0] + m[0][1] * bh->newtrans[1] + m[0][2] * bh->newtrans[2];
  t[1] = m[1][0] * bh->newtrans[0] + m[1][1] * bh->newtrans[1] + m[1][2] * bh->newtrans[2];
  t[2] = m[2][0] * bh->newtrans[0] + m[2][1] * bh->newtrans[1] + m[2][2] * bh->newtrans[2];

  bh->camcent.x += t[0];
  bh->camcent.y += t[1];
  bh->camcent.z += t[2];


  /*
   * rotate view system with spaceball
   */
  bh->camviewvec.x = m[0][0] * bh->orig_camviewvec.x + m[0][1] * bh->orig_camviewvec.y + m[0][2] * bh->orig_camviewvec.z;
  bh->camviewvec.y = m[1][0] * bh->orig_camviewvec.x + m[1][1] * bh->orig_camviewvec.y + m[1][2] * bh->orig_camviewvec.z;
  bh->camviewvec.z = m[2][0] * bh->orig_camviewvec.x + m[2][1] * bh->orig_camviewvec.y + m[2][2] * bh->orig_camviewvec.z;

  bh->camupvec.x = m[0][0] * bh->orig_camupvec.x + m[0][1] * bh->orig_camupvec.y + m[0][2] * bh->orig_camupvec.z;
  bh->camupvec.y = m[1][0] * bh->orig_camupvec.x + m[1][1] * bh->orig_camupvec.y + m[1][2] * bh->orig_camupvec.z;
  bh->camupvec.z = m[2][0] * bh->orig_camupvec.x + m[2][1] * bh->orig_camupvec.y + m[2][2] * bh->orig_camupvec.z;

  /*
   * update camera parameters before we render again
   */
  rt_camera_position(scene, bh->camcent, bh->camviewvec, bh->camupvec);

  return 0;
}

#endif


#include "sball.h"

typedef struct {
  SBallHandle sball;

  apivector camcent;
  apivector camviewvec;
  apivector camupvec;

  apivector orig_camcent;
  apivector orig_camviewvec;
  apivector orig_camupvec;
  apivector orig_camrightvec;

  float curtrans[3];
  float newtrans[3];
  float curquat[4];
  float lastquat[4];
} sbHandle;

void * tachyon_init_spaceball(SceneHandle scene, char * port);
int tachyon_spaceball_update(sbHandle * bh, SceneHandle scene);


/* 
 * sphere.c - This file contains the functions for dealing with spheres.
 *
 *  $Id: sphere.c,v 1.28 2002/07/09 16:14:31 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "intersect.h"
#include "util.h"

#define SPHERE_PRIVATE
#include "sphere.h"

static object_methods sphere_methods = {
  (void (*)(const void *, void *))(sphere_intersect),
  (void (*)(const void *, const void *, const void *, void *))(sphere_normal),
  sphere_bbox, 
  free 
};

object * newsphere(void * tex, vector ctr, flt rad) {
  sphere * s;
  
  s=(sphere *) malloc(sizeof(sphere));
  memset(s, 0, sizeof(sphere));
  s->methods = &sphere_methods;

  s->tex=tex;
  s->ctr=ctr;
  s->rad=rad;

  return (object *) s;
}

static int sphere_bbox(void * obj, vector * min, vector * max) {
  sphere * s = (sphere *) obj;

  min->x = s->ctr.x - s->rad;
  min->y = s->ctr.y - s->rad;
  min->z = s->ctr.z - s->rad;
  max->x = s->ctr.x + s->rad;
  max->y = s->ctr.y + s->rad;
  max->z = s->ctr.z + s->rad;

  return 1;
}

static void sphere_intersect(const sphere * spr, ray * ry) {
  flt b, disc, t1, t2, temp;
  vector V;

  VSUB(spr->ctr, ry->o, V);
  VDOT(b, V, ry->d); 
  VDOT(temp, V, V);  

  disc=b*b + spr->rad*spr->rad - temp;

  if (disc<=0.0) return;
  disc=sqrt(disc);

  t2=b+disc;
  if (t2 <= SPEPSILON) 
    return;
  ry->add_intersection(t2, (object *) spr, ry);  

  t1=b-disc;
  if (t1 > SPEPSILON) 
    ry->add_intersection(t1, (object *) spr, ry);  
}

static void sphere_normal(const sphere * spr, const vector * pnt, const ray * incident, vector * N) {
  flt len;

  N->x = pnt->x - spr->ctr.x;
  N->y = pnt->y - spr->ctr.y;
  N->z = pnt->z - spr->ctr.z;

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}


/* 
 * sphere.h - This file contains the defines for spheres etc.
 *
 *  $Id: sphere.h,v 1.12 2002/08/04 21:43:34 johns Exp $
 */

object * newsphere(void *, vector, flt);

#ifdef SPHERE_PRIVATE

typedef struct {
  RT_OBJECT_HEAD
  vector ctr;
  flt rad;
} sphere;

static int sphere_bbox(void * obj, vector * min, vector * max);
static void sphere_intersect(const sphere *, ray *);
static void sphere_normal(const sphere *, const vector *, const ray *, vector *);

#endif /* SPHERE_PRIVATE */

/*
 * tachyon.h - The declarations and prototypes needed so that 3rd party     
 *   driver code can run the raytracer.  Third party driver code should       
 *   only use the functions in this header file to interface with the 
 *   rendering engine.                                            
 *
 * $Id: tachyon.h,v 1.69 2004/02/03 06:09:11 johns Exp $
 *
 */

#if !defined(TACHYON_H)
#define TACHYON_H 1

#ifdef  __cplusplus
extern "C" {
#endif

#include "rtcommon.h" /* defintions common to all interfaces */

/********************************************/
/* Types defined for use with the API calls */
/********************************************/

typedef void * SceneHandle;

typedef struct {
   apiflt x;
   apiflt y;
   apiflt z;
} apivector;

typedef struct {
   float r;
   float g;
   float b;
} apicolor;

typedef struct {
  int texturefunc; /* which texture function to use */
  apicolor col;    /* base object color */
  int shadowcast;  /* does the object cast a shadow */
  apiflt ambient;  /* ambient lighting */
  apiflt diffuse;  /* diffuse reflection */
  apiflt specular; /* specular reflection */
  apiflt opacity;  /* how opaque the object is */ 
  apivector ctr;   /* origin of texture */
  apivector rot;   /* rotation of texture around origin */
  apivector scale; /* scale of texture in x,y,z */ 
  apivector uaxs;  /* planar map u axis */
  apivector vaxs;  /* planar map v axis */
  char imap[96];   /* name of image map */ 
} apitexture;

/********************************************/
/* Functions implemented to provide the API */
/********************************************/

apivector rt_vector(apiflt x, apiflt y, apiflt z); /* helper to make vectors */
apicolor  rt_color(float r, float g, float b);  /* helper to make colors */

void rt_set_ui_message(void (* func) (int, char *)); 
void rt_set_ui_progress(void (* func) (int));

/*
 * rt_initialize(&argc, &argv)
 *
 * takes pointer to argument count, and pointer to argument array
 * 1. resets and initializes the raytracing system
 * 2. initializes internal parallel processing facilities, and tests
 *    inter-node connectivity.
 * 3. deallocates previously allocated internal data structures
 * 4. returns the id of this computational node on success, -1 on failure.
 */ 
int rt_initialize(int *, char ***); 


/*
 * rt_finalize()
 *
 * shutdown the ray tracing library for good, at final use before
 * program termination.  The ray tracer may not be used after rt_finalize
 * has been called.
 */ 
void rt_finalize(void); 

/*
 * rt_newscene()
 *
 * Allocates, initializes, and returns a handle for a new scene.  
 */
SceneHandle rt_newscene(void); 


/* 
 * rt_deletescene(SceneHandle)
 *
 * Destroys / deallocates the specified scene.
 */
void rt_deletescene(SceneHandle);

/*
 * rt_renderscene(SceneHandle)
 *
 * Renders the current scene.
 */
void rt_renderscene(SceneHandle);

/*
 * rt_outputfile(SceneHandle, outname);
 * 
 * Sets the output filename of the specified scene.
 */
void rt_outputfile(SceneHandle, const char * outname); 

/*
 * rt_outputformat(SceneHandle, format);
 *
 * Sets the format of the output image(s)
 */
void rt_outputformat(SceneHandle, int format);

/*
 * rt_resolution(SceneHandle, hres, vres)
 * rt_get_resolution(SceneHandle, &hres, &vres)
 *
 * Sets the horizontal and vertical resolution (in pixels)
 * for the specified scene.
 */
void rt_resolution(SceneHandle, int hres, int vres);
void rt_get_resolution(SceneHandle, int *hres, int *vres);

/*
 * rt_aa_maxsamples(SceneHandle, maxsamples)
 * 
 * Sets the maximum number of supersamples to take for any pixel.
 */
void rt_aa_maxsamples(SceneHandle, int maxsamples);

/*
 * rt_verbose(SceneHandle, onoff);
 *
 * Enables or Disables verbose messages from the ray tracing library
 * during rendering. (a zero value means off, non-zero means on)
 */
void rt_verbose(SceneHandle, int v);


/*
 * rt_rawimage(SceneHandle, unsigned char *rawimage);
 *
 * Have the ray tracer save the output image in the specified
 * memory area, in raw 24-bit, packed, pixel interleaved, unssigned
 * RGB bytes.  The caller is responsible for making sure that there
 * is enough space in the memory area for the entire image.
 */
void rt_rawimage(SceneHandle, unsigned char *rawimage);

/*
 * rt_set_numthreads(SceneHandle, int) 
 *
 * Explicitly sets the number of threads the ray tracer will use
 */
void rt_set_numthreads(SceneHandle, int);

/*
 * rt_background(SceneHandle, apicolor);
 *
 * Sets the background color of the specified scene.
 */
void rt_background(SceneHandle, apicolor);


/*
 * rt_fog_mode(SceneHandle, mode);
 */
void rt_fog_mode(SceneHandle, int);

/*
 * rt_fog_parms(SceneHandle, color, start, end, density);
 */
void rt_fog_parms(SceneHandle, apicolor, apiflt, apiflt, apiflt);


/*
 * rt_trans_mode(SceneHandle, mode);
 */
void rt_trans_mode(SceneHandle, int);



/*
 * rt_boundmode(SceneHandle, int)
 * 
 * Enables/Disables automatic generation and use of ray tracing acceleration
 * data structures. 
 */
void rt_boundmode(SceneHandle, int);


/* 
 * rt_boundthresh(SceneHandle, int)
 * 
 * Sets the threshold to be used when automatic generation of ray tracing
 * acceleration structures is to be used.  The threshold represents the 
 * minimum number of objects which must be present in an area of space 
 * before an automatic acceleration system will consider optimizing the
 * objects using spatial subdivision or automatic bounds generation methods.
 */
void rt_boundthresh(SceneHandle, int);

/* 
 * rt_shadermode()
 *
 * Sets the shading mode for the specified scene. 
 *
 * Modes are sorted from lowest quality (and fastest execution)
 * to highest quality (and slowest execution)
 */
void rt_shadermode(SceneHandle voidscene, int mode);

/*
 * rt_phong_shader()
 *
 * Set the equation used for rendering specular highlights
 *
 */
void rt_phong_shader(SceneHandle voidscene, int mode);
 

/*
 * rt_camera_setup(scene, zoom, aspect, alias, maxdepth, ctr, viewdir, updir)
 *
 * NOTE: This API should be deprecated, but a suitable replacement has not 
 *       been written yet.
 */
void rt_camera_setup(SceneHandle, apiflt, apiflt, int, int,
	apivector, apivector,  apivector);

/*
 * rt_camera_projection(scene, mode)
 */
void rt_camera_projection(SceneHandle, int);

/*
 * set depth-of-field options
 */
void rt_camera_dof(SceneHandle voidscene, flt focallength, flt aperture);

/* 
 * rt_camera_position(scene, center, viewdir, updir)
 */ 
void rt_camera_position(SceneHandle, apivector, apivector, apivector);

/* 
 * rt_get_camera_position(scene, center, viewdir, updir, rightdir)
 */ 
void rt_get_camera_position(SceneHandle, apivector *, apivector *, apivector *, apivector *);

/*
 * rt_camera_frustum(scene, left, right, bottom, top)
 */
void rt_camera_frustum(SceneHandle, flt, flt, flt, flt);

/*
 * rt_texture(SceneHandle, texture *)
 *
 * translates a texture definition into the internal format used
 * by the ray tracing system, and returns an opaque pointer to the
 * internally used structure, which should be passed to object creation
 * routines.
 *
 * NOTE: This API should be deprecated, but a suitable replacement has not 
 *       been written yet.
 */
void * rt_texture(SceneHandle, apitexture *);

void * rt_light(SceneHandle, void * , apivector, apiflt);     
  /* add a point light */
  /* parms: texture, center, radius */ 

void * rt_directional_light(SceneHandle, void * , apivector);     
  /* add a directional light */
  /* parms: texture, direction */ 

void * rt_spotlight(SceneHandle, void * , apivector, apiflt, apivector, apiflt, apiflt);     
  /* add a spotlightlight */
  /* parms: texture, center, radius, direction, falloffstart, falloffend */ 

void rt_light_attenuation(void *, apiflt, apiflt, apiflt);
  /* parms: Light, Constant factor, Linear factor, Quadratic factor */

void rt_sphere(SceneHandle, void *, apivector, apiflt);    /* add a sphere */
  /* sphere parms: texture, center, radius */

void rt_scalarvol(SceneHandle, void *, apivector, apivector,
		 int, int, int, const char *, void *); 

void rt_extvol(SceneHandle, void *, apivector, apivector, int, apiflt (* evaluator)(apiflt, apiflt, apiflt)); 

void rt_box(SceneHandle, void *, apivector, apivector);  
  /* box parms: texture, min, max */

void rt_plane(SceneHandle, void *, apivector, apivector);  
  /* plane parms: texture, center, normal */

void rt_ring(SceneHandle, void *, apivector, apivector, apiflt, apiflt); 
  /* ring parms: texture, center, normal, inner, outer */

void rt_tri(SceneHandle, void *, apivector, apivector, apivector);  
  /* tri parms: texture, vertex 0, vertex 1, vertex 2 */

void rt_stri(SceneHandle, void *, apivector, apivector, apivector, 
			apivector, apivector, apivector); 
 /* stri parms: texture, vertex 0, vertex 1, vertex 2, norm 0, norm 1, norm 2 */

void rt_vcstri(SceneHandle, void *, apivector, apivector, apivector, 
			apivector, apivector, apivector,
			apicolor, apicolor, apicolor); 
 /* vcstri parms: texture, vertex 0, vertex 1, vertex 2,            */
 /*               norm 0, norm 1, norm 2, color 0, color 1, color 2 */

void rt_heightfield(SceneHandle, void *, apivector, int, int, apiflt *, apiflt, apiflt);
  /* field parms: texture, center, m, n, field, wx, wy */

void rt_landscape(SceneHandle, void *, int, int, apivector,  apiflt, apiflt);

void rt_quadsphere(SceneHandle, void *, apivector, apiflt); /* add quadric sphere */
  /* sphere parms: texture, center, radius */

void rt_cylinder(SceneHandle, void *, apivector, apivector, apiflt);

void rt_fcylinder(SceneHandle, void *, apivector, apivector, apiflt);

void rt_polycylinder(SceneHandle, void *, apivector *, int, apiflt);

/* new texture handling routines */
void rt_tex_color(void * voidtex, apicolor col); 

void rt_tex_phong(void * voidtex, apiflt phong, apiflt phongexp, int type); 


#ifdef  __cplusplus
}
#endif
#endif
/* 
 * texture.c - This file contains functions for implementing textures.
 * 
 *  $Id: texture.c,v 1.23 2004/02/03 06:00:40 johns Exp $ 
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "texture.h"
#include "coordsys.h"
#include "imap.h"
#include "vector.h"
#include "box.h"
#include "util.h"

/* plain vanilla texture solely based on object color */
color constant_texture(const vector * hit, const texture * tx, const ray * ry) {
  standard_texture * tex = (standard_texture *) tx;
  return tex->col;
}

/* cylindrical image map */
color image_cyl_texture(const vector * hit, const texture * tx, const ray * ry) {
  vector rh;
  flt u, v, miprad, maxscale, cyrad;
  standard_texture * tex = (standard_texture *) tx;
 
  rh.x=hit->x - tex->ctr.x;
  rh.z=hit->y - tex->ctr.y;
  rh.y=hit->z - tex->ctr.z;
 
  xyztocyl(rh, 1.0, &u, &v);

  u = u * tex->scale.x;  
  u = u + tex->rot.x;
  u = u - ((int) u);
  if (u < 0.0) u+=1.0; 

  v = v * tex->scale.y; 
  v = v + tex->rot.y;
  v = v - ((int) v);
  if (v < 0.0) v+=1.0; 

  cyrad = EPSILON + 8.0 * sqrt(rh.x*rh.x + rh.y*rh.y + rh.z*rh.z);

  maxscale = (fabs(tex->scale.x) > fabs(tex->scale.y)) ? 
             tex->scale.x : tex->scale.y;

  miprad = (0.05 * ry->opticdist * fabs(maxscale)) / cyrad;

  return MIPMap(tex->img, u, v, miprad);
}  

/* spherical image map */
color image_sphere_texture(const vector * hit, const texture * tx, const ray * ry) {
  vector rh;
  flt u, v, miprad, maxscale, sprad;
  standard_texture * tex = (standard_texture *) tx;
 
  rh.x=hit->x - tex->ctr.x;
  rh.y=hit->y - tex->ctr.y;
  rh.z=hit->z - tex->ctr.z;
 
  xyztospr(rh, &u, &v);

  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - ((int) u);
  if (u < 0.0) u+=1.0;
 
  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - ((int) v);
  if (v < 0.0) v+=1.0;

  sprad = EPSILON + 8.0 * sqrt(rh.x*rh.x + rh.y*rh.y + rh.z*rh.z);

  maxscale = (fabs(tex->scale.x) > fabs(tex->scale.y)) ? 
             tex->scale.x : tex->scale.y;

  miprad = (0.05 * ry->opticdist * fabs(maxscale)) / sprad;
 
  return MIPMap(tex->img, u, v, miprad);
}

/* planar image map */
color image_plane_texture(const vector * hit, const texture * tx, const ray * ry) {
  vector pnt;
  flt u, v, miprad, maxscale;
  standard_texture * tex = (standard_texture *) tx;
 
  pnt.x=hit->x - tex->ctr.x;
  pnt.y=hit->y - tex->ctr.y;
  pnt.z=hit->z - tex->ctr.z;

  VDOT(u, tex->uaxs, pnt);
  VDOT(v, tex->vaxs, pnt); 

  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - ((int) u);
  if (u < 0.0) u += 1.0;

  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - ((int) v);
  if (v < 0.0) v += 1.0;

  
  maxscale = (fabs(tex->scale.x) > fabs(tex->scale.y)) ? 
             tex->scale.x : tex->scale.y;

  miprad = 0.05 * ry->opticdist * fabs(maxscale);

  return MIPMap(tex->img, u, v, miprad);
}

color grit_texture(const vector * hit, const texture * tx, const ray * ry) {
  int rnum;
  flt fnum;
  color col;
  standard_texture * tex = (standard_texture *) tx;

  rnum=rand() % 4096;
  fnum=(rnum / 4096.0 * 0.2) + 0.8;

  col.r=tex->col.r * fnum;
  col.g=tex->col.g * fnum;
  col.b=tex->col.b * fnum;

  return col;
}

color checker_texture(const vector * hit, const texture * tx, const ray * ry) {
  long x,y,z;
  flt xh,yh,zh;
  color col;
  standard_texture * tex = (standard_texture *) tx;

  xh=hit->x - tex->ctr.x; 
  x=(long) ((fabs(xh) * 3) + 0.5);
  x=x % 2;
  yh=hit->y - tex->ctr.y;
  y=(long) ((fabs(yh) * 3) + 0.5);
  y=y % 2;
  zh=hit->z - tex->ctr.z;
  z=(long) ((fabs(zh) * 3) + 0.5);
  z=z % 2;

  if (((x + y + z) % 2)==1) {
    col.r=1.0;
    col.g=0.2;
    col.b=0.0;
  }
  else {
    col.r=0.0;
    col.g=0.2;
    col.b=1.0;
  }

  return col;
}

color cyl_checker_texture(const vector * hit, const texture * tx, const ray * ry) {
  long x,y;
  vector rh;
  flt u,v;
  color col;
  standard_texture * tex = (standard_texture *) tx;
 
  rh.x=hit->x - tex->ctr.x;
  rh.y=hit->y - tex->ctr.y;
  rh.z=hit->z - tex->ctr.z;

  xyztocyl(rh, 1.0, &u, &v); 

  x=(long) (fabs(u) * 18.0);
  x=x % 2;
  y=(long) (fabs(v) * 10.0);
  y=y % 2;
 
  if (((x + y) % 2)==1) {
    col.r=1.0;
    col.g=0.2;
    col.b=0.0;
  }
  else {
    col.r=0.0;
    col.g=0.2;
    col.b=1.0;
  }
 
  return col;
}


color wood_texture(const vector * hit, const texture * tx, const ray * ry) {
  flt radius, angle;
  int grain;
  color col;
  flt x,y,z;
  standard_texture * tex = (standard_texture *) tx;

  x=(hit->x - tex->ctr.x) / tex->scale.x;
  y=(hit->y - tex->ctr.y) / tex->scale.y;
  z=(hit->z - tex->ctr.z) / tex->scale.z;

  radius=sqrt(x*x + z*z);
  if (z == 0.0) 
    angle=3.1415926/2.0;
  else 
    angle=atan(x / z);

  radius=radius + 3.0 * sin(20 * angle + y / 150.0);
  grain=((int) (radius + 0.5)) % 60;
  if (grain < 40) {
    col.r=0.8;
    col.g=1.0;
    col.b=0.2;
  }
  else {
    col.r=0.0;
    col.g=0.0;
    col.b=0.0;
  }     

  return col;
} 



#define NMAX 28
short int NoiseMatrix[NMAX][NMAX][NMAX];

void InitNoise(void) {
  byte x,y,z,i,j,k;
  unsigned int rndval = 1234567; /* pathetic random number seed */

  for (x=0; x<NMAX; x++) {
    for (y=0; y<NMAX; y++) {
      for (z=0; z<NMAX; z++) {
        NoiseMatrix[x][y][z]=(short int) ((rt_rand(&rndval) / RT_RAND_MAX) * 12000.0);

        if (x==NMAX-1) i=0; 
        else i=x;

        if (y==NMAX-1) j=0;
        else j=y;

        if (z==NMAX-1) k=0;
        else k=z;

        NoiseMatrix[x][y][z]=NoiseMatrix[i][j][k];
      }
    }
  }
}

int Noise(flt x, flt y, flt z) {
  byte ix, iy, iz;
  flt ox, oy, oz;
  int p000, p001, p010, p011;
  int p100, p101, p110, p111;
  int p00, p01, p10, p11;
  int p0, p1;
  int d00, d01, d10, d11;
  int d0, d1, d;

  x=fabs(x);
  y=fabs(y);
  z=fabs(z);

  ix=((int) x) % NMAX;
  iy=((int) y) % NMAX;
  iz=((int) z) % NMAX;

  ox=(x - ((int) x));
  oy=(y - ((int) y));
  oz=(z - ((int) z));

  p000=NoiseMatrix[ix][iy][iz];
  p001=NoiseMatrix[ix][iy][iz+1];
  p010=NoiseMatrix[ix][iy+1][iz];
  p011=NoiseMatrix[ix][iy+1][iz+1];
  p100=NoiseMatrix[ix+1][iy][iz];
  p101=NoiseMatrix[ix+1][iy][iz+1];
  p110=NoiseMatrix[ix+1][iy+1][iz];
  p111=NoiseMatrix[ix+1][iy+1][iz+1];

  d00=p100-p000;
  d01=p101-p001;
  d10=p110-p010;
  d11=p111-p011;

  p00=(int) ((int) d00*ox) + p000;
  p01=(int) ((int) d01*ox) + p001;
  p10=(int) ((int) d10*ox) + p010;
  p11=(int) ((int) d11*ox) + p011;
  d0=p10-p00;
  d1=p11-p01;
  p0=(int) ((int) d0*oy) + p00;
  p1=(int) ((int) d1*oy) + p01;
  d=p1-p0;

  return (int) ((int) d*oz) + p0;
}

color marble_texture(const vector * hit, const texture * tx, const ray * ry) {
  flt i,d;
  flt x,y,z;
  color col;
  standard_texture * tex = (standard_texture *) tx;
 
  x=hit->x;
  y=hit->y; 
  z=hit->z;

  x=x * 1.0;

  d=x + 0.0006 * Noise(x, (y * 1.0), (z * 1.0));
  d=d*(((int) d) % 25);
  i=0.0 + 0.10 * fabs(d - 10.0 - 20.0 * ((int) d * 0.05));
  if (i > 1.0) i=1.0;
  if (i < 0.0) i=0.0;  

/*
  col.r=i * tex->col.r;
  col.g=i * tex->col.g;
  col.b=i * tex->col.b;
*/

  col.r = (1.0 + sin(i * 6.28)) / 2.0;
  col.g = (1.0 + sin(i * 16.28)) / 2.0;
  col.b = (1.0 + cos(i * 30.28)) / 2.0;

  return col;      
}


color gnoise_texture(const vector * hit, const texture * tx, const ray * ry) {
  color col;
  flt f;
  standard_texture * tex = (standard_texture *) tx;

  f=Noise((hit->x - tex->ctr.x), 
          (hit->y - tex->ctr.y), 
	  (hit->z - tex->ctr.z));

  if (f < 0.01) f=0.01;
  if (f > 1.0) f=1.0;

  col.r=tex->col.r * f;
  col.g=tex->col.g * f;
  col.b=tex->col.b * f;

  return col;
}

void InitTextures(void) {
  InitNoise();
  ResetImages();
}

/*
 * texture.h This file contains all of the includes and defines for the texture 
 * mapping part of the shader.
 *
 *  $Id: texture.h,v 1.11 2004/02/03 06:00:40 johns Exp $
 */

void InitTextures(void);
color     constant_texture(const vector *, const texture *, const ray *);
color    image_cyl_texture(const vector *, const texture *, const ray *);
color image_sphere_texture(const vector *, const texture *, const ray *);
color  image_plane_texture(const vector *, const texture *, const ray *);
color      checker_texture(const vector *, const texture *, const ray *);
color  cyl_checker_texture(const vector *, const texture *, const ray *);
color         grit_texture(const vector *, const texture *, const ray *);
color         wood_texture(const vector *, const texture *, const ray *);
color       marble_texture(const vector *, const texture *, const ray *);
color       gnoise_texture(const vector *, const texture *, const ray *);
int Noise(flt, flt, flt);
void InitTextures(void);

/* 
 * tgafile.c - This file contains the code to write 24 bit targa files...
 *
 *  $Id: tgafile.c,v 1.25 2003/08/22 05:05:12 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "util.h"
#include "ui.h"
#include "imageio.h"
#include "tgafile.h"


typedef struct {
  unsigned short width;
  unsigned short height;
  FILE * ofp;
} tgahandle;

int createtgafile(char *name, unsigned short width, unsigned short height) {
  int filesize;
  FILE * ofp;

  filesize = 3*width*height + 18 - 10;
  
  if (name==NULL) {
    return IMAGEWRITEERR;
  } else {
    ofp=fopen(name, "w+b");
    if (ofp == NULL) {
      char msgtxt[2048];
      sprintf(msgtxt, "Cannot create %s for output!", name);
      rt_ui_message(MSG_ERR, msgtxt);
      rt_ui_message(MSG_ABORT, "Rendering Aborted.");
      return IMAGEWRITEERR;
    } 

    fputc(0, ofp); /* IdLength      */
    fputc(0, ofp); /* ColorMapType  */
    fputc(2, ofp); /* ImageTypeCode */
    fputc(0, ofp); /* ColorMapOrigin, low byte */
    fputc(0, ofp); /* ColorMapOrigin, high byte */
    fputc(0, ofp); /* ColorMapLength, low byte */
    fputc(0, ofp); /* ColorMapLength, high byte */
    fputc(0, ofp); /* ColorMapEntrySize */
    fputc(0, ofp); /* XOrigin, low byte */
    fputc(0, ofp); /* XOrigin, high byte */
    fputc(0, ofp); /* YOrigin, low byte */
    fputc(0, ofp); /* YOrigin, high byte */
    fputc((width & 0xff),         ofp); /* Width, low byte */
    fputc(((width >> 8) & 0xff),  ofp); /* Width, high byte */
    fputc((height & 0xff),        ofp); /* Height, low byte */
    fputc(((height >> 8) & 0xff), ofp); /* Height, high byte */
    fputc(24, ofp);   /* ImagePixelSize */
    fputc(0x20, ofp); /* ImageDescriptorByte 0x20 == flip vertically */

    fseek(ofp, filesize, 0);
    fprintf(ofp, "9876543210"); 

    fclose(ofp);
  } 

  return IMAGENOERR;
}    

void * opentgafile(char * filename) {
  tgahandle * tga; 
  tga = malloc(sizeof(tgahandle));
  
  tga->ofp=fopen(filename, "r+b");
  if (tga->ofp == NULL) {
    char msgtxt[2048];
    sprintf(msgtxt, "Cannot open %s for output!", filename);
    rt_ui_message(MSG_ERR, msgtxt);
    rt_ui_message(MSG_ABORT, "Rendering Aborted.");
    return NULL;
  } 

  fseek(tga->ofp, 12, 0);  
  tga->width = fgetc(tga->ofp);
  tga->width |= fgetc(tga->ofp) << 8;
  tga->height = fgetc(tga->ofp);
  tga->height |= fgetc(tga->ofp) << 8;

  return tga;
} 

void writetgaregion(void * voidhandle, int startx, int starty, 
                    int stopx, int stopy, unsigned char * buffer) {
  int x, y, totalx, totaly;
  unsigned char * bufpos;
  int filepos, numbytes;
  tgahandle * tga = (tgahandle *) voidhandle;
  unsigned char * fixbuf; 

  totalx = stopx - startx + 1;
  totaly = stopy - starty + 1;

  fixbuf = (unsigned char *) malloc(totalx * 3);
  if (fixbuf == NULL) {
    rt_ui_message(MSG_ERR, "writetgaregion: failed memory allocation!\n");
    return;
  }
  
  for (y=0; y<totaly; y++) {
    bufpos=buffer + (totalx*3)*(totaly-y-1);
    filepos=18 + tga->width*3*(tga->height - starty - totaly + y + 1) + 
            (startx - 1)*3; 

    if (filepos >= 18) {
      fseek(tga->ofp, filepos, 0); 

      for (x=0; x<(3*totalx); x+=3) {
        fixbuf[x    ] = bufpos[x + 2];
        fixbuf[x + 1] = bufpos[x + 1];
        fixbuf[x + 2] = bufpos[x    ];
      }
 
      numbytes = fwrite(fixbuf, 3, totalx, tga->ofp);
      
      if (numbytes != totalx) {
        char msgtxt[256];
	sprintf(msgtxt, "File write problem, %d bytes written.", numbytes);  
        rt_ui_message(MSG_ERR, msgtxt);
      }
    }
    else {
      rt_ui_message(MSG_ERR, "writetgaregion: file ptr out of range!!!\n");
      return;  /* don't try to continue */
    }
  }

  free(fixbuf);
}

void closetgafile(void * voidhandle) {
  tgahandle * tga = (tgahandle *) voidhandle;

  fclose(tga->ofp);
  free(tga);  
}

int readtga(char * name, int * xres, int * yres, unsigned char **imgdata) {
  int format, width, height, w1, w2, h1, h2, depth, flags;
  int imgsize, bytesread, i, tmp;
  FILE * ifp;

  ifp=fopen(name, "r");  
  if (ifp==NULL) {
    return IMAGEBADFILE; /* couldn't open the file */
  }

  /* read the targa header */
  fgetc( ifp); /* ID length */
  fgetc( ifp); /* colormap type */
  format = fgetc( ifp); /* image type */
  fgetc( ifp); /* color map origin */
  fgetc( ifp); /* color map origin */
  fgetc( ifp); /* color map length */
  fgetc( ifp); /* color map length */
  fgetc( ifp); /* color map entry size */
  fgetc( ifp); /* x origin */
  fgetc( ifp); /* x origin */
  fgetc( ifp); /* y origin */
  fgetc( ifp); /* y origin */
  w1 = fgetc( ifp); /* width (low) */
  w2 = fgetc( ifp); /* width (hi) */
  h1 = fgetc( ifp); /* height (low) */
  h2 = fgetc( ifp); /* height (hi) */
  depth = fgetc( ifp); /* image pixel size */
  flags = fgetc( ifp); /* image descriptor byte */

  if ((format != 2) || (depth != 24)) {
    fclose(ifp);
    return IMAGEUNSUP; /* unsupported targa format */
  }
    

  width = ((w2 << 8) | w1);
  height = ((h2 << 8) | h1);

  imgsize = 3 * width * height;
  *imgdata = malloc(imgsize);
  bytesread = fread(*imgdata, 1, imgsize, ifp);
  fclose(ifp);

  /* flip image vertically */
  if (flags == 0x20) {
    int rowsize = 3 * width;
    unsigned char * copytmp;

    copytmp = malloc(rowsize);

    for (i=0; i<height / 2; i++) {
      memcpy(copytmp, &((*imgdata)[rowsize*i]), rowsize);
      memcpy(&(*imgdata)[rowsize*i], &(*imgdata)[rowsize*(height - 1 - i)], rowsize);
      memcpy(&(*imgdata)[rowsize*(height - 1 - i)], copytmp, rowsize);
    }

    free(copytmp);       
  }


  /* convert from BGR order to RGB order */
  for (i=0; i<imgsize; i+=3) {
    tmp = (*imgdata)[i]; /* Blue */
    (*imgdata)[i] = (*imgdata)[i+2]; /* Red */
    (*imgdata)[i+2] = tmp; /* Blue */    
  }

  *xres = width;
  *yres = height;

  if (bytesread != imgsize) 
    return IMAGEREADERR;

  return IMAGENOERR;
}


int writetga(char * name, int xres, int yres, unsigned char *imgdata) {
  void * outfile;
  int rc = IMAGENOERR;

  rc = createtgafile(name, (unsigned short) xres, (unsigned short) yres);
  if (rc == IMAGENOERR) {
    outfile = opentgafile(name);

    if (outfile == NULL) 
      return IMAGEWRITEERR;

    writetgaregion(outfile, 1, 1, xres, yres, imgdata);
    closetgafile(outfile);
  }

  return rc;
}



/* 
 * tgafile.h - this file contains defines and structures for tgafile.c
 *
 *  $Id: tgafile.h,v 1.9 2003/08/22 05:05:12 johns Exp $
 */

/* declare other functions */
int createtgafile(char *, unsigned short, unsigned short);
void * opentgafile(char *);
void writetgaregion(void *, int, int, int, int, unsigned char *);
void closetgafile(void *);
int readtga(char * name, int * xres, int * yres, unsigned char **imgdata);
int writetga(char * name, int xres, int yres, unsigned char *imgdata);
/*
 *  tgatoyuv.c - converts .tga files to Abekas YUV format .yuv files..
 *
 *   $Id: tgatoyuv.c,v 1.3 1998/05/01 01:14:50 johns Exp $
 */ 



#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#ifdef MPI
#include <mpi.h>
#endif

/* ONLY HANDLES 352x240 images!!! */

#define TGASZ 253440
#define YUVSZ 168960

void readtga(char * fname, unsigned char * mem) {
  unsigned char hdr[40];
  FILE * ifp;

  ifp = fopen(fname, "r");
  if (ifp == NULL) { 
    printf("Error opening %s for input!\n", fname);
    return;
  }

  fread(hdr, 18, 1, ifp); /* read in tga file header */   
  fread(mem, TGASZ, 1, ifp);

  fclose(ifp);
}

void writeyuv(char *fname, unsigned char * data) {
  FILE * ofp;
   
  ofp = fopen(fname, "w+b");

  fwrite(data, YUVSZ, 1, ofp);

  fclose(ofp); 
}

void bgrtoyuv(unsigned char * bgr, unsigned char *yuv) {
  int z,t;
  unsigned char r,g,b;
  unsigned long y1,y2,u,v,u0,u1,u2,v0,v1,v2;
  unsigned char * yuvptr;

  y1=y2=u=v=u0=u1=u2=v0=v1=v2=0;

  yuvptr = yuv;
  z=0;
  for (t=0; t<(TGASZ / 3); t+=2) {

    /* first pel (gives Y and half of chroma) */
    b = bgr[z*3    ]; /* blue  */
    g = bgr[z*3 + 1]; /* green */
    r = bgr[z*3 + 2]; /* red   */

    y1 = 16829 * r + 33039 * g + 6416 * b + (0xffff & y2);
    u1 = -4853 * r - 9530 * g + 14383 * b;
    v1 = 14386 * r - 12046 * g - 2340 * b;
 
    /* second pel (gives Y and quarter U and quarter V) */
    z++;
    b = bgr[z*3    ]; /* blue  */
    g = bgr[z*3 + 1]; /* green */
    r = bgr[z*3 + 2]; /* red   */
    y2 = 16829 * r + 33039 * g + 6416 * b + (0xffff & y1);
    u2 = -2426 * r - 4765 * g + 7191 * b;
    v2 = 7193 * r - 6023 * g - 1170 * b;
 
    /* filter the chroma */
    u = u0 + u1 + u2 + (0xffff & u);
    v = v0 + v1 + v2 + (0xffff & v);

    u0 = u2;
    v0 = v2;
 
    *yuvptr++ = (unsigned char) ((unsigned long) (u >> 16) + 128);
    *yuvptr++ = (unsigned char) ((unsigned long) (y1 >> 16) + 16);
    *yuvptr++ = (unsigned char) ((unsigned long) (v >> 16) + 128);
    *yuvptr++ = (unsigned char) ((unsigned long) (y2 >> 16) + 16);
   
    /* next pel...*/ 
    z++;
  }
}

int main (int argc, char **argv) {
  int fs, fe;
  int i;
  unsigned char *tgadata, *yuvdata;
  char tganame[800];
  char yuvname[800];
  int numnodes;
  int mynode;

  mynode=0;
  numnodes=1;

#ifdef MPI
  MPI_Init(&argc, &argv); /* initialize MPI */

  MPI_Comm_rank(MPI_COMM_WORLD, &mynode);
  MPI_Comm_size(MPI_COMM_WORLD, &numnodes);

  if (mynode == 0) 
    printf("Parallel tga to yuv converter\n");

  MPI_Barrier(MPI_COMM_WORLD);
#endif

  tgadata = malloc(TGASZ);
  yuvdata = malloc(YUVSZ);

  if (mynode == 0)  
    printf("Converting 352x240 .tga files to abekas YUV files...\n");

  if (argc != 4) { 
    if (mynode == 0)  
      printf("Usage is: tgatoyuv basename  startframe#  endframe# \n");
    exit(0);
  }

  if (mynode == 0) 
    printf("Using %s as base filename for frames %s -> %s\n", 
					argv[1], argv[2], argv[3]);

  fs = atoi(argv[2]);
  fe = atoi(argv[3]); 
  
  for (i=(fs + mynode); i<=fe; i+=numnodes) {
    sprintf(tganame, "%s.%04d.tga", argv[1], i);
    sprintf(yuvname, "%s.%04d.yuv", argv[1], i);
    printf("converting %s -> %s . . .\n", tganame, yuvname);

    readtga(tganame, tgadata);
    bgrtoyuv(tgadata, yuvdata);
    writeyuv(yuvname, yuvdata);     
  }

#ifdef MPI
  MPI_Barrier(MPI_COMM_WORLD);

  if (mynode == 0) 
    printf("All nodes complete, all images converted.\n");

  MPI_Finalize(); /* close MPI */
#endif

  return 0;
}

/*
 * threads.c - code for spawning threads on various platforms.
 *
 *  $Id: threads.c,v 1.35 2002/07/03 22:30:25 johns Exp $
 */ 

#include "machine.h"
#include "threads.h"
#include "ui.h"

#ifdef _MSC_VER
#include <windows.h> /* main Win32 APIs and types */
#include <winbase.h> /* system services headers */
#endif

#if defined(SunOS) || defined(Irix) || defined(Linux) || defined(_CRAY) || defined(__osf__) || defined(AIX)
#include<unistd.h>  /* sysconf() headers, used by most systems */
#endif

#if defined(__APPLE__) && defined(THR)
#include <Carbon/Carbon.h> /* Carbon APIs for Multiprocessing */
#endif

#if defined(HPUX)
#include <sys/mpctl.h> /* HP-UX Multiprocessing headers */
#endif


int rt_thread_numprocessors(void) {
  int a=1;

  return a;
}


int rt_thread_setconcurrency(int nthr) {
  int status=0;

  return status;
}

int rt_thread_create(rt_thread_t * thr, void * routine(void *), void * arg) {
  int status=0;

#ifdef THR
#ifdef USEPOSIXTHREADS 
  status = pthread_create(thr, NULL, routine, arg);
#endif 
#endif /* THR */
 
  return status;
}


int rt_thread_join(rt_thread_t thr, void ** stat) {
  int status=0;  

#ifdef THR
#ifdef USEPOSIXTHREADS
  status = pthread_join(thr, stat);
#endif /* USEPOSIXTHREADS */
#endif /* THR */

  return status;
}  


#if !defined(THR)

rt_barrier_t * rt_thread_barrier_init(int n_clients) {
  return NULL;
}

void rt_thread_barrier_destroy(rt_barrier_t *barrier) {
}

int rt_thread_barrier(rt_barrier_t *barrier, int increment) {
  return 0;
}

#else 

#ifdef USEPOSIXTHREADS
rt_barrier_t * rt_thread_barrier_init(int n_clients) {
  rt_barrier_t *barrier = (rt_barrier_t *) malloc(sizeof(rt_barrier_t));

  if (barrier != NULL) {
    barrier->n_clients = n_clients;
    barrier->n_waiting = 0;
    barrier->phase = 0;
    barrier->sum = 0;
    pthread_mutex_init(&barrier->lock, NULL);
    pthread_cond_init(&barrier->wait_cv, NULL);
  }

  return barrier;
}

void rt_thread_barrier_destroy(rt_barrier_t *barrier) {
  pthread_mutex_destroy(&barrier->lock);
  pthread_cond_destroy(&barrier->wait_cv);
  free(barrier);
}

int rt_thread_barrier(rt_barrier_t *barrier, int increment) {
  int my_phase;

  pthread_mutex_lock(&barrier->lock);
  my_phase = barrier->phase;
  barrier->sum += increment;
  barrier->n_waiting++;

  if (barrier->n_waiting == barrier->n_clients) {
    barrier->result = barrier->sum;
    barrier->sum = 0;
    barrier->n_waiting = 0;
    barrier->phase = 1 - my_phase;
    pthread_cond_broadcast(&barrier->wait_cv);
  }

  while (barrier->phase == my_phase) {
    pthread_cond_wait(&barrier->wait_cv, &barrier->lock);
  }

  pthread_mutex_unlock(&barrier->lock);

  return (barrier->result);
}
#endif
#endif /* THR */



/*
 * threads.h - code for spawning threads on various platforms.
 *
 *  $Id: threads.h,v 1.23 2002/08/05 05:40:40 johns Exp $
 */ 

#ifndef RT_THREADS_INC
#define RT_THREADS_INC 1

/* define which thread calls to use */
#if defined(USEPOSIXTHREADS) && defined(USEUITHREADS)
#error You may only define USEPOSIXTHREADS or USEUITHREADS, but not both
#endif

/* POSIX Threads */
#if defined(HPUX) || defined(__PARAGON__) || defined(Irix) || defined(Linux) ||     defined(_CRAY) || defined(__osf__) || defined(AIX) || defined(__APPLE__)
#if !defined(USEUITHREADS) && !defined(USEPOSIXTHREADS)
#define USEPOSIXTHREADS
#endif
#endif

/* Unix International Threads */
#if defined(SunOS)
#if !defined(USEPOSIXTHREADS) && !defined(USEUITHREADS)
#define USEUITHREADS
#endif
#endif


#ifdef THR
#ifdef USEPOSIXTHREADS
#include <pthread.h>

typedef pthread_t        rt_thread_t;
typedef pthread_mutex_t   rt_mutex_t;

typedef struct barrier_struct {
  int padding1[8]; /* Padding bytes to avoid false sharing and cache aliasing */
  pthread_mutex_t lock;   /* Mutex lock for the structure */
  int n_clients;          /* Number of threads to wait for at barrier */
  int n_waiting;          /* Number of currently waiting threads */
  int phase;              /* Flag to separate waiters from fast workers */
  int sum;                /* Sum of arguments passed to barrier_wait */
  int result;             /* Answer to be returned by barrier_wait */
  pthread_cond_t wait_cv; /* Clients wait on condition variable to proceed */
  int padding2[8]; /* Padding bytes to avoid false sharing and cache aliasing */
} rt_barrier_t;

typedef struct rwlock_struct {
  pthread_mutex_t lock;         /* read/write monitor lock */
  int rwlock;                   /* >0 = #rdrs, <0 = wrtr, 0=none */
  pthread_cond_t  rdrs_ok;      /* start waiting readers */
  unsigned int waiting_writers; /* # of waiting writers  */
  pthread_cond_t  wrtr_ok;      /* start waiting writers */ 
} rt_rwlock_t;

#endif

#ifdef USEUITHREADS
#include <thread.h>

typedef thread_t  rt_thread_t;
typedef mutex_t   rt_mutex_t;
typedef rwlock_t  rt_rwlock_t;

typedef struct barrier_struct {
  int padding1[8]; /* Padding bytes to avoid false sharing and cache aliasing */
  mutex_t lock;           /* Mutex lock for the structure */
  int n_clients;          /* Number of threads to wait for at barrier */
  int n_waiting;          /* Number of currently waiting threads */
  int phase;              /* Flag to separate waiters from fast workers */
  int sum;                /* Sum of arguments passed to barrier_wait */
  int result;             /* Answer to be returned by barrier_wait */
  cond_t wait_cv;         /* Clients wait on condition variable to proceed */
  int padding2[8]; /* Padding bytes to avoid false sharing and cache aliasing */
} rt_barrier_t;

#endif



#ifdef _MSC_VER
#include <windows.h>
typedef HANDLE rt_thread_t;
typedef HANDLE rt_mutex_t;
typedef HANDLE cond;
#endif
#endif



#ifndef THR
typedef int rt_thread_t;
typedef int rt_mutex_t;
typedef int rt_barrier_t;
typedef int rt_rwlock_t;
#endif



int rt_thread_numprocessors(void);
int rt_thread_setconcurrency(int);
int rt_thread_create(rt_thread_t *, void * routine(void *), void *);
int rt_thread_join(rt_thread_t, void **);

int rt_mutex_init(rt_mutex_t *);
int rt_mutex_lock(rt_mutex_t *);
int rt_mutex_unlock(rt_mutex_t *);

int rt_rwlock_init(rt_rwlock_t *);
int rt_rwlock_readlock(rt_rwlock_t *);
int rt_rwlock_writelock(rt_rwlock_t *);
int rt_rwlock_unlock(rt_rwlock_t *);

rt_barrier_t * rt_thread_barrier_init(int n_clients);
void rt_thread_barrier_destroy(rt_barrier_t *barrier);
int rt_thread_barrier(rt_barrier_t *barrier, int increment);

#endif
/* 
 * trace.c - This file contains the functions for firing primary rays
 *           and handling subsequent calculations
 *
 *   $Id: trace.c,v 1.105 2002/08/05 05:27:46 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "shade.h"
#include "camera.h"
#include "util.h"
#include "threads.h"
#include "parallel.h"
#include "intersect.h"
#include "ui.h"
#include "trace.h"

color trace(ray * primary) {
  if (primary->depth > 0) {
    reset_intersection(primary);
    intersect_objects(primary);
    return primary->scene->shader(primary);
  }

  /* if ray is truncated, return the background as its color */
  return primary->scene->background;
}

void * thread_trace(thr_parms * t) {
  unsigned long * local_mbox = NULL;
  scenedef * scene;
  int addr, R,G,B;
  unsigned char * img;
  color col;
  ray primary;
  int x, y, do_ui, hskip;
  int startx, stopx, xinc, starty, stopy, yinc, hsize, vres;

#if defined(_OPENMP)
#pragma omp parallel
{
#endif

  /*
   * Copy all of the frequently used parameters into local variables.
   * This seems to improve performance, especially on NUMA systems.
   */
  startx = t->startx;
  stopx  = t->stopx;
  xinc   = t->xinc;
 
  starty = t->starty;
  stopy  = t->stopy;
  yinc   = t->yinc;
 
  scene  = t->scene;
  img    = scene->img;
  hsize  = scene->hres*3;
  vres   = scene->vres;
  hskip  = xinc * 3;
  do_ui = (scene->mynode == 0 && t->tid == 0);

#if !defined(DISABLEMBOX)
   /* allocate mailbox array per thread... */
#if defined(_OPENMP)
  local_mbox = (unsigned long *)calloc(sizeof(unsigned long)*scene->numobjects, 1);
#else
  if (t->local_mbox == NULL)  
    local_mbox = (unsigned long *)calloc(sizeof(unsigned long)*scene->objgroup.numobjects, 1);
  else 
    local_mbox = t->local_mbox;
#endif
#else
  local_mbox = NULL; /* mailboxes are disabled */
#endif

#if defined(_OPENMP)
#pragma omp single
#endif
  /* 
   * If we are getting close to integer wraparound on the    
   * ray serial numbers, we need to re-clear the mailbox     
   * array(s).  Each thread maintains its own serial numbers 
   * so only those threads that are getting hit hard will    
   * need to re-clear their mailbox arrays.  In all likelihood,
   * the threads will tend to hit their counter limits at about
   * the same time though.
   * When compiled on platforms with a 64-bit long, this counter won't 
   * wraparound in _anyone's_ lifetime, so no need to even check....
   * On lesser-bit platforms, we're not quite so lucky, so we have to check.
   */
#if !defined(LP64)
  if (local_mbox != NULL) {
    if (t->serialno > (((unsigned long) 1) << ((sizeof(unsigned long) * 8) - 3))) {
      memset(local_mbox, 0, sizeof(unsigned long) * scene->objgroup.numobjects);
      t->serialno = 1;
    }
  }
#endif

  /* setup the thread-specific properties of the primary ray(s) */
  camray_init(scene, &primary, t->serialno, local_mbox);

#if defined(_OPENMP)
#pragma omp for schedule(runtime)
#endif
  for (y=starty; y<=stopy; y+=yinc) {
    addr = hsize * (y - 1) + (3 * (startx - 1));    /* scanline address */
    for (x=startx; x<=stopx; x+=xinc) {
      col=scene->camera.cam_ray(&primary, x, y);   /* generate ray */ 

      /*
	BEGIN_VEC3Arg(SIMD_TRACE, &col, &img[addr]);
     
	; Note: Only 3 floats out of 4 floats in a simd reg are useful
	; assume s0 contains 255|255|255|255 loaded outside the entire loop
	;
	sfld4  r9, r0, s4     ; load 3 floats into s0 from col
	sfmul4 s4, s0, s8     ; s8 - 3 floats * 255.0
	sftoi4 s8, r0, s12    ; convert 3 floats to 3 integers
	ssat4  s12, i8, s16   ; saturate integers to 8 bits
	spak4  s16, i1, s20   ; pack to chars
	sst1   s20, i3, r10   ; store 3 bytes to img

	addr += END_VEC();`
      */
     	


      R = (int) (col.r * 255.0);  /* quantize float to integer */
      G = (int) (col.g * 255.0);  /* quantize float to integer */
      B = (int) (col.b * 255.0);  /* quantize float to integer */

      if (R > 255) R = 255;      /* clamp pixel value to range 0-255      */
      img[addr    ] = (byte) R;  /* Store final pixel to the image buffer */
      if (G > 255) G = 255;      /* clamp pixel value to range 0-255      */
      img[addr + 1] = (byte) G;  /* Store final pixel to the image buffer */
      if (B > 255) B = 255;      /* clamp pixel value to range 0-255      */
      img[addr + 2] = (byte) B;  /* Store final pixel to the image buffer */


      addr += hskip;
    } /* end of x-loop */

    if (do_ui && !((y-1) % 64)) {
      rt_ui_progress((100 * y) / vres);  /* call progress meter callback */
    } 

#ifdef MPI
    if (scene->nodes > 1) {
      rt_thread_barrier(t->runbar, 1);
      rt_sendrecvscanline(scene->parbuf);
    }
#endif

  } /* end y-loop */

  t->serialno = primary.serial + 1;

#if defined(_OPENMP)
  if (local_mbox != NULL)
    free(local_mbox);
#else
  if (t->local_mbox == NULL) {
    if (local_mbox != NULL)
      free(local_mbox);
  }
#endif

  /*if (scene->nodes == 1)
    rt_thread_barrier(t->runbar, 1);*/

#if defined(_OPENMP)
  }
#endif

  return(NULL);  
}

/* 
 * trace.h - This file contains the declarations for the main tracing calls.
 *
 *   $Id: trace.h,v 1.32 2001/01/19 08:31:39 johns Exp $
 */

typedef struct {
  int tid;
  int nthr;
  scenedef * scene;
  unsigned long * local_mbox;
  unsigned long serialno; 
  int startx;
  int stopx;
  int xinc;
  int starty;
  int stopy;
  int yinc;
  rt_barrier_t * runbar; /* Thread barrier */
} thr_parms;

color trace(ray *);
void * thread_trace(thr_parms *); 

/*
 * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 */
#include <math.h>
#include "trackball.h"

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void
vzero(float *v)
{
    v[0] = 0.0;
    v[1] = 0.0;
    v[2] = 0.0;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 *
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
        /* Zero rotation */
        vzero(q);
        q[3] = 1.0;
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0) t = 1.0;
    if (t < -1.0) t = -1.0;
    phi = 2.0 * asin(t);

    axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,sin(phi/2.0));
    q[3] = cos(phi/2.0);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
        z = sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 *
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1);
    vscale(t1,q2[3]);

    vcopy(q2,t2);
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 *
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0 - 2.0 * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0 * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0 * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0;

    m[1][0] = 2.0 * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0 - 2.0 * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0;

    m[2][0] = 2.0 * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0 - 2.0 * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;
}

/*
 * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
axis_to_quat(float a[3], float phi, float q[4]);

/* 
 * triangle.c - This file contains the functions for dealing with triangles.
 *
 *  $Id: triangle.c,v 1.33 2004/02/03 06:04:39 johns Exp $
 */
 
#include "machine.h"
#include "types.h"
#include "vector.h"
#include "macros.h"
#include "intersect.h"
#include "util.h"

#define TRIANGLE_PRIVATE
#include "triangle.h"

static object_methods tri_methods = {
  (void (*)(const void *, void *))(tri_intersect),
  (void (*)(const void *, const void *, const void *, void *))(tri_normal),
  tri_bbox, 
  free 
};

static object_methods stri_methods = {
  (void (*)(const void *, void *))(tri_intersect),
  (void (*)(const void *, const void *, const void *, void *))(stri_normal),
  tri_bbox, 
  free 
};

static object_methods vcstri_methods = {
  (void (*)(const void *, void *))(tri_intersect),
  (void (*)(const void *, const void *, const void *, void *))(stri_normal),
  tri_bbox, 
  free 
};

object * newtri(void * tex, vector v0, vector v1, vector v2) {
  tri * t;
  vector edge1, edge2, edge3;

  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);

  /* check to see if this will be a degenerate triangle before creation */
  if ((VLength(&edge1) >= EPSILON) && 
      (VLength(&edge2) >= EPSILON) && 
      (VLength(&edge3) >= EPSILON)) {

    t=(tri *) malloc(sizeof(tri));

    t->nextobj = NULL;
    t->methods = &tri_methods;

    t->tex = tex;
    t->v0 = v0;
    t->edge1 = edge1;
    t->edge2 = edge2;
 
    return (object *) t;
  }
  
  return NULL; /* was a degenerate triangle */
}


object * newstri(void * tex, vector v0, vector v1, vector v2,
                           vector n0, vector n1, vector n2) {
  stri * t;
  vector edge1, edge2, edge3;

  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);

  /* check to see if this will be a degenerate triangle before creation */
  if ((VLength(&edge1) >= EPSILON) && 
      (VLength(&edge2) >= EPSILON) &&
      (VLength(&edge3) >= EPSILON)) {

    t=(stri *) malloc(sizeof(stri));

    t->nextobj = NULL;
    t->methods = &stri_methods;
 
    t->tex = tex;
    t->v0 = v0;
    t->edge1 = edge1;
    t->edge2 = edge2;
    t->n0 = n0;
    t->n1 = n1;
    t->n2 = n2;

    return (object *) t;
  }

  return NULL; /* was a degenerate triangle */
}


object * newvcstri(void * voidtex, vector v0, vector v1, vector v2,
                   vector n0, vector n1, vector n2,
                   color c0, color c1, color c2) {
  vcstri * t;
  vector edge1, edge2, edge3;
  vcstri_texture * tex = (vcstri_texture *) voidtex; 

  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);

  /* check to see if this will be a degenerate triangle before creation */
  if ((VLength(&edge1) >= EPSILON) && 
      (VLength(&edge2) >= EPSILON) &&
      (VLength(&edge3) >= EPSILON)) {

    t=(vcstri *) malloc(sizeof(vcstri));

    t->nextobj = NULL;
    t->methods = &stri_methods;
 
    t->v0 = v0;
    t->edge1 = edge1;
    t->edge2 = edge2;
    t->n0 = n0;
    t->n1 = n1;
    t->n2 = n2;

    tex->c0 = c0;
    tex->c1 = c1;
    tex->c2 = c2;
    tex->obj = t; /* XXX hack to let the texture function get c0c1c2 data */
    tex->texfunc = (color(*)(const void *, const void *, void *))(vcstri_color);
    t->tex = (texture *) tex;

    return (object *) t;
  }

  return NULL; /* was a degenerate triangle */
}

#define CROSS(dest,v1,v2) \
          dest.x=v1.y*v2.z-v1.z*v2.y; \
          dest.y=v1.z*v2.x-v1.x*v2.z; \
          dest.z=v1.x*v2.y-v1.y*v2.x;

#define DOT(v1,v2) (v1.x*v2.x+v1.y*v2.y+v1.z*v2.z)

#define SUB(dest,v1,v2) \
          dest.x=v1.x-v2.x; \
          dest.y=v1.y-v2.y; \
          dest.z=v1.z-v2.z;

static int tri_bbox(void * obj, vector * min, vector * max) {
  tri * t = (tri *) obj;
  vector v1, v2;

  VAdd(&t->v0, &t->edge1, &v1); 
  VAdd(&t->v0, &t->edge2, &v2); 

  min->x = MYMIN( t->v0.x , MYMIN( v1.x , v2.x ));
  min->y = MYMIN( t->v0.y , MYMIN( v1.y , v2.y ));
  min->z = MYMIN( t->v0.z , MYMIN( v1.z , v2.z ));

  max->x = MYMAX( t->v0.x , MYMAX( v1.x , v2.x ));
  max->y = MYMAX( t->v0.y , MYMAX( v1.y , v2.y ));
  max->z = MYMAX( t->v0.z , MYMAX( v1.z , v2.z ));

  return 1;
}

static void tri_intersect(const tri * trn, ray * ry) {
  vector tvec, pvec, qvec;
  flt det, inv_det, t, u, v;

  /* begin calculating determinant - also used to calculate U parameter */
  CROSS(pvec, ry->d, trn->edge2);

  /* if determinant is near zero, ray lies in plane of triangle */
  det = DOT(trn->edge1, pvec);

#if 0           /* define TEST_CULL if culling is desired */
   if (det < EPSILON)
      return;

   /* calculate distance from vert0 to ray origin */
   SUB(tvec, ry->o, trn->v0);

   /* calculate U parameter and test bounds */
   u = DOT(tvec, pvec);
   if (u < 0.0 || u > det)
      return;

   /* prepare to test V parameter */
   CROSS(qvec, tvec, trn->edge1);

   /* calculate V parameter and test bounds */
   v = DOT(ry->d, qvec);
   if (v < 0.0 || u + v > det)
      return;

   /* calculate t, scale parameters, ray intersects triangle */
   t = DOT(trn->edge2, qvec);
   inv_det = 1.0 / det;
   t *= inv_det;
   u *= inv_det;
   v *= inv_det;
#else                    /* the non-culling branch */
   if (det > -EPSILON && det < EPSILON)
     return;

   inv_det = 1.0 / det;

   /* calculate distance from vert0 to ray origin */
   SUB(tvec, ry->o, trn->v0);

   /* calculate U parameter and test bounds */
   u = DOT(tvec, pvec) * inv_det;
   if (u < 0.0 || u > 1.0)
     return;

   /* prepare to test V parameter */
   CROSS(qvec, tvec, trn->edge1);

   /* calculate V parameter and test bounds */
   v = DOT(ry->d, qvec) * inv_det;
   if (v < 0.0 || u + v > 1.0)
     return;

   /* calculate t, ray intersects triangle */
   t = DOT(trn->edge2, qvec) * inv_det;
#endif

  ry->add_intersection(t,(object *) trn, ry);
}


static void tri_normal(const tri * trn, const vector * hit, const ray * incident, vector * N) {
  flt len;

  CROSS((*N), trn->edge1, trn->edge2);

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}


static void stri_normal(const stri * trn, const vector * hit, const ray * incident, vector * N) {
  flt U, V, W, lensqr, len;
  vector P, tmp, norm;
  
  CROSS(norm, trn->edge1, trn->edge2);
  lensqr = DOT(norm, norm); 

  VSUB((*hit), trn->v0, P);

  CROSS(tmp, P, trn->edge2);
  U = DOT(tmp, norm) / lensqr;   

  CROSS(tmp, trn->edge1, P);
  V = DOT(tmp, norm) / lensqr;   

  W = 1.0 - (U + V);

  N->x = W*trn->n0.x + U*trn->n1.x + V*trn->n2.x;
  N->y = W*trn->n0.y + U*trn->n1.y + V*trn->n2.y;
  N->z = W*trn->n0.z + U*trn->n1.z + V*trn->n2.z;

  len = sqrt(N->x*N->x + N->y*N->y + N->z*N->z);
  N->x /= len;
  N->y /= len;
  N->z /= len;
}


static color vcstri_color(const vector * hit, const texture * tx, const ray * incident) {
  vcstri_texture * tex = (vcstri_texture *) tx;
  const vcstri * trn = (vcstri *) tex->obj;
  flt U, V, W, lensqr;
  vector P, tmp, norm;
  color col;
  
  CROSS(norm, trn->edge1, trn->edge2);
  lensqr = DOT(norm, norm); 

  VSUB((*hit), trn->v0, P);

  CROSS(tmp, P, trn->edge2);
  U = DOT(tmp, norm) / lensqr;   

  CROSS(tmp, trn->edge1, P);
  V = DOT(tmp, norm) / lensqr;   

  W = 1.0 - (U + V);

  col.r = W*tex->c0.r + U*tex->c1.r + V*tex->c2.r;
  col.g = W*tex->c0.g + U*tex->c1.g + V*tex->c2.g;
  col.b = W*tex->c0.b + U*tex->c1.b + V*tex->c2.b;

  return col;
}


/* 
 * triangle.h - This file contains the defines for triangles etc.
 *
 *  $Id: triangle.h,v 1.18 2004/02/02 22:58:04 johns Exp $
 */

object * newtri(void *, vector, vector, vector);
object * newstri(void *, vector, vector, vector, vector, vector, vector);
object * newvcstri(void *, vector, vector, vector, vector, vector, vector,
                   color, color, color);

#ifdef TRIANGLE_PRIVATE

#define TRIXMAJOR 0
#define TRIYMAJOR 1
#define TRIZMAJOR 2
 
typedef struct {
  RT_OBJECT_HEAD
  vector edge2;
  vector edge1;
  vector v0;
} tri; 

typedef struct {
  RT_OBJECT_HEAD
  vector edge2;
  vector edge1;
  vector v0;
  vector n0;
  vector n1;
  vector n2;
} stri; 

typedef struct {
  RT_OBJECT_HEAD
  vector edge2;
  vector edge1;
  vector v0;
  vector n0;
  vector n1;
  vector n2;
  color  c0;
  color  c1;
  color  c2;
} vcstri; 

static int tri_bbox(void * obj, vector * min, vector * max);

static void tri_intersect(const tri *, ray *);

static void tri_normal(const tri *, const vector *, const ray *, vector *);
static void stri_normal(const stri *, const vector *, const ray *, vector *);

static color vcstri_color(const vector * hit, const texture * tex, const ray * incident);
#endif


/* 
 * types.h - This file contains all of the type definitions for the raytracer
 *
 *  $Id: types.h,v 1.95 2004/02/03 06:05:32 johns Exp $
 */

#ifndef TYPES_H
#define TYPES_H 1

#include "rtcommon.h" /* defintions common to all interfaces */

struct ray_t;

#ifdef USESINGLEFLT
/* All floating point types will be based on "float" */
#define SPEPSILON   0.0001f     /* amount to crawl down a ray           */
#define EPSILON     0.0001f     /* amount to crawl down a ray           */
#define FHUGE       1e18f       /* biggest fp number we care about      */
#define TWOPI       6.28318531f /* guess... :-)                         */
#define MINCONTRIB  0.001959f   /* 1.0 / 512.0, smallest contribution   */
                                /* to overall pixel color we care about */
#else
/* All floating point types will be based on "double" */
#define SPEPSILON   0.000001    /* amount to crawl down a ray           */
#define EPSILON     0.000001    /* amount to crawl down a ray           */
#define FHUGE       1e18        /* biggest fp number we care about      */
#define TWOPI       6.28318531  /* guess... :-)                         */
#define MINCONTRIB  0.001959    /* 1.0 / 512.0, smallest contribution   */
                                /* to overall pixel color we care about */
#endif

#define BOUNDTHRESH 16         /* subdivide cells /w > # of children   */

/* 
 * Maximum internal table sizes 
 * Use prime numbers for best memory system performance
 * (helps avoid cache aliasing..)
 */
#define MAXIMGS   39         /* maxiumum number of distinct images   */

/* 
 * Ray flags 
 *
 * These are used in order to skip calculations which are only
 * needed some of the time.  For example, when shooting shadow
 * rays, we only have to find *one* intersection that's valid, 
 * if we find even one, we can quit early, thus saving lots of work.
 */
#define RT_RAY_REGULAR   1  /* A regular ray, fewer shorcuts available    */
#define RT_RAY_SHADOW    2  /* A shadow ray, we can early-exit asap       */
#define RT_RAY_FINISHED  4  /* We've found what we're looking for already */
                            /* early-exit at soonest opportunity..        */

/* 
 * Texture flags
 * 
 * These are used in order to skip calculations that are only needed
 * some of the time.
 */
#define RT_TEXTURE_NOFLAGS    0 /* No options set             */
#define RT_TEXTURE_SHADOWCAST 1 /* This object casts a shadow */ 
#define RT_TEXTURE_ISLIGHT    2 /* This object is a light     */


typedef unsigned char byte; /* 1 byte */

typedef struct {
   flt x;        /* X coordinate value */
   flt y;        /* Y coordinate value */
   flt z;        /* Z coordinate value */
} vector;


typedef struct {
   float r;      /* Red component   */
   float g;      /* Green component */
   float b;      /* Blue component  */
} color;


typedef struct {
   byte r;       /* Red component   */
   byte g;       /* Green component */
   byte b;       /* Blue component  */
} bytecolor;


typedef struct {         /* Raw 24 bit image structure, for tga, ppm etc */
  int loaded;            /* image memory residence flag    */
  int xres;              /* image X axis size              */
  int yres;              /* image Y axis size              */
  int bpp;               /* image bits per pixel           */
  char name[96];         /* image filename (with path)     */
  unsigned char * data;  /* pointer to raw byte image data */
} rawimage;


typedef struct {
  int levels;
  rawimage const ** images;
} mipmap;


typedef struct {         /* Scalar Volume Data */
  int loaded;            /* Volume data memory residence flag */
  int xres;		 /* volume X axis size                */
  int yres;		 /* volume Y axis size                */
  int zres;		 /* volume Z axis size                */
  flt opacity;		 /* opacity per unit length           */
  char name[96];         /* Volume data filename              */
  unsigned char * data;  /* pointer to raw byte volume data   */
} scalarvol;


#define RT_TEXTURE_HEAD \
  color (* texfunc)(const void *, const void *, void *);                 \
  unsigned int flags; /* texturing/lighting flags */                     \
  flt ambient;        /* ambient lighting */                             \
  flt diffuse; 	      /* diffuse reflection */                           \
  flt phong;          /* phong specular highlights */                    \
  flt phongexp;       /* phong exponent/shininess factor */              \
  int phongtype;      /* phong type: 0 == plastic, nonzero == metal */   \
  flt specular;       /* specular reflection */                          \
  flt opacity;        /* how opaque the object is */ 


typedef struct {
  RT_TEXTURE_HEAD
} texture;

typedef struct {
  RT_TEXTURE_HEAD
  color  col;         /* base object color */
  vector ctr;         /* origin of texture */
  vector rot;         /* rotation of texture about origin */
  vector scale;       /* scale of texture in x,y,z */
  vector uaxs;	      /* planar map U axis */
  vector vaxs;	      /* planar map V axis */
  void * img;         /* pointer to image for image mapping */
  void * obj;         /* object ptr, hack for vol shaders */
} standard_texture;

typedef struct {
  RT_TEXTURE_HEAD
  void * obj;         /* object ptr, hack for vcstri for now */
  color c0;           /* color for vertex 0 */
  color c1;           /* color for vertex 1 */
  color c2;           /* color for vertex 2 */
} vcstri_texture;


typedef struct {
  void (* intersect)(const void *, void *);        /* intersection func ptr  */
  void (* normal)(const void *, const void *, const void *, void *); /* normal function ptr    */
  int (* bbox)(void *, vector *, vector *);        /* return the object bbox */
  void (* freeobj)(void *);                        /* free the object        */
} object_methods;
 

#define RT_OBJECT_HEAD \
  unsigned int id;           /* Unique Object serial number    */ \
  void * nextobj;            /* pointer to next object in list */ \
  object_methods * methods;  /* this object's methods          */ \
  texture * tex;             /* object texture                 */ 
	

typedef struct {
  RT_OBJECT_HEAD
} object; 


typedef struct {
  const object * obj;        /* to object we hit                        */ 
  flt t;                     /* distance along the ray to the hit point */
} intersection;


typedef struct {
  int num;                   /* number of intersections    */
  intersection closest;      /* closest intersection > 0.0 */
} intersectstruct;



typedef struct {
  int projection;            /* camera projection mode                  */
  vector center;             /* center of the camera in world coords    */
  vector viewvec;            /* view direction of the camera  (Z axis)  */
  vector rightvec;           /* right axis for the camera     (X axis)  */
  vector upvec;              /* up axis for the camera        (Y axis)  */
  flt camzoom;               /* zoom factor for the camera              */
  flt px;                    /* width of image plane in world coords    */
  flt py;                    /* height of image plane in world coords   */
  flt psx;                   /* width of pixel in world coords          */
  flt psy;                   /* height of pixel in world coords         */
  flt focallength;           /* distance from eye to focal plane        */
  flt left;                  /* left side of perspective frustum        */
  flt right;                 /* right side of perspective frustum       */
  flt top;                   /* top side of perspective frustum         */
  flt bottom;                /* bottom side of perspective frustum      */
  flt aperture;              /* depth of field aperture                 */
  vector projcent;           /* center of image plane in world coords   */
  color (* cam_ray)(void *, flt, flt);   /* camera ray generator fctn   */
  vector lowleft;            /* lower left corner of image plane        */
  vector iplaneright;        /* image plane right vector                */
  vector iplaneup;           /* image plane up    vector                */
} camdef;

typedef struct fogdata_t {
  color (* fog_fctn)(struct fogdata_t *, color, flt);  /* fogging function */
  color col;                 /* fog color                               */
  flt start;                 /* fog start parameter                     */
  flt end;                   /* fog end parameter                       */
  flt density;               /* fog density parameter                   */
} fogdata;

typedef struct {
  int numcpus;               /* number of processors on this node       */
  flt cpuspeed;              /* relative speed of cpus on this node     */
  flt nodespeed;             /* relative speed index for this node      */
  char machname[512];        /* machine/node name                       */
} nodeinfo;

typedef struct list {
  void * item;
  struct list * next;
} list;

typedef struct {
  vector hit;  /* ray object intersection hit point */
  vector N;    /* surface normal at the hit point */
  vector L;    /* vector point in the direction from hit point to the light */
  flt    Llen; /* distance from hit point to the light (if any) */
} shadedata;

typedef struct {
  object * boundedobj;       /* bounded object list, starts out empty   */
  object * unboundedobj;     /* unbounded object list, starts out empty */
  int numobjects;            /* number of objects in group              */
} displist;
 
typedef struct {
  char outfilename[200];     /* name of the output image                */
  int writeimagefile;        /* enable/disable writing of image to disk */
  unsigned char * img;       /* pointer to a raw rgb image to be stored */
  int imginternal;           /* image was allocated by the library      */
  int imgformat;             /* output format for final image           */
  int numthreads;            /* user controlled number of threads       */
  int nodes;                 /* number of distributed memory nodes      */
  int mynode;                /* my distributed memory node number       */
  nodeinfo * cpuinfo;        /* overall cpu/node/threads info           */
  int hres;                  /* horizontal output image resolution      */
  int vres;                  /* vertical output image resolution        */
  flt aspectratio;           /* aspect ratio of output image            */
  int raydepth;              /* maximum recursion depth                 */
  int antialiasing;          /* number of antialiasing rays to fire     */
  int verbosemode;           /* verbose reporting flag                  */
  int boundmode;             /* automatic spatial subdivision flag      */
  int boundthresh;           /* threshold number of subobjects          */
  list * texlist;            /* linked list of texture objects          */
  camdef camera;             /* camera definition                       */
  color (* shader)(void *);  /* main shader used for the whole scene    */  
  flt (* phongfunc)(const struct ray_t * incident, const shadedata * shadevars, flt specpower);              /* phong shader used for whole scene       */ 
  int transmode;             /* transparency mode                       */
  color background;          /* scene background color                  */
  fogdata fog;               /* fog parameters                          */
  displist objgroup;         /* objects in the scene                    */
  list * lightlist;          /* linked list of lights in the scene      */
  int numlights;             /* number of lights in the scene           */
  int scenecheck;            /* re-check scene for changes              */
  void * parbuf;             /* parallel message passing handle         */
  void * threads;            /* thread handles                          */
  void * threadparms;        /* thread parameters                       */
} scenedef;


typedef struct ray_t {
   vector o;             /* origin of the ray X,Y,Z                        */
   vector d;             /* normalized direction of the ray                */
   flt maxdist;          /* maximum distance to search for intersections   */
   flt opticdist;        /* total distance traveled from camera so far     */  
   void (* add_intersection)(flt, const object *, struct ray_t *); 
   intersectstruct intstruct; /* ptr to thread's intersection data         */ 
   unsigned int depth;   /* levels left to recurse.. (maxdepth - curdepth) */
   unsigned int flags;   /* ray flags, any special treatment needed etc    */
   unsigned long serial; /* serial number of the ray                       */
   unsigned long * mbox; /* mailbox array for optimizing intersections     */
   scenedef * scene;     /* pointer to the scene, for global parms such as */
                         /* background colors etc                          */
   unsigned int randval; /* random number seed                             */
} ray;


/* a proposed structure to pass to shader helper functions */
/* this might help organize the shading code in a much nicer way */
typedef struct {  
  ray * incident; 
  object * obj;  
  texture * tex;
  vector pnt;
  vector N;
} shadeinfo;  


#endif
/*
 * ui.c - Contains functions for dealing with user interfaces
 *
 *  $Id: ui.c,v 1.7 1998/07/26 00:23:28 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"
#include "util.h"
#include "ui.h"

static void (* rt_static_ui_message) (int, char *) = NULL;
static void (* rt_static_ui_progress) (int) = NULL;
static int (* rt_static_ui_checkaction) (void) = NULL;

void rt_set_ui_message(void (* func) (int, char *)) {
  rt_static_ui_message = func;
}

void rt_set_ui_progress(void (* func) (int)) {
  rt_static_ui_progress = func;
}

void rt_ui_message(int level, char * msg) {
  if (rt_static_ui_message != NULL) 
    rt_static_ui_message(level, msg);
}

void rt_ui_progress(int percent) {
  if (rt_static_ui_progress != NULL)
    rt_static_ui_progress(percent);
}

int rt_ui_checkaction(void) {
  if (rt_static_ui_checkaction != NULL) 
    return rt_static_ui_checkaction();
  else
    return 0;
}














/*
 * ui.h - defines for user interface functions
 *
 *  $Id: ui.h,v 1.2 1997/12/04 06:26:01 johns Exp $
 */

/* Different types of message, for levels of verbosity etc */
#define MSG_0      100
#define MSG_1      101
#define MSG_2      102
#define MSG_3      103
#define MSG_4      104
#define MSG_5      105
#define MSG_ERR    200
#define MSG_ABORT  300

void rt_ui_message(int, char *);
void rt_ui_progress(int);
int  rt_ui_checkaction(void);

/*
 * util.c - Contains all of the timing functions for various platforms.
 *
 *  $Id: util.c,v 1.46 2001/12/03 07:27:05 johns Exp $ 
 */

#include "machine.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "types.h"
#include "macros.h"
#include "util.h"
#include "parallel.h"
#include "ui.h"

#if defined(__PARAGON__) || defined(__IPSC__)
#if defined(__IPSC__)
#include <cube.h>
#endif     /* iPSC/860 specific */

#if defined(__PARAGON__)
#include <nx.h>
#endif     /* Paragon XP/S specific */

#include <estat.h>
#endif /* iPSC/860 and Paragon specific items */

/* most platforms will use the regular time function gettimeofday() */
#if !defined(__IPSC__) && !defined(__PARAGON__) && !defined(NEXT)
#define STDTIME
#endif

#if defined(NEXT) 
#include <time.h>
#undef STDTIME
#define OLDUNIXTIME
#endif

#if defined(_MSC_VER) || defined(WIN32)
#include <windows.h>
#undef STDTIME
#define WIN32GETTICKCOUNT
#endif

void rt_finalize(void); /* UGLY! tachyon.h needs more cleanup before it can */
                        /* be properly included without risk of bogosity    */

#if defined(Linux) || defined(Bsd) || defined(AIX) || defined(SunOS) || defined(HPUX) || defined(_CRAYT3E) || defined(_CRAY) || defined(_CRAYC) || defined(__osf__) || defined(__BEOS__)
#include <sys/time.h>
#endif

#if defined(MCOS) || defined(VXWORKS)
#define POSIXTIME
#endif


#if defined(WIN32GETTICKCOUNT)
typedef struct {
  DWORD starttime;
  DWORD endtime;
} rt_timer;

void rt_timer_start(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  t->starttime = GetTickCount();
}

void rt_timer_stop(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  t->endtime = GetTickCount();
}

float rt_timer_time(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  flt ttime;

  ttime = (double) (t->endtime - t->starttime) / 1000.0;

  return (float) ttime;
}
#endif


#if defined(POSIXTIME)
#undef STDTIME
#include <time.h>

typedef struct {
  struct timespec starttime;
  struct timespec endtime;
} rt_timer;

void rt_timer_start(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  clock_gettime(CLOCK_REALTIME, &t->starttime);
}

void rt_timer_stop(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  clock_gettime(CLOCK_REALTIME, &t->endtime);
}

float rt_timer_time(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  flt ttime, start, end;

  start = (t->starttime.tv_sec + 1.0 * t->starttime.tv_nsec / 1000000000.0);
    end = (t->endtime.tv_sec + 1.0 * t->endtime.tv_nsec / 1000000000.0);
  ttime = end - start;

  return (float) ttime;
}
#endif



/* if we're running on a Paragon or iPSC/860, use mclock() hi res timers */
#if defined(__IPSC__) || defined(__PARAGON__)

typedef struct {
  long starttime;
  long stoptime;
} rt_timer;

void rt_timer_start(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  t->starttime=mclock(); 
}

void rt_timer_stop(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  t->stoptime=mclock();
}

float rt_timer_time(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  flt a;
  a = t->stoptime - t->starttime;
  a = ( a / 1000.0 );
  return (float) a;
}
#endif



/* if we're on a Unix with gettimeofday() we'll use newer timers */
#ifdef STDTIME 
typedef struct {
  struct timeval starttime, endtime;
#ifndef VMS
  struct timezone tz;
#endif
} rt_timer;

void rt_timer_start(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
#ifdef VMS
  gettimeofday(&t->starttime, NULL);
#else
  gettimeofday(&t->starttime, &t->tz);
#endif
} 
  
void rt_timer_stop(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
#ifdef VMS
  gettimeofday(&t->endtime, NULL);
#else
  gettimeofday(&t->endtime, &t->tz);
#endif
} 
  
float rt_timer_time(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  double ttime, start, end;

  start = (t->starttime.tv_sec + 1.0 * t->starttime.tv_usec / 1000000.0);
    end = (t->endtime.tv_sec + 1.0 * t->endtime.tv_usec / 1000000.0);
  ttime = end - start;

  return (float) ttime;
}  
#endif



/* use the old fashioned Unix time functions */
#ifdef OLDUNIXTIME
typedef struct {
  time_t starttime;
  time_t stoptime;
} rt_timer;

void rt_timer_start(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  time(&t->starttime);
}

void rt_timer_stop(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  time(&t->stoptime);
}

float rt_timer_time(rt_timerhandle v) {
  rt_timer * t = (rt_timer *) v;
  flt a;
  a = difftime(t->stoptime, t->starttime);
  return (float) a;
}
#endif


/* 
 * system independent routines to create and destroy timers 
 */
rt_timerhandle rt_timer_create(void) {
  rt_timer * t;  
  t = (rt_timer *) malloc(sizeof(rt_timer));
  memset(t, 0, sizeof(rt_timer));
  return t;
}

void rt_timer_destroy(rt_timerhandle v) {
  free(v);
}




/*
 * Code for machines with deficient libc's etc.
 */

#if defined(__IPSC__) && !defined(__PARAGON__) 

/* the iPSC/860 libc is *missing* strstr(), so here it is.. */
char * strstr(const char *s, const char *find) {
  register char c, sc;
  register size_t len;

  if ((c = *find++) != 0) {
    len = strlen(find);
    do {
      do {
        if ((sc = *s++) == 0)
          return (NULL);
      } while (sc != c);
    } while (strncmp(s, find, len) != 0);
    s--;
  }
  return ((char *)s);
}
#endif

/* the Mercury libc is *missing* isascii(), so here it is.. */
#if defined(MCOS)
   int isascii(int c) {
     return (!((c) & ~0177));
   }
#endif

/*
 * Thread Safe Random Number Generators
 * (no internal static data storage)
 * 
 * Note: According to numerical recipes, one should not use
 *       random numbers in any way similar to rand() % number,
 *       as the greatest degree of randomness tends to be found
 *       in the upper bits of the random number, rather than the
 *       lower bits.  
 */

/*
 * Simple 32-bit random number generator suggested in
 * numerical recipes in C book.
 *
 * This random number generator has been fixed to work on 
 * machines that have "int" types which are larger than 32 bits.
 *
 * The rt_rand() API is similar to the reentrant "rand_r" version
 * found in some libc implementations.
 */
unsigned int rt_rand(unsigned int * idum) {
  *idum = ((1664525 * (*idum)) + 1013904223) & ((unsigned int) 0xffffffff); 
  return *idum;
}


/* 
 * util.h - This file contains defines for the timer functions...
 *
 *  $Id: util.h,v 1.10 2000/11/22 21:53:35 johns Exp $
 */

#if !defined(RT_UTIL_H) 
#define RT_UTIL_H 1

typedef void * rt_timerhandle;         /* a timer handle */
rt_timerhandle rt_timer_create(void);  /* create a timer (clears timer)  */
void rt_timer_destroy(rt_timerhandle); /* create a timer (clears timer)  */
void rt_timer_start(rt_timerhandle);   /* start a timer  (clears timer)  */
void rt_timer_stop(rt_timerhandle);    /* stop a timer                   */
float rt_timer_time(rt_timerhandle);   /* report elapsed time in seconds */

#define RT_RAND_MAX 4294967296.0       /* Maximum random value from rt_rand */
unsigned int rt_rand(unsigned int *);  /* thread-safe 32-bit random numbers */

#endif
/* 
 * vector.c - This file contains all of the vector arithmetic functions.
 *
 *  $Id: vector.c,v 1.5 2002/07/09 00:48:40 johns Exp $
 */

#include "machine.h"
#include "types.h"
#include "macros.h"


flt VDot(const vector *a, const vector *b) {

  return (a->x*b->x + a->y*b->y + a->z*b->z);
}

void VCross(const vector * a, const vector * b, vector * c) {
  c->x = (a->y * b->z) - (a->z * b->y);
  c->y = (a->z * b->x) - (a->x * b->z);
  c->z = (a->x * b->y) - (a->y * b->x);
}

flt VLength(const vector * a) {
  return (flt) sqrt((a->x * a->x) + (a->y * a->y) + (a->z * a->z));
}

void VNorm(vector * a) {
  flt len;

  len=sqrt((a->x * a->x) + (a->y * a->y) + (a->z * a->z));
  if (len != 0.0) {
    a->x /= len;
    a->y /= len;
    a->z /= len;
  }
}

void VAdd(const vector * a, const vector * b, vector * c) {
  c->x = (a->x + b->x);
  c->y = (a->y + b->y);
  c->z = (a->z + b->z);
}
    
void VSub(const vector * a, const vector * b, vector * c) {
  c->x = (a->x - b->x);
  c->y = (a->y - b->y);
  c->z = (a->z - b->z);
}

void VAddS(flt a, const vector * A, const vector * B, vector * C) {
  C->x = (a * A->x) + B->x;
  C->y = (a * A->y) + B->y;
  C->z = (a * A->z) + B->z;
}

vector Raypnt(const ray * a, flt t) {
  vector temp;

  temp.x=a->o.x + (a->d.x * t);
  temp.y=a->o.y + (a->d.y * t);
  temp.z=a->o.z + (a->d.z * t);

  return temp;
}

void VScale(vector * a, flt s) {
  a->x *= s;
  a->y *= s;
  a->z *= s;
}

void ColorAddS(color * a, const color * b, flt s) {
  a->r += b->r * s;
  a->g += b->g * s;
  a->b += b->b * s;
}

void ColorAccum(color * a, const color * b) {
  a->r += b->r;
  a->g += b->g;
  a->b += b->b;
}

void ColorScale(color * a, flt s) {
  a->r *= s;
  a->g *= s;
  a->b *= s;
}

/*
 * vector.h - This file contains declarations of vector functions
 *
 *  $Id: vector.h,v 1.5 2002/07/09 00:48:40 johns Exp $
 */

flt VDot(const vector *, const vector *);
void VCross(const vector *, const vector *, vector *);
flt VLength(const vector *);
void VNorm(vector *);
void VAdd(const vector *, const vector *, vector *);
void VSub(const vector *, const vector *, vector *);
void VAddS(flt, const vector *, const vector *, vector *);
vector Raypnt(const ray *, flt);
void VScale(vector * a, flt s); 

void ColorAddS(color * a, const color * b, flt s); 
void ColorAccum(color * a, const color * b); 
void ColorScale(color * a, flt s); 

/*
 * vol.c - Volume rendering helper routines etc.
 *
 *
 *  $Id: vol.c,v 1.43 2004/02/03 06:00:40 johns Exp $
 */

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "macros.h"
#include "vector.h"
#include "util.h"
#include "parallel.h"
#include "threads.h"
#include "vol.h"
#include "box.h"
#include "trace.h"
#include "ui.h"
#include "shade.h"

int scalarvol_bbox(void * obj, vector * min, vector * max) {
  box * b = (box *) obj;

  *min = b->min;
  *max = b->max;

  return 1;
}

#if 0  /* not yet... */
static object_methods scalarvol_methods = {
  (void (*)(void *, void *))(box_intersect),
  (void (*)(void *, void *, void *, void *))(box_normal),
  scalarvol_bbox, 
  free 
};
#endif

void * newscalarvol(void * voidtex, vector min, vector max, 
                    int xs, int ys, int zs, const char * fname, 
                    scalarvol * invol) {
  standard_texture * tx, * tex;
  scalarvol * vol;

  tex=(standard_texture *) voidtex;
  tex->flags = RT_TEXTURE_NOFLAGS; /* doesn't cast a shadow */

  tx=malloc(sizeof(texture));

  /* is the volume data already loaded? */
  if (invol==NULL) {
    vol=malloc(sizeof(scalarvol));
    vol->loaded=0;
    vol->data=NULL;
  } else {
    vol=invol;
  }

  vol->opacity=tex->opacity;
  vol->xres=xs;
  vol->yres=ys;
  vol->zres=zs;
  strcpy(vol->name, fname);

  tx->ctr.x = 0.0;
  tx->ctr.y = 0.0;
  tx->ctr.z = 0.0;
  tx->rot   = tx->ctr;
  tx->scale = tx->ctr;
  tx->uaxs  = tx->ctr;
  tx->vaxs  = tx->ctr;

  tx->flags = RT_TEXTURE_NOFLAGS;

  tx->col = tex->col;
  tx->ambient  = 1.0;
  tx->diffuse  = 0.0;
  tx->specular = 0.0;
  tx->opacity  = 1.0;
  tx->img = vol;
  tx->texfunc = (color(*)(const void *, const void *, void *))(scalar_volume_texture);

  tx->obj = (void *) newbox(tx, min, max); /* XXX hack!! */

  /* Force load of volume data so that we don't have to do mutex locks */
  /* inside the rendering threads                                      */
  if (!vol->loaded) {
    LoadVol(vol);
    vol->loaded=1;
  }

  return (void *) tx->obj;
}


color VoxelColor(flt scalar) {
  color col;

  if (scalar > 1.0) 
    scalar = 1.0;

  if (scalar < 0.0)
    scalar = 0.0;

  if (scalar < 0.25) {
    col.r = scalar * 4.0;
    col.g = 0.0;
    col.b = 0.0;
  }
  else {
    if (scalar < 0.75) {
      col.r = 1.0;
      col.g = (scalar - 0.25) * 2.0;
      col.b = 0.0;
    }
    else {
      col.r = 1.0;
      col.g = 1.0;
      col.b = (scalar - 0.75) * 4.0;
    }
  }

  return col;
} 

color scalar_volume_texture(const vector * hit, const texture * tx, ray * ry) {
  color col, col2;
  box * bx;
  flt a, tx1, tx2, ty1, ty2, tz1, tz2;
  flt tnear, tfar;
  flt t, tdist, dt, sum, tt; 
  vector pnt, bln;
  scalarvol * vol;
  flt scalar, transval; 
  int x, y, z;
  unsigned char * ptr;
  standard_texture * tex = (standard_texture *) tx;

  bx=(box *) tex->obj;
  vol=(scalarvol *) ((standard_texture *) bx->tex)->img;
   
  col.r=0.0;
  col.g=0.0;
  col.b=0.0;
 
  tnear= -FHUGE;
  tfar= FHUGE;
 
  if (ry->d.x == 0.0) {
    if ((ry->o.x < bx->min.x) || (ry->o.x > bx->max.x)) return col;
  }
  else {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if (tx1 > tx2) { a=tx1; tx1=tx2; tx2=a; }
    if (tx1 > tnear) tnear=tx1;
    if (tx2 < tfar)   tfar=tx2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
 if (ry->d.y == 0.0) {
    if ((ry->o.y < bx->min.y) || (ry->o.y > bx->max.y)) return col;
  }
  else {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if (ty1 > ty2) { a=ty1; ty1=ty2; ty2=a; }
    if (ty1 > tnear) tnear=ty1;
    if (ty2 < tfar)   tfar=ty2;
  }
  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (ry->d.z == 0.0) {
    if ((ry->o.z < bx->min.z) || (ry->o.z > bx->max.z)) return col;
  }
  else {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if (tz1 > tz2) { a=tz1; tz1=tz2; tz2=a; }
    if (tz1 > tnear) tnear=tz1;
    if (tz2 < tfar)   tfar=tz2;
  }

#if 0
  /* XXX this is where we cause early exit if the volumetric */
  /*     object intersects other geometric objects           */

  /* stop at closest intersection from other objects */
  if (ry->maxdist < tfar) 
    tfar = ry->maxdist;
#endif

  if (tnear > tfar) return col;
  if (tfar < 0.0) return col;
 
  if (tnear < 0.0) tnear=0.0;
 
  tdist=sqrt(vol->xres*vol->xres + vol->yres*vol->yres + vol->zres*vol->zres);
  tt = (vol->opacity / tdist); 

  bln.x=fabs(bx->min.x - bx->max.x);
  bln.y=fabs(bx->min.y - bx->max.y);
  bln.z=fabs(bx->min.z - bx->max.z);
  
  dt=sqrt(bln.x*bln.x + bln.y*bln.y + bln.z*bln.z) / tdist; 
  sum=0.0;

  for (t=tnear; t<=tfar; t+=dt) {
    pnt.x=((ry->o.x + (ry->d.x * t)) - bx->min.x) / bln.x;
    pnt.y=((ry->o.y + (ry->d.y * t)) - bx->min.y) / bln.y;
    pnt.z=((ry->o.z + (ry->d.z * t)) - bx->min.z) / bln.z;
 
    x=(int) ((vol->xres - 1.5) * pnt.x + 0.5);
    y=(int) ((vol->yres - 1.5) * pnt.y + 0.5);
    z=(int) ((vol->zres - 1.5) * pnt.z + 0.5);
   
    ptr = vol->data + ((vol->xres * vol->yres * z) + (vol->xres * y) + x);
   
    scalar = (flt) ((flt) 1.0 * ((int) ptr[0])) / 255.0;

    sum += tt * scalar; 

    transval = tt * scalar; 

    col2 = VoxelColor(scalar);

    if (sum < 1.0) {
      col.r += transval * col2.r;
      col.g += transval * col2.g;
      col.b += transval * col2.b;
      if (sum < 0.0) sum=0.0;
    }  
    else { 
      sum=1.0;
    }
  }


  /* XXX this has to be changed in order to allow volumetric objects */
  /*     to intersect with geometric objects                         */

  if (sum < 1.0) {      /* spawn transmission rays / refraction */    
    color transcol;
    shadedata shadevars;
    shadevars.hit=*hit;
    transcol = shade_transmission(ry, &shadevars, 1.0 - sum);

    col.r += transcol.r; /* add the transmitted ray  */    
    col.g += transcol.g; /* to the diffuse and       */
    col.b += transcol.b; /* transmission total..     */  
  }

  return col;
}

void LoadVol(scalarvol * vol) { 
  FILE * dfile;
 
  dfile=fopen(vol->name, "r");
  if (dfile==NULL) {
    char msgtxt[2048];
    sprintf(msgtxt, "Vol: can't open %s for input!!! Aborting\n",vol->name); 
    rt_ui_message(MSG_ERR, msgtxt);
    rt_ui_message(MSG_ABORT, "Rendering Aborted.");
    exit(1);
  }  
 
  if (rt_mynode()==0) {
    char msgtxt[2048];
    sprintf(msgtxt, "Loading %dx%dx%d volume set from %s",
	vol->xres, vol->yres, vol->zres, vol->name);
    rt_ui_message(MSG_0, msgtxt);
  } 
  vol->data = malloc(vol->xres * vol->yres * vol->zres);

  fread(vol->data, 1, (vol->xres * vol->yres * vol->zres), dfile);
}


/*
 * vol.h - Volume rendering definitions etc.
 *
 *
 *  $Id: vol.h,v 1.6 2002/07/09 18:17:26 johns Exp $
 */


void * newscalarvol(void * intex, vector min, vector max, 
                    int xs, int ys, int zs, 
                    const char * fname, scalarvol * invol);

void  LoadVol(scalarvol *);
color scalar_volume_texture(const vector *, const texture *, ray *);

/*
 *  winbmp.c - This file deals with Windows Bitmap image files 
 *             (reading/writing)
 *
 *  $Id: winbmp.c,v 1.1 2000/08/15 06:26:07 johns Exp $
 */ 

#include <stdio.h>
#include "machine.h"
#include "types.h"
#include "util.h"
#include "imageio.h" /* error codes etc */
#include "winbmp.h"    /* the protos for this file */

static void write_le_int32(FILE * dfile, int num) {
  fputc((num      ) & 0xFF, dfile);
  fputc((num >> 8 ) & 0xFF, dfile);
  fputc((num >> 16) & 0xFF, dfile);
  fputc((num >> 24) & 0xFF, dfile);
}

static void write_le_int16(FILE * dfile, int num) {
  fputc((num      ) & 0xFF, dfile);
  fputc((num >> 8 ) & 0xFF, dfile);
}

int writebmp(char * filename, int xs, int ys, unsigned char * img) {
  if (img != NULL) {
    FILE * dfile;

    if ((dfile = fopen(filename, "wb")) != NULL) {
      int i, y; /* loop variables */
      int imgdataoffset = 14 + 40;     /* file header + bitmap header size */
      int rowsz = ((xs * 3) + 3) & -4; /* size of one padded row of pixels */
      int imgdatasize = rowsz * ys;    /* size of image data */
      int filesize = imgdataoffset + imgdatasize;
      unsigned char * rowbuf = NULL; 

      /* write out bitmap file header (14 bytes) */
      fputc('B', dfile);
      fputc('M', dfile);
      write_le_int32(dfile, filesize);
      write_le_int16(dfile, 0);
      write_le_int16(dfile, 0);
      write_le_int32(dfile, imgdataoffset);

      /* write out bitmap header (40 bytes) */
      write_le_int32(dfile, 40); /* size of bitmap header structure */
      write_le_int32(dfile, xs); /* size of image in x */
      write_le_int32(dfile, ys); /* size of image in y */
      write_le_int16(dfile, 1);  /* num color planes (only "1" is legal) */
      write_le_int16(dfile, 24); /* bits per pixel */

      /* fields added in Win 3.x */
      write_le_int32(dfile, 0);           /* compression used (0 == none) */
      write_le_int32(dfile, imgdatasize); /* size of bitmap in bytes */
      write_le_int32(dfile, 1000);        /* horizontal pixels per meter */
      write_le_int32(dfile, 1000);        /* vertical pixels per meter */
      write_le_int32(dfile, 1 << 24);     /* number of colors in the image */
      write_le_int32(dfile, 0);           /* min num of important colors */

      /* write out actual image data */
      rowbuf = (unsigned char *) malloc(rowsz);
      if (rowbuf != NULL) {
        memset(rowbuf, 0, rowsz); /* clear the buffer (and padding) to black */

        for (y=0; y<ys; y++) {
          int addr = xs * 3 * y;

          /* write one row of the image, in reversed RGB -> BGR pixel order */
          /* padding bytes remain 0's, shouldn't have to re-clear them. */
          for (i=0; i<rowsz; i+=3) {
            rowbuf[i    ] = img[addr + i + 2]; /* blue  */
            rowbuf[i + 1] = img[addr + i + 1]; /* green */
            rowbuf[i + 2] = img[addr + i    ]; /* red   */
          }

          fwrite(rowbuf, rowsz, 1, dfile); /* write the whole row of pixels */
        }
        free(rowbuf);
      }
      fclose(dfile);
    }
  }

  return IMAGENOERR;
}




/*
 *  winbmp.h - This file deals with Windows Bitmap image files 
 *             (reading/writing)
 *
 *  $Id: winbmp.h,v 1.1 2000/08/15 06:26:07 johns Exp $
 */ 

int writebmp(char * name, int xres, int yres, unsigned char *imgdata);
